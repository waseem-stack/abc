var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(d) {
    return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d
}
function getAugmentedNamespace(d) {
    if (d.__esModule)
        return d;
    var g = d.default;
    if (typeof g == "function") {
        var b = function _() {
            return this instanceof _ ? Reflect.construct(g, arguments, this.constructor) : g.apply(this, arguments)
        };
        b.prototype = g.prototype
    } else
        b = {};
    return Object.defineProperty(b, "__esModule", {
        value: !0
    }),
    Object.keys(d).forEach(function(_) {
        var $ = Object.getOwnPropertyDescriptor(d, _);
        Object.defineProperty(b, _, $.get ? $ : {
            enumerable: !0,
            get: function() {
                return d[_]
            }
        })
    }),
    b
}
var jsxRuntime$1 = {
    exports: {}
}
  , reactJsxRuntime_production_min$1 = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element")
  , n$4 = Symbol.for("react.portal")
  , p$5 = Symbol.for("react.fragment")
  , q$3 = Symbol.for("react.strict_mode")
  , r$2 = Symbol.for("react.profiler")
  , t$3 = Symbol.for("react.provider")
  , u$3 = Symbol.for("react.context")
  , v$2 = Symbol.for("react.forward_ref")
  , w$1 = Symbol.for("react.suspense")
  , x = Symbol.for("react.memo")
  , y = Symbol.for("react.lazy")
  , z$1 = Symbol.iterator;
function A$1(d) {
    return d === null || typeof d != "object" ? null : (d = z$1 && d[z$1] || d["@@iterator"],
    typeof d == "function" ? d : null)
}
var B$1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$1 = Object.assign
  , D$1 = {};
function E$1(d, g, b) {
    this.props = d,
    this.context = g,
    this.refs = D$1,
    this.updater = b || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(d, g) {
    if (typeof d != "object" && typeof d != "function" && d != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, d, g, "setState")
}
;
E$1.prototype.forceUpdate = function(d) {
    this.updater.enqueueForceUpdate(this, d, "forceUpdate")
}
;
function F() {}
F.prototype = E$1.prototype;
function G$1(d, g, b) {
    this.props = d,
    this.context = g,
    this.refs = D$1,
    this.updater = b || B$1
}
var H$1 = G$1.prototype = new F;
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$1(d, g, b) {
    var _, $ = {}, et = null, tt = null;
    if (g != null)
        for (_ in g.ref !== void 0 && (tt = g.ref),
        g.key !== void 0 && (et = "" + g.key),
        g)
            J.call(g, _) && !L$1.hasOwnProperty(_) && ($[_] = g[_]);
    var rt = arguments.length - 2;
    if (rt === 1)
        $.children = b;
    else if (1 < rt) {
        for (var nt = Array(rt), it = 0; it < rt; it++)
            nt[it] = arguments[it + 2];
        $.children = nt
    }
    if (d && d.defaultProps)
        for (_ in rt = d.defaultProps,
        rt)
            $[_] === void 0 && ($[_] = rt[_]);
    return {
        $$typeof: l$3,
        type: d,
        key: et,
        ref: tt,
        props: $,
        _owner: K$1.current
    }
}
function N$1(d, g) {
    return {
        $$typeof: l$3,
        type: d.type,
        key: g,
        ref: d.ref,
        props: d.props,
        _owner: d._owner
    }
}
function O$1(d) {
    return typeof d == "object" && d !== null && d.$$typeof === l$3
}
function escape$1(d) {
    var g = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + d.replace(/[=:]/g, function(b) {
        return g[b]
    })
}
var P$2 = /\/+/g;
function Q$1(d, g) {
    return typeof d == "object" && d !== null && d.key != null ? escape$1("" + d.key) : g.toString(36)
}
function R$1(d, g, b, _, $) {
    var et = typeof d;
    (et === "undefined" || et === "boolean") && (d = null);
    var tt = !1;
    if (d === null)
        tt = !0;
    else
        switch (et) {
        case "string":
        case "number":
            tt = !0;
            break;
        case "object":
            switch (d.$$typeof) {
            case l$3:
            case n$4:
                tt = !0
            }
        }
    if (tt)
        return tt = d,
        $ = $(tt),
        d = _ === "" ? "." + Q$1(tt, 0) : _,
        I$1($) ? (b = "",
        d != null && (b = d.replace(P$2, "$&/") + "/"),
        R$1($, g, b, "", function(it) {
            return it
        })) : $ != null && (O$1($) && ($ = N$1($, b + (!$.key || tt && tt.key === $.key ? "" : ("" + $.key).replace(P$2, "$&/") + "/") + d)),
        g.push($)),
        1;
    if (tt = 0,
    _ = _ === "" ? "." : _ + ":",
    I$1(d))
        for (var rt = 0; rt < d.length; rt++) {
            et = d[rt];
            var nt = _ + Q$1(et, rt);
            tt += R$1(et, g, b, nt, $)
        }
    else if (nt = A$1(d),
    typeof nt == "function")
        for (d = nt.call(d),
        rt = 0; !(et = d.next()).done; )
            et = et.value,
            nt = _ + Q$1(et, rt++),
            tt += R$1(et, g, b, nt, $);
    else if (et === "object")
        throw g = String(d),
        Error("Objects are not valid as a React child (found: " + (g === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : g) + "). If you meant to render a collection of children, use an array instead.");
    return tt
}
function S$1(d, g, b) {
    if (d == null)
        return d;
    var _ = []
      , $ = 0;
    return R$1(d, _, "", "", function(et) {
        return g.call(b, et, $++)
    }),
    _
}
function T$1(d) {
    if (d._status === -1) {
        var g = d._result;
        g = g(),
        g.then(function(b) {
            (d._status === 0 || d._status === -1) && (d._status = 1,
            d._result = b)
        }, function(b) {
            (d._status === 0 || d._status === -1) && (d._status = 2,
            d._result = b)
        }),
        d._status === -1 && (d._status = 0,
        d._result = g)
    }
    if (d._status === 1)
        return d._result.default;
    throw d._result
}
var U$1 = {
    current: null
}
  , V$1 = {
    transition: null
}
  , W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
};
function X$1() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$1,
    forEach: function(d, g, b) {
        S$1(d, function() {
            g.apply(this, arguments)
        }, b)
    },
    count: function(d) {
        var g = 0;
        return S$1(d, function() {
            g++
        }),
        g
    },
    toArray: function(d) {
        return S$1(d, function(g) {
            return g
        }) || []
    },
    only: function(d) {
        if (!O$1(d))
            throw Error("React.Children.only expected to receive a single React element child.");
        return d
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(d, g, b) {
    if (d == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + d + ".");
    var _ = C$1({}, d.props)
      , $ = d.key
      , et = d.ref
      , tt = d._owner;
    if (g != null) {
        if (g.ref !== void 0 && (et = g.ref,
        tt = K$1.current),
        g.key !== void 0 && ($ = "" + g.key),
        d.type && d.type.defaultProps)
            var rt = d.type.defaultProps;
        for (nt in g)
            J.call(g, nt) && !L$1.hasOwnProperty(nt) && (_[nt] = g[nt] === void 0 && rt !== void 0 ? rt[nt] : g[nt])
    }
    var nt = arguments.length - 2;
    if (nt === 1)
        _.children = b;
    else if (1 < nt) {
        rt = Array(nt);
        for (var it = 0; it < nt; it++)
            rt[it] = arguments[it + 2];
        _.children = rt
    }
    return {
        $$typeof: l$3,
        type: d.type,
        key: $,
        ref: et,
        props: _,
        _owner: tt
    }
}
;
react_production_min.createContext = function(d) {
    return d = {
        $$typeof: u$3,
        _currentValue: d,
        _currentValue2: d,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    d.Provider = {
        $$typeof: t$3,
        _context: d
    },
    d.Consumer = d
}
;
react_production_min.createElement = M$1;
react_production_min.createFactory = function(d) {
    var g = M$1.bind(null, d);
    return g.type = d,
    g
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(d) {
    return {
        $$typeof: v$2,
        render: d
    }
}
;
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(d) {
    return {
        $$typeof: y,
        _payload: {
            _status: -1,
            _result: d
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(d, g) {
    return {
        $$typeof: x,
        type: d,
        compare: g === void 0 ? null : g
    }
}
;
react_production_min.startTransition = function(d) {
    var g = V$1.transition;
    V$1.transition = {};
    try {
        d()
    } finally {
        V$1.transition = g
    }
}
;
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(d, g) {
    return U$1.current.useCallback(d, g)
}
;
react_production_min.useContext = function(d) {
    return U$1.current.useContext(d)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(d) {
    return U$1.current.useDeferredValue(d)
}
;
react_production_min.useEffect = function(d, g) {
    return U$1.current.useEffect(d, g)
}
;
react_production_min.useId = function() {
    return U$1.current.useId()
}
;
react_production_min.useImperativeHandle = function(d, g, b) {
    return U$1.current.useImperativeHandle(d, g, b)
}
;
react_production_min.useInsertionEffect = function(d, g) {
    return U$1.current.useInsertionEffect(d, g)
}
;
react_production_min.useLayoutEffect = function(d, g) {
    return U$1.current.useLayoutEffect(d, g)
}
;
react_production_min.useMemo = function(d, g) {
    return U$1.current.useMemo(d, g)
}
;
react_production_min.useReducer = function(d, g, b) {
    return U$1.current.useReducer(d, g, b)
}
;
react_production_min.useRef = function(d) {
    return U$1.current.useRef(d)
}
;
react_production_min.useState = function(d) {
    return U$1.current.useState(d)
}
;
react_production_min.useSyncExternalStore = function(d, g, b) {
    return U$1.current.useSyncExternalStore(d, g, b)
}
;
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
}
;
react_production_min.version = "18.3.1";
react.exports = react_production_min;
var reactExports = react.exports;
const React = getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports
  , k$2 = Symbol.for("react.element")
  , l$2 = Symbol.for("react.fragment")
  , m$2 = Object.prototype.hasOwnProperty
  , n$3 = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$4 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$2(d, g, b) {
    var _, $ = {}, et = null, tt = null;
    b !== void 0 && (et = "" + b),
    g.key !== void 0 && (et = "" + g.key),
    g.ref !== void 0 && (tt = g.ref);
    for (_ in g)
        m$2.call(g, _) && !p$4.hasOwnProperty(_) && ($[_] = g[_]);
    if (d && d.defaultProps)
        for (_ in g = d.defaultProps,
        g)
            $[_] === void 0 && ($[_] = g[_]);
    return {
        $$typeof: k$2,
        type: d,
        key: et,
        ref: tt,
        props: $,
        _owner: n$3.current
    }
}
reactJsxRuntime_production_min$1.Fragment = l$2;
reactJsxRuntime_production_min$1.jsx = q$2;
reactJsxRuntime_production_min$1.jsxs = q$2;
jsxRuntime$1.exports = reactJsxRuntime_production_min$1;
var jsxRuntimeExports = jsxRuntime$1.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(d) {
    function g(Et, St) {
        var Lt = Et.length;
        Et.push(St);
        e: for (; 0 < Lt; ) {
            var Mt = Lt - 1 >>> 1
              , ar = Et[Mt];
            if (0 < $(ar, St))
                Et[Mt] = St,
                Et[Lt] = ar,
                Lt = Mt;
            else
                break e
        }
    }
    function b(Et) {
        return Et.length === 0 ? null : Et[0]
    }
    function _(Et) {
        if (Et.length === 0)
            return null;
        var St = Et[0]
          , Lt = Et.pop();
        if (Lt !== St) {
            Et[0] = Lt;
            e: for (var Mt = 0, ar = Et.length, wr = ar >>> 1; Mt < wr; ) {
                var Tr = 2 * (Mt + 1) - 1
                  , Pr = Et[Tr]
                  , kr = Tr + 1
                  , jr = Et[kr];
                if (0 > $(Pr, Lt))
                    kr < ar && 0 > $(jr, Pr) ? (Et[Mt] = jr,
                    Et[kr] = Lt,
                    Mt = kr) : (Et[Mt] = Pr,
                    Et[Tr] = Lt,
                    Mt = Tr);
                else if (kr < ar && 0 > $(jr, Lt))
                    Et[Mt] = jr,
                    Et[kr] = Lt,
                    Mt = kr;
                else
                    break e
            }
        }
        return St
    }
    function $(Et, St) {
        var Lt = Et.sortIndex - St.sortIndex;
        return Lt !== 0 ? Lt : Et.id - St.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var et = performance;
        d.unstable_now = function() {
            return et.now()
        }
    } else {
        var tt = Date
          , rt = tt.now();
        d.unstable_now = function() {
            return tt.now() - rt
        }
    }
    var nt = []
      , it = []
      , ot = 1
      , at = null
      , st = 3
      , dt = !1
      , ft = !1
      , ht = !1
      , xt = typeof setTimeout == "function" ? setTimeout : null
      , lt = typeof clearTimeout == "function" ? clearTimeout : null
      , ct = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function ut(Et) {
        for (var St = b(it); St !== null; ) {
            if (St.callback === null)
                _(it);
            else if (St.startTime <= Et)
                _(it),
                St.sortIndex = St.expirationTime,
                g(nt, St);
            else
                break;
            St = b(it)
        }
    }
    function pt(Et) {
        if (ht = !1,
        ut(Et),
        !ft)
            if (b(nt) !== null)
                ft = !0,
                Rt(vt);
            else {
                var St = b(it);
                St !== null && qt(pt, St.startTime - Et)
            }
    }
    function vt(Et, St) {
        ft = !1,
        ht && (ht = !1,
        lt(kt),
        kt = -1),
        dt = !0;
        var Lt = st;
        try {
            for (ut(St),
            at = b(nt); at !== null && (!(at.expirationTime > St) || Et && !Ht()); ) {
                var Mt = at.callback;
                if (typeof Mt == "function") {
                    at.callback = null,
                    st = at.priorityLevel;
                    var ar = Mt(at.expirationTime <= St);
                    St = d.unstable_now(),
                    typeof ar == "function" ? at.callback = ar : at === b(nt) && _(nt),
                    ut(St)
                } else
                    _(nt);
                at = b(nt)
            }
            if (at !== null)
                var wr = !0;
            else {
                var Tr = b(it);
                Tr !== null && qt(pt, Tr.startTime - St),
                wr = !1
            }
            return wr
        } finally {
            at = null,
            st = Lt,
            dt = !1
        }
    }
    var _t = !1
      , Pt = null
      , kt = -1
      , $t = 5
      , Wt = -1;
    function Ht() {
        return !(d.unstable_now() - Wt < $t)
    }
    function Dt() {
        if (Pt !== null) {
            var Et = d.unstable_now();
            Wt = Et;
            var St = !0;
            try {
                St = Pt(!0, Et)
            } finally {
                St ? Vt() : (_t = !1,
                Pt = null)
            }
        } else
            _t = !1
    }
    var Vt;
    if (typeof ct == "function")
        Vt = function() {
            ct(Dt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Ft = new MessageChannel
          , Kt = Ft.port2;
        Ft.port1.onmessage = Dt,
        Vt = function() {
            Kt.postMessage(null)
        }
    } else
        Vt = function() {
            xt(Dt, 0)
        }
        ;
    function Rt(Et) {
        Pt = Et,
        _t || (_t = !0,
        Vt())
    }
    function qt(Et, St) {
        kt = xt(function() {
            Et(d.unstable_now())
        }, St)
    }
    d.unstable_IdlePriority = 5,
    d.unstable_ImmediatePriority = 1,
    d.unstable_LowPriority = 4,
    d.unstable_NormalPriority = 3,
    d.unstable_Profiling = null,
    d.unstable_UserBlockingPriority = 2,
    d.unstable_cancelCallback = function(Et) {
        Et.callback = null
    }
    ,
    d.unstable_continueExecution = function() {
        ft || dt || (ft = !0,
        Rt(vt))
    }
    ,
    d.unstable_forceFrameRate = function(Et) {
        0 > Et || 125 < Et ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : $t = 0 < Et ? Math.floor(1e3 / Et) : 5
    }
    ,
    d.unstable_getCurrentPriorityLevel = function() {
        return st
    }
    ,
    d.unstable_getFirstCallbackNode = function() {
        return b(nt)
    }
    ,
    d.unstable_next = function(Et) {
        switch (st) {
        case 1:
        case 2:
        case 3:
            var St = 3;
            break;
        default:
            St = st
        }
        var Lt = st;
        st = St;
        try {
            return Et()
        } finally {
            st = Lt
        }
    }
    ,
    d.unstable_pauseExecution = function() {}
    ,
    d.unstable_requestPaint = function() {}
    ,
    d.unstable_runWithPriority = function(Et, St) {
        switch (Et) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            Et = 3
        }
        var Lt = st;
        st = Et;
        try {
            return St()
        } finally {
            st = Lt
        }
    }
    ,
    d.unstable_scheduleCallback = function(Et, St, Lt) {
        var Mt = d.unstable_now();
        switch (typeof Lt == "object" && Lt !== null ? (Lt = Lt.delay,
        Lt = typeof Lt == "number" && 0 < Lt ? Mt + Lt : Mt) : Lt = Mt,
        Et) {
        case 1:
            var ar = -1;
            break;
        case 2:
            ar = 250;
            break;
        case 5:
            ar = 1073741823;
            break;
        case 4:
            ar = 1e4;
            break;
        default:
            ar = 5e3
        }
        return ar = Lt + ar,
        Et = {
            id: ot++,
            callback: St,
            priorityLevel: Et,
            startTime: Lt,
            expirationTime: ar,
            sortIndex: -1
        },
        Lt > Mt ? (Et.sortIndex = Lt,
        g(it, Et),
        b(nt) === null && Et === b(it) && (ht ? (lt(kt),
        kt = -1) : ht = !0,
        qt(pt, Lt - Mt))) : (Et.sortIndex = ar,
        g(nt, Et),
        ft || dt || (ft = !0,
        Rt(vt))),
        Et
    }
    ,
    d.unstable_shouldYield = Ht,
    d.unstable_wrapCallback = function(Et) {
        var St = st;
        return function() {
            var Lt = st;
            st = St;
            try {
                return Et.apply(this, arguments)
            } finally {
                st = Lt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports;
function p$3(d) {
    for (var g = "https://reactjs.org/docs/error-decoder.html?invariant=" + d, b = 1; b < arguments.length; b++)
        g += "&args[]=" + encodeURIComponent(arguments[b]);
    return "Minified React error #" + d + "; visit " + g + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(d, g) {
    ha(d, g),
    ha(d + "Capture", g)
}
function ha(d, g) {
    for (ea[d] = g,
    d = 0; d < g.length; d++)
        da.add(g[d])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(d) {
    return ja.call(ma, d) ? !0 : ja.call(la, d) ? !1 : ka.test(d) ? ma[d] = !0 : (la[d] = !0,
    !1)
}
function pa(d, g, b, _) {
    if (b !== null && b.type === 0)
        return !1;
    switch (typeof g) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return _ ? !1 : b !== null ? !b.acceptsBooleans : (d = d.toLowerCase().slice(0, 5),
        d !== "data-" && d !== "aria-");
    default:
        return !1
    }
}
function qa(d, g, b, _) {
    if (g === null || typeof g > "u" || pa(d, g, b, _))
        return !0;
    if (_)
        return !1;
    if (b !== null)
        switch (b.type) {
        case 3:
            return !g;
        case 4:
            return g === !1;
        case 5:
            return isNaN(g);
        case 6:
            return isNaN(g) || 1 > g
        }
    return !1
}
function v$1(d, g, b, _, $, et, tt) {
    this.acceptsBooleans = g === 2 || g === 3 || g === 4,
    this.attributeName = _,
    this.attributeNamespace = $,
    this.mustUseProperty = b,
    this.propertyName = d,
    this.type = g,
    this.sanitizeURL = et,
    this.removeEmptyString = tt
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d) {
    z[d] = new v$1(d,0,!1,d,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(d) {
    var g = d[0];
    z[g] = new v$1(g,1,!1,d[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(d) {
    z[d] = new v$1(d,2,!1,d.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(d) {
    z[d] = new v$1(d,2,!1,d,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d) {
    z[d] = new v$1(d,3,!1,d.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(d) {
    z[d] = new v$1(d,3,!0,d,null,!1,!1)
});
["capture", "download"].forEach(function(d) {
    z[d] = new v$1(d,4,!1,d,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(d) {
    z[d] = new v$1(d,6,!1,d,null,!1,!1)
});
["rowSpan", "start"].forEach(function(d) {
    z[d] = new v$1(d,5,!1,d.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(d) {
    return d[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d) {
    var g = d.replace(ra, sa);
    z[g] = new v$1(g,1,!1,d,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d) {
    var g = d.replace(ra, sa);
    z[g] = new v$1(g,1,!1,d,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(d) {
    var g = d.replace(ra, sa);
    z[g] = new v$1(g,1,!1,d,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(d) {
    z[d] = new v$1(d,1,!1,d.toLowerCase(),null,!1,!1)
});
z.xlinkHref = new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(d) {
    z[d] = new v$1(d,1,!1,d.toLowerCase(),null,!0,!0)
});
function ta(d, g, b, _) {
    var $ = z.hasOwnProperty(g) ? z[g] : null;
    ($ !== null ? $.type !== 0 : _ || !(2 < g.length) || g[0] !== "o" && g[0] !== "O" || g[1] !== "n" && g[1] !== "N") && (qa(g, b, $, _) && (b = null),
    _ || $ === null ? oa(g) && (b === null ? d.removeAttribute(g) : d.setAttribute(g, "" + b)) : $.mustUseProperty ? d[$.propertyName] = b === null ? $.type === 3 ? !1 : "" : b : (g = $.attributeName,
    _ = $.attributeNamespace,
    b === null ? d.removeAttribute(g) : ($ = $.type,
    b = $ === 3 || $ === 4 && b === !0 ? "" : "" + b,
    _ ? d.setAttributeNS(_, g, b) : d.setAttribute(g, b))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(d) {
    return d === null || typeof d != "object" ? null : (d = Ja && d[Ja] || d["@@iterator"],
    typeof d == "function" ? d : null)
}
var A = Object.assign, La;
function Ma(d) {
    if (La === void 0)
        try {
            throw Error()
        } catch (b) {
            var g = b.stack.trim().match(/\n( *(at )?)/);
            La = g && g[1] || ""
        }
    return `
` + La + d
}
var Na = !1;
function Oa(d, g) {
    if (!d || Na)
        return "";
    Na = !0;
    var b = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (g)
            if (g = function() {
                throw Error()
            }
            ,
            Object.defineProperty(g.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(g, [])
                } catch (it) {
                    var _ = it
                }
                Reflect.construct(d, [], g)
            } else {
                try {
                    g.call()
                } catch (it) {
                    _ = it
                }
                d.call(g.prototype)
            }
        else {
            try {
                throw Error()
            } catch (it) {
                _ = it
            }
            d()
        }
    } catch (it) {
        if (it && _ && typeof it.stack == "string") {
            for (var $ = it.stack.split(`
`), et = _.stack.split(`
`), tt = $.length - 1, rt = et.length - 1; 1 <= tt && 0 <= rt && $[tt] !== et[rt]; )
                rt--;
            for (; 1 <= tt && 0 <= rt; tt--,
            rt--)
                if ($[tt] !== et[rt]) {
                    if (tt !== 1 || rt !== 1)
                        do
                            if (tt--,
                            rt--,
                            0 > rt || $[tt] !== et[rt]) {
                                var nt = `
` + $[tt].replace(" at new ", " at ");
                                return d.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", d.displayName)),
                                nt
                            }
                        while (1 <= tt && 0 <= rt);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = b
    }
    return (d = d ? d.displayName || d.name : "") ? Ma(d) : ""
}
function Pa(d) {
    switch (d.tag) {
    case 5:
        return Ma(d.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return d = Oa(d.type, !1),
        d;
    case 11:
        return d = Oa(d.type.render, !1),
        d;
    case 1:
        return d = Oa(d.type, !0),
        d;
    default:
        return ""
    }
}
function Qa(d) {
    if (d == null)
        return null;
    if (typeof d == "function")
        return d.displayName || d.name || null;
    if (typeof d == "string")
        return d;
    switch (d) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof d == "object")
        switch (d.$$typeof) {
        case Ca:
            return (d.displayName || "Context") + ".Consumer";
        case Ba:
            return (d._context.displayName || "Context") + ".Provider";
        case Da:
            var g = d.render;
            return d = d.displayName,
            d || (d = g.displayName || g.name || "",
            d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"),
            d;
        case Ga:
            return g = d.displayName || null,
            g !== null ? g : Qa(d.type) || "Memo";
        case Ha:
            g = d._payload,
            d = d._init;
            try {
                return Qa(d(g))
            } catch {}
        }
    return null
}
function Ra(d) {
    var g = d.type;
    switch (d.tag) {
    case 24:
        return "Cache";
    case 9:
        return (g.displayName || "Context") + ".Consumer";
    case 10:
        return (g._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return d = g.render,
        d = d.displayName || d.name || "",
        g.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return g;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa(g);
    case 8:
        return g === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof g == "function")
            return g.displayName || g.name || null;
        if (typeof g == "string")
            return g
    }
    return null
}
function Sa(d) {
    switch (typeof d) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return d;
    case "object":
        return d;
    default:
        return ""
    }
}
function Ta(d) {
    var g = d.type;
    return (d = d.nodeName) && d.toLowerCase() === "input" && (g === "checkbox" || g === "radio")
}
function Ua(d) {
    var g = Ta(d) ? "checked" : "value"
      , b = Object.getOwnPropertyDescriptor(d.constructor.prototype, g)
      , _ = "" + d[g];
    if (!d.hasOwnProperty(g) && typeof b < "u" && typeof b.get == "function" && typeof b.set == "function") {
        var $ = b.get
          , et = b.set;
        return Object.defineProperty(d, g, {
            configurable: !0,
            get: function() {
                return $.call(this)
            },
            set: function(tt) {
                _ = "" + tt,
                et.call(this, tt)
            }
        }),
        Object.defineProperty(d, g, {
            enumerable: b.enumerable
        }),
        {
            getValue: function() {
                return _
            },
            setValue: function(tt) {
                _ = "" + tt
            },
            stopTracking: function() {
                d._valueTracker = null,
                delete d[g]
            }
        }
    }
}
function Va(d) {
    d._valueTracker || (d._valueTracker = Ua(d))
}
function Wa(d) {
    if (!d)
        return !1;
    var g = d._valueTracker;
    if (!g)
        return !0;
    var b = g.getValue()
      , _ = "";
    return d && (_ = Ta(d) ? d.checked ? "true" : "false" : d.value),
    d = _,
    d !== b ? (g.setValue(d),
    !0) : !1
}
function Xa(d) {
    if (d = d || (typeof document < "u" ? document : void 0),
    typeof d > "u")
        return null;
    try {
        return d.activeElement || d.body
    } catch {
        return d.body
    }
}
function Ya(d, g) {
    var b = g.checked;
    return A({}, g, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: b ?? d._wrapperState.initialChecked
    })
}
function Za(d, g) {
    var b = g.defaultValue == null ? "" : g.defaultValue
      , _ = g.checked != null ? g.checked : g.defaultChecked;
    b = Sa(g.value != null ? g.value : b),
    d._wrapperState = {
        initialChecked: _,
        initialValue: b,
        controlled: g.type === "checkbox" || g.type === "radio" ? g.checked != null : g.value != null
    }
}
function ab(d, g) {
    g = g.checked,
    g != null && ta(d, "checked", g, !1)
}
function bb(d, g) {
    ab(d, g);
    var b = Sa(g.value)
      , _ = g.type;
    if (b != null)
        _ === "number" ? (b === 0 && d.value === "" || d.value != b) && (d.value = "" + b) : d.value !== "" + b && (d.value = "" + b);
    else if (_ === "submit" || _ === "reset") {
        d.removeAttribute("value");
        return
    }
    g.hasOwnProperty("value") ? cb(d, g.type, b) : g.hasOwnProperty("defaultValue") && cb(d, g.type, Sa(g.defaultValue)),
    g.checked == null && g.defaultChecked != null && (d.defaultChecked = !!g.defaultChecked)
}
function db(d, g, b) {
    if (g.hasOwnProperty("value") || g.hasOwnProperty("defaultValue")) {
        var _ = g.type;
        if (!(_ !== "submit" && _ !== "reset" || g.value !== void 0 && g.value !== null))
            return;
        g = "" + d._wrapperState.initialValue,
        b || g === d.value || (d.value = g),
        d.defaultValue = g
    }
    b = d.name,
    b !== "" && (d.name = ""),
    d.defaultChecked = !!d._wrapperState.initialChecked,
    b !== "" && (d.name = b)
}
function cb(d, g, b) {
    (g !== "number" || Xa(d.ownerDocument) !== d) && (b == null ? d.defaultValue = "" + d._wrapperState.initialValue : d.defaultValue !== "" + b && (d.defaultValue = "" + b))
}
var eb = Array.isArray;
function fb(d, g, b, _) {
    if (d = d.options,
    g) {
        g = {};
        for (var $ = 0; $ < b.length; $++)
            g["$" + b[$]] = !0;
        for (b = 0; b < d.length; b++)
            $ = g.hasOwnProperty("$" + d[b].value),
            d[b].selected !== $ && (d[b].selected = $),
            $ && _ && (d[b].defaultSelected = !0)
    } else {
        for (b = "" + Sa(b),
        g = null,
        $ = 0; $ < d.length; $++) {
            if (d[$].value === b) {
                d[$].selected = !0,
                _ && (d[$].defaultSelected = !0);
                return
            }
            g !== null || d[$].disabled || (g = d[$])
        }
        g !== null && (g.selected = !0)
    }
}
function gb(d, g) {
    if (g.dangerouslySetInnerHTML != null)
        throw Error(p$3(91));
    return A({}, g, {
        value: void 0,
        defaultValue: void 0,
        children: "" + d._wrapperState.initialValue
    })
}
function hb(d, g) {
    var b = g.value;
    if (b == null) {
        if (b = g.children,
        g = g.defaultValue,
        b != null) {
            if (g != null)
                throw Error(p$3(92));
            if (eb(b)) {
                if (1 < b.length)
                    throw Error(p$3(93));
                b = b[0]
            }
            g = b
        }
        g == null && (g = ""),
        b = g
    }
    d._wrapperState = {
        initialValue: Sa(b)
    }
}
function ib(d, g) {
    var b = Sa(g.value)
      , _ = Sa(g.defaultValue);
    b != null && (b = "" + b,
    b !== d.value && (d.value = b),
    g.defaultValue == null && d.defaultValue !== b && (d.defaultValue = b)),
    _ != null && (d.defaultValue = "" + _)
}
function jb(d) {
    var g = d.textContent;
    g === d._wrapperState.initialValue && g !== "" && g !== null && (d.value = g)
}
function kb(d) {
    switch (d) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(d, g) {
    return d == null || d === "http://www.w3.org/1999/xhtml" ? kb(g) : d === "http://www.w3.org/2000/svg" && g === "foreignObject" ? "http://www.w3.org/1999/xhtml" : d
}
var mb, nb = function(d) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(g, b, _, $) {
        MSApp.execUnsafeLocalFunction(function() {
            return d(g, b, _, $)
        })
    }
    : d
}(function(d, g) {
    if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in d)
        d.innerHTML = g;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + g.valueOf().toString() + "</svg>",
        g = mb.firstChild; d.firstChild; )
            d.removeChild(d.firstChild);
        for (; g.firstChild; )
            d.appendChild(g.firstChild)
    }
});
function ob(d, g) {
    if (g) {
        var b = d.firstChild;
        if (b && b === d.lastChild && b.nodeType === 3) {
            b.nodeValue = g;
            return
        }
    }
    d.textContent = g
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(d) {
    qb.forEach(function(g) {
        g = g + d.charAt(0).toUpperCase() + d.substring(1),
        pb[g] = pb[d]
    })
});
function rb(d, g, b) {
    return g == null || typeof g == "boolean" || g === "" ? "" : b || typeof g != "number" || g === 0 || pb.hasOwnProperty(d) && pb[d] ? ("" + g).trim() : g + "px"
}
function sb(d, g) {
    d = d.style;
    for (var b in g)
        if (g.hasOwnProperty(b)) {
            var _ = b.indexOf("--") === 0
              , $ = rb(b, g[b], _);
            b === "float" && (b = "cssFloat"),
            _ ? d.setProperty(b, $) : d[b] = $
        }
}
var tb = A({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(d, g) {
    if (g) {
        if (tb[d] && (g.children != null || g.dangerouslySetInnerHTML != null))
            throw Error(p$3(137, d));
        if (g.dangerouslySetInnerHTML != null) {
            if (g.children != null)
                throw Error(p$3(60));
            if (typeof g.dangerouslySetInnerHTML != "object" || !("__html"in g.dangerouslySetInnerHTML))
                throw Error(p$3(61))
        }
        if (g.style != null && typeof g.style != "object")
            throw Error(p$3(62))
    }
}
function vb(d, g) {
    if (d.indexOf("-") === -1)
        return typeof g.is == "string";
    switch (d) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(d) {
    return d = d.target || d.srcElement || window,
    d.correspondingUseElement && (d = d.correspondingUseElement),
    d.nodeType === 3 ? d.parentNode : d
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(d) {
    if (d = Cb(d)) {
        if (typeof yb != "function")
            throw Error(p$3(280));
        var g = d.stateNode;
        g && (g = Db(g),
        yb(d.stateNode, d.type, g))
    }
}
function Eb(d) {
    zb ? Ab ? Ab.push(d) : Ab = [d] : zb = d
}
function Fb() {
    if (zb) {
        var d = zb
          , g = Ab;
        if (Ab = zb = null,
        Bb(d),
        g)
            for (d = 0; d < g.length; d++)
                Bb(g[d])
    }
}
function Gb(d, g) {
    return d(g)
}
function Hb() {}
var Ib = !1;
function Jb(d, g, b) {
    if (Ib)
        return d(g, b);
    Ib = !0;
    try {
        return Gb(d, g, b)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(d, g) {
    var b = d.stateNode;
    if (b === null)
        return null;
    var _ = Db(b);
    if (_ === null)
        return null;
    b = _[g];
    e: switch (g) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (_ = !_.disabled) || (d = d.type,
        _ = !(d === "button" || d === "input" || d === "select" || d === "textarea")),
        d = !_;
        break e;
    default:
        d = !1
    }
    if (d)
        return null;
    if (b && typeof b != "function")
        throw Error(p$3(231, g, typeof b));
    return b
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(d, g, b, _, $, et, tt, rt, nt) {
    var it = Array.prototype.slice.call(arguments, 3);
    try {
        g.apply(b, it)
    } catch (ot) {
        this.onError(ot)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(d) {
        Ob = !0,
        Pb = d
    }
};
function Tb(d, g, b, _, $, et, tt, rt, nt) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(d, g, b, _, $, et, tt, rt, nt) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var it = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$3(198));
        Qb || (Qb = !0,
        Rb = it)
    }
}
function Vb(d) {
    var g = d
      , b = d;
    if (d.alternate)
        for (; g.return; )
            g = g.return;
    else {
        d = g;
        do
            g = d,
            g.flags & 4098 && (b = g.return),
            d = g.return;
        while (d)
    }
    return g.tag === 3 ? b : null
}
function Wb(d) {
    if (d.tag === 13) {
        var g = d.memoizedState;
        if (g === null && (d = d.alternate,
        d !== null && (g = d.memoizedState)),
        g !== null)
            return g.dehydrated
    }
    return null
}
function Xb(d) {
    if (Vb(d) !== d)
        throw Error(p$3(188))
}
function Yb(d) {
    var g = d.alternate;
    if (!g) {
        if (g = Vb(d),
        g === null)
            throw Error(p$3(188));
        return g !== d ? null : d
    }
    for (var b = d, _ = g; ; ) {
        var $ = b.return;
        if ($ === null)
            break;
        var et = $.alternate;
        if (et === null) {
            if (_ = $.return,
            _ !== null) {
                b = _;
                continue
            }
            break
        }
        if ($.child === et.child) {
            for (et = $.child; et; ) {
                if (et === b)
                    return Xb($),
                    d;
                if (et === _)
                    return Xb($),
                    g;
                et = et.sibling
            }
            throw Error(p$3(188))
        }
        if (b.return !== _.return)
            b = $,
            _ = et;
        else {
            for (var tt = !1, rt = $.child; rt; ) {
                if (rt === b) {
                    tt = !0,
                    b = $,
                    _ = et;
                    break
                }
                if (rt === _) {
                    tt = !0,
                    _ = $,
                    b = et;
                    break
                }
                rt = rt.sibling
            }
            if (!tt) {
                for (rt = et.child; rt; ) {
                    if (rt === b) {
                        tt = !0,
                        b = et,
                        _ = $;
                        break
                    }
                    if (rt === _) {
                        tt = !0,
                        _ = et,
                        b = $;
                        break
                    }
                    rt = rt.sibling
                }
                if (!tt)
                    throw Error(p$3(189))
            }
        }
        if (b.alternate !== _)
            throw Error(p$3(190))
    }
    if (b.tag !== 3)
        throw Error(p$3(188));
    return b.stateNode.current === b ? d : g
}
function Zb(d) {
    return d = Yb(d),
    d !== null ? $b(d) : null
}
function $b(d) {
    if (d.tag === 5 || d.tag === 6)
        return d;
    for (d = d.child; d !== null; ) {
        var g = $b(d);
        if (g !== null)
            return g;
        d = d.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(d) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, d, void 0, (d.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(d) {
    return d >>>= 0,
    d === 0 ? 32 : 31 - (pc(d) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(d) {
    switch (d & -d) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return d & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return d & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return d
    }
}
function uc(d, g) {
    var b = d.pendingLanes;
    if (b === 0)
        return 0;
    var _ = 0
      , $ = d.suspendedLanes
      , et = d.pingedLanes
      , tt = b & 268435455;
    if (tt !== 0) {
        var rt = tt & ~$;
        rt !== 0 ? _ = tc(rt) : (et &= tt,
        et !== 0 && (_ = tc(et)))
    } else
        tt = b & ~$,
        tt !== 0 ? _ = tc(tt) : et !== 0 && (_ = tc(et));
    if (_ === 0)
        return 0;
    if (g !== 0 && g !== _ && !(g & $) && ($ = _ & -_,
    et = g & -g,
    $ >= et || $ === 16 && (et & 4194240) !== 0))
        return g;
    if (_ & 4 && (_ |= b & 16),
    g = d.entangledLanes,
    g !== 0)
        for (d = d.entanglements,
        g &= _; 0 < g; )
            b = 31 - oc(g),
            $ = 1 << b,
            _ |= d[b],
            g &= ~$;
    return _
}
function vc(d, g) {
    switch (d) {
    case 1:
    case 2:
    case 4:
        return g + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return g + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(d, g) {
    for (var b = d.suspendedLanes, _ = d.pingedLanes, $ = d.expirationTimes, et = d.pendingLanes; 0 < et; ) {
        var tt = 31 - oc(et)
          , rt = 1 << tt
          , nt = $[tt];
        nt === -1 ? (!(rt & b) || rt & _) && ($[tt] = vc(rt, g)) : nt <= g && (d.expiredLanes |= rt),
        et &= ~rt
    }
}
function xc(d) {
    return d = d.pendingLanes & -1073741825,
    d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
}
function yc() {
    var d = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    d
}
function zc(d) {
    for (var g = [], b = 0; 31 > b; b++)
        g.push(d);
    return g
}
function Ac(d, g, b) {
    d.pendingLanes |= g,
    g !== 536870912 && (d.suspendedLanes = 0,
    d.pingedLanes = 0),
    d = d.eventTimes,
    g = 31 - oc(g),
    d[g] = b
}
function Bc(d, g) {
    var b = d.pendingLanes & ~g;
    d.pendingLanes = g,
    d.suspendedLanes = 0,
    d.pingedLanes = 0,
    d.expiredLanes &= g,
    d.mutableReadLanes &= g,
    d.entangledLanes &= g,
    g = d.entanglements;
    var _ = d.eventTimes;
    for (d = d.expirationTimes; 0 < b; ) {
        var $ = 31 - oc(b)
          , et = 1 << $;
        g[$] = 0,
        _[$] = -1,
        d[$] = -1,
        b &= ~et
    }
}
function Cc(d, g) {
    var b = d.entangledLanes |= g;
    for (d = d.entanglements; b; ) {
        var _ = 31 - oc(b)
          , $ = 1 << _;
        $ & g | d[_] & g && (d[_] |= g),
        b &= ~$
    }
}
var C = 0;
function Dc(d) {
    return d &= -d,
    1 < d ? 4 < d ? d & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(d, g) {
    switch (d) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete(g.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(g.pointerId)
    }
}
function Tc(d, g, b, _, $, et) {
    return d === null || d.nativeEvent !== et ? (d = {
        blockedOn: g,
        domEventName: b,
        eventSystemFlags: _,
        nativeEvent: et,
        targetContainers: [$]
    },
    g !== null && (g = Cb(g),
    g !== null && Fc(g)),
    d) : (d.eventSystemFlags |= _,
    g = d.targetContainers,
    $ !== null && g.indexOf($) === -1 && g.push($),
    d)
}
function Uc(d, g, b, _, $) {
    switch (g) {
    case "focusin":
        return Lc = Tc(Lc, d, g, b, _, $),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, d, g, b, _, $),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, d, g, b, _, $),
        !0;
    case "pointerover":
        var et = $.pointerId;
        return Oc.set(et, Tc(Oc.get(et) || null, d, g, b, _, $)),
        !0;
    case "gotpointercapture":
        return et = $.pointerId,
        Pc.set(et, Tc(Pc.get(et) || null, d, g, b, _, $)),
        !0
    }
    return !1
}
function Vc(d) {
    var g = Wc(d.target);
    if (g !== null) {
        var b = Vb(g);
        if (b !== null) {
            if (g = b.tag,
            g === 13) {
                if (g = Wb(b),
                g !== null) {
                    d.blockedOn = g,
                    Ic(d.priority, function() {
                        Gc(b)
                    });
                    return
                }
            } else if (g === 3 && b.stateNode.current.memoizedState.isDehydrated) {
                d.blockedOn = b.tag === 3 ? b.stateNode.containerInfo : null;
                return
            }
        }
    }
    d.blockedOn = null
}
function Xc(d) {
    if (d.blockedOn !== null)
        return !1;
    for (var g = d.targetContainers; 0 < g.length; ) {
        var b = Yc(d.domEventName, d.eventSystemFlags, g[0], d.nativeEvent);
        if (b === null) {
            b = d.nativeEvent;
            var _ = new b.constructor(b.type,b);
            wb = _,
            b.target.dispatchEvent(_),
            wb = null
        } else
            return g = Cb(b),
            g !== null && Fc(g),
            d.blockedOn = b,
            !1;
        g.shift()
    }
    return !0
}
function Zc(d, g, b) {
    Xc(d) && b.delete(g)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(d, g) {
    d.blockedOn === g && (d.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(d) {
    function g($) {
        return ad($, d)
    }
    if (0 < Kc.length) {
        ad(Kc[0], d);
        for (var b = 1; b < Kc.length; b++) {
            var _ = Kc[b];
            _.blockedOn === d && (_.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, d),
    Mc !== null && ad(Mc, d),
    Nc !== null && ad(Nc, d),
    Oc.forEach(g),
    Pc.forEach(g),
    b = 0; b < Qc.length; b++)
        _ = Qc[b],
        _.blockedOn === d && (_.blockedOn = null);
    for (; 0 < Qc.length && (b = Qc[0],
    b.blockedOn === null); )
        Vc(b),
        b.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(d, g, b, _) {
    var $ = C
      , et = cd.transition;
    cd.transition = null;
    try {
        C = 1,
        fd(d, g, b, _)
    } finally {
        C = $,
        cd.transition = et
    }
}
function gd(d, g, b, _) {
    var $ = C
      , et = cd.transition;
    cd.transition = null;
    try {
        C = 4,
        fd(d, g, b, _)
    } finally {
        C = $,
        cd.transition = et
    }
}
function fd(d, g, b, _) {
    if (dd) {
        var $ = Yc(d, g, b, _);
        if ($ === null)
            hd(d, g, _, id$4, b),
            Sc(d, _);
        else if (Uc($, d, g, b, _))
            _.stopPropagation();
        else if (Sc(d, _),
        g & 4 && -1 < Rc.indexOf(d)) {
            for (; $ !== null; ) {
                var et = Cb($);
                if (et !== null && Ec(et),
                et = Yc(d, g, b, _),
                et === null && hd(d, g, _, id$4, b),
                et === $)
                    break;
                $ = et
            }
            $ !== null && _.stopPropagation()
        } else
            hd(d, g, _, null, b)
    }
}
var id$4 = null;
function Yc(d, g, b, _) {
    if (id$4 = null,
    d = xb(_),
    d = Wc(d),
    d !== null)
        if (g = Vb(d),
        g === null)
            d = null;
        else if (b = g.tag,
        b === 13) {
            if (d = Wb(g),
            d !== null)
                return d;
            d = null
        } else if (b === 3) {
            if (g.stateNode.current.memoizedState.isDehydrated)
                return g.tag === 3 ? g.stateNode.containerInfo : null;
            d = null
        } else
            g !== d && (d = null);
    return id$4 = d,
    null
}
function jd(d) {
    switch (d) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var d, g = ld, b = g.length, _, $ = "value"in kd ? kd.value : kd.textContent, et = $.length;
    for (d = 0; d < b && g[d] === $[d]; d++)
        ;
    var tt = b - d;
    for (_ = 1; _ <= tt && g[b - _] === $[et - _]; _++)
        ;
    return md = $.slice(d, 1 < _ ? 1 - _ : void 0)
}
function od(d) {
    var g = d.keyCode;
    return "charCode"in d ? (d = d.charCode,
    d === 0 && g === 13 && (d = 13)) : d = g,
    d === 10 && (d = 13),
    32 <= d || d === 13 ? d : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(d) {
    function g(b, _, $, et, tt) {
        this._reactName = b,
        this._targetInst = $,
        this.type = _,
        this.nativeEvent = et,
        this.target = tt,
        this.currentTarget = null;
        for (var rt in d)
            d.hasOwnProperty(rt) && (b = d[rt],
            this[rt] = b ? b(et) : et[rt]);
        return this.isDefaultPrevented = (et.defaultPrevented != null ? et.defaultPrevented : et.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A(g.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var b = this.nativeEvent;
            b && (b.preventDefault ? b.preventDefault() : typeof b.returnValue != "unknown" && (b.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var b = this.nativeEvent;
            b && (b.stopPropagation ? b.stopPropagation() : typeof b.cancelBubble != "unknown" && (b.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    g
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(d) {
        return d.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(d) {
        return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget
    },
    movementX: function(d) {
        return "movementX"in d ? d.movementX : (d !== yd && (yd && d.type === "mousemove" ? (wd = d.screenX - yd.screenX,
        xd = d.screenY - yd.screenY) : xd = wd = 0,
        yd = d),
        wd)
    },
    movementY: function(d) {
        return "movementY"in d ? d.movementY : xd
    }
}), Bd = rd(Ad), Cd = A({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A({}, sd, {
    clipboardData: function(d) {
        return "clipboardData"in d ? d.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(d) {
    var g = this.nativeEvent;
    return g.getModifierState ? g.getModifierState(d) : (d = Od[d]) ? !!g[d] : !1
}
function zd() {
    return Pd
}
var Qd = A({}, ud, {
    key: function(d) {
        if (d.key) {
            var g = Md[d.key] || d.key;
            if (g !== "Unidentified")
                return g
        }
        return d.type === "keypress" ? (d = od(d),
        d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? Nd[d.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(d) {
        return d.type === "keypress" ? od(d) : 0
    },
    keyCode: function(d) {
        return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0
    },
    which: function(d) {
        return d.type === "keypress" ? od(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A({}, Ad, {
    deltaX: function(d) {
        return "deltaX"in d ? d.deltaX : "wheelDeltaX"in d ? -d.wheelDeltaX : 0
    },
    deltaY: function(d) {
        return "deltaY"in d ? d.deltaY : "wheelDeltaY"in d ? -d.wheelDeltaY : "wheelDelta"in d ? -d.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be = null;
ia && "documentMode"in document && (be = document.documentMode);
var ce = ia && "TextEvent"in window && !be
  , de = ia && (!ae || be && 8 < be && 11 >= be)
  , ee = String.fromCharCode(32)
  , fe = !1;
function ge(d, g) {
    switch (d) {
    case "keyup":
        return $d.indexOf(g.keyCode) !== -1;
    case "keydown":
        return g.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he(d) {
    return d = d.detail,
    typeof d == "object" && "data"in d ? d.data : null
}
var ie = !1;
function je(d, g) {
    switch (d) {
    case "compositionend":
        return he(g);
    case "keypress":
        return g.which !== 32 ? null : (fe = !0,
        ee);
    case "textInput":
        return d = g.data,
        d === ee && fe ? null : d;
    default:
        return null
    }
}
function ke(d, g) {
    if (ie)
        return d === "compositionend" || !ae && ge(d, g) ? (d = nd(),
        md = ld = kd = null,
        ie = !1,
        d) : null;
    switch (d) {
    case "paste":
        return null;
    case "keypress":
        if (!(g.ctrlKey || g.altKey || g.metaKey) || g.ctrlKey && g.altKey) {
            if (g.char && 1 < g.char.length)
                return g.char;
            if (g.which)
                return String.fromCharCode(g.which)
        }
        return null;
    case "compositionend":
        return de && g.locale !== "ko" ? null : g.data;
    default:
        return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(d) {
    var g = d && d.nodeName && d.nodeName.toLowerCase();
    return g === "input" ? !!le[d.type] : g === "textarea"
}
function ne(d, g, b, _) {
    Eb(_),
    g = oe(g, "onChange"),
    0 < g.length && (b = new td("onChange","change",null,b,_),
    d.push({
        event: b,
        listeners: g
    }))
}
var pe = null
  , qe = null;
function re(d) {
    se(d, 0)
}
function te(d) {
    var g = ue(d);
    if (Wa(g))
        return d
}
function ve(d, g) {
    if (d === "change")
        return g
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput"in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else
        xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be),
    qe = pe = null)
}
function Be(d) {
    if (d.propertyName === "value" && te(qe)) {
        var g = [];
        ne(g, qe, d, xb(d)),
        Jb(re, g)
    }
}
function Ce(d, g, b) {
    d === "focusin" ? (Ae(),
    pe = g,
    qe = b,
    pe.attachEvent("onpropertychange", Be)) : d === "focusout" && Ae()
}
function De(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown")
        return te(qe)
}
function Ee(d, g) {
    if (d === "click")
        return te(g)
}
function Fe(d, g) {
    if (d === "input" || d === "change")
        return te(g)
}
function Ge(d, g) {
    return d === g && (d !== 0 || 1 / d === 1 / g) || d !== d && g !== g
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(d, g) {
    if (He(d, g))
        return !0;
    if (typeof d != "object" || d === null || typeof g != "object" || g === null)
        return !1;
    var b = Object.keys(d)
      , _ = Object.keys(g);
    if (b.length !== _.length)
        return !1;
    for (_ = 0; _ < b.length; _++) {
        var $ = b[_];
        if (!ja.call(g, $) || !He(d[$], g[$]))
            return !1
    }
    return !0
}
function Je(d) {
    for (; d && d.firstChild; )
        d = d.firstChild;
    return d
}
function Ke(d, g) {
    var b = Je(d);
    d = 0;
    for (var _; b; ) {
        if (b.nodeType === 3) {
            if (_ = d + b.textContent.length,
            d <= g && _ >= g)
                return {
                    node: b,
                    offset: g - d
                };
            d = _
        }
        e: {
            for (; b; ) {
                if (b.nextSibling) {
                    b = b.nextSibling;
                    break e
                }
                b = b.parentNode
            }
            b = void 0
        }
        b = Je(b)
    }
}
function Le(d, g) {
    return d && g ? d === g ? !0 : d && d.nodeType === 3 ? !1 : g && g.nodeType === 3 ? Le(d, g.parentNode) : "contains"in d ? d.contains(g) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(g) & 16) : !1 : !1
}
function Me() {
    for (var d = window, g = Xa(); g instanceof d.HTMLIFrameElement; ) {
        try {
            var b = typeof g.contentWindow.location.href == "string"
        } catch {
            b = !1
        }
        if (b)
            d = g.contentWindow;
        else
            break;
        g = Xa(d.document)
    }
    return g
}
function Ne(d) {
    var g = d && d.nodeName && d.nodeName.toLowerCase();
    return g && (g === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || g === "textarea" || d.contentEditable === "true")
}
function Oe(d) {
    var g = Me()
      , b = d.focusedElem
      , _ = d.selectionRange;
    if (g !== b && b && b.ownerDocument && Le(b.ownerDocument.documentElement, b)) {
        if (_ !== null && Ne(b)) {
            if (g = _.start,
            d = _.end,
            d === void 0 && (d = g),
            "selectionStart"in b)
                b.selectionStart = g,
                b.selectionEnd = Math.min(d, b.value.length);
            else if (d = (g = b.ownerDocument || document) && g.defaultView || window,
            d.getSelection) {
                d = d.getSelection();
                var $ = b.textContent.length
                  , et = Math.min(_.start, $);
                _ = _.end === void 0 ? et : Math.min(_.end, $),
                !d.extend && et > _ && ($ = _,
                _ = et,
                et = $),
                $ = Ke(b, et);
                var tt = Ke(b, _);
                $ && tt && (d.rangeCount !== 1 || d.anchorNode !== $.node || d.anchorOffset !== $.offset || d.focusNode !== tt.node || d.focusOffset !== tt.offset) && (g = g.createRange(),
                g.setStart($.node, $.offset),
                d.removeAllRanges(),
                et > _ ? (d.addRange(g),
                d.extend(tt.node, tt.offset)) : (g.setEnd(tt.node, tt.offset),
                d.addRange(g)))
            }
        }
        for (g = [],
        d = b; d = d.parentNode; )
            d.nodeType === 1 && g.push({
                element: d,
                left: d.scrollLeft,
                top: d.scrollTop
            });
        for (typeof b.focus == "function" && b.focus(),
        b = 0; b < g.length; b++)
            d = g[b],
            d.element.scrollLeft = d.left,
            d.element.scrollTop = d.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se = null
  , Te = !1;
function Ue(d, g, b) {
    var _ = b.window === b ? b.document : b.nodeType === 9 ? b : b.ownerDocument;
    Te || Qe == null || Qe !== Xa(_) || (_ = Qe,
    "selectionStart"in _ && Ne(_) ? _ = {
        start: _.selectionStart,
        end: _.selectionEnd
    } : (_ = (_.ownerDocument && _.ownerDocument.defaultView || window).getSelection(),
    _ = {
        anchorNode: _.anchorNode,
        anchorOffset: _.anchorOffset,
        focusNode: _.focusNode,
        focusOffset: _.focusOffset
    }),
    Se && Ie(Se, _) || (Se = _,
    _ = oe(Re, "onSelect"),
    0 < _.length && (g = new td("onSelect","select",null,g,b),
    d.push({
        event: g,
        listeners: _
    }),
    g.target = Qe)))
}
function Ve(d, g) {
    var b = {};
    return b[d.toLowerCase()] = g.toLowerCase(),
    b["Webkit" + d] = "webkit" + g,
    b["Moz" + d] = "moz" + g,
    b
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(d) {
    if (Xe[d])
        return Xe[d];
    if (!We[d])
        return d;
    var g = We[d], b;
    for (b in g)
        if (g.hasOwnProperty(b) && b in Ye)
            return Xe[d] = g[b];
    return d
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(d, g) {
    df.set(d, g),
    fa(g, [d])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(d, g, b) {
    var _ = d.type || "unknown-event";
    d.currentTarget = b,
    Ub(_, g, void 0, d),
    d.currentTarget = null
}
function se(d, g) {
    g = (g & 4) !== 0;
    for (var b = 0; b < d.length; b++) {
        var _ = d[b]
          , $ = _.event;
        _ = _.listeners;
        e: {
            var et = void 0;
            if (g)
                for (var tt = _.length - 1; 0 <= tt; tt--) {
                    var rt = _[tt]
                      , nt = rt.instance
                      , it = rt.currentTarget;
                    if (rt = rt.listener,
                    nt !== et && $.isPropagationStopped())
                        break e;
                    nf($, rt, it),
                    et = nt
                }
            else
                for (tt = 0; tt < _.length; tt++) {
                    if (rt = _[tt],
                    nt = rt.instance,
                    it = rt.currentTarget,
                    rt = rt.listener,
                    nt !== et && $.isPropagationStopped())
                        break e;
                    nf($, rt, it),
                    et = nt
                }
        }
    }
    if (Qb)
        throw d = Rb,
        Qb = !1,
        Rb = null,
        d
}
function D(d, g) {
    var b = g[of];
    b === void 0 && (b = g[of] = new Set);
    var _ = d + "__bubble";
    b.has(_) || (pf(g, d, 2, !1),
    b.add(_))
}
function qf(d, g, b) {
    var _ = 0;
    g && (_ |= 4),
    pf(b, d, _, g)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(d) {
    if (!d[rf]) {
        d[rf] = !0,
        da.forEach(function(b) {
            b !== "selectionchange" && (mf.has(b) || qf(b, !1, d),
            qf(b, !0, d))
        });
        var g = d.nodeType === 9 ? d : d.ownerDocument;
        g === null || g[rf] || (g[rf] = !0,
        qf("selectionchange", !1, g))
    }
}
function pf(d, g, b, _) {
    switch (jd(g)) {
    case 1:
        var $ = ed;
        break;
    case 4:
        $ = gd;
        break;
    default:
        $ = fd
    }
    b = $.bind(null, g, b, d),
    $ = void 0,
    !Lb || g !== "touchstart" && g !== "touchmove" && g !== "wheel" || ($ = !0),
    _ ? $ !== void 0 ? d.addEventListener(g, b, {
        capture: !0,
        passive: $
    }) : d.addEventListener(g, b, !0) : $ !== void 0 ? d.addEventListener(g, b, {
        passive: $
    }) : d.addEventListener(g, b, !1)
}
function hd(d, g, b, _, $) {
    var et = _;
    if (!(g & 1) && !(g & 2) && _ !== null)
        e: for (; ; ) {
            if (_ === null)
                return;
            var tt = _.tag;
            if (tt === 3 || tt === 4) {
                var rt = _.stateNode.containerInfo;
                if (rt === $ || rt.nodeType === 8 && rt.parentNode === $)
                    break;
                if (tt === 4)
                    for (tt = _.return; tt !== null; ) {
                        var nt = tt.tag;
                        if ((nt === 3 || nt === 4) && (nt = tt.stateNode.containerInfo,
                        nt === $ || nt.nodeType === 8 && nt.parentNode === $))
                            return;
                        tt = tt.return
                    }
                for (; rt !== null; ) {
                    if (tt = Wc(rt),
                    tt === null)
                        return;
                    if (nt = tt.tag,
                    nt === 5 || nt === 6) {
                        _ = et = tt;
                        continue e
                    }
                    rt = rt.parentNode
                }
            }
            _ = _.return
        }
    Jb(function() {
        var it = et
          , ot = xb(b)
          , at = [];
        e: {
            var st = df.get(d);
            if (st !== void 0) {
                var dt = td
                  , ft = d;
                switch (d) {
                case "keypress":
                    if (od(b) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    dt = Rd;
                    break;
                case "focusin":
                    ft = "focus",
                    dt = Fd;
                    break;
                case "focusout":
                    ft = "blur",
                    dt = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    dt = Fd;
                    break;
                case "click":
                    if (b.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    dt = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    dt = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    dt = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    dt = Hd;
                    break;
                case cf:
                    dt = Xd;
                    break;
                case "scroll":
                    dt = vd;
                    break;
                case "wheel":
                    dt = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    dt = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    dt = Td
                }
                var ht = (g & 4) !== 0
                  , xt = !ht && d === "scroll"
                  , lt = ht ? st !== null ? st + "Capture" : null : st;
                ht = [];
                for (var ct = it, ut; ct !== null; ) {
                    ut = ct;
                    var pt = ut.stateNode;
                    if (ut.tag === 5 && pt !== null && (ut = pt,
                    lt !== null && (pt = Kb(ct, lt),
                    pt != null && ht.push(tf(ct, pt, ut)))),
                    xt)
                        break;
                    ct = ct.return
                }
                0 < ht.length && (st = new dt(st,ft,null,b,ot),
                at.push({
                    event: st,
                    listeners: ht
                }))
            }
        }
        if (!(g & 7)) {
            e: {
                if (st = d === "mouseover" || d === "pointerover",
                dt = d === "mouseout" || d === "pointerout",
                st && b !== wb && (ft = b.relatedTarget || b.fromElement) && (Wc(ft) || ft[uf]))
                    break e;
                if ((dt || st) && (st = ot.window === ot ? ot : (st = ot.ownerDocument) ? st.defaultView || st.parentWindow : window,
                dt ? (ft = b.relatedTarget || b.toElement,
                dt = it,
                ft = ft ? Wc(ft) : null,
                ft !== null && (xt = Vb(ft),
                ft !== xt || ft.tag !== 5 && ft.tag !== 6) && (ft = null)) : (dt = null,
                ft = it),
                dt !== ft)) {
                    if (ht = Bd,
                    pt = "onMouseLeave",
                    lt = "onMouseEnter",
                    ct = "mouse",
                    (d === "pointerout" || d === "pointerover") && (ht = Td,
                    pt = "onPointerLeave",
                    lt = "onPointerEnter",
                    ct = "pointer"),
                    xt = dt == null ? st : ue(dt),
                    ut = ft == null ? st : ue(ft),
                    st = new ht(pt,ct + "leave",dt,b,ot),
                    st.target = xt,
                    st.relatedTarget = ut,
                    pt = null,
                    Wc(ot) === it && (ht = new ht(lt,ct + "enter",ft,b,ot),
                    ht.target = ut,
                    ht.relatedTarget = xt,
                    pt = ht),
                    xt = pt,
                    dt && ft)
                        t: {
                            for (ht = dt,
                            lt = ft,
                            ct = 0,
                            ut = ht; ut; ut = vf(ut))
                                ct++;
                            for (ut = 0,
                            pt = lt; pt; pt = vf(pt))
                                ut++;
                            for (; 0 < ct - ut; )
                                ht = vf(ht),
                                ct--;
                            for (; 0 < ut - ct; )
                                lt = vf(lt),
                                ut--;
                            for (; ct--; ) {
                                if (ht === lt || lt !== null && ht === lt.alternate)
                                    break t;
                                ht = vf(ht),
                                lt = vf(lt)
                            }
                            ht = null
                        }
                    else
                        ht = null;
                    dt !== null && wf(at, st, dt, ht, !1),
                    ft !== null && xt !== null && wf(at, xt, ft, ht, !0)
                }
            }
            e: {
                if (st = it ? ue(it) : window,
                dt = st.nodeName && st.nodeName.toLowerCase(),
                dt === "select" || dt === "input" && st.type === "file")
                    var vt = ve;
                else if (me(st))
                    if (we)
                        vt = Fe;
                    else {
                        vt = De;
                        var _t = Ce
                    }
                else
                    (dt = st.nodeName) && dt.toLowerCase() === "input" && (st.type === "checkbox" || st.type === "radio") && (vt = Ee);
                if (vt && (vt = vt(d, it))) {
                    ne(at, vt, b, ot);
                    break e
                }
                _t && _t(d, st, it),
                d === "focusout" && (_t = st._wrapperState) && _t.controlled && st.type === "number" && cb(st, "number", st.value)
            }
            switch (_t = it ? ue(it) : window,
            d) {
            case "focusin":
                (me(_t) || _t.contentEditable === "true") && (Qe = _t,
                Re = it,
                Se = null);
                break;
            case "focusout":
                Se = Re = Qe = null;
                break;
            case "mousedown":
                Te = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te = !1,
                Ue(at, b, ot);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(at, b, ot)
            }
            var Pt;
            if (ae)
                e: {
                    switch (d) {
                    case "compositionstart":
                        var kt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        kt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        kt = "onCompositionUpdate";
                        break e
                    }
                    kt = void 0
                }
            else
                ie ? ge(d, b) && (kt = "onCompositionEnd") : d === "keydown" && b.keyCode === 229 && (kt = "onCompositionStart");
            kt && (de && b.locale !== "ko" && (ie || kt !== "onCompositionStart" ? kt === "onCompositionEnd" && ie && (Pt = nd()) : (kd = ot,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            _t = oe(it, kt),
            0 < _t.length && (kt = new Ld(kt,d,null,b,ot),
            at.push({
                event: kt,
                listeners: _t
            }),
            Pt ? kt.data = Pt : (Pt = he(b),
            Pt !== null && (kt.data = Pt)))),
            (Pt = ce ? je(d, b) : ke(d, b)) && (it = oe(it, "onBeforeInput"),
            0 < it.length && (ot = new Ld("onBeforeInput","beforeinput",null,b,ot),
            at.push({
                event: ot,
                listeners: it
            }),
            ot.data = Pt))
        }
        se(at, g)
    })
}
function tf(d, g, b) {
    return {
        instance: d,
        listener: g,
        currentTarget: b
    }
}
function oe(d, g) {
    for (var b = g + "Capture", _ = []; d !== null; ) {
        var $ = d
          , et = $.stateNode;
        $.tag === 5 && et !== null && ($ = et,
        et = Kb(d, b),
        et != null && _.unshift(tf(d, et, $)),
        et = Kb(d, g),
        et != null && _.push(tf(d, et, $))),
        d = d.return
    }
    return _
}
function vf(d) {
    if (d === null)
        return null;
    do
        d = d.return;
    while (d && d.tag !== 5);
    return d || null
}
function wf(d, g, b, _, $) {
    for (var et = g._reactName, tt = []; b !== null && b !== _; ) {
        var rt = b
          , nt = rt.alternate
          , it = rt.stateNode;
        if (nt !== null && nt === _)
            break;
        rt.tag === 5 && it !== null && (rt = it,
        $ ? (nt = Kb(b, et),
        nt != null && tt.unshift(tf(b, nt, rt))) : $ || (nt = Kb(b, et),
        nt != null && tt.push(tf(b, nt, rt)))),
        b = b.return
    }
    tt.length !== 0 && d.push({
        event: g,
        listeners: tt
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(d) {
    return (typeof d == "string" ? d : "" + d).replace(xf, `
`).replace(yf, "")
}
function Af(d, g, b) {
    if (g = zf(g),
    zf(d) !== g && b)
        throw Error(p$3(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(d, g) {
    return d === "textarea" || d === "noscript" || typeof g.children == "string" || typeof g.children == "number" || typeof g.dangerouslySetInnerHTML == "object" && g.dangerouslySetInnerHTML !== null && g.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(d) {
    return Hf.resolve(null).then(d).catch(If)
}
: Ff;
function If(d) {
    setTimeout(function() {
        throw d
    })
}
function Kf(d, g) {
    var b = g
      , _ = 0;
    do {
        var $ = b.nextSibling;
        if (d.removeChild(b),
        $ && $.nodeType === 8)
            if (b = $.data,
            b === "/$") {
                if (_ === 0) {
                    d.removeChild($),
                    bd(g);
                    return
                }
                _--
            } else
                b !== "$" && b !== "$?" && b !== "$!" || _++;
        b = $
    } while (b);
    bd(g)
}
function Lf(d) {
    for (; d != null; d = d.nextSibling) {
        var g = d.nodeType;
        if (g === 1 || g === 3)
            break;
        if (g === 8) {
            if (g = d.data,
            g === "$" || g === "$!" || g === "$?")
                break;
            if (g === "/$")
                return null
        }
    }
    return d
}
function Mf(d) {
    d = d.previousSibling;
    for (var g = 0; d; ) {
        if (d.nodeType === 8) {
            var b = d.data;
            if (b === "$" || b === "$!" || b === "$?") {
                if (g === 0)
                    return d;
                g--
            } else
                b === "/$" && g++
        }
        d = d.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(d) {
    var g = d[Of];
    if (g)
        return g;
    for (var b = d.parentNode; b; ) {
        if (g = b[uf] || b[Of]) {
            if (b = g.alternate,
            g.child !== null || b !== null && b.child !== null)
                for (d = Mf(d); d !== null; ) {
                    if (b = d[Of])
                        return b;
                    d = Mf(d)
                }
            return g
        }
        d = b,
        b = d.parentNode
    }
    return null
}
function Cb(d) {
    return d = d[Of] || d[uf],
    !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d
}
function ue(d) {
    if (d.tag === 5 || d.tag === 6)
        return d.stateNode;
    throw Error(p$3(33))
}
function Db(d) {
    return d[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(d) {
    return {
        current: d
    }
}
function E(d) {
    0 > Tf || (d.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(d, g) {
    Tf++,
    Sf[Tf] = d.current,
    d.current = g
}
var Vf = {}
  , H = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(d, g) {
    var b = d.type.contextTypes;
    if (!b)
        return Vf;
    var _ = d.stateNode;
    if (_ && _.__reactInternalMemoizedUnmaskedChildContext === g)
        return _.__reactInternalMemoizedMaskedChildContext;
    var $ = {}, et;
    for (et in b)
        $[et] = g[et];
    return _ && (d = d.stateNode,
    d.__reactInternalMemoizedUnmaskedChildContext = g,
    d.__reactInternalMemoizedMaskedChildContext = $),
    $
}
function Zf(d) {
    return d = d.childContextTypes,
    d != null
}
function $f() {
    E(Wf),
    E(H)
}
function ag(d, g, b) {
    if (H.current !== Vf)
        throw Error(p$3(168));
    G(H, g),
    G(Wf, b)
}
function bg(d, g, b) {
    var _ = d.stateNode;
    if (g = g.childContextTypes,
    typeof _.getChildContext != "function")
        return b;
    _ = _.getChildContext();
    for (var $ in _)
        if (!($ in g))
            throw Error(p$3(108, Ra(d) || "Unknown", $));
    return A({}, b, _)
}
function cg(d) {
    return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H.current,
    G(H, d),
    G(Wf, Wf.current),
    !0
}
function dg(d, g, b) {
    var _ = d.stateNode;
    if (!_)
        throw Error(p$3(169));
    b ? (d = bg(d, g, Xf),
    _.__reactInternalMemoizedMergedChildContext = d,
    E(Wf),
    E(H),
    G(H, d)) : E(Wf),
    G(Wf, b)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(d) {
    eg === null ? eg = [d] : eg.push(d)
}
function ig(d) {
    fg = !0,
    hg(d)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var d = 0
          , g = C;
        try {
            var b = eg;
            for (C = 1; d < b.length; d++) {
                var _ = b[d];
                do
                    _ = _(!0);
                while (_ !== null)
            }
            eg = null,
            fg = !1
        } catch ($) {
            throw eg !== null && (eg = eg.slice(d + 1)),
            ac(fc, jg),
            $
        } finally {
            C = g,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(d, g) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = d,
    ng = g
}
function ug(d, g, b) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = d;
    var _ = rg;
    d = sg;
    var $ = 32 - oc(_) - 1;
    _ &= ~(1 << $),
    b += 1;
    var et = 32 - oc(g) + $;
    if (30 < et) {
        var tt = $ - $ % 5;
        et = (_ & (1 << tt) - 1).toString(32),
        _ >>= tt,
        $ -= tt,
        rg = 1 << 32 - oc(g) + $ | b << $ | _,
        sg = et + d
    } else
        rg = 1 << et | b << $ | _,
        sg = d
}
function vg(d) {
    d.return !== null && (tg(d, 1),
    ug(d, 1, 0))
}
function wg(d) {
    for (; d === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; d === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I = !1
  , zg = null;
function Ag(d, g) {
    var b = Bg(5, null, null, 0);
    b.elementType = "DELETED",
    b.stateNode = g,
    b.return = d,
    g = d.deletions,
    g === null ? (d.deletions = [b],
    d.flags |= 16) : g.push(b)
}
function Cg(d, g) {
    switch (d.tag) {
    case 5:
        var b = d.type;
        return g = g.nodeType !== 1 || b.toLowerCase() !== g.nodeName.toLowerCase() ? null : g,
        g !== null ? (d.stateNode = g,
        xg = d,
        yg = Lf(g.firstChild),
        !0) : !1;
    case 6:
        return g = d.pendingProps === "" || g.nodeType !== 3 ? null : g,
        g !== null ? (d.stateNode = g,
        xg = d,
        yg = null,
        !0) : !1;
    case 13:
        return g = g.nodeType !== 8 ? null : g,
        g !== null ? (b = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        d.memoizedState = {
            dehydrated: g,
            treeContext: b,
            retryLane: 1073741824
        },
        b = Bg(18, null, null, 0),
        b.stateNode = g,
        b.return = d,
        d.child = b,
        xg = d,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0
}
function Eg(d) {
    if (I) {
        var g = yg;
        if (g) {
            var b = g;
            if (!Cg(d, g)) {
                if (Dg(d))
                    throw Error(p$3(418));
                g = Lf(b.nextSibling);
                var _ = xg;
                g && Cg(d, g) ? Ag(_, b) : (d.flags = d.flags & -4097 | 2,
                I = !1,
                xg = d)
            }
        } else {
            if (Dg(d))
                throw Error(p$3(418));
            d.flags = d.flags & -4097 | 2,
            I = !1,
            xg = d
        }
    }
}
function Fg(d) {
    for (d = d.return; d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13; )
        d = d.return;
    xg = d
}
function Gg(d) {
    if (d !== xg)
        return !1;
    if (!I)
        return Fg(d),
        I = !0,
        !1;
    var g;
    if ((g = d.tag !== 3) && !(g = d.tag !== 5) && (g = d.type,
    g = g !== "head" && g !== "body" && !Ef(d.type, d.memoizedProps)),
    g && (g = yg)) {
        if (Dg(d))
            throw Hg(),
            Error(p$3(418));
        for (; g; )
            Ag(d, g),
            g = Lf(g.nextSibling)
    }
    if (Fg(d),
    d.tag === 13) {
        if (d = d.memoizedState,
        d = d !== null ? d.dehydrated : null,
        !d)
            throw Error(p$3(317));
        e: {
            for (d = d.nextSibling,
            g = 0; d; ) {
                if (d.nodeType === 8) {
                    var b = d.data;
                    if (b === "/$") {
                        if (g === 0) {
                            yg = Lf(d.nextSibling);
                            break e
                        }
                        g--
                    } else
                        b !== "$" && b !== "$!" && b !== "$?" || g++
                }
                d = d.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(d.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var d = yg; d; )
        d = Lf(d.nextSibling)
}
function Ig() {
    yg = xg = null,
    I = !1
}
function Jg(d) {
    zg === null ? zg = [d] : zg.push(d)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(d, g, b) {
    if (d = b.ref,
    d !== null && typeof d != "function" && typeof d != "object") {
        if (b._owner) {
            if (b = b._owner,
            b) {
                if (b.tag !== 1)
                    throw Error(p$3(309));
                var _ = b.stateNode
            }
            if (!_)
                throw Error(p$3(147, d));
            var $ = _
              , et = "" + d;
            return g !== null && g.ref !== null && typeof g.ref == "function" && g.ref._stringRef === et ? g.ref : (g = function(tt) {
                var rt = $.refs;
                tt === null ? delete rt[et] : rt[et] = tt
            }
            ,
            g._stringRef = et,
            g)
        }
        if (typeof d != "string")
            throw Error(p$3(284));
        if (!b._owner)
            throw Error(p$3(290, d))
    }
    return d
}
function Mg(d, g) {
    throw d = Object.prototype.toString.call(g),
    Error(p$3(31, d === "[object Object]" ? "object with keys {" + Object.keys(g).join(", ") + "}" : d))
}
function Ng(d) {
    var g = d._init;
    return g(d._payload)
}
function Og(d) {
    function g(lt, ct) {
        if (d) {
            var ut = lt.deletions;
            ut === null ? (lt.deletions = [ct],
            lt.flags |= 16) : ut.push(ct)
        }
    }
    function b(lt, ct) {
        if (!d)
            return null;
        for (; ct !== null; )
            g(lt, ct),
            ct = ct.sibling;
        return null
    }
    function _(lt, ct) {
        for (lt = new Map; ct !== null; )
            ct.key !== null ? lt.set(ct.key, ct) : lt.set(ct.index, ct),
            ct = ct.sibling;
        return lt
    }
    function $(lt, ct) {
        return lt = Pg(lt, ct),
        lt.index = 0,
        lt.sibling = null,
        lt
    }
    function et(lt, ct, ut) {
        return lt.index = ut,
        d ? (ut = lt.alternate,
        ut !== null ? (ut = ut.index,
        ut < ct ? (lt.flags |= 2,
        ct) : ut) : (lt.flags |= 2,
        ct)) : (lt.flags |= 1048576,
        ct)
    }
    function tt(lt) {
        return d && lt.alternate === null && (lt.flags |= 2),
        lt
    }
    function rt(lt, ct, ut, pt) {
        return ct === null || ct.tag !== 6 ? (ct = Qg(ut, lt.mode, pt),
        ct.return = lt,
        ct) : (ct = $(ct, ut),
        ct.return = lt,
        ct)
    }
    function nt(lt, ct, ut, pt) {
        var vt = ut.type;
        return vt === ya ? ot(lt, ct, ut.props.children, pt, ut.key) : ct !== null && (ct.elementType === vt || typeof vt == "object" && vt !== null && vt.$$typeof === Ha && Ng(vt) === ct.type) ? (pt = $(ct, ut.props),
        pt.ref = Lg(lt, ct, ut),
        pt.return = lt,
        pt) : (pt = Rg(ut.type, ut.key, ut.props, null, lt.mode, pt),
        pt.ref = Lg(lt, ct, ut),
        pt.return = lt,
        pt)
    }
    function it(lt, ct, ut, pt) {
        return ct === null || ct.tag !== 4 || ct.stateNode.containerInfo !== ut.containerInfo || ct.stateNode.implementation !== ut.implementation ? (ct = Sg(ut, lt.mode, pt),
        ct.return = lt,
        ct) : (ct = $(ct, ut.children || []),
        ct.return = lt,
        ct)
    }
    function ot(lt, ct, ut, pt, vt) {
        return ct === null || ct.tag !== 7 ? (ct = Tg(ut, lt.mode, pt, vt),
        ct.return = lt,
        ct) : (ct = $(ct, ut),
        ct.return = lt,
        ct)
    }
    function at(lt, ct, ut) {
        if (typeof ct == "string" && ct !== "" || typeof ct == "number")
            return ct = Qg("" + ct, lt.mode, ut),
            ct.return = lt,
            ct;
        if (typeof ct == "object" && ct !== null) {
            switch (ct.$$typeof) {
            case va:
                return ut = Rg(ct.type, ct.key, ct.props, null, lt.mode, ut),
                ut.ref = Lg(lt, null, ct),
                ut.return = lt,
                ut;
            case wa:
                return ct = Sg(ct, lt.mode, ut),
                ct.return = lt,
                ct;
            case Ha:
                var pt = ct._init;
                return at(lt, pt(ct._payload), ut)
            }
            if (eb(ct) || Ka(ct))
                return ct = Tg(ct, lt.mode, ut, null),
                ct.return = lt,
                ct;
            Mg(lt, ct)
        }
        return null
    }
    function st(lt, ct, ut, pt) {
        var vt = ct !== null ? ct.key : null;
        if (typeof ut == "string" && ut !== "" || typeof ut == "number")
            return vt !== null ? null : rt(lt, ct, "" + ut, pt);
        if (typeof ut == "object" && ut !== null) {
            switch (ut.$$typeof) {
            case va:
                return ut.key === vt ? nt(lt, ct, ut, pt) : null;
            case wa:
                return ut.key === vt ? it(lt, ct, ut, pt) : null;
            case Ha:
                return vt = ut._init,
                st(lt, ct, vt(ut._payload), pt)
            }
            if (eb(ut) || Ka(ut))
                return vt !== null ? null : ot(lt, ct, ut, pt, null);
            Mg(lt, ut)
        }
        return null
    }
    function dt(lt, ct, ut, pt, vt) {
        if (typeof pt == "string" && pt !== "" || typeof pt == "number")
            return lt = lt.get(ut) || null,
            rt(ct, lt, "" + pt, vt);
        if (typeof pt == "object" && pt !== null) {
            switch (pt.$$typeof) {
            case va:
                return lt = lt.get(pt.key === null ? ut : pt.key) || null,
                nt(ct, lt, pt, vt);
            case wa:
                return lt = lt.get(pt.key === null ? ut : pt.key) || null,
                it(ct, lt, pt, vt);
            case Ha:
                var _t = pt._init;
                return dt(lt, ct, ut, _t(pt._payload), vt)
            }
            if (eb(pt) || Ka(pt))
                return lt = lt.get(ut) || null,
                ot(ct, lt, pt, vt, null);
            Mg(ct, pt)
        }
        return null
    }
    function ft(lt, ct, ut, pt) {
        for (var vt = null, _t = null, Pt = ct, kt = ct = 0, $t = null; Pt !== null && kt < ut.length; kt++) {
            Pt.index > kt ? ($t = Pt,
            Pt = null) : $t = Pt.sibling;
            var Wt = st(lt, Pt, ut[kt], pt);
            if (Wt === null) {
                Pt === null && (Pt = $t);
                break
            }
            d && Pt && Wt.alternate === null && g(lt, Pt),
            ct = et(Wt, ct, kt),
            _t === null ? vt = Wt : _t.sibling = Wt,
            _t = Wt,
            Pt = $t
        }
        if (kt === ut.length)
            return b(lt, Pt),
            I && tg(lt, kt),
            vt;
        if (Pt === null) {
            for (; kt < ut.length; kt++)
                Pt = at(lt, ut[kt], pt),
                Pt !== null && (ct = et(Pt, ct, kt),
                _t === null ? vt = Pt : _t.sibling = Pt,
                _t = Pt);
            return I && tg(lt, kt),
            vt
        }
        for (Pt = _(lt, Pt); kt < ut.length; kt++)
            $t = dt(Pt, lt, kt, ut[kt], pt),
            $t !== null && (d && $t.alternate !== null && Pt.delete($t.key === null ? kt : $t.key),
            ct = et($t, ct, kt),
            _t === null ? vt = $t : _t.sibling = $t,
            _t = $t);
        return d && Pt.forEach(function(Ht) {
            return g(lt, Ht)
        }),
        I && tg(lt, kt),
        vt
    }
    function ht(lt, ct, ut, pt) {
        var vt = Ka(ut);
        if (typeof vt != "function")
            throw Error(p$3(150));
        if (ut = vt.call(ut),
        ut == null)
            throw Error(p$3(151));
        for (var _t = vt = null, Pt = ct, kt = ct = 0, $t = null, Wt = ut.next(); Pt !== null && !Wt.done; kt++,
        Wt = ut.next()) {
            Pt.index > kt ? ($t = Pt,
            Pt = null) : $t = Pt.sibling;
            var Ht = st(lt, Pt, Wt.value, pt);
            if (Ht === null) {
                Pt === null && (Pt = $t);
                break
            }
            d && Pt && Ht.alternate === null && g(lt, Pt),
            ct = et(Ht, ct, kt),
            _t === null ? vt = Ht : _t.sibling = Ht,
            _t = Ht,
            Pt = $t
        }
        if (Wt.done)
            return b(lt, Pt),
            I && tg(lt, kt),
            vt;
        if (Pt === null) {
            for (; !Wt.done; kt++,
            Wt = ut.next())
                Wt = at(lt, Wt.value, pt),
                Wt !== null && (ct = et(Wt, ct, kt),
                _t === null ? vt = Wt : _t.sibling = Wt,
                _t = Wt);
            return I && tg(lt, kt),
            vt
        }
        for (Pt = _(lt, Pt); !Wt.done; kt++,
        Wt = ut.next())
            Wt = dt(Pt, lt, kt, Wt.value, pt),
            Wt !== null && (d && Wt.alternate !== null && Pt.delete(Wt.key === null ? kt : Wt.key),
            ct = et(Wt, ct, kt),
            _t === null ? vt = Wt : _t.sibling = Wt,
            _t = Wt);
        return d && Pt.forEach(function(Dt) {
            return g(lt, Dt)
        }),
        I && tg(lt, kt),
        vt
    }
    function xt(lt, ct, ut, pt) {
        if (typeof ut == "object" && ut !== null && ut.type === ya && ut.key === null && (ut = ut.props.children),
        typeof ut == "object" && ut !== null) {
            switch (ut.$$typeof) {
            case va:
                e: {
                    for (var vt = ut.key, _t = ct; _t !== null; ) {
                        if (_t.key === vt) {
                            if (vt = ut.type,
                            vt === ya) {
                                if (_t.tag === 7) {
                                    b(lt, _t.sibling),
                                    ct = $(_t, ut.props.children),
                                    ct.return = lt,
                                    lt = ct;
                                    break e
                                }
                            } else if (_t.elementType === vt || typeof vt == "object" && vt !== null && vt.$$typeof === Ha && Ng(vt) === _t.type) {
                                b(lt, _t.sibling),
                                ct = $(_t, ut.props),
                                ct.ref = Lg(lt, _t, ut),
                                ct.return = lt,
                                lt = ct;
                                break e
                            }
                            b(lt, _t);
                            break
                        } else
                            g(lt, _t);
                        _t = _t.sibling
                    }
                    ut.type === ya ? (ct = Tg(ut.props.children, lt.mode, pt, ut.key),
                    ct.return = lt,
                    lt = ct) : (pt = Rg(ut.type, ut.key, ut.props, null, lt.mode, pt),
                    pt.ref = Lg(lt, ct, ut),
                    pt.return = lt,
                    lt = pt)
                }
                return tt(lt);
            case wa:
                e: {
                    for (_t = ut.key; ct !== null; ) {
                        if (ct.key === _t)
                            if (ct.tag === 4 && ct.stateNode.containerInfo === ut.containerInfo && ct.stateNode.implementation === ut.implementation) {
                                b(lt, ct.sibling),
                                ct = $(ct, ut.children || []),
                                ct.return = lt,
                                lt = ct;
                                break e
                            } else {
                                b(lt, ct);
                                break
                            }
                        else
                            g(lt, ct);
                        ct = ct.sibling
                    }
                    ct = Sg(ut, lt.mode, pt),
                    ct.return = lt,
                    lt = ct
                }
                return tt(lt);
            case Ha:
                return _t = ut._init,
                xt(lt, ct, _t(ut._payload), pt)
            }
            if (eb(ut))
                return ft(lt, ct, ut, pt);
            if (Ka(ut))
                return ht(lt, ct, ut, pt);
            Mg(lt, ut)
        }
        return typeof ut == "string" && ut !== "" || typeof ut == "number" ? (ut = "" + ut,
        ct !== null && ct.tag === 6 ? (b(lt, ct.sibling),
        ct = $(ct, ut),
        ct.return = lt,
        lt = ct) : (b(lt, ct),
        ct = Qg(ut, lt.mode, pt),
        ct.return = lt,
        lt = ct),
        tt(lt)) : b(lt, ct)
    }
    return xt
}
var Ug = Og(!0)
  , Vg = Og(!1)
  , Wg = Uf(null)
  , Xg = null
  , Yg = null
  , Zg = null;
function $g() {
    Zg = Yg = Xg = null
}
function ah(d) {
    var g = Wg.current;
    E(Wg),
    d._currentValue = g
}
function bh(d, g, b) {
    for (; d !== null; ) {
        var _ = d.alternate;
        if ((d.childLanes & g) !== g ? (d.childLanes |= g,
        _ !== null && (_.childLanes |= g)) : _ !== null && (_.childLanes & g) !== g && (_.childLanes |= g),
        d === b)
            break;
        d = d.return
    }
}
function ch(d, g) {
    Xg = d,
    Zg = Yg = null,
    d = d.dependencies,
    d !== null && d.firstContext !== null && (d.lanes & g && (dh = !0),
    d.firstContext = null)
}
function eh(d) {
    var g = d._currentValue;
    if (Zg !== d)
        if (d = {
            context: d,
            memoizedValue: g,
            next: null
        },
        Yg === null) {
            if (Xg === null)
                throw Error(p$3(308));
            Yg = d,
            Xg.dependencies = {
                lanes: 0,
                firstContext: d
            }
        } else
            Yg = Yg.next = d;
    return g
}
var fh = null;
function gh(d) {
    fh === null ? fh = [d] : fh.push(d)
}
function hh(d, g, b, _) {
    var $ = g.interleaved;
    return $ === null ? (b.next = b,
    gh(g)) : (b.next = $.next,
    $.next = b),
    g.interleaved = b,
    ih(d, _)
}
function ih(d, g) {
    d.lanes |= g;
    var b = d.alternate;
    for (b !== null && (b.lanes |= g),
    b = d,
    d = d.return; d !== null; )
        d.childLanes |= g,
        b = d.alternate,
        b !== null && (b.childLanes |= g),
        b = d,
        d = d.return;
    return b.tag === 3 ? b.stateNode : null
}
var jh = !1;
function kh(d) {
    d.updateQueue = {
        baseState: d.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function lh(d, g) {
    d = d.updateQueue,
    g.updateQueue === d && (g.updateQueue = {
        baseState: d.baseState,
        firstBaseUpdate: d.firstBaseUpdate,
        lastBaseUpdate: d.lastBaseUpdate,
        shared: d.shared,
        effects: d.effects
    })
}
function mh(d, g) {
    return {
        eventTime: d,
        lane: g,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function nh(d, g, b) {
    var _ = d.updateQueue;
    if (_ === null)
        return null;
    if (_ = _.shared,
    K & 2) {
        var $ = _.pending;
        return $ === null ? g.next = g : (g.next = $.next,
        $.next = g),
        _.pending = g,
        ih(d, b)
    }
    return $ = _.interleaved,
    $ === null ? (g.next = g,
    gh(_)) : (g.next = $.next,
    $.next = g),
    _.interleaved = g,
    ih(d, b)
}
function oh(d, g, b) {
    if (g = g.updateQueue,
    g !== null && (g = g.shared,
    (b & 4194240) !== 0)) {
        var _ = g.lanes;
        _ &= d.pendingLanes,
        b |= _,
        g.lanes = b,
        Cc(d, b)
    }
}
function ph(d, g) {
    var b = d.updateQueue
      , _ = d.alternate;
    if (_ !== null && (_ = _.updateQueue,
    b === _)) {
        var $ = null
          , et = null;
        if (b = b.firstBaseUpdate,
        b !== null) {
            do {
                var tt = {
                    eventTime: b.eventTime,
                    lane: b.lane,
                    tag: b.tag,
                    payload: b.payload,
                    callback: b.callback,
                    next: null
                };
                et === null ? $ = et = tt : et = et.next = tt,
                b = b.next
            } while (b !== null);
            et === null ? $ = et = g : et = et.next = g
        } else
            $ = et = g;
        b = {
            baseState: _.baseState,
            firstBaseUpdate: $,
            lastBaseUpdate: et,
            shared: _.shared,
            effects: _.effects
        },
        d.updateQueue = b;
        return
    }
    d = b.lastBaseUpdate,
    d === null ? b.firstBaseUpdate = g : d.next = g,
    b.lastBaseUpdate = g
}
function qh(d, g, b, _) {
    var $ = d.updateQueue;
    jh = !1;
    var et = $.firstBaseUpdate
      , tt = $.lastBaseUpdate
      , rt = $.shared.pending;
    if (rt !== null) {
        $.shared.pending = null;
        var nt = rt
          , it = nt.next;
        nt.next = null,
        tt === null ? et = it : tt.next = it,
        tt = nt;
        var ot = d.alternate;
        ot !== null && (ot = ot.updateQueue,
        rt = ot.lastBaseUpdate,
        rt !== tt && (rt === null ? ot.firstBaseUpdate = it : rt.next = it,
        ot.lastBaseUpdate = nt))
    }
    if (et !== null) {
        var at = $.baseState;
        tt = 0,
        ot = it = nt = null,
        rt = et;
        do {
            var st = rt.lane
              , dt = rt.eventTime;
            if ((_ & st) === st) {
                ot !== null && (ot = ot.next = {
                    eventTime: dt,
                    lane: 0,
                    tag: rt.tag,
                    payload: rt.payload,
                    callback: rt.callback,
                    next: null
                });
                e: {
                    var ft = d
                      , ht = rt;
                    switch (st = g,
                    dt = b,
                    ht.tag) {
                    case 1:
                        if (ft = ht.payload,
                        typeof ft == "function") {
                            at = ft.call(dt, at, st);
                            break e
                        }
                        at = ft;
                        break e;
                    case 3:
                        ft.flags = ft.flags & -65537 | 128;
                    case 0:
                        if (ft = ht.payload,
                        st = typeof ft == "function" ? ft.call(dt, at, st) : ft,
                        st == null)
                            break e;
                        at = A({}, at, st);
                        break e;
                    case 2:
                        jh = !0
                    }
                }
                rt.callback !== null && rt.lane !== 0 && (d.flags |= 64,
                st = $.effects,
                st === null ? $.effects = [rt] : st.push(rt))
            } else
                dt = {
                    eventTime: dt,
                    lane: st,
                    tag: rt.tag,
                    payload: rt.payload,
                    callback: rt.callback,
                    next: null
                },
                ot === null ? (it = ot = dt,
                nt = at) : ot = ot.next = dt,
                tt |= st;
            if (rt = rt.next,
            rt === null) {
                if (rt = $.shared.pending,
                rt === null)
                    break;
                st = rt,
                rt = st.next,
                st.next = null,
                $.lastBaseUpdate = st,
                $.shared.pending = null
            }
        } while (1);
        if (ot === null && (nt = at),
        $.baseState = nt,
        $.firstBaseUpdate = it,
        $.lastBaseUpdate = ot,
        g = $.shared.interleaved,
        g !== null) {
            $ = g;
            do
                tt |= $.lane,
                $ = $.next;
            while ($ !== g)
        } else
            et === null && ($.shared.lanes = 0);
        rh |= tt,
        d.lanes = tt,
        d.memoizedState = at
    }
}
function sh(d, g, b) {
    if (d = g.effects,
    g.effects = null,
    d !== null)
        for (g = 0; g < d.length; g++) {
            var _ = d[g]
              , $ = _.callback;
            if ($ !== null) {
                if (_.callback = null,
                _ = b,
                typeof $ != "function")
                    throw Error(p$3(191, $));
                $.call(_)
            }
        }
}
var th = {}
  , uh = Uf(th)
  , vh$1 = Uf(th)
  , wh = Uf(th);
function xh(d) {
    if (d === th)
        throw Error(p$3(174));
    return d
}
function yh(d, g) {
    switch (G(wh, g),
    G(vh$1, d),
    G(uh, th),
    d = g.nodeType,
    d) {
    case 9:
    case 11:
        g = (g = g.documentElement) ? g.namespaceURI : lb(null, "");
        break;
    default:
        d = d === 8 ? g.parentNode : g,
        g = d.namespaceURI || null,
        d = d.tagName,
        g = lb(g, d)
    }
    E(uh),
    G(uh, g)
}
function zh() {
    E(uh),
    E(vh$1),
    E(wh)
}
function Ah(d) {
    xh(wh.current);
    var g = xh(uh.current)
      , b = lb(g, d.type);
    g !== b && (G(vh$1, d),
    G(uh, b))
}
function Bh(d) {
    vh$1.current === d && (E(uh),
    E(vh$1))
}
var L = Uf(0);
function Ch(d) {
    for (var g = d; g !== null; ) {
        if (g.tag === 13) {
            var b = g.memoizedState;
            if (b !== null && (b = b.dehydrated,
            b === null || b.data === "$?" || b.data === "$!"))
                return g
        } else if (g.tag === 19 && g.memoizedProps.revealOrder !== void 0) {
            if (g.flags & 128)
                return g
        } else if (g.child !== null) {
            g.child.return = g,
            g = g.child;
            continue
        }
        if (g === d)
            break;
        for (; g.sibling === null; ) {
            if (g.return === null || g.return === d)
                return null;
            g = g.return
        }
        g.sibling.return = g.return,
        g = g.sibling
    }
    return null
}
var Dh = [];
function Eh() {
    for (var d = 0; d < Dh.length; d++)
        Dh[d]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher
  , Gh = ua.ReactCurrentBatchConfig
  , Hh = 0
  , M = null
  , N = null
  , O = null
  , Ih = !1
  , Jh = !1
  , Kh = 0
  , Lh = 0;
function P$1() {
    throw Error(p$3(321))
}
function Mh(d, g) {
    if (g === null)
        return !1;
    for (var b = 0; b < g.length && b < d.length; b++)
        if (!He(d[b], g[b]))
            return !1;
    return !0
}
function Nh(d, g, b, _, $, et) {
    if (Hh = et,
    M = g,
    g.memoizedState = null,
    g.updateQueue = null,
    g.lanes = 0,
    Fh.current = d === null || d.memoizedState === null ? Oh : Ph,
    d = b(_, $),
    Jh) {
        et = 0;
        do {
            if (Jh = !1,
            Kh = 0,
            25 <= et)
                throw Error(p$3(301));
            et += 1,
            O = N = null,
            g.updateQueue = null,
            Fh.current = Qh,
            d = b(_, $)
        } while (Jh)
    }
    if (Fh.current = Rh,
    g = N !== null && N.next !== null,
    Hh = 0,
    O = N = M = null,
    Ih = !1,
    g)
        throw Error(p$3(300));
    return d
}
function Sh() {
    var d = Kh !== 0;
    return Kh = 0,
    d
}
function Th() {
    var d = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O === null ? M.memoizedState = O = d : O = O.next = d,
    O
}
function Uh() {
    if (N === null) {
        var d = M.alternate;
        d = d !== null ? d.memoizedState : null
    } else
        d = N.next;
    var g = O === null ? M.memoizedState : O.next;
    if (g !== null)
        O = g,
        N = d;
    else {
        if (d === null)
            throw Error(p$3(310));
        N = d,
        d = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null
        },
        O === null ? M.memoizedState = O = d : O = O.next = d
    }
    return O
}
function Vh(d, g) {
    return typeof g == "function" ? g(d) : g
}
function Wh(d) {
    var g = Uh()
      , b = g.queue;
    if (b === null)
        throw Error(p$3(311));
    b.lastRenderedReducer = d;
    var _ = N
      , $ = _.baseQueue
      , et = b.pending;
    if (et !== null) {
        if ($ !== null) {
            var tt = $.next;
            $.next = et.next,
            et.next = tt
        }
        _.baseQueue = $ = et,
        b.pending = null
    }
    if ($ !== null) {
        et = $.next,
        _ = _.baseState;
        var rt = tt = null
          , nt = null
          , it = et;
        do {
            var ot = it.lane;
            if ((Hh & ot) === ot)
                nt !== null && (nt = nt.next = {
                    lane: 0,
                    action: it.action,
                    hasEagerState: it.hasEagerState,
                    eagerState: it.eagerState,
                    next: null
                }),
                _ = it.hasEagerState ? it.eagerState : d(_, it.action);
            else {
                var at = {
                    lane: ot,
                    action: it.action,
                    hasEagerState: it.hasEagerState,
                    eagerState: it.eagerState,
                    next: null
                };
                nt === null ? (rt = nt = at,
                tt = _) : nt = nt.next = at,
                M.lanes |= ot,
                rh |= ot
            }
            it = it.next
        } while (it !== null && it !== et);
        nt === null ? tt = _ : nt.next = rt,
        He(_, g.memoizedState) || (dh = !0),
        g.memoizedState = _,
        g.baseState = tt,
        g.baseQueue = nt,
        b.lastRenderedState = _
    }
    if (d = b.interleaved,
    d !== null) {
        $ = d;
        do
            et = $.lane,
            M.lanes |= et,
            rh |= et,
            $ = $.next;
        while ($ !== d)
    } else
        $ === null && (b.lanes = 0);
    return [g.memoizedState, b.dispatch]
}
function Xh(d) {
    var g = Uh()
      , b = g.queue;
    if (b === null)
        throw Error(p$3(311));
    b.lastRenderedReducer = d;
    var _ = b.dispatch
      , $ = b.pending
      , et = g.memoizedState;
    if ($ !== null) {
        b.pending = null;
        var tt = $ = $.next;
        do
            et = d(et, tt.action),
            tt = tt.next;
        while (tt !== $);
        He(et, g.memoizedState) || (dh = !0),
        g.memoizedState = et,
        g.baseQueue === null && (g.baseState = et),
        b.lastRenderedState = et
    }
    return [et, _]
}
function Yh() {}
function Zh(d, g) {
    var b = M
      , _ = Uh()
      , $ = g()
      , et = !He(_.memoizedState, $);
    if (et && (_.memoizedState = $,
    dh = !0),
    _ = _.queue,
    $h(ai.bind(null, b, _, d), [d]),
    _.getSnapshot !== g || et || O !== null && O.memoizedState.tag & 1) {
        if (b.flags |= 2048,
        bi(9, ci.bind(null, b, _, $, g), void 0, null),
        Q === null)
            throw Error(p$3(349));
        Hh & 30 || di(b, g, $)
    }
    return $
}
function di(d, g, b) {
    d.flags |= 16384,
    d = {
        getSnapshot: g,
        value: b
    },
    g = M.updateQueue,
    g === null ? (g = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = g,
    g.stores = [d]) : (b = g.stores,
    b === null ? g.stores = [d] : b.push(d))
}
function ci(d, g, b, _) {
    g.value = b,
    g.getSnapshot = _,
    ei(g) && fi(d)
}
function ai(d, g, b) {
    return b(function() {
        ei(g) && fi(d)
    })
}
function ei(d) {
    var g = d.getSnapshot;
    d = d.value;
    try {
        var b = g();
        return !He(d, b)
    } catch {
        return !0
    }
}
function fi(d) {
    var g = ih(d, 1);
    g !== null && gi(g, d, 1, -1)
}
function hi(d) {
    var g = Th();
    return typeof d == "function" && (d = d()),
    g.memoizedState = g.baseState = d,
    d = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: d
    },
    g.queue = d,
    d = d.dispatch = ii.bind(null, M, d),
    [g.memoizedState, d]
}
function bi(d, g, b, _) {
    return d = {
        tag: d,
        create: g,
        destroy: b,
        deps: _,
        next: null
    },
    g = M.updateQueue,
    g === null ? (g = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = g,
    g.lastEffect = d.next = d) : (b = g.lastEffect,
    b === null ? g.lastEffect = d.next = d : (_ = b.next,
    b.next = d,
    d.next = _,
    g.lastEffect = d)),
    d
}
function ji() {
    return Uh().memoizedState
}
function ki(d, g, b, _) {
    var $ = Th();
    M.flags |= d,
    $.memoizedState = bi(1 | g, b, void 0, _ === void 0 ? null : _)
}
function li(d, g, b, _) {
    var $ = Uh();
    _ = _ === void 0 ? null : _;
    var et = void 0;
    if (N !== null) {
        var tt = N.memoizedState;
        if (et = tt.destroy,
        _ !== null && Mh(_, tt.deps)) {
            $.memoizedState = bi(g, b, et, _);
            return
        }
    }
    M.flags |= d,
    $.memoizedState = bi(1 | g, b, et, _)
}
function mi(d, g) {
    return ki(8390656, 8, d, g)
}
function $h(d, g) {
    return li(2048, 8, d, g)
}
function ni(d, g) {
    return li(4, 2, d, g)
}
function oi(d, g) {
    return li(4, 4, d, g)
}
function pi(d, g) {
    if (typeof g == "function")
        return d = d(),
        g(d),
        function() {
            g(null)
        }
        ;
    if (g != null)
        return d = d(),
        g.current = d,
        function() {
            g.current = null
        }
}
function qi(d, g, b) {
    return b = b != null ? b.concat([d]) : null,
    li(4, 4, pi.bind(null, g, d), b)
}
function ri() {}
function si(d, g) {
    var b = Uh();
    g = g === void 0 ? null : g;
    var _ = b.memoizedState;
    return _ !== null && g !== null && Mh(g, _[1]) ? _[0] : (b.memoizedState = [d, g],
    d)
}
function ti(d, g) {
    var b = Uh();
    g = g === void 0 ? null : g;
    var _ = b.memoizedState;
    return _ !== null && g !== null && Mh(g, _[1]) ? _[0] : (d = d(),
    b.memoizedState = [d, g],
    d)
}
function ui(d, g, b) {
    return Hh & 21 ? (He(b, g) || (b = yc(),
    M.lanes |= b,
    rh |= b,
    d.baseState = !0),
    g) : (d.baseState && (d.baseState = !1,
    dh = !0),
    d.memoizedState = b)
}
function vi(d, g) {
    var b = C;
    C = b !== 0 && 4 > b ? b : 4,
    d(!0);
    var _ = Gh.transition;
    Gh.transition = {};
    try {
        d(!1),
        g()
    } finally {
        C = b,
        Gh.transition = _
    }
}
function wi() {
    return Uh().memoizedState
}
function xi(d, g, b) {
    var _ = yi(d);
    if (b = {
        lane: _,
        action: b,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    zi(d))
        Ai(g, b);
    else if (b = hh(d, g, b, _),
    b !== null) {
        var $ = R();
        gi(b, d, _, $),
        Bi(b, g, _)
    }
}
function ii(d, g, b) {
    var _ = yi(d)
      , $ = {
        lane: _,
        action: b,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (zi(d))
        Ai(g, $);
    else {
        var et = d.alternate;
        if (d.lanes === 0 && (et === null || et.lanes === 0) && (et = g.lastRenderedReducer,
        et !== null))
            try {
                var tt = g.lastRenderedState
                  , rt = et(tt, b);
                if ($.hasEagerState = !0,
                $.eagerState = rt,
                He(rt, tt)) {
                    var nt = g.interleaved;
                    nt === null ? ($.next = $,
                    gh(g)) : ($.next = nt.next,
                    nt.next = $),
                    g.interleaved = $;
                    return
                }
            } catch {} finally {}
        b = hh(d, g, $, _),
        b !== null && ($ = R(),
        gi(b, d, _, $),
        Bi(b, g, _))
    }
}
function zi(d) {
    var g = d.alternate;
    return d === M || g !== null && g === M
}
function Ai(d, g) {
    Jh = Ih = !0;
    var b = d.pending;
    b === null ? g.next = g : (g.next = b.next,
    b.next = g),
    d.pending = g
}
function Bi(d, g, b) {
    if (b & 4194240) {
        var _ = g.lanes;
        _ &= d.pendingLanes,
        b |= _,
        g.lanes = b,
        Cc(d, b)
    }
}
var Rh = {
    readContext: eh,
    useCallback: P$1,
    useContext: P$1,
    useEffect: P$1,
    useImperativeHandle: P$1,
    useInsertionEffect: P$1,
    useLayoutEffect: P$1,
    useMemo: P$1,
    useReducer: P$1,
    useRef: P$1,
    useState: P$1,
    useDebugValue: P$1,
    useDeferredValue: P$1,
    useTransition: P$1,
    useMutableSource: P$1,
    useSyncExternalStore: P$1,
    useId: P$1,
    unstable_isNewReconciler: !1
}
  , Oh = {
    readContext: eh,
    useCallback: function(d, g) {
        return Th().memoizedState = [d, g === void 0 ? null : g],
        d
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function(d, g, b) {
        return b = b != null ? b.concat([d]) : null,
        ki(4194308, 4, pi.bind(null, g, d), b)
    },
    useLayoutEffect: function(d, g) {
        return ki(4194308, 4, d, g)
    },
    useInsertionEffect: function(d, g) {
        return ki(4, 2, d, g)
    },
    useMemo: function(d, g) {
        var b = Th();
        return g = g === void 0 ? null : g,
        d = d(),
        b.memoizedState = [d, g],
        d
    },
    useReducer: function(d, g, b) {
        var _ = Th();
        return g = b !== void 0 ? b(g) : g,
        _.memoizedState = _.baseState = g,
        d = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: d,
            lastRenderedState: g
        },
        _.queue = d,
        d = d.dispatch = xi.bind(null, M, d),
        [_.memoizedState, d]
    },
    useRef: function(d) {
        var g = Th();
        return d = {
            current: d
        },
        g.memoizedState = d
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function(d) {
        return Th().memoizedState = d
    },
    useTransition: function() {
        var d = hi(!1)
          , g = d[0];
        return d = vi.bind(null, d[1]),
        Th().memoizedState = d,
        [g, d]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(d, g, b) {
        var _ = M
          , $ = Th();
        if (I) {
            if (b === void 0)
                throw Error(p$3(407));
            b = b()
        } else {
            if (b = g(),
            Q === null)
                throw Error(p$3(349));
            Hh & 30 || di(_, g, b)
        }
        $.memoizedState = b;
        var et = {
            value: b,
            getSnapshot: g
        };
        return $.queue = et,
        mi(ai.bind(null, _, et, d), [d]),
        _.flags |= 2048,
        bi(9, ci.bind(null, _, et, b, g), void 0, null),
        b
    },
    useId: function() {
        var d = Th()
          , g = Q.identifierPrefix;
        if (I) {
            var b = sg
              , _ = rg;
            b = (_ & ~(1 << 32 - oc(_) - 1)).toString(32) + b,
            g = ":" + g + "R" + b,
            b = Kh++,
            0 < b && (g += "H" + b.toString(32)),
            g += ":"
        } else
            b = Lh++,
            g = ":" + g + "r" + b.toString(32) + ":";
        return d.memoizedState = g
    },
    unstable_isNewReconciler: !1
}
  , Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
        return Wh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(d) {
        var g = Uh();
        return ui(g, N.memoizedState, d)
    },
    useTransition: function() {
        var d = Wh(Vh)[0]
          , g = Uh().memoizedState;
        return [d, g]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
}
  , Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
        return Xh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(d) {
        var g = Uh();
        return N === null ? g.memoizedState = d : ui(g, N.memoizedState, d)
    },
    useTransition: function() {
        var d = Xh(Vh)[0]
          , g = Uh().memoizedState;
        return [d, g]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
};
function Ci(d, g) {
    if (d && d.defaultProps) {
        g = A({}, g),
        d = d.defaultProps;
        for (var b in d)
            g[b] === void 0 && (g[b] = d[b]);
        return g
    }
    return g
}
function Di(d, g, b, _) {
    g = d.memoizedState,
    b = b(_, g),
    b = b == null ? g : A({}, g, b),
    d.memoizedState = b,
    d.lanes === 0 && (d.updateQueue.baseState = b)
}
var Ei = {
    isMounted: function(d) {
        return (d = d._reactInternals) ? Vb(d) === d : !1
    },
    enqueueSetState: function(d, g, b) {
        d = d._reactInternals;
        var _ = R()
          , $ = yi(d)
          , et = mh(_, $);
        et.payload = g,
        b != null && (et.callback = b),
        g = nh(d, et, $),
        g !== null && (gi(g, d, $, _),
        oh(g, d, $))
    },
    enqueueReplaceState: function(d, g, b) {
        d = d._reactInternals;
        var _ = R()
          , $ = yi(d)
          , et = mh(_, $);
        et.tag = 1,
        et.payload = g,
        b != null && (et.callback = b),
        g = nh(d, et, $),
        g !== null && (gi(g, d, $, _),
        oh(g, d, $))
    },
    enqueueForceUpdate: function(d, g) {
        d = d._reactInternals;
        var b = R()
          , _ = yi(d)
          , $ = mh(b, _);
        $.tag = 2,
        g != null && ($.callback = g),
        g = nh(d, $, _),
        g !== null && (gi(g, d, _, b),
        oh(g, d, _))
    }
};
function Fi(d, g, b, _, $, et, tt) {
    return d = d.stateNode,
    typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(_, et, tt) : g.prototype && g.prototype.isPureReactComponent ? !Ie(b, _) || !Ie($, et) : !0
}
function Gi(d, g, b) {
    var _ = !1
      , $ = Vf
      , et = g.contextType;
    return typeof et == "object" && et !== null ? et = eh(et) : ($ = Zf(g) ? Xf : H.current,
    _ = g.contextTypes,
    et = (_ = _ != null) ? Yf(d, $) : Vf),
    g = new g(b,et),
    d.memoizedState = g.state !== null && g.state !== void 0 ? g.state : null,
    g.updater = Ei,
    d.stateNode = g,
    g._reactInternals = d,
    _ && (d = d.stateNode,
    d.__reactInternalMemoizedUnmaskedChildContext = $,
    d.__reactInternalMemoizedMaskedChildContext = et),
    g
}
function Hi(d, g, b, _) {
    d = g.state,
    typeof g.componentWillReceiveProps == "function" && g.componentWillReceiveProps(b, _),
    typeof g.UNSAFE_componentWillReceiveProps == "function" && g.UNSAFE_componentWillReceiveProps(b, _),
    g.state !== d && Ei.enqueueReplaceState(g, g.state, null)
}
function Ii(d, g, b, _) {
    var $ = d.stateNode;
    $.props = b,
    $.state = d.memoizedState,
    $.refs = {},
    kh(d);
    var et = g.contextType;
    typeof et == "object" && et !== null ? $.context = eh(et) : (et = Zf(g) ? Xf : H.current,
    $.context = Yf(d, et)),
    $.state = d.memoizedState,
    et = g.getDerivedStateFromProps,
    typeof et == "function" && (Di(d, g, et, b),
    $.state = d.memoizedState),
    typeof g.getDerivedStateFromProps == "function" || typeof $.getSnapshotBeforeUpdate == "function" || typeof $.UNSAFE_componentWillMount != "function" && typeof $.componentWillMount != "function" || (g = $.state,
    typeof $.componentWillMount == "function" && $.componentWillMount(),
    typeof $.UNSAFE_componentWillMount == "function" && $.UNSAFE_componentWillMount(),
    g !== $.state && Ei.enqueueReplaceState($, $.state, null),
    qh(d, b, $, _),
    $.state = d.memoizedState),
    typeof $.componentDidMount == "function" && (d.flags |= 4194308)
}
function Ji(d, g) {
    try {
        var b = ""
          , _ = g;
        do
            b += Pa(_),
            _ = _.return;
        while (_);
        var $ = b
    } catch (et) {
        $ = `
Error generating stack: ` + et.message + `
` + et.stack
    }
    return {
        value: d,
        source: g,
        stack: $,
        digest: null
    }
}
function Ki(d, g, b) {
    return {
        value: d,
        source: null,
        stack: b ?? null,
        digest: g ?? null
    }
}
function Li(d, g) {
    try {
        console.error(g.value)
    } catch (b) {
        setTimeout(function() {
            throw b
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(d, g, b) {
    b = mh(-1, b),
    b.tag = 3,
    b.payload = {
        element: null
    };
    var _ = g.value;
    return b.callback = function() {
        Oi || (Oi = !0,
        Pi = _),
        Li(d, g)
    }
    ,
    b
}
function Qi(d, g, b) {
    b = mh(-1, b),
    b.tag = 3;
    var _ = d.type.getDerivedStateFromError;
    if (typeof _ == "function") {
        var $ = g.value;
        b.payload = function() {
            return _($)
        }
        ,
        b.callback = function() {
            Li(d, g)
        }
    }
    var et = d.stateNode;
    return et !== null && typeof et.componentDidCatch == "function" && (b.callback = function() {
        Li(d, g),
        typeof _ != "function" && (Ri === null ? Ri = new Set([this]) : Ri.add(this));
        var tt = g.stack;
        this.componentDidCatch(g.value, {
            componentStack: tt !== null ? tt : ""
        })
    }
    ),
    b
}
function Si(d, g, b) {
    var _ = d.pingCache;
    if (_ === null) {
        _ = d.pingCache = new Mi;
        var $ = new Set;
        _.set(g, $)
    } else
        $ = _.get(g),
        $ === void 0 && ($ = new Set,
        _.set(g, $));
    $.has(b) || ($.add(b),
    d = Ti.bind(null, d, g, b),
    g.then(d, d))
}
function Ui(d) {
    do {
        var g;
        if ((g = d.tag === 13) && (g = d.memoizedState,
        g = g !== null ? g.dehydrated !== null : !0),
        g)
            return d;
        d = d.return
    } while (d !== null);
    return null
}
function Vi(d, g, b, _, $) {
    return d.mode & 1 ? (d.flags |= 65536,
    d.lanes = $,
    d) : (d === g ? d.flags |= 65536 : (d.flags |= 128,
    b.flags |= 131072,
    b.flags &= -52805,
    b.tag === 1 && (b.alternate === null ? b.tag = 17 : (g = mh(-1, 1),
    g.tag = 2,
    nh(b, g, 1))),
    b.lanes |= 1),
    d)
}
var Wi = ua.ReactCurrentOwner
  , dh = !1;
function Xi(d, g, b, _) {
    g.child = d === null ? Vg(g, null, b, _) : Ug(g, d.child, b, _)
}
function Yi(d, g, b, _, $) {
    b = b.render;
    var et = g.ref;
    return ch(g, $),
    _ = Nh(d, g, b, _, et, $),
    b = Sh(),
    d !== null && !dh ? (g.updateQueue = d.updateQueue,
    g.flags &= -2053,
    d.lanes &= ~$,
    Zi(d, g, $)) : (I && b && vg(g),
    g.flags |= 1,
    Xi(d, g, _, $),
    g.child)
}
function $i(d, g, b, _, $) {
    if (d === null) {
        var et = b.type;
        return typeof et == "function" && !aj(et) && et.defaultProps === void 0 && b.compare === null && b.defaultProps === void 0 ? (g.tag = 15,
        g.type = et,
        bj(d, g, et, _, $)) : (d = Rg(b.type, null, _, g, g.mode, $),
        d.ref = g.ref,
        d.return = g,
        g.child = d)
    }
    if (et = d.child,
    !(d.lanes & $)) {
        var tt = et.memoizedProps;
        if (b = b.compare,
        b = b !== null ? b : Ie,
        b(tt, _) && d.ref === g.ref)
            return Zi(d, g, $)
    }
    return g.flags |= 1,
    d = Pg(et, _),
    d.ref = g.ref,
    d.return = g,
    g.child = d
}
function bj(d, g, b, _, $) {
    if (d !== null) {
        var et = d.memoizedProps;
        if (Ie(et, _) && d.ref === g.ref)
            if (dh = !1,
            g.pendingProps = _ = et,
            (d.lanes & $) !== 0)
                d.flags & 131072 && (dh = !0);
            else
                return g.lanes = d.lanes,
                Zi(d, g, $)
    }
    return cj(d, g, b, _, $)
}
function dj(d, g, b) {
    var _ = g.pendingProps
      , $ = _.children
      , et = d !== null ? d.memoizedState : null;
    if (_.mode === "hidden")
        if (!(g.mode & 1))
            g.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(ej, fj),
            fj |= b;
        else {
            if (!(b & 1073741824))
                return d = et !== null ? et.baseLanes | b : b,
                g.lanes = g.childLanes = 1073741824,
                g.memoizedState = {
                    baseLanes: d,
                    cachePool: null,
                    transitions: null
                },
                g.updateQueue = null,
                G(ej, fj),
                fj |= d,
                null;
            g.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            _ = et !== null ? et.baseLanes : b,
            G(ej, fj),
            fj |= _
        }
    else
        et !== null ? (_ = et.baseLanes | b,
        g.memoizedState = null) : _ = b,
        G(ej, fj),
        fj |= _;
    return Xi(d, g, $, b),
    g.child
}
function gj(d, g) {
    var b = g.ref;
    (d === null && b !== null || d !== null && d.ref !== b) && (g.flags |= 512,
    g.flags |= 2097152)
}
function cj(d, g, b, _, $) {
    var et = Zf(b) ? Xf : H.current;
    return et = Yf(g, et),
    ch(g, $),
    b = Nh(d, g, b, _, et, $),
    _ = Sh(),
    d !== null && !dh ? (g.updateQueue = d.updateQueue,
    g.flags &= -2053,
    d.lanes &= ~$,
    Zi(d, g, $)) : (I && _ && vg(g),
    g.flags |= 1,
    Xi(d, g, b, $),
    g.child)
}
function hj(d, g, b, _, $) {
    if (Zf(b)) {
        var et = !0;
        cg(g)
    } else
        et = !1;
    if (ch(g, $),
    g.stateNode === null)
        ij(d, g),
        Gi(g, b, _),
        Ii(g, b, _, $),
        _ = !0;
    else if (d === null) {
        var tt = g.stateNode
          , rt = g.memoizedProps;
        tt.props = rt;
        var nt = tt.context
          , it = b.contextType;
        typeof it == "object" && it !== null ? it = eh(it) : (it = Zf(b) ? Xf : H.current,
        it = Yf(g, it));
        var ot = b.getDerivedStateFromProps
          , at = typeof ot == "function" || typeof tt.getSnapshotBeforeUpdate == "function";
        at || typeof tt.UNSAFE_componentWillReceiveProps != "function" && typeof tt.componentWillReceiveProps != "function" || (rt !== _ || nt !== it) && Hi(g, tt, _, it),
        jh = !1;
        var st = g.memoizedState;
        tt.state = st,
        qh(g, _, tt, $),
        nt = g.memoizedState,
        rt !== _ || st !== nt || Wf.current || jh ? (typeof ot == "function" && (Di(g, b, ot, _),
        nt = g.memoizedState),
        (rt = jh || Fi(g, b, rt, _, st, nt, it)) ? (at || typeof tt.UNSAFE_componentWillMount != "function" && typeof tt.componentWillMount != "function" || (typeof tt.componentWillMount == "function" && tt.componentWillMount(),
        typeof tt.UNSAFE_componentWillMount == "function" && tt.UNSAFE_componentWillMount()),
        typeof tt.componentDidMount == "function" && (g.flags |= 4194308)) : (typeof tt.componentDidMount == "function" && (g.flags |= 4194308),
        g.memoizedProps = _,
        g.memoizedState = nt),
        tt.props = _,
        tt.state = nt,
        tt.context = it,
        _ = rt) : (typeof tt.componentDidMount == "function" && (g.flags |= 4194308),
        _ = !1)
    } else {
        tt = g.stateNode,
        lh(d, g),
        rt = g.memoizedProps,
        it = g.type === g.elementType ? rt : Ci(g.type, rt),
        tt.props = it,
        at = g.pendingProps,
        st = tt.context,
        nt = b.contextType,
        typeof nt == "object" && nt !== null ? nt = eh(nt) : (nt = Zf(b) ? Xf : H.current,
        nt = Yf(g, nt));
        var dt = b.getDerivedStateFromProps;
        (ot = typeof dt == "function" || typeof tt.getSnapshotBeforeUpdate == "function") || typeof tt.UNSAFE_componentWillReceiveProps != "function" && typeof tt.componentWillReceiveProps != "function" || (rt !== at || st !== nt) && Hi(g, tt, _, nt),
        jh = !1,
        st = g.memoizedState,
        tt.state = st,
        qh(g, _, tt, $);
        var ft = g.memoizedState;
        rt !== at || st !== ft || Wf.current || jh ? (typeof dt == "function" && (Di(g, b, dt, _),
        ft = g.memoizedState),
        (it = jh || Fi(g, b, it, _, st, ft, nt) || !1) ? (ot || typeof tt.UNSAFE_componentWillUpdate != "function" && typeof tt.componentWillUpdate != "function" || (typeof tt.componentWillUpdate == "function" && tt.componentWillUpdate(_, ft, nt),
        typeof tt.UNSAFE_componentWillUpdate == "function" && tt.UNSAFE_componentWillUpdate(_, ft, nt)),
        typeof tt.componentDidUpdate == "function" && (g.flags |= 4),
        typeof tt.getSnapshotBeforeUpdate == "function" && (g.flags |= 1024)) : (typeof tt.componentDidUpdate != "function" || rt === d.memoizedProps && st === d.memoizedState || (g.flags |= 4),
        typeof tt.getSnapshotBeforeUpdate != "function" || rt === d.memoizedProps && st === d.memoizedState || (g.flags |= 1024),
        g.memoizedProps = _,
        g.memoizedState = ft),
        tt.props = _,
        tt.state = ft,
        tt.context = nt,
        _ = it) : (typeof tt.componentDidUpdate != "function" || rt === d.memoizedProps && st === d.memoizedState || (g.flags |= 4),
        typeof tt.getSnapshotBeforeUpdate != "function" || rt === d.memoizedProps && st === d.memoizedState || (g.flags |= 1024),
        _ = !1)
    }
    return jj(d, g, b, _, et, $)
}
function jj(d, g, b, _, $, et) {
    gj(d, g);
    var tt = (g.flags & 128) !== 0;
    if (!_ && !tt)
        return $ && dg(g, b, !1),
        Zi(d, g, et);
    _ = g.stateNode,
    Wi.current = g;
    var rt = tt && typeof b.getDerivedStateFromError != "function" ? null : _.render();
    return g.flags |= 1,
    d !== null && tt ? (g.child = Ug(g, d.child, null, et),
    g.child = Ug(g, null, rt, et)) : Xi(d, g, rt, et),
    g.memoizedState = _.state,
    $ && dg(g, b, !0),
    g.child
}
function kj(d) {
    var g = d.stateNode;
    g.pendingContext ? ag(d, g.pendingContext, g.pendingContext !== g.context) : g.context && ag(d, g.context, !1),
    yh(d, g.containerInfo)
}
function lj(d, g, b, _, $) {
    return Ig(),
    Jg($),
    g.flags |= 256,
    Xi(d, g, b, _),
    g.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function nj(d) {
    return {
        baseLanes: d,
        cachePool: null,
        transitions: null
    }
}
function oj(d, g, b) {
    var _ = g.pendingProps, $ = L.current, et = !1, tt = (g.flags & 128) !== 0, rt;
    if ((rt = tt) || (rt = d !== null && d.memoizedState === null ? !1 : ($ & 2) !== 0),
    rt ? (et = !0,
    g.flags &= -129) : (d === null || d.memoizedState !== null) && ($ |= 1),
    G(L, $ & 1),
    d === null)
        return Eg(g),
        d = g.memoizedState,
        d !== null && (d = d.dehydrated,
        d !== null) ? (g.mode & 1 ? d.data === "$!" ? g.lanes = 8 : g.lanes = 1073741824 : g.lanes = 1,
        null) : (tt = _.children,
        d = _.fallback,
        et ? (_ = g.mode,
        et = g.child,
        tt = {
            mode: "hidden",
            children: tt
        },
        !(_ & 1) && et !== null ? (et.childLanes = 0,
        et.pendingProps = tt) : et = pj(tt, _, 0, null),
        d = Tg(d, _, b, null),
        et.return = g,
        d.return = g,
        et.sibling = d,
        g.child = et,
        g.child.memoizedState = nj(b),
        g.memoizedState = mj,
        d) : qj(g, tt));
    if ($ = d.memoizedState,
    $ !== null && (rt = $.dehydrated,
    rt !== null))
        return rj(d, g, tt, _, rt, $, b);
    if (et) {
        et = _.fallback,
        tt = g.mode,
        $ = d.child,
        rt = $.sibling;
        var nt = {
            mode: "hidden",
            children: _.children
        };
        return !(tt & 1) && g.child !== $ ? (_ = g.child,
        _.childLanes = 0,
        _.pendingProps = nt,
        g.deletions = null) : (_ = Pg($, nt),
        _.subtreeFlags = $.subtreeFlags & 14680064),
        rt !== null ? et = Pg(rt, et) : (et = Tg(et, tt, b, null),
        et.flags |= 2),
        et.return = g,
        _.return = g,
        _.sibling = et,
        g.child = _,
        _ = et,
        et = g.child,
        tt = d.child.memoizedState,
        tt = tt === null ? nj(b) : {
            baseLanes: tt.baseLanes | b,
            cachePool: null,
            transitions: tt.transitions
        },
        et.memoizedState = tt,
        et.childLanes = d.childLanes & ~b,
        g.memoizedState = mj,
        _
    }
    return et = d.child,
    d = et.sibling,
    _ = Pg(et, {
        mode: "visible",
        children: _.children
    }),
    !(g.mode & 1) && (_.lanes = b),
    _.return = g,
    _.sibling = null,
    d !== null && (b = g.deletions,
    b === null ? (g.deletions = [d],
    g.flags |= 16) : b.push(d)),
    g.child = _,
    g.memoizedState = null,
    _
}
function qj(d, g) {
    return g = pj({
        mode: "visible",
        children: g
    }, d.mode, 0, null),
    g.return = d,
    d.child = g
}
function sj(d, g, b, _) {
    return _ !== null && Jg(_),
    Ug(g, d.child, null, b),
    d = qj(g, g.pendingProps.children),
    d.flags |= 2,
    g.memoizedState = null,
    d
}
function rj(d, g, b, _, $, et, tt) {
    if (b)
        return g.flags & 256 ? (g.flags &= -257,
        _ = Ki(Error(p$3(422))),
        sj(d, g, tt, _)) : g.memoizedState !== null ? (g.child = d.child,
        g.flags |= 128,
        null) : (et = _.fallback,
        $ = g.mode,
        _ = pj({
            mode: "visible",
            children: _.children
        }, $, 0, null),
        et = Tg(et, $, tt, null),
        et.flags |= 2,
        _.return = g,
        et.return = g,
        _.sibling = et,
        g.child = _,
        g.mode & 1 && Ug(g, d.child, null, tt),
        g.child.memoizedState = nj(tt),
        g.memoizedState = mj,
        et);
    if (!(g.mode & 1))
        return sj(d, g, tt, null);
    if ($.data === "$!") {
        if (_ = $.nextSibling && $.nextSibling.dataset,
        _)
            var rt = _.dgst;
        return _ = rt,
        et = Error(p$3(419)),
        _ = Ki(et, _, void 0),
        sj(d, g, tt, _)
    }
    if (rt = (tt & d.childLanes) !== 0,
    dh || rt) {
        if (_ = Q,
        _ !== null) {
            switch (tt & -tt) {
            case 4:
                $ = 2;
                break;
            case 16:
                $ = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                $ = 32;
                break;
            case 536870912:
                $ = 268435456;
                break;
            default:
                $ = 0
            }
            $ = $ & (_.suspendedLanes | tt) ? 0 : $,
            $ !== 0 && $ !== et.retryLane && (et.retryLane = $,
            ih(d, $),
            gi(_, d, $, -1))
        }
        return tj(),
        _ = Ki(Error(p$3(421))),
        sj(d, g, tt, _)
    }
    return $.data === "$?" ? (g.flags |= 128,
    g.child = d.child,
    g = uj.bind(null, d),
    $._reactRetry = g,
    null) : (d = et.treeContext,
    yg = Lf($.nextSibling),
    xg = g,
    I = !0,
    zg = null,
    d !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = d.id,
    sg = d.overflow,
    qg = g),
    g = qj(g, _.children),
    g.flags |= 4096,
    g)
}
function vj(d, g, b) {
    d.lanes |= g;
    var _ = d.alternate;
    _ !== null && (_.lanes |= g),
    bh(d.return, g, b)
}
function wj(d, g, b, _, $) {
    var et = d.memoizedState;
    et === null ? d.memoizedState = {
        isBackwards: g,
        rendering: null,
        renderingStartTime: 0,
        last: _,
        tail: b,
        tailMode: $
    } : (et.isBackwards = g,
    et.rendering = null,
    et.renderingStartTime = 0,
    et.last = _,
    et.tail = b,
    et.tailMode = $)
}
function xj(d, g, b) {
    var _ = g.pendingProps
      , $ = _.revealOrder
      , et = _.tail;
    if (Xi(d, g, _.children, b),
    _ = L.current,
    _ & 2)
        _ = _ & 1 | 2,
        g.flags |= 128;
    else {
        if (d !== null && d.flags & 128)
            e: for (d = g.child; d !== null; ) {
                if (d.tag === 13)
                    d.memoizedState !== null && vj(d, b, g);
                else if (d.tag === 19)
                    vj(d, b, g);
                else if (d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === g)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === g)
                        break e;
                    d = d.return
                }
                d.sibling.return = d.return,
                d = d.sibling
            }
        _ &= 1
    }
    if (G(L, _),
    !(g.mode & 1))
        g.memoizedState = null;
    else
        switch ($) {
        case "forwards":
            for (b = g.child,
            $ = null; b !== null; )
                d = b.alternate,
                d !== null && Ch(d) === null && ($ = b),
                b = b.sibling;
            b = $,
            b === null ? ($ = g.child,
            g.child = null) : ($ = b.sibling,
            b.sibling = null),
            wj(g, !1, $, b, et);
            break;
        case "backwards":
            for (b = null,
            $ = g.child,
            g.child = null; $ !== null; ) {
                if (d = $.alternate,
                d !== null && Ch(d) === null) {
                    g.child = $;
                    break
                }
                d = $.sibling,
                $.sibling = b,
                b = $,
                $ = d
            }
            wj(g, !0, b, null, et);
            break;
        case "together":
            wj(g, !1, null, null, void 0);
            break;
        default:
            g.memoizedState = null
        }
    return g.child
}
function ij(d, g) {
    !(g.mode & 1) && d !== null && (d.alternate = null,
    g.alternate = null,
    g.flags |= 2)
}
function Zi(d, g, b) {
    if (d !== null && (g.dependencies = d.dependencies),
    rh |= g.lanes,
    !(b & g.childLanes))
        return null;
    if (d !== null && g.child !== d.child)
        throw Error(p$3(153));
    if (g.child !== null) {
        for (d = g.child,
        b = Pg(d, d.pendingProps),
        g.child = b,
        b.return = g; d.sibling !== null; )
            d = d.sibling,
            b = b.sibling = Pg(d, d.pendingProps),
            b.return = g;
        b.sibling = null
    }
    return g.child
}
function yj(d, g, b) {
    switch (g.tag) {
    case 3:
        kj(g),
        Ig();
        break;
    case 5:
        Ah(g);
        break;
    case 1:
        Zf(g.type) && cg(g);
        break;
    case 4:
        yh(g, g.stateNode.containerInfo);
        break;
    case 10:
        var _ = g.type._context
          , $ = g.memoizedProps.value;
        G(Wg, _._currentValue),
        _._currentValue = $;
        break;
    case 13:
        if (_ = g.memoizedState,
        _ !== null)
            return _.dehydrated !== null ? (G(L, L.current & 1),
            g.flags |= 128,
            null) : b & g.child.childLanes ? oj(d, g, b) : (G(L, L.current & 1),
            d = Zi(d, g, b),
            d !== null ? d.sibling : null);
        G(L, L.current & 1);
        break;
    case 19:
        if (_ = (b & g.childLanes) !== 0,
        d.flags & 128) {
            if (_)
                return xj(d, g, b);
            g.flags |= 128
        }
        if ($ = g.memoizedState,
        $ !== null && ($.rendering = null,
        $.tail = null,
        $.lastEffect = null),
        G(L, L.current),
        _)
            break;
        return null;
    case 22:
    case 23:
        return g.lanes = 0,
        dj(d, g, b)
    }
    return Zi(d, g, b)
}
var zj, Aj, Bj, Cj;
zj = function(d, g) {
    for (var b = g.child; b !== null; ) {
        if (b.tag === 5 || b.tag === 6)
            d.appendChild(b.stateNode);
        else if (b.tag !== 4 && b.child !== null) {
            b.child.return = b,
            b = b.child;
            continue
        }
        if (b === g)
            break;
        for (; b.sibling === null; ) {
            if (b.return === null || b.return === g)
                return;
            b = b.return
        }
        b.sibling.return = b.return,
        b = b.sibling
    }
}
;
Aj = function() {}
;
Bj = function(d, g, b, _) {
    var $ = d.memoizedProps;
    if ($ !== _) {
        d = g.stateNode,
        xh(uh.current);
        var et = null;
        switch (b) {
        case "input":
            $ = Ya(d, $),
            _ = Ya(d, _),
            et = [];
            break;
        case "select":
            $ = A({}, $, {
                value: void 0
            }),
            _ = A({}, _, {
                value: void 0
            }),
            et = [];
            break;
        case "textarea":
            $ = gb(d, $),
            _ = gb(d, _),
            et = [];
            break;
        default:
            typeof $.onClick != "function" && typeof _.onClick == "function" && (d.onclick = Bf)
        }
        ub(b, _);
        var tt;
        b = null;
        for (it in $)
            if (!_.hasOwnProperty(it) && $.hasOwnProperty(it) && $[it] != null)
                if (it === "style") {
                    var rt = $[it];
                    for (tt in rt)
                        rt.hasOwnProperty(tt) && (b || (b = {}),
                        b[tt] = "")
                } else
                    it !== "dangerouslySetInnerHTML" && it !== "children" && it !== "suppressContentEditableWarning" && it !== "suppressHydrationWarning" && it !== "autoFocus" && (ea.hasOwnProperty(it) ? et || (et = []) : (et = et || []).push(it, null));
        for (it in _) {
            var nt = _[it];
            if (rt = $ != null ? $[it] : void 0,
            _.hasOwnProperty(it) && nt !== rt && (nt != null || rt != null))
                if (it === "style")
                    if (rt) {
                        for (tt in rt)
                            !rt.hasOwnProperty(tt) || nt && nt.hasOwnProperty(tt) || (b || (b = {}),
                            b[tt] = "");
                        for (tt in nt)
                            nt.hasOwnProperty(tt) && rt[tt] !== nt[tt] && (b || (b = {}),
                            b[tt] = nt[tt])
                    } else
                        b || (et || (et = []),
                        et.push(it, b)),
                        b = nt;
                else
                    it === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0,
                    rt = rt ? rt.__html : void 0,
                    nt != null && rt !== nt && (et = et || []).push(it, nt)) : it === "children" ? typeof nt != "string" && typeof nt != "number" || (et = et || []).push(it, "" + nt) : it !== "suppressContentEditableWarning" && it !== "suppressHydrationWarning" && (ea.hasOwnProperty(it) ? (nt != null && it === "onScroll" && D("scroll", d),
                    et || rt === nt || (et = [])) : (et = et || []).push(it, nt))
        }
        b && (et = et || []).push("style", b);
        var it = et;
        (g.updateQueue = it) && (g.flags |= 4)
    }
}
;
Cj = function(d, g, b, _) {
    b !== _ && (g.flags |= 4)
}
;
function Dj(d, g) {
    if (!I)
        switch (d.tailMode) {
        case "hidden":
            g = d.tail;
            for (var b = null; g !== null; )
                g.alternate !== null && (b = g),
                g = g.sibling;
            b === null ? d.tail = null : b.sibling = null;
            break;
        case "collapsed":
            b = d.tail;
            for (var _ = null; b !== null; )
                b.alternate !== null && (_ = b),
                b = b.sibling;
            _ === null ? g || d.tail === null ? d.tail = null : d.tail.sibling = null : _.sibling = null
        }
}
function S(d) {
    var g = d.alternate !== null && d.alternate.child === d.child
      , b = 0
      , _ = 0;
    if (g)
        for (var $ = d.child; $ !== null; )
            b |= $.lanes | $.childLanes,
            _ |= $.subtreeFlags & 14680064,
            _ |= $.flags & 14680064,
            $.return = d,
            $ = $.sibling;
    else
        for ($ = d.child; $ !== null; )
            b |= $.lanes | $.childLanes,
            _ |= $.subtreeFlags,
            _ |= $.flags,
            $.return = d,
            $ = $.sibling;
    return d.subtreeFlags |= _,
    d.childLanes = b,
    g
}
function Ej(d, g, b) {
    var _ = g.pendingProps;
    switch (wg(g),
    g.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S(g),
        null;
    case 1:
        return Zf(g.type) && $f(),
        S(g),
        null;
    case 3:
        return _ = g.stateNode,
        zh(),
        E(Wf),
        E(H),
        Eh(),
        _.pendingContext && (_.context = _.pendingContext,
        _.pendingContext = null),
        (d === null || d.child === null) && (Gg(g) ? g.flags |= 4 : d === null || d.memoizedState.isDehydrated && !(g.flags & 256) || (g.flags |= 1024,
        zg !== null && (Fj(zg),
        zg = null))),
        Aj(d, g),
        S(g),
        null;
    case 5:
        Bh(g);
        var $ = xh(wh.current);
        if (b = g.type,
        d !== null && g.stateNode != null)
            Bj(d, g, b, _, $),
            d.ref !== g.ref && (g.flags |= 512,
            g.flags |= 2097152);
        else {
            if (!_) {
                if (g.stateNode === null)
                    throw Error(p$3(166));
                return S(g),
                null
            }
            if (d = xh(uh.current),
            Gg(g)) {
                _ = g.stateNode,
                b = g.type;
                var et = g.memoizedProps;
                switch (_[Of] = g,
                _[Pf] = et,
                d = (g.mode & 1) !== 0,
                b) {
                case "dialog":
                    D("cancel", _),
                    D("close", _);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D("load", _);
                    break;
                case "video":
                case "audio":
                    for ($ = 0; $ < lf.length; $++)
                        D(lf[$], _);
                    break;
                case "source":
                    D("error", _);
                    break;
                case "img":
                case "image":
                case "link":
                    D("error", _),
                    D("load", _);
                    break;
                case "details":
                    D("toggle", _);
                    break;
                case "input":
                    Za(_, et),
                    D("invalid", _);
                    break;
                case "select":
                    _._wrapperState = {
                        wasMultiple: !!et.multiple
                    },
                    D("invalid", _);
                    break;
                case "textarea":
                    hb(_, et),
                    D("invalid", _)
                }
                ub(b, et),
                $ = null;
                for (var tt in et)
                    if (et.hasOwnProperty(tt)) {
                        var rt = et[tt];
                        tt === "children" ? typeof rt == "string" ? _.textContent !== rt && (et.suppressHydrationWarning !== !0 && Af(_.textContent, rt, d),
                        $ = ["children", rt]) : typeof rt == "number" && _.textContent !== "" + rt && (et.suppressHydrationWarning !== !0 && Af(_.textContent, rt, d),
                        $ = ["children", "" + rt]) : ea.hasOwnProperty(tt) && rt != null && tt === "onScroll" && D("scroll", _)
                    }
                switch (b) {
                case "input":
                    Va(_),
                    db(_, et, !0);
                    break;
                case "textarea":
                    Va(_),
                    jb(_);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof et.onClick == "function" && (_.onclick = Bf)
                }
                _ = $,
                g.updateQueue = _,
                _ !== null && (g.flags |= 4)
            } else {
                tt = $.nodeType === 9 ? $ : $.ownerDocument,
                d === "http://www.w3.org/1999/xhtml" && (d = kb(b)),
                d === "http://www.w3.org/1999/xhtml" ? b === "script" ? (d = tt.createElement("div"),
                d.innerHTML = "<script><\/script>",
                d = d.removeChild(d.firstChild)) : typeof _.is == "string" ? d = tt.createElement(b, {
                    is: _.is
                }) : (d = tt.createElement(b),
                b === "select" && (tt = d,
                _.multiple ? tt.multiple = !0 : _.size && (tt.size = _.size))) : d = tt.createElementNS(d, b),
                d[Of] = g,
                d[Pf] = _,
                zj(d, g, !1, !1),
                g.stateNode = d;
                e: {
                    switch (tt = vb(b, _),
                    b) {
                    case "dialog":
                        D("cancel", d),
                        D("close", d),
                        $ = _;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D("load", d),
                        $ = _;
                        break;
                    case "video":
                    case "audio":
                        for ($ = 0; $ < lf.length; $++)
                            D(lf[$], d);
                        $ = _;
                        break;
                    case "source":
                        D("error", d),
                        $ = _;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D("error", d),
                        D("load", d),
                        $ = _;
                        break;
                    case "details":
                        D("toggle", d),
                        $ = _;
                        break;
                    case "input":
                        Za(d, _),
                        $ = Ya(d, _),
                        D("invalid", d);
                        break;
                    case "option":
                        $ = _;
                        break;
                    case "select":
                        d._wrapperState = {
                            wasMultiple: !!_.multiple
                        },
                        $ = A({}, _, {
                            value: void 0
                        }),
                        D("invalid", d);
                        break;
                    case "textarea":
                        hb(d, _),
                        $ = gb(d, _),
                        D("invalid", d);
                        break;
                    default:
                        $ = _
                    }
                    ub(b, $),
                    rt = $;
                    for (et in rt)
                        if (rt.hasOwnProperty(et)) {
                            var nt = rt[et];
                            et === "style" ? sb(d, nt) : et === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0,
                            nt != null && nb(d, nt)) : et === "children" ? typeof nt == "string" ? (b !== "textarea" || nt !== "") && ob(d, nt) : typeof nt == "number" && ob(d, "" + nt) : et !== "suppressContentEditableWarning" && et !== "suppressHydrationWarning" && et !== "autoFocus" && (ea.hasOwnProperty(et) ? nt != null && et === "onScroll" && D("scroll", d) : nt != null && ta(d, et, nt, tt))
                        }
                    switch (b) {
                    case "input":
                        Va(d),
                        db(d, _, !1);
                        break;
                    case "textarea":
                        Va(d),
                        jb(d);
                        break;
                    case "option":
                        _.value != null && d.setAttribute("value", "" + Sa(_.value));
                        break;
                    case "select":
                        d.multiple = !!_.multiple,
                        et = _.value,
                        et != null ? fb(d, !!_.multiple, et, !1) : _.defaultValue != null && fb(d, !!_.multiple, _.defaultValue, !0);
                        break;
                    default:
                        typeof $.onClick == "function" && (d.onclick = Bf)
                    }
                    switch (b) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        _ = !!_.autoFocus;
                        break e;
                    case "img":
                        _ = !0;
                        break e;
                    default:
                        _ = !1
                    }
                }
                _ && (g.flags |= 4)
            }
            g.ref !== null && (g.flags |= 512,
            g.flags |= 2097152)
        }
        return S(g),
        null;
    case 6:
        if (d && g.stateNode != null)
            Cj(d, g, d.memoizedProps, _);
        else {
            if (typeof _ != "string" && g.stateNode === null)
                throw Error(p$3(166));
            if (b = xh(wh.current),
            xh(uh.current),
            Gg(g)) {
                if (_ = g.stateNode,
                b = g.memoizedProps,
                _[Of] = g,
                (et = _.nodeValue !== b) && (d = xg,
                d !== null))
                    switch (d.tag) {
                    case 3:
                        Af(_.nodeValue, b, (d.mode & 1) !== 0);
                        break;
                    case 5:
                        d.memoizedProps.suppressHydrationWarning !== !0 && Af(_.nodeValue, b, (d.mode & 1) !== 0)
                    }
                et && (g.flags |= 4)
            } else
                _ = (b.nodeType === 9 ? b : b.ownerDocument).createTextNode(_),
                _[Of] = g,
                g.stateNode = _
        }
        return S(g),
        null;
    case 13:
        if (E(L),
        _ = g.memoizedState,
        d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
            if (I && yg !== null && g.mode & 1 && !(g.flags & 128))
                Hg(),
                Ig(),
                g.flags |= 98560,
                et = !1;
            else if (et = Gg(g),
            _ !== null && _.dehydrated !== null) {
                if (d === null) {
                    if (!et)
                        throw Error(p$3(318));
                    if (et = g.memoizedState,
                    et = et !== null ? et.dehydrated : null,
                    !et)
                        throw Error(p$3(317));
                    et[Of] = g
                } else
                    Ig(),
                    !(g.flags & 128) && (g.memoizedState = null),
                    g.flags |= 4;
                S(g),
                et = !1
            } else
                zg !== null && (Fj(zg),
                zg = null),
                et = !0;
            if (!et)
                return g.flags & 65536 ? g : null
        }
        return g.flags & 128 ? (g.lanes = b,
        g) : (_ = _ !== null,
        _ !== (d !== null && d.memoizedState !== null) && _ && (g.child.flags |= 8192,
        g.mode & 1 && (d === null || L.current & 1 ? T === 0 && (T = 3) : tj())),
        g.updateQueue !== null && (g.flags |= 4),
        S(g),
        null);
    case 4:
        return zh(),
        Aj(d, g),
        d === null && sf(g.stateNode.containerInfo),
        S(g),
        null;
    case 10:
        return ah(g.type._context),
        S(g),
        null;
    case 17:
        return Zf(g.type) && $f(),
        S(g),
        null;
    case 19:
        if (E(L),
        et = g.memoizedState,
        et === null)
            return S(g),
            null;
        if (_ = (g.flags & 128) !== 0,
        tt = et.rendering,
        tt === null)
            if (_)
                Dj(et, !1);
            else {
                if (T !== 0 || d !== null && d.flags & 128)
                    for (d = g.child; d !== null; ) {
                        if (tt = Ch(d),
                        tt !== null) {
                            for (g.flags |= 128,
                            Dj(et, !1),
                            _ = tt.updateQueue,
                            _ !== null && (g.updateQueue = _,
                            g.flags |= 4),
                            g.subtreeFlags = 0,
                            _ = b,
                            b = g.child; b !== null; )
                                et = b,
                                d = _,
                                et.flags &= 14680066,
                                tt = et.alternate,
                                tt === null ? (et.childLanes = 0,
                                et.lanes = d,
                                et.child = null,
                                et.subtreeFlags = 0,
                                et.memoizedProps = null,
                                et.memoizedState = null,
                                et.updateQueue = null,
                                et.dependencies = null,
                                et.stateNode = null) : (et.childLanes = tt.childLanes,
                                et.lanes = tt.lanes,
                                et.child = tt.child,
                                et.subtreeFlags = 0,
                                et.deletions = null,
                                et.memoizedProps = tt.memoizedProps,
                                et.memoizedState = tt.memoizedState,
                                et.updateQueue = tt.updateQueue,
                                et.type = tt.type,
                                d = tt.dependencies,
                                et.dependencies = d === null ? null : {
                                    lanes: d.lanes,
                                    firstContext: d.firstContext
                                }),
                                b = b.sibling;
                            return G(L, L.current & 1 | 2),
                            g.child
                        }
                        d = d.sibling
                    }
                et.tail !== null && B() > Gj && (g.flags |= 128,
                _ = !0,
                Dj(et, !1),
                g.lanes = 4194304)
            }
        else {
            if (!_)
                if (d = Ch(tt),
                d !== null) {
                    if (g.flags |= 128,
                    _ = !0,
                    b = d.updateQueue,
                    b !== null && (g.updateQueue = b,
                    g.flags |= 4),
                    Dj(et, !0),
                    et.tail === null && et.tailMode === "hidden" && !tt.alternate && !I)
                        return S(g),
                        null
                } else
                    2 * B() - et.renderingStartTime > Gj && b !== 1073741824 && (g.flags |= 128,
                    _ = !0,
                    Dj(et, !1),
                    g.lanes = 4194304);
            et.isBackwards ? (tt.sibling = g.child,
            g.child = tt) : (b = et.last,
            b !== null ? b.sibling = tt : g.child = tt,
            et.last = tt)
        }
        return et.tail !== null ? (g = et.tail,
        et.rendering = g,
        et.tail = g.sibling,
        et.renderingStartTime = B(),
        g.sibling = null,
        b = L.current,
        G(L, _ ? b & 1 | 2 : b & 1),
        g) : (S(g),
        null);
    case 22:
    case 23:
        return Hj(),
        _ = g.memoizedState !== null,
        d !== null && d.memoizedState !== null !== _ && (g.flags |= 8192),
        _ && g.mode & 1 ? fj & 1073741824 && (S(g),
        g.subtreeFlags & 6 && (g.flags |= 8192)) : S(g),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$3(156, g.tag))
}
function Ij(d, g) {
    switch (wg(g),
    g.tag) {
    case 1:
        return Zf(g.type) && $f(),
        d = g.flags,
        d & 65536 ? (g.flags = d & -65537 | 128,
        g) : null;
    case 3:
        return zh(),
        E(Wf),
        E(H),
        Eh(),
        d = g.flags,
        d & 65536 && !(d & 128) ? (g.flags = d & -65537 | 128,
        g) : null;
    case 5:
        return Bh(g),
        null;
    case 13:
        if (E(L),
        d = g.memoizedState,
        d !== null && d.dehydrated !== null) {
            if (g.alternate === null)
                throw Error(p$3(340));
            Ig()
        }
        return d = g.flags,
        d & 65536 ? (g.flags = d & -65537 | 128,
        g) : null;
    case 19:
        return E(L),
        null;
    case 4:
        return zh(),
        null;
    case 10:
        return ah(g.type._context),
        null;
    case 22:
    case 23:
        return Hj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jj = !1
  , U = !1
  , Kj = typeof WeakSet == "function" ? WeakSet : Set
  , V = null;
function Lj(d, g) {
    var b = d.ref;
    if (b !== null)
        if (typeof b == "function")
            try {
                b(null)
            } catch (_) {
                W(d, g, _)
            }
        else
            b.current = null
}
function Mj(d, g, b) {
    try {
        b()
    } catch (_) {
        W(d, g, _)
    }
}
var Nj = !1;
function Oj(d, g) {
    if (Cf = dd,
    d = Me(),
    Ne(d)) {
        if ("selectionStart"in d)
            var b = {
                start: d.selectionStart,
                end: d.selectionEnd
            };
        else
            e: {
                b = (b = d.ownerDocument) && b.defaultView || window;
                var _ = b.getSelection && b.getSelection();
                if (_ && _.rangeCount !== 0) {
                    b = _.anchorNode;
                    var $ = _.anchorOffset
                      , et = _.focusNode;
                    _ = _.focusOffset;
                    try {
                        b.nodeType,
                        et.nodeType
                    } catch {
                        b = null;
                        break e
                    }
                    var tt = 0
                      , rt = -1
                      , nt = -1
                      , it = 0
                      , ot = 0
                      , at = d
                      , st = null;
                    t: for (; ; ) {
                        for (var dt; at !== b || $ !== 0 && at.nodeType !== 3 || (rt = tt + $),
                        at !== et || _ !== 0 && at.nodeType !== 3 || (nt = tt + _),
                        at.nodeType === 3 && (tt += at.nodeValue.length),
                        (dt = at.firstChild) !== null; )
                            st = at,
                            at = dt;
                        for (; ; ) {
                            if (at === d)
                                break t;
                            if (st === b && ++it === $ && (rt = tt),
                            st === et && ++ot === _ && (nt = tt),
                            (dt = at.nextSibling) !== null)
                                break;
                            at = st,
                            st = at.parentNode
                        }
                        at = dt
                    }
                    b = rt === -1 || nt === -1 ? null : {
                        start: rt,
                        end: nt
                    }
                } else
                    b = null
            }
        b = b || {
            start: 0,
            end: 0
        }
    } else
        b = null;
    for (Df = {
        focusedElem: d,
        selectionRange: b
    },
    dd = !1,
    V = g; V !== null; )
        if (g = V,
        d = g.child,
        (g.subtreeFlags & 1028) !== 0 && d !== null)
            d.return = g,
            V = d;
        else
            for (; V !== null; ) {
                g = V;
                try {
                    var ft = g.alternate;
                    if (g.flags & 1024)
                        switch (g.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (ft !== null) {
                                var ht = ft.memoizedProps
                                  , xt = ft.memoizedState
                                  , lt = g.stateNode
                                  , ct = lt.getSnapshotBeforeUpdate(g.elementType === g.type ? ht : Ci(g.type, ht), xt);
                                lt.__reactInternalSnapshotBeforeUpdate = ct
                            }
                            break;
                        case 3:
                            var ut = g.stateNode.containerInfo;
                            ut.nodeType === 1 ? ut.textContent = "" : ut.nodeType === 9 && ut.documentElement && ut.removeChild(ut.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$3(163))
                        }
                } catch (pt) {
                    W(g, g.return, pt)
                }
                if (d = g.sibling,
                d !== null) {
                    d.return = g.return,
                    V = d;
                    break
                }
                V = g.return
            }
    return ft = Nj,
    Nj = !1,
    ft
}
function Pj(d, g, b) {
    var _ = g.updateQueue;
    if (_ = _ !== null ? _.lastEffect : null,
    _ !== null) {
        var $ = _ = _.next;
        do {
            if (($.tag & d) === d) {
                var et = $.destroy;
                $.destroy = void 0,
                et !== void 0 && Mj(g, b, et)
            }
            $ = $.next
        } while ($ !== _)
    }
}
function Qj(d, g) {
    if (g = g.updateQueue,
    g = g !== null ? g.lastEffect : null,
    g !== null) {
        var b = g = g.next;
        do {
            if ((b.tag & d) === d) {
                var _ = b.create;
                b.destroy = _()
            }
            b = b.next
        } while (b !== g)
    }
}
function Rj(d) {
    var g = d.ref;
    if (g !== null) {
        var b = d.stateNode;
        switch (d.tag) {
        case 5:
            d = b;
            break;
        default:
            d = b
        }
        typeof g == "function" ? g(d) : g.current = d
    }
}
function Sj(d) {
    var g = d.alternate;
    g !== null && (d.alternate = null,
    Sj(g)),
    d.child = null,
    d.deletions = null,
    d.sibling = null,
    d.tag === 5 && (g = d.stateNode,
    g !== null && (delete g[Of],
    delete g[Pf],
    delete g[of],
    delete g[Qf],
    delete g[Rf])),
    d.stateNode = null,
    d.return = null,
    d.dependencies = null,
    d.memoizedProps = null,
    d.memoizedState = null,
    d.pendingProps = null,
    d.stateNode = null,
    d.updateQueue = null
}
function Tj(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4
}
function Uj(d) {
    e: for (; ; ) {
        for (; d.sibling === null; ) {
            if (d.return === null || Tj(d.return))
                return null;
            d = d.return
        }
        for (d.sibling.return = d.return,
        d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18; ) {
            if (d.flags & 2 || d.child === null || d.tag === 4)
                continue e;
            d.child.return = d,
            d = d.child
        }
        if (!(d.flags & 2))
            return d.stateNode
    }
}
function Vj(d, g, b) {
    var _ = d.tag;
    if (_ === 5 || _ === 6)
        d = d.stateNode,
        g ? b.nodeType === 8 ? b.parentNode.insertBefore(d, g) : b.insertBefore(d, g) : (b.nodeType === 8 ? (g = b.parentNode,
        g.insertBefore(d, b)) : (g = b,
        g.appendChild(d)),
        b = b._reactRootContainer,
        b != null || g.onclick !== null || (g.onclick = Bf));
    else if (_ !== 4 && (d = d.child,
    d !== null))
        for (Vj(d, g, b),
        d = d.sibling; d !== null; )
            Vj(d, g, b),
            d = d.sibling
}
function Wj(d, g, b) {
    var _ = d.tag;
    if (_ === 5 || _ === 6)
        d = d.stateNode,
        g ? b.insertBefore(d, g) : b.appendChild(d);
    else if (_ !== 4 && (d = d.child,
    d !== null))
        for (Wj(d, g, b),
        d = d.sibling; d !== null; )
            Wj(d, g, b),
            d = d.sibling
}
var X = null
  , Xj = !1;
function Yj(d, g, b) {
    for (b = b.child; b !== null; )
        Zj(d, g, b),
        b = b.sibling
}
function Zj(d, g, b) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, b)
        } catch {}
    switch (b.tag) {
    case 5:
        U || Lj(b, g);
    case 6:
        var _ = X
          , $ = Xj;
        X = null,
        Yj(d, g, b),
        X = _,
        Xj = $,
        X !== null && (Xj ? (d = X,
        b = b.stateNode,
        d.nodeType === 8 ? d.parentNode.removeChild(b) : d.removeChild(b)) : X.removeChild(b.stateNode));
        break;
    case 18:
        X !== null && (Xj ? (d = X,
        b = b.stateNode,
        d.nodeType === 8 ? Kf(d.parentNode, b) : d.nodeType === 1 && Kf(d, b),
        bd(d)) : Kf(X, b.stateNode));
        break;
    case 4:
        _ = X,
        $ = Xj,
        X = b.stateNode.containerInfo,
        Xj = !0,
        Yj(d, g, b),
        X = _,
        Xj = $;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U && (_ = b.updateQueue,
        _ !== null && (_ = _.lastEffect,
        _ !== null))) {
            $ = _ = _.next;
            do {
                var et = $
                  , tt = et.destroy;
                et = et.tag,
                tt !== void 0 && (et & 2 || et & 4) && Mj(b, g, tt),
                $ = $.next
            } while ($ !== _)
        }
        Yj(d, g, b);
        break;
    case 1:
        if (!U && (Lj(b, g),
        _ = b.stateNode,
        typeof _.componentWillUnmount == "function"))
            try {
                _.props = b.memoizedProps,
                _.state = b.memoizedState,
                _.componentWillUnmount()
            } catch (rt) {
                W(b, g, rt)
            }
        Yj(d, g, b);
        break;
    case 21:
        Yj(d, g, b);
        break;
    case 22:
        b.mode & 1 ? (U = (_ = U) || b.memoizedState !== null,
        Yj(d, g, b),
        U = _) : Yj(d, g, b);
        break;
    default:
        Yj(d, g, b)
    }
}
function ak(d) {
    var g = d.updateQueue;
    if (g !== null) {
        d.updateQueue = null;
        var b = d.stateNode;
        b === null && (b = d.stateNode = new Kj),
        g.forEach(function(_) {
            var $ = bk.bind(null, d, _);
            b.has(_) || (b.add(_),
            _.then($, $))
        })
    }
}
function ck(d, g) {
    var b = g.deletions;
    if (b !== null)
        for (var _ = 0; _ < b.length; _++) {
            var $ = b[_];
            try {
                var et = d
                  , tt = g
                  , rt = tt;
                e: for (; rt !== null; ) {
                    switch (rt.tag) {
                    case 5:
                        X = rt.stateNode,
                        Xj = !1;
                        break e;
                    case 3:
                        X = rt.stateNode.containerInfo,
                        Xj = !0;
                        break e;
                    case 4:
                        X = rt.stateNode.containerInfo,
                        Xj = !0;
                        break e
                    }
                    rt = rt.return
                }
                if (X === null)
                    throw Error(p$3(160));
                Zj(et, tt, $),
                X = null,
                Xj = !1;
                var nt = $.alternate;
                nt !== null && (nt.return = null),
                $.return = null
            } catch (it) {
                W($, g, it)
            }
        }
    if (g.subtreeFlags & 12854)
        for (g = g.child; g !== null; )
            dk(g, d),
            g = g.sibling
}
function dk(d, g) {
    var b = d.alternate
      , _ = d.flags;
    switch (d.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ck(g, d),
        ek(d),
        _ & 4) {
            try {
                Pj(3, d, d.return),
                Qj(3, d)
            } catch (ht) {
                W(d, d.return, ht)
            }
            try {
                Pj(5, d, d.return)
            } catch (ht) {
                W(d, d.return, ht)
            }
        }
        break;
    case 1:
        ck(g, d),
        ek(d),
        _ & 512 && b !== null && Lj(b, b.return);
        break;
    case 5:
        if (ck(g, d),
        ek(d),
        _ & 512 && b !== null && Lj(b, b.return),
        d.flags & 32) {
            var $ = d.stateNode;
            try {
                ob($, "")
            } catch (ht) {
                W(d, d.return, ht)
            }
        }
        if (_ & 4 && ($ = d.stateNode,
        $ != null)) {
            var et = d.memoizedProps
              , tt = b !== null ? b.memoizedProps : et
              , rt = d.type
              , nt = d.updateQueue;
            if (d.updateQueue = null,
            nt !== null)
                try {
                    rt === "input" && et.type === "radio" && et.name != null && ab($, et),
                    vb(rt, tt);
                    var it = vb(rt, et);
                    for (tt = 0; tt < nt.length; tt += 2) {
                        var ot = nt[tt]
                          , at = nt[tt + 1];
                        ot === "style" ? sb($, at) : ot === "dangerouslySetInnerHTML" ? nb($, at) : ot === "children" ? ob($, at) : ta($, ot, at, it)
                    }
                    switch (rt) {
                    case "input":
                        bb($, et);
                        break;
                    case "textarea":
                        ib($, et);
                        break;
                    case "select":
                        var st = $._wrapperState.wasMultiple;
                        $._wrapperState.wasMultiple = !!et.multiple;
                        var dt = et.value;
                        dt != null ? fb($, !!et.multiple, dt, !1) : st !== !!et.multiple && (et.defaultValue != null ? fb($, !!et.multiple, et.defaultValue, !0) : fb($, !!et.multiple, et.multiple ? [] : "", !1))
                    }
                    $[Pf] = et
                } catch (ht) {
                    W(d, d.return, ht)
                }
        }
        break;
    case 6:
        if (ck(g, d),
        ek(d),
        _ & 4) {
            if (d.stateNode === null)
                throw Error(p$3(162));
            $ = d.stateNode,
            et = d.memoizedProps;
            try {
                $.nodeValue = et
            } catch (ht) {
                W(d, d.return, ht)
            }
        }
        break;
    case 3:
        if (ck(g, d),
        ek(d),
        _ & 4 && b !== null && b.memoizedState.isDehydrated)
            try {
                bd(g.containerInfo)
            } catch (ht) {
                W(d, d.return, ht)
            }
        break;
    case 4:
        ck(g, d),
        ek(d);
        break;
    case 13:
        ck(g, d),
        ek(d),
        $ = d.child,
        $.flags & 8192 && (et = $.memoizedState !== null,
        $.stateNode.isHidden = et,
        !et || $.alternate !== null && $.alternate.memoizedState !== null || (fk = B())),
        _ & 4 && ak(d);
        break;
    case 22:
        if (ot = b !== null && b.memoizedState !== null,
        d.mode & 1 ? (U = (it = U) || ot,
        ck(g, d),
        U = it) : ck(g, d),
        ek(d),
        _ & 8192) {
            if (it = d.memoizedState !== null,
            (d.stateNode.isHidden = it) && !ot && d.mode & 1)
                for (V = d,
                ot = d.child; ot !== null; ) {
                    for (at = V = ot; V !== null; ) {
                        switch (st = V,
                        dt = st.child,
                        st.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pj(4, st, st.return);
                            break;
                        case 1:
                            Lj(st, st.return);
                            var ft = st.stateNode;
                            if (typeof ft.componentWillUnmount == "function") {
                                _ = st,
                                b = st.return;
                                try {
                                    g = _,
                                    ft.props = g.memoizedProps,
                                    ft.state = g.memoizedState,
                                    ft.componentWillUnmount()
                                } catch (ht) {
                                    W(_, b, ht)
                                }
                            }
                            break;
                        case 5:
                            Lj(st, st.return);
                            break;
                        case 22:
                            if (st.memoizedState !== null) {
                                gk(at);
                                continue
                            }
                        }
                        dt !== null ? (dt.return = st,
                        V = dt) : gk(at)
                    }
                    ot = ot.sibling
                }
            e: for (ot = null,
            at = d; ; ) {
                if (at.tag === 5) {
                    if (ot === null) {
                        ot = at;
                        try {
                            $ = at.stateNode,
                            it ? (et = $.style,
                            typeof et.setProperty == "function" ? et.setProperty("display", "none", "important") : et.display = "none") : (rt = at.stateNode,
                            nt = at.memoizedProps.style,
                            tt = nt != null && nt.hasOwnProperty("display") ? nt.display : null,
                            rt.style.display = rb("display", tt))
                        } catch (ht) {
                            W(d, d.return, ht)
                        }
                    }
                } else if (at.tag === 6) {
                    if (ot === null)
                        try {
                            at.stateNode.nodeValue = it ? "" : at.memoizedProps
                        } catch (ht) {
                            W(d, d.return, ht)
                        }
                } else if ((at.tag !== 22 && at.tag !== 23 || at.memoizedState === null || at === d) && at.child !== null) {
                    at.child.return = at,
                    at = at.child;
                    continue
                }
                if (at === d)
                    break e;
                for (; at.sibling === null; ) {
                    if (at.return === null || at.return === d)
                        break e;
                    ot === at && (ot = null),
                    at = at.return
                }
                ot === at && (ot = null),
                at.sibling.return = at.return,
                at = at.sibling
            }
        }
        break;
    case 19:
        ck(g, d),
        ek(d),
        _ & 4 && ak(d);
        break;
    case 21:
        break;
    default:
        ck(g, d),
        ek(d)
    }
}
function ek(d) {
    var g = d.flags;
    if (g & 2) {
        try {
            e: {
                for (var b = d.return; b !== null; ) {
                    if (Tj(b)) {
                        var _ = b;
                        break e
                    }
                    b = b.return
                }
                throw Error(p$3(160))
            }
            switch (_.tag) {
            case 5:
                var $ = _.stateNode;
                _.flags & 32 && (ob($, ""),
                _.flags &= -33);
                var et = Uj(d);
                Wj(d, et, $);
                break;
            case 3:
            case 4:
                var tt = _.stateNode.containerInfo
                  , rt = Uj(d);
                Vj(d, rt, tt);
                break;
            default:
                throw Error(p$3(161))
            }
        } catch (nt) {
            W(d, d.return, nt)
        }
        d.flags &= -3
    }
    g & 4096 && (d.flags &= -4097)
}
function hk(d, g, b) {
    V = d,
    ik(d)
}
function ik(d, g, b) {
    for (var _ = (d.mode & 1) !== 0; V !== null; ) {
        var $ = V
          , et = $.child;
        if ($.tag === 22 && _) {
            var tt = $.memoizedState !== null || Jj;
            if (!tt) {
                var rt = $.alternate
                  , nt = rt !== null && rt.memoizedState !== null || U;
                rt = Jj;
                var it = U;
                if (Jj = tt,
                (U = nt) && !it)
                    for (V = $; V !== null; )
                        tt = V,
                        nt = tt.child,
                        tt.tag === 22 && tt.memoizedState !== null ? jk($) : nt !== null ? (nt.return = tt,
                        V = nt) : jk($);
                for (; et !== null; )
                    V = et,
                    ik(et),
                    et = et.sibling;
                V = $,
                Jj = rt,
                U = it
            }
            kk(d)
        } else
            $.subtreeFlags & 8772 && et !== null ? (et.return = $,
            V = et) : kk(d)
    }
}
function kk(d) {
    for (; V !== null; ) {
        var g = V;
        if (g.flags & 8772) {
            var b = g.alternate;
            try {
                if (g.flags & 8772)
                    switch (g.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Qj(5, g);
                        break;
                    case 1:
                        var _ = g.stateNode;
                        if (g.flags & 4 && !U)
                            if (b === null)
                                _.componentDidMount();
                            else {
                                var $ = g.elementType === g.type ? b.memoizedProps : Ci(g.type, b.memoizedProps);
                                _.componentDidUpdate($, b.memoizedState, _.__reactInternalSnapshotBeforeUpdate)
                            }
                        var et = g.updateQueue;
                        et !== null && sh(g, et, _);
                        break;
                    case 3:
                        var tt = g.updateQueue;
                        if (tt !== null) {
                            if (b = null,
                            g.child !== null)
                                switch (g.child.tag) {
                                case 5:
                                    b = g.child.stateNode;
                                    break;
                                case 1:
                                    b = g.child.stateNode
                                }
                            sh(g, tt, b)
                        }
                        break;
                    case 5:
                        var rt = g.stateNode;
                        if (b === null && g.flags & 4) {
                            b = rt;
                            var nt = g.memoizedProps;
                            switch (g.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                nt.autoFocus && b.focus();
                                break;
                            case "img":
                                nt.src && (b.src = nt.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (g.memoizedState === null) {
                            var it = g.alternate;
                            if (it !== null) {
                                var ot = it.memoizedState;
                                if (ot !== null) {
                                    var at = ot.dehydrated;
                                    at !== null && bd(at)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$3(163))
                    }
                U || g.flags & 512 && Rj(g)
            } catch (st) {
                W(g, g.return, st)
            }
        }
        if (g === d) {
            V = null;
            break
        }
        if (b = g.sibling,
        b !== null) {
            b.return = g.return,
            V = b;
            break
        }
        V = g.return
    }
}
function gk(d) {
    for (; V !== null; ) {
        var g = V;
        if (g === d) {
            V = null;
            break
        }
        var b = g.sibling;
        if (b !== null) {
            b.return = g.return,
            V = b;
            break
        }
        V = g.return
    }
}
function jk(d) {
    for (; V !== null; ) {
        var g = V;
        try {
            switch (g.tag) {
            case 0:
            case 11:
            case 15:
                var b = g.return;
                try {
                    Qj(4, g)
                } catch (nt) {
                    W(g, b, nt)
                }
                break;
            case 1:
                var _ = g.stateNode;
                if (typeof _.componentDidMount == "function") {
                    var $ = g.return;
                    try {
                        _.componentDidMount()
                    } catch (nt) {
                        W(g, $, nt)
                    }
                }
                var et = g.return;
                try {
                    Rj(g)
                } catch (nt) {
                    W(g, et, nt)
                }
                break;
            case 5:
                var tt = g.return;
                try {
                    Rj(g)
                } catch (nt) {
                    W(g, tt, nt)
                }
            }
        } catch (nt) {
            W(g, g.return, nt)
        }
        if (g === d) {
            V = null;
            break
        }
        var rt = g.sibling;
        if (rt !== null) {
            rt.return = g.return,
            V = rt;
            break
        }
        V = g.return
    }
}
var lk = Math.ceil
  , mk = ua.ReactCurrentDispatcher
  , nk = ua.ReactCurrentOwner
  , ok = ua.ReactCurrentBatchConfig
  , K = 0
  , Q = null
  , Y = null
  , Z = 0
  , fj = 0
  , ej = Uf(0)
  , T = 0
  , pk = null
  , rh = 0
  , qk = 0
  , rk = 0
  , sk = null
  , tk = null
  , fk = 0
  , Gj = 1 / 0
  , uk = null
  , Oi = !1
  , Pi = null
  , Ri = null
  , vk = !1
  , wk = null
  , xk = 0
  , yk = 0
  , zk = null
  , Ak = -1
  , Bk = 0;
function R() {
    return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B()
}
function yi(d) {
    return d.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()),
    Bk) : (d = C,
    d !== 0 || (d = window.event,
    d = d === void 0 ? 16 : jd(d.type)),
    d) : 1
}
function gi(d, g, b, _) {
    if (50 < yk)
        throw yk = 0,
        zk = null,
        Error(p$3(185));
    Ac(d, b, _),
    (!(K & 2) || d !== Q) && (d === Q && (!(K & 2) && (qk |= b),
    T === 4 && Ck(d, Z)),
    Dk(d, _),
    b === 1 && K === 0 && !(g.mode & 1) && (Gj = B() + 500,
    fg && jg()))
}
function Dk(d, g) {
    var b = d.callbackNode;
    wc(d, g);
    var _ = uc(d, d === Q ? Z : 0);
    if (_ === 0)
        b !== null && bc(b),
        d.callbackNode = null,
        d.callbackPriority = 0;
    else if (g = _ & -_,
    d.callbackPriority !== g) {
        if (b != null && bc(b),
        g === 1)
            d.tag === 0 ? ig(Ek.bind(null, d)) : hg(Ek.bind(null, d)),
            Jf(function() {
                !(K & 6) && jg()
            }),
            b = null;
        else {
            switch (Dc(_)) {
            case 1:
                b = fc;
                break;
            case 4:
                b = gc;
                break;
            case 16:
                b = hc;
                break;
            case 536870912:
                b = jc;
                break;
            default:
                b = hc
            }
            b = Fk(b, Gk.bind(null, d))
        }
        d.callbackPriority = g,
        d.callbackNode = b
    }
}
function Gk(d, g) {
    if (Ak = -1,
    Bk = 0,
    K & 6)
        throw Error(p$3(327));
    var b = d.callbackNode;
    if (Hk() && d.callbackNode !== b)
        return null;
    var _ = uc(d, d === Q ? Z : 0);
    if (_ === 0)
        return null;
    if (_ & 30 || _ & d.expiredLanes || g)
        g = Ik(d, _);
    else {
        g = _;
        var $ = K;
        K |= 2;
        var et = Jk();
        (Q !== d || Z !== g) && (uk = null,
        Gj = B() + 500,
        Kk(d, g));
        do
            try {
                Lk();
                break
            } catch (rt) {
                Mk(d, rt)
            }
        while (1);
        $g(),
        mk.current = et,
        K = $,
        Y !== null ? g = 0 : (Q = null,
        Z = 0,
        g = T)
    }
    if (g !== 0) {
        if (g === 2 && ($ = xc(d),
        $ !== 0 && (_ = $,
        g = Nk(d, $))),
        g === 1)
            throw b = pk,
            Kk(d, 0),
            Ck(d, _),
            Dk(d, B()),
            b;
        if (g === 6)
            Ck(d, _);
        else {
            if ($ = d.current.alternate,
            !(_ & 30) && !Ok($) && (g = Ik(d, _),
            g === 2 && (et = xc(d),
            et !== 0 && (_ = et,
            g = Nk(d, et))),
            g === 1))
                throw b = pk,
                Kk(d, 0),
                Ck(d, _),
                Dk(d, B()),
                b;
            switch (d.finishedWork = $,
            d.finishedLanes = _,
            g) {
            case 0:
            case 1:
                throw Error(p$3(345));
            case 2:
                Pk(d, tk, uk);
                break;
            case 3:
                if (Ck(d, _),
                (_ & 130023424) === _ && (g = fk + 500 - B(),
                10 < g)) {
                    if (uc(d, 0) !== 0)
                        break;
                    if ($ = d.suspendedLanes,
                    ($ & _) !== _) {
                        R(),
                        d.pingedLanes |= d.suspendedLanes & $;
                        break
                    }
                    d.timeoutHandle = Ff(Pk.bind(null, d, tk, uk), g);
                    break
                }
                Pk(d, tk, uk);
                break;
            case 4:
                if (Ck(d, _),
                (_ & 4194240) === _)
                    break;
                for (g = d.eventTimes,
                $ = -1; 0 < _; ) {
                    var tt = 31 - oc(_);
                    et = 1 << tt,
                    tt = g[tt],
                    tt > $ && ($ = tt),
                    _ &= ~et
                }
                if (_ = $,
                _ = B() - _,
                _ = (120 > _ ? 120 : 480 > _ ? 480 : 1080 > _ ? 1080 : 1920 > _ ? 1920 : 3e3 > _ ? 3e3 : 4320 > _ ? 4320 : 1960 * lk(_ / 1960)) - _,
                10 < _) {
                    d.timeoutHandle = Ff(Pk.bind(null, d, tk, uk), _);
                    break
                }
                Pk(d, tk, uk);
                break;
            case 5:
                Pk(d, tk, uk);
                break;
            default:
                throw Error(p$3(329))
            }
        }
    }
    return Dk(d, B()),
    d.callbackNode === b ? Gk.bind(null, d) : null
}
function Nk(d, g) {
    var b = sk;
    return d.current.memoizedState.isDehydrated && (Kk(d, g).flags |= 256),
    d = Ik(d, g),
    d !== 2 && (g = tk,
    tk = b,
    g !== null && Fj(g)),
    d
}
function Fj(d) {
    tk === null ? tk = d : tk.push.apply(tk, d)
}
function Ok(d) {
    for (var g = d; ; ) {
        if (g.flags & 16384) {
            var b = g.updateQueue;
            if (b !== null && (b = b.stores,
            b !== null))
                for (var _ = 0; _ < b.length; _++) {
                    var $ = b[_]
                      , et = $.getSnapshot;
                    $ = $.value;
                    try {
                        if (!He(et(), $))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (b = g.child,
        g.subtreeFlags & 16384 && b !== null)
            b.return = g,
            g = b;
        else {
            if (g === d)
                break;
            for (; g.sibling === null; ) {
                if (g.return === null || g.return === d)
                    return !0;
                g = g.return
            }
            g.sibling.return = g.return,
            g = g.sibling
        }
    }
    return !0
}
function Ck(d, g) {
    for (g &= ~rk,
    g &= ~qk,
    d.suspendedLanes |= g,
    d.pingedLanes &= ~g,
    d = d.expirationTimes; 0 < g; ) {
        var b = 31 - oc(g)
          , _ = 1 << b;
        d[b] = -1,
        g &= ~_
    }
}
function Ek(d) {
    if (K & 6)
        throw Error(p$3(327));
    Hk();
    var g = uc(d, 0);
    if (!(g & 1))
        return Dk(d, B()),
        null;
    var b = Ik(d, g);
    if (d.tag !== 0 && b === 2) {
        var _ = xc(d);
        _ !== 0 && (g = _,
        b = Nk(d, _))
    }
    if (b === 1)
        throw b = pk,
        Kk(d, 0),
        Ck(d, g),
        Dk(d, B()),
        b;
    if (b === 6)
        throw Error(p$3(345));
    return d.finishedWork = d.current.alternate,
    d.finishedLanes = g,
    Pk(d, tk, uk),
    Dk(d, B()),
    null
}
function Qk(d, g) {
    var b = K;
    K |= 1;
    try {
        return d(g)
    } finally {
        K = b,
        K === 0 && (Gj = B() + 500,
        fg && jg())
    }
}
function Rk(d) {
    wk !== null && wk.tag === 0 && !(K & 6) && Hk();
    var g = K;
    K |= 1;
    var b = ok.transition
      , _ = C;
    try {
        if (ok.transition = null,
        C = 1,
        d)
            return d()
    } finally {
        C = _,
        ok.transition = b,
        K = g,
        !(K & 6) && jg()
    }
}
function Hj() {
    fj = ej.current,
    E(ej)
}
function Kk(d, g) {
    d.finishedWork = null,
    d.finishedLanes = 0;
    var b = d.timeoutHandle;
    if (b !== -1 && (d.timeoutHandle = -1,
    Gf(b)),
    Y !== null)
        for (b = Y.return; b !== null; ) {
            var _ = b;
            switch (wg(_),
            _.tag) {
            case 1:
                _ = _.type.childContextTypes,
                _ != null && $f();
                break;
            case 3:
                zh(),
                E(Wf),
                E(H),
                Eh();
                break;
            case 5:
                Bh(_);
                break;
            case 4:
                zh();
                break;
            case 13:
                E(L);
                break;
            case 19:
                E(L);
                break;
            case 10:
                ah(_.type._context);
                break;
            case 22:
            case 23:
                Hj()
            }
            b = b.return
        }
    if (Q = d,
    Y = d = Pg(d.current, null),
    Z = fj = g,
    T = 0,
    pk = null,
    rk = qk = rh = 0,
    tk = sk = null,
    fh !== null) {
        for (g = 0; g < fh.length; g++)
            if (b = fh[g],
            _ = b.interleaved,
            _ !== null) {
                b.interleaved = null;
                var $ = _.next
                  , et = b.pending;
                if (et !== null) {
                    var tt = et.next;
                    et.next = $,
                    _.next = tt
                }
                b.pending = _
            }
        fh = null
    }
    return d
}
function Mk(d, g) {
    do {
        var b = Y;
        try {
            if ($g(),
            Fh.current = Rh,
            Ih) {
                for (var _ = M.memoizedState; _ !== null; ) {
                    var $ = _.queue;
                    $ !== null && ($.pending = null),
                    _ = _.next
                }
                Ih = !1
            }
            if (Hh = 0,
            O = N = M = null,
            Jh = !1,
            Kh = 0,
            nk.current = null,
            b === null || b.return === null) {
                T = 1,
                pk = g,
                Y = null;
                break
            }
            e: {
                var et = d
                  , tt = b.return
                  , rt = b
                  , nt = g;
                if (g = Z,
                rt.flags |= 32768,
                nt !== null && typeof nt == "object" && typeof nt.then == "function") {
                    var it = nt
                      , ot = rt
                      , at = ot.tag;
                    if (!(ot.mode & 1) && (at === 0 || at === 11 || at === 15)) {
                        var st = ot.alternate;
                        st ? (ot.updateQueue = st.updateQueue,
                        ot.memoizedState = st.memoizedState,
                        ot.lanes = st.lanes) : (ot.updateQueue = null,
                        ot.memoizedState = null)
                    }
                    var dt = Ui(tt);
                    if (dt !== null) {
                        dt.flags &= -257,
                        Vi(dt, tt, rt, et, g),
                        dt.mode & 1 && Si(et, it, g),
                        g = dt,
                        nt = it;
                        var ft = g.updateQueue;
                        if (ft === null) {
                            var ht = new Set;
                            ht.add(nt),
                            g.updateQueue = ht
                        } else
                            ft.add(nt);
                        break e
                    } else {
                        if (!(g & 1)) {
                            Si(et, it, g),
                            tj();
                            break e
                        }
                        nt = Error(p$3(426))
                    }
                } else if (I && rt.mode & 1) {
                    var xt = Ui(tt);
                    if (xt !== null) {
                        !(xt.flags & 65536) && (xt.flags |= 256),
                        Vi(xt, tt, rt, et, g),
                        Jg(Ji(nt, rt));
                        break e
                    }
                }
                et = nt = Ji(nt, rt),
                T !== 4 && (T = 2),
                sk === null ? sk = [et] : sk.push(et),
                et = tt;
                do {
                    switch (et.tag) {
                    case 3:
                        et.flags |= 65536,
                        g &= -g,
                        et.lanes |= g;
                        var lt = Ni(et, nt, g);
                        ph(et, lt);
                        break e;
                    case 1:
                        rt = nt;
                        var ct = et.type
                          , ut = et.stateNode;
                        if (!(et.flags & 128) && (typeof ct.getDerivedStateFromError == "function" || ut !== null && typeof ut.componentDidCatch == "function" && (Ri === null || !Ri.has(ut)))) {
                            et.flags |= 65536,
                            g &= -g,
                            et.lanes |= g;
                            var pt = Qi(et, rt, g);
                            ph(et, pt);
                            break e
                        }
                    }
                    et = et.return
                } while (et !== null)
            }
            Sk(b)
        } catch (vt) {
            g = vt,
            Y === b && b !== null && (Y = b = b.return);
            continue
        }
        break
    } while (1)
}
function Jk() {
    var d = mk.current;
    return mk.current = Rh,
    d === null ? Rh : d
}
function tj() {
    (T === 0 || T === 3 || T === 2) && (T = 4),
    Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z)
}
function Ik(d, g) {
    var b = K;
    K |= 2;
    var _ = Jk();
    (Q !== d || Z !== g) && (uk = null,
    Kk(d, g));
    do
        try {
            Tk();
            break
        } catch ($) {
            Mk(d, $)
        }
    while (1);
    if ($g(),
    K = b,
    mk.current = _,
    Y !== null)
        throw Error(p$3(261));
    return Q = null,
    Z = 0,
    T
}
function Tk() {
    for (; Y !== null; )
        Uk(Y)
}
function Lk() {
    for (; Y !== null && !cc(); )
        Uk(Y)
}
function Uk(d) {
    var g = Vk(d.alternate, d, fj);
    d.memoizedProps = d.pendingProps,
    g === null ? Sk(d) : Y = g,
    nk.current = null
}
function Sk(d) {
    var g = d;
    do {
        var b = g.alternate;
        if (d = g.return,
        g.flags & 32768) {
            if (b = Ij(b, g),
            b !== null) {
                b.flags &= 32767,
                Y = b;
                return
            }
            if (d !== null)
                d.flags |= 32768,
                d.subtreeFlags = 0,
                d.deletions = null;
            else {
                T = 6,
                Y = null;
                return
            }
        } else if (b = Ej(b, g, fj),
        b !== null) {
            Y = b;
            return
        }
        if (g = g.sibling,
        g !== null) {
            Y = g;
            return
        }
        Y = g = d
    } while (g !== null);
    T === 0 && (T = 5)
}
function Pk(d, g, b) {
    var _ = C
      , $ = ok.transition;
    try {
        ok.transition = null,
        C = 1,
        Wk(d, g, b, _)
    } finally {
        ok.transition = $,
        C = _
    }
    return null
}
function Wk(d, g, b, _) {
    do
        Hk();
    while (wk !== null);
    if (K & 6)
        throw Error(p$3(327));
    b = d.finishedWork;
    var $ = d.finishedLanes;
    if (b === null)
        return null;
    if (d.finishedWork = null,
    d.finishedLanes = 0,
    b === d.current)
        throw Error(p$3(177));
    d.callbackNode = null,
    d.callbackPriority = 0;
    var et = b.lanes | b.childLanes;
    if (Bc(d, et),
    d === Q && (Y = Q = null,
    Z = 0),
    !(b.subtreeFlags & 2064) && !(b.flags & 2064) || vk || (vk = !0,
    Fk(hc, function() {
        return Hk(),
        null
    })),
    et = (b.flags & 15990) !== 0,
    b.subtreeFlags & 15990 || et) {
        et = ok.transition,
        ok.transition = null;
        var tt = C;
        C = 1;
        var rt = K;
        K |= 4,
        nk.current = null,
        Oj(d, b),
        dk(b, d),
        Oe(Df),
        dd = !!Cf,
        Df = Cf = null,
        d.current = b,
        hk(b),
        dc(),
        K = rt,
        C = tt,
        ok.transition = et
    } else
        d.current = b;
    if (vk && (vk = !1,
    wk = d,
    xk = $),
    et = d.pendingLanes,
    et === 0 && (Ri = null),
    mc(b.stateNode),
    Dk(d, B()),
    g !== null)
        for (_ = d.onRecoverableError,
        b = 0; b < g.length; b++)
            $ = g[b],
            _($.value, {
                componentStack: $.stack,
                digest: $.digest
            });
    if (Oi)
        throw Oi = !1,
        d = Pi,
        Pi = null,
        d;
    return xk & 1 && d.tag !== 0 && Hk(),
    et = d.pendingLanes,
    et & 1 ? d === zk ? yk++ : (yk = 0,
    zk = d) : yk = 0,
    jg(),
    null
}
function Hk() {
    if (wk !== null) {
        var d = Dc(xk)
          , g = ok.transition
          , b = C;
        try {
            if (ok.transition = null,
            C = 16 > d ? 16 : d,
            wk === null)
                var _ = !1;
            else {
                if (d = wk,
                wk = null,
                xk = 0,
                K & 6)
                    throw Error(p$3(331));
                var $ = K;
                for (K |= 4,
                V = d.current; V !== null; ) {
                    var et = V
                      , tt = et.child;
                    if (V.flags & 16) {
                        var rt = et.deletions;
                        if (rt !== null) {
                            for (var nt = 0; nt < rt.length; nt++) {
                                var it = rt[nt];
                                for (V = it; V !== null; ) {
                                    var ot = V;
                                    switch (ot.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pj(8, ot, et)
                                    }
                                    var at = ot.child;
                                    if (at !== null)
                                        at.return = ot,
                                        V = at;
                                    else
                                        for (; V !== null; ) {
                                            ot = V;
                                            var st = ot.sibling
                                              , dt = ot.return;
                                            if (Sj(ot),
                                            ot === it) {
                                                V = null;
                                                break
                                            }
                                            if (st !== null) {
                                                st.return = dt,
                                                V = st;
                                                break
                                            }
                                            V = dt
                                        }
                                }
                            }
                            var ft = et.alternate;
                            if (ft !== null) {
                                var ht = ft.child;
                                if (ht !== null) {
                                    ft.child = null;
                                    do {
                                        var xt = ht.sibling;
                                        ht.sibling = null,
                                        ht = xt
                                    } while (ht !== null)
                                }
                            }
                            V = et
                        }
                    }
                    if (et.subtreeFlags & 2064 && tt !== null)
                        tt.return = et,
                        V = tt;
                    else
                        e: for (; V !== null; ) {
                            if (et = V,
                            et.flags & 2048)
                                switch (et.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pj(9, et, et.return)
                                }
                            var lt = et.sibling;
                            if (lt !== null) {
                                lt.return = et.return,
                                V = lt;
                                break e
                            }
                            V = et.return
                        }
                }
                var ct = d.current;
                for (V = ct; V !== null; ) {
                    tt = V;
                    var ut = tt.child;
                    if (tt.subtreeFlags & 2064 && ut !== null)
                        ut.return = tt,
                        V = ut;
                    else
                        e: for (tt = ct; V !== null; ) {
                            if (rt = V,
                            rt.flags & 2048)
                                try {
                                    switch (rt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, rt)
                                    }
                                } catch (vt) {
                                    W(rt, rt.return, vt)
                                }
                            if (rt === tt) {
                                V = null;
                                break e
                            }
                            var pt = rt.sibling;
                            if (pt !== null) {
                                pt.return = rt.return,
                                V = pt;
                                break e
                            }
                            V = rt.return
                        }
                }
                if (K = $,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, d)
                    } catch {}
                _ = !0
            }
            return _
        } finally {
            C = b,
            ok.transition = g
        }
    }
    return !1
}
function Xk(d, g, b) {
    g = Ji(b, g),
    g = Ni(d, g, 1),
    d = nh(d, g, 1),
    g = R(),
    d !== null && (Ac(d, 1, g),
    Dk(d, g))
}
function W(d, g, b) {
    if (d.tag === 3)
        Xk(d, d, b);
    else
        for (; g !== null; ) {
            if (g.tag === 3) {
                Xk(g, d, b);
                break
            } else if (g.tag === 1) {
                var _ = g.stateNode;
                if (typeof g.type.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && (Ri === null || !Ri.has(_))) {
                    d = Ji(b, d),
                    d = Qi(g, d, 1),
                    g = nh(g, d, 1),
                    d = R(),
                    g !== null && (Ac(g, 1, d),
                    Dk(g, d));
                    break
                }
            }
            g = g.return
        }
}
function Ti(d, g, b) {
    var _ = d.pingCache;
    _ !== null && _.delete(g),
    g = R(),
    d.pingedLanes |= d.suspendedLanes & b,
    Q === d && (Z & b) === b && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(d, 0) : rk |= b),
    Dk(d, g)
}
function Yk(d, g) {
    g === 0 && (d.mode & 1 ? (g = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : g = 1);
    var b = R();
    d = ih(d, g),
    d !== null && (Ac(d, g, b),
    Dk(d, b))
}
function uj(d) {
    var g = d.memoizedState
      , b = 0;
    g !== null && (b = g.retryLane),
    Yk(d, b)
}
function bk(d, g) {
    var b = 0;
    switch (d.tag) {
    case 13:
        var _ = d.stateNode
          , $ = d.memoizedState;
        $ !== null && (b = $.retryLane);
        break;
    case 19:
        _ = d.stateNode;
        break;
    default:
        throw Error(p$3(314))
    }
    _ !== null && _.delete(g),
    Yk(d, b)
}
var Vk;
Vk = function(d, g, b) {
    if (d !== null)
        if (d.memoizedProps !== g.pendingProps || Wf.current)
            dh = !0;
        else {
            if (!(d.lanes & b) && !(g.flags & 128))
                return dh = !1,
                yj(d, g, b);
            dh = !!(d.flags & 131072)
        }
    else
        dh = !1,
        I && g.flags & 1048576 && ug(g, ng, g.index);
    switch (g.lanes = 0,
    g.tag) {
    case 2:
        var _ = g.type;
        ij(d, g),
        d = g.pendingProps;
        var $ = Yf(g, H.current);
        ch(g, b),
        $ = Nh(null, g, _, d, $, b);
        var et = Sh();
        return g.flags |= 1,
        typeof $ == "object" && $ !== null && typeof $.render == "function" && $.$$typeof === void 0 ? (g.tag = 1,
        g.memoizedState = null,
        g.updateQueue = null,
        Zf(_) ? (et = !0,
        cg(g)) : et = !1,
        g.memoizedState = $.state !== null && $.state !== void 0 ? $.state : null,
        kh(g),
        $.updater = Ei,
        g.stateNode = $,
        $._reactInternals = g,
        Ii(g, _, d, b),
        g = jj(null, g, _, !0, et, b)) : (g.tag = 0,
        I && et && vg(g),
        Xi(null, g, $, b),
        g = g.child),
        g;
    case 16:
        _ = g.elementType;
        e: {
            switch (ij(d, g),
            d = g.pendingProps,
            $ = _._init,
            _ = $(_._payload),
            g.type = _,
            $ = g.tag = Zk(_),
            d = Ci(_, d),
            $) {
            case 0:
                g = cj(null, g, _, d, b);
                break e;
            case 1:
                g = hj(null, g, _, d, b);
                break e;
            case 11:
                g = Yi(null, g, _, d, b);
                break e;
            case 14:
                g = $i(null, g, _, Ci(_.type, d), b);
                break e
            }
            throw Error(p$3(306, _, ""))
        }
        return g;
    case 0:
        return _ = g.type,
        $ = g.pendingProps,
        $ = g.elementType === _ ? $ : Ci(_, $),
        cj(d, g, _, $, b);
    case 1:
        return _ = g.type,
        $ = g.pendingProps,
        $ = g.elementType === _ ? $ : Ci(_, $),
        hj(d, g, _, $, b);
    case 3:
        e: {
            if (kj(g),
            d === null)
                throw Error(p$3(387));
            _ = g.pendingProps,
            et = g.memoizedState,
            $ = et.element,
            lh(d, g),
            qh(g, _, null, b);
            var tt = g.memoizedState;
            if (_ = tt.element,
            et.isDehydrated)
                if (et = {
                    element: _,
                    isDehydrated: !1,
                    cache: tt.cache,
                    pendingSuspenseBoundaries: tt.pendingSuspenseBoundaries,
                    transitions: tt.transitions
                },
                g.updateQueue.baseState = et,
                g.memoizedState = et,
                g.flags & 256) {
                    $ = Ji(Error(p$3(423)), g),
                    g = lj(d, g, _, b, $);
                    break e
                } else if (_ !== $) {
                    $ = Ji(Error(p$3(424)), g),
                    g = lj(d, g, _, b, $);
                    break e
                } else
                    for (yg = Lf(g.stateNode.containerInfo.firstChild),
                    xg = g,
                    I = !0,
                    zg = null,
                    b = Vg(g, null, _, b),
                    g.child = b; b; )
                        b.flags = b.flags & -3 | 4096,
                        b = b.sibling;
            else {
                if (Ig(),
                _ === $) {
                    g = Zi(d, g, b);
                    break e
                }
                Xi(d, g, _, b)
            }
            g = g.child
        }
        return g;
    case 5:
        return Ah(g),
        d === null && Eg(g),
        _ = g.type,
        $ = g.pendingProps,
        et = d !== null ? d.memoizedProps : null,
        tt = $.children,
        Ef(_, $) ? tt = null : et !== null && Ef(_, et) && (g.flags |= 32),
        gj(d, g),
        Xi(d, g, tt, b),
        g.child;
    case 6:
        return d === null && Eg(g),
        null;
    case 13:
        return oj(d, g, b);
    case 4:
        return yh(g, g.stateNode.containerInfo),
        _ = g.pendingProps,
        d === null ? g.child = Ug(g, null, _, b) : Xi(d, g, _, b),
        g.child;
    case 11:
        return _ = g.type,
        $ = g.pendingProps,
        $ = g.elementType === _ ? $ : Ci(_, $),
        Yi(d, g, _, $, b);
    case 7:
        return Xi(d, g, g.pendingProps, b),
        g.child;
    case 8:
        return Xi(d, g, g.pendingProps.children, b),
        g.child;
    case 12:
        return Xi(d, g, g.pendingProps.children, b),
        g.child;
    case 10:
        e: {
            if (_ = g.type._context,
            $ = g.pendingProps,
            et = g.memoizedProps,
            tt = $.value,
            G(Wg, _._currentValue),
            _._currentValue = tt,
            et !== null)
                if (He(et.value, tt)) {
                    if (et.children === $.children && !Wf.current) {
                        g = Zi(d, g, b);
                        break e
                    }
                } else
                    for (et = g.child,
                    et !== null && (et.return = g); et !== null; ) {
                        var rt = et.dependencies;
                        if (rt !== null) {
                            tt = et.child;
                            for (var nt = rt.firstContext; nt !== null; ) {
                                if (nt.context === _) {
                                    if (et.tag === 1) {
                                        nt = mh(-1, b & -b),
                                        nt.tag = 2;
                                        var it = et.updateQueue;
                                        if (it !== null) {
                                            it = it.shared;
                                            var ot = it.pending;
                                            ot === null ? nt.next = nt : (nt.next = ot.next,
                                            ot.next = nt),
                                            it.pending = nt
                                        }
                                    }
                                    et.lanes |= b,
                                    nt = et.alternate,
                                    nt !== null && (nt.lanes |= b),
                                    bh(et.return, b, g),
                                    rt.lanes |= b;
                                    break
                                }
                                nt = nt.next
                            }
                        } else if (et.tag === 10)
                            tt = et.type === g.type ? null : et.child;
                        else if (et.tag === 18) {
                            if (tt = et.return,
                            tt === null)
                                throw Error(p$3(341));
                            tt.lanes |= b,
                            rt = tt.alternate,
                            rt !== null && (rt.lanes |= b),
                            bh(tt, b, g),
                            tt = et.sibling
                        } else
                            tt = et.child;
                        if (tt !== null)
                            tt.return = et;
                        else
                            for (tt = et; tt !== null; ) {
                                if (tt === g) {
                                    tt = null;
                                    break
                                }
                                if (et = tt.sibling,
                                et !== null) {
                                    et.return = tt.return,
                                    tt = et;
                                    break
                                }
                                tt = tt.return
                            }
                        et = tt
                    }
            Xi(d, g, $.children, b),
            g = g.child
        }
        return g;
    case 9:
        return $ = g.type,
        _ = g.pendingProps.children,
        ch(g, b),
        $ = eh($),
        _ = _($),
        g.flags |= 1,
        Xi(d, g, _, b),
        g.child;
    case 14:
        return _ = g.type,
        $ = Ci(_, g.pendingProps),
        $ = Ci(_.type, $),
        $i(d, g, _, $, b);
    case 15:
        return bj(d, g, g.type, g.pendingProps, b);
    case 17:
        return _ = g.type,
        $ = g.pendingProps,
        $ = g.elementType === _ ? $ : Ci(_, $),
        ij(d, g),
        g.tag = 1,
        Zf(_) ? (d = !0,
        cg(g)) : d = !1,
        ch(g, b),
        Gi(g, _, $),
        Ii(g, _, $, b),
        jj(null, g, _, !0, d, b);
    case 19:
        return xj(d, g, b);
    case 22:
        return dj(d, g, b)
    }
    throw Error(p$3(156, g.tag))
}
;
function Fk(d, g) {
    return ac(d, g)
}
function $k(d, g, b, _) {
    this.tag = d,
    this.key = b,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = g,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = _,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(d, g, b, _) {
    return new $k(d,g,b,_)
}
function aj(d) {
    return d = d.prototype,
    !(!d || !d.isReactComponent)
}
function Zk(d) {
    if (typeof d == "function")
        return aj(d) ? 1 : 0;
    if (d != null) {
        if (d = d.$$typeof,
        d === Da)
            return 11;
        if (d === Ga)
            return 14
    }
    return 2
}
function Pg(d, g) {
    var b = d.alternate;
    return b === null ? (b = Bg(d.tag, g, d.key, d.mode),
    b.elementType = d.elementType,
    b.type = d.type,
    b.stateNode = d.stateNode,
    b.alternate = d,
    d.alternate = b) : (b.pendingProps = g,
    b.type = d.type,
    b.flags = 0,
    b.subtreeFlags = 0,
    b.deletions = null),
    b.flags = d.flags & 14680064,
    b.childLanes = d.childLanes,
    b.lanes = d.lanes,
    b.child = d.child,
    b.memoizedProps = d.memoizedProps,
    b.memoizedState = d.memoizedState,
    b.updateQueue = d.updateQueue,
    g = d.dependencies,
    b.dependencies = g === null ? null : {
        lanes: g.lanes,
        firstContext: g.firstContext
    },
    b.sibling = d.sibling,
    b.index = d.index,
    b.ref = d.ref,
    b
}
function Rg(d, g, b, _, $, et) {
    var tt = 2;
    if (_ = d,
    typeof d == "function")
        aj(d) && (tt = 1);
    else if (typeof d == "string")
        tt = 5;
    else
        e: switch (d) {
        case ya:
            return Tg(b.children, $, et, g);
        case za:
            tt = 8,
            $ |= 8;
            break;
        case Aa:
            return d = Bg(12, b, g, $ | 2),
            d.elementType = Aa,
            d.lanes = et,
            d;
        case Ea:
            return d = Bg(13, b, g, $),
            d.elementType = Ea,
            d.lanes = et,
            d;
        case Fa:
            return d = Bg(19, b, g, $),
            d.elementType = Fa,
            d.lanes = et,
            d;
        case Ia:
            return pj(b, $, et, g);
        default:
            if (typeof d == "object" && d !== null)
                switch (d.$$typeof) {
                case Ba:
                    tt = 10;
                    break e;
                case Ca:
                    tt = 9;
                    break e;
                case Da:
                    tt = 11;
                    break e;
                case Ga:
                    tt = 14;
                    break e;
                case Ha:
                    tt = 16,
                    _ = null;
                    break e
                }
            throw Error(p$3(130, d == null ? d : typeof d, ""))
        }
    return g = Bg(tt, b, g, $),
    g.elementType = d,
    g.type = _,
    g.lanes = et,
    g
}
function Tg(d, g, b, _) {
    return d = Bg(7, d, _, g),
    d.lanes = b,
    d
}
function pj(d, g, b, _) {
    return d = Bg(22, d, _, g),
    d.elementType = Ia,
    d.lanes = b,
    d.stateNode = {
        isHidden: !1
    },
    d
}
function Qg(d, g, b) {
    return d = Bg(6, d, null, g),
    d.lanes = b,
    d
}
function Sg(d, g, b) {
    return g = Bg(4, d.children !== null ? d.children : [], d.key, g),
    g.lanes = b,
    g.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation
    },
    g
}
function al(d, g, b, _, $) {
    this.tag = g,
    this.containerInfo = d,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = _,
    this.onRecoverableError = $,
    this.mutableSourceEagerHydrationData = null
}
function bl(d, g, b, _, $, et, tt, rt, nt) {
    return d = new al(d,g,b,rt,nt),
    g === 1 ? (g = 1,
    et === !0 && (g |= 8)) : g = 0,
    et = Bg(3, null, null, g),
    d.current = et,
    et.stateNode = d,
    et.memoizedState = {
        element: _,
        isDehydrated: b,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    kh(et),
    d
}
function cl(d, g, b) {
    var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: _ == null ? null : "" + _,
        children: d,
        containerInfo: g,
        implementation: b
    }
}
function dl(d) {
    if (!d)
        return Vf;
    d = d._reactInternals;
    e: {
        if (Vb(d) !== d || d.tag !== 1)
            throw Error(p$3(170));
        var g = d;
        do {
            switch (g.tag) {
            case 3:
                g = g.stateNode.context;
                break e;
            case 1:
                if (Zf(g.type)) {
                    g = g.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            g = g.return
        } while (g !== null);
        throw Error(p$3(171))
    }
    if (d.tag === 1) {
        var b = d.type;
        if (Zf(b))
            return bg(d, b, g)
    }
    return g
}
function el(d, g, b, _, $, et, tt, rt, nt) {
    return d = bl(b, _, !0, d, $, et, tt, rt, nt),
    d.context = dl(null),
    b = d.current,
    _ = R(),
    $ = yi(b),
    et = mh(_, $),
    et.callback = g ?? null,
    nh(b, et, $),
    d.current.lanes = $,
    Ac(d, $, _),
    Dk(d, _),
    d
}
function fl(d, g, b, _) {
    var $ = g.current
      , et = R()
      , tt = yi($);
    return b = dl(b),
    g.context === null ? g.context = b : g.pendingContext = b,
    g = mh(et, tt),
    g.payload = {
        element: d
    },
    _ = _ === void 0 ? null : _,
    _ !== null && (g.callback = _),
    d = nh($, g, tt),
    d !== null && (gi(d, $, tt, et),
    oh(d, $, tt)),
    tt
}
function gl(d) {
    if (d = d.current,
    !d.child)
        return null;
    switch (d.child.tag) {
    case 5:
        return d.child.stateNode;
    default:
        return d.child.stateNode
    }
}
function hl(d, g) {
    if (d = d.memoizedState,
    d !== null && d.dehydrated !== null) {
        var b = d.retryLane;
        d.retryLane = b !== 0 && b < g ? b : g
    }
}
function il(d, g) {
    hl(d, g),
    (d = d.alternate) && hl(d, g)
}
function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(d) {
    console.error(d)
}
;
function ll(d) {
    this._internalRoot = d
}
ml.prototype.render = ll.prototype.render = function(d) {
    var g = this._internalRoot;
    if (g === null)
        throw Error(p$3(409));
    fl(d, g, null, null)
}
;
ml.prototype.unmount = ll.prototype.unmount = function() {
    var d = this._internalRoot;
    if (d !== null) {
        this._internalRoot = null;
        var g = d.containerInfo;
        Rk(function() {
            fl(null, d, null, null)
        }),
        g[uf] = null
    }
}
;
function ml(d) {
    this._internalRoot = d
}
ml.prototype.unstable_scheduleHydration = function(d) {
    if (d) {
        var g = Hc();
        d = {
            blockedOn: null,
            target: d,
            priority: g
        };
        for (var b = 0; b < Qc.length && g !== 0 && g < Qc[b].priority; b++)
            ;
        Qc.splice(b, 0, d),
        b === 0 && Vc(d)
    }
}
;
function nl(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
}
function ol(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11 && (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "))
}
function pl() {}
function ql(d, g, b, _, $) {
    if ($) {
        if (typeof _ == "function") {
            var et = _;
            _ = function() {
                var it = gl(tt);
                et.call(it)
            }
        }
        var tt = el(g, _, d, 0, null, !1, !1, "", pl);
        return d._reactRootContainer = tt,
        d[uf] = tt.current,
        sf(d.nodeType === 8 ? d.parentNode : d),
        Rk(),
        tt
    }
    for (; $ = d.lastChild; )
        d.removeChild($);
    if (typeof _ == "function") {
        var rt = _;
        _ = function() {
            var it = gl(nt);
            rt.call(it)
        }
    }
    var nt = bl(d, 0, !1, null, null, !1, !1, "", pl);
    return d._reactRootContainer = nt,
    d[uf] = nt.current,
    sf(d.nodeType === 8 ? d.parentNode : d),
    Rk(function() {
        fl(g, nt, b, _)
    }),
    nt
}
function rl(d, g, b, _, $) {
    var et = b._reactRootContainer;
    if (et) {
        var tt = et;
        if (typeof $ == "function") {
            var rt = $;
            $ = function() {
                var nt = gl(tt);
                rt.call(nt)
            }
        }
        fl(g, tt, d, $)
    } else
        tt = ql(b, g, d, $, _);
    return gl(tt)
}
Ec = function(d) {
    switch (d.tag) {
    case 3:
        var g = d.stateNode;
        if (g.current.memoizedState.isDehydrated) {
            var b = tc(g.pendingLanes);
            b !== 0 && (Cc(g, b | 1),
            Dk(g, B()),
            !(K & 6) && (Gj = B() + 500,
            jg()))
        }
        break;
    case 13:
        Rk(function() {
            var _ = ih(d, 1);
            if (_ !== null) {
                var $ = R();
                gi(_, d, 1, $)
            }
        }),
        il(d, 1)
    }
}
;
Fc = function(d) {
    if (d.tag === 13) {
        var g = ih(d, 134217728);
        if (g !== null) {
            var b = R();
            gi(g, d, 134217728, b)
        }
        il(d, 134217728)
    }
}
;
Gc = function(d) {
    if (d.tag === 13) {
        var g = yi(d)
          , b = ih(d, g);
        if (b !== null) {
            var _ = R();
            gi(b, d, g, _)
        }
        il(d, g)
    }
}
;
Hc = function() {
    return C
}
;
Ic = function(d, g) {
    var b = C;
    try {
        return C = d,
        g()
    } finally {
        C = b
    }
}
;
yb = function(d, g, b) {
    switch (g) {
    case "input":
        if (bb(d, b),
        g = b.name,
        b.type === "radio" && g != null) {
            for (b = d; b.parentNode; )
                b = b.parentNode;
            for (b = b.querySelectorAll("input[name=" + JSON.stringify("" + g) + '][type="radio"]'),
            g = 0; g < b.length; g++) {
                var _ = b[g];
                if (_ !== d && _.form === d.form) {
                    var $ = Db(_);
                    if (!$)
                        throw Error(p$3(90));
                    Wa(_),
                    bb(_, $)
                }
            }
        }
        break;
    case "textarea":
        ib(d, b);
        break;
    case "select":
        g = b.value,
        g != null && fb(d, !!b.multiple, g, !1)
    }
}
;
Gb = Qk;
Hb = Rk;
var sl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Qk]
}
  , tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(d) {
        return d = Zb(d),
        d === null ? null : d.stateNode
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
        try {
            kc = vl.inject(ul),
            lc = vl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(d, g) {
    var b = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(g))
        throw Error(p$3(200));
    return cl(d, g, null, b)
}
;
reactDom_production_min.createRoot = function(d, g) {
    if (!nl(d))
        throw Error(p$3(299));
    var b = !1
      , _ = ""
      , $ = kl;
    return g != null && (g.unstable_strictMode === !0 && (b = !0),
    g.identifierPrefix !== void 0 && (_ = g.identifierPrefix),
    g.onRecoverableError !== void 0 && ($ = g.onRecoverableError)),
    g = bl(d, 1, !1, null, null, b, !1, _, $),
    d[uf] = g.current,
    sf(d.nodeType === 8 ? d.parentNode : d),
    new ll(g)
}
;
reactDom_production_min.findDOMNode = function(d) {
    if (d == null)
        return null;
    if (d.nodeType === 1)
        return d;
    var g = d._reactInternals;
    if (g === void 0)
        throw typeof d.render == "function" ? Error(p$3(188)) : (d = Object.keys(d).join(","),
        Error(p$3(268, d)));
    return d = Zb(g),
    d = d === null ? null : d.stateNode,
    d
}
;
reactDom_production_min.flushSync = function(d) {
    return Rk(d)
}
;
reactDom_production_min.hydrate = function(d, g, b) {
    if (!ol(g))
        throw Error(p$3(200));
    return rl(null, d, g, !0, b)
}
;
reactDom_production_min.hydrateRoot = function(d, g, b) {
    if (!nl(d))
        throw Error(p$3(405));
    var _ = b != null && b.hydratedSources || null
      , $ = !1
      , et = ""
      , tt = kl;
    if (b != null && (b.unstable_strictMode === !0 && ($ = !0),
    b.identifierPrefix !== void 0 && (et = b.identifierPrefix),
    b.onRecoverableError !== void 0 && (tt = b.onRecoverableError)),
    g = el(g, null, d, 1, b ?? null, $, !1, et, tt),
    d[uf] = g.current,
    sf(d),
    _)
        for (d = 0; d < _.length; d++)
            b = _[d],
            $ = b._getVersion,
            $ = $(b._source),
            g.mutableSourceEagerHydrationData == null ? g.mutableSourceEagerHydrationData = [b, $] : g.mutableSourceEagerHydrationData.push(b, $);
    return new ml(g)
}
;
reactDom_production_min.render = function(d, g, b) {
    if (!ol(g))
        throw Error(p$3(200));
    return rl(null, d, g, !1, b)
}
;
reactDom_production_min.unmountComponentAtNode = function(d) {
    if (!ol(d))
        throw Error(p$3(40));
    return d._reactRootContainer ? (Rk(function() {
        rl(null, null, d, !1, function() {
            d._reactRootContainer = null,
            d[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(d, g, b, _) {
    if (!ol(b))
        throw Error(p$3(200));
    if (d == null || d._reactInternals === void 0)
        throw Error(p$3(38));
    return rl(d, g, b, !1, _)
}
;
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (d) {
            console.error(d)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports
  , m$1 = reactDomExports;
client.createRoot = m$1.createRoot,
client.hydrateRoot = m$1.hydrateRoot;
var classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(d) {
    (function() {
        var g = {}.hasOwnProperty;
        function b() {
            for (var et = "", tt = 0; tt < arguments.length; tt++) {
                var rt = arguments[tt];
                rt && (et = $(et, _(rt)))
            }
            return et
        }
        function _(et) {
            if (typeof et == "string" || typeof et == "number")
                return et;
            if (typeof et != "object")
                return "";
            if (Array.isArray(et))
                return b.apply(null, et);
            if (et.toString !== Object.prototype.toString && !et.toString.toString().includes("[native code]"))
                return et.toString();
            var tt = "";
            for (var rt in et)
                g.call(et, rt) && et[rt] && (tt = $(tt, rt));
            return tt
        }
        function $(et, tt) {
            return tt ? et ? et + " " + tt : et + tt : et
        }
        d.exports ? (b.default = b,
        d.exports = b) : window.classNames = b
    }
    )()
}
)(classnames);
var classnamesExports = classnames.exports;
const classNames = getDefaultExportFromCjs(classnamesExports);
var dist$4 = {
    exports: {}
};
function memoize(d) {
    var g = {};
    return function(b) {
        return g[b] === void 0 && (g[b] = d(b)),
        g[b]
    }
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , index = memoize(function(d) {
    return reactPropsRegex.test(d) || d.charCodeAt(0) === 111 && d.charCodeAt(1) === 110 && d.charCodeAt(2) < 91
});
const isPropValid_browser_esm = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: index
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$1 = getAugmentedNamespace(isPropValid_browser_esm);
(function(d, g) {
    (function(b, _) {
        d.exports = _(reactExports)
    }
    )(self, function(b) {
        return (()=>{
            var _ = {
                297: rt=>{
                    rt.exports = b
                }
            }
              , $ = {};
            function et(rt) {
                var nt = $[rt];
                if (nt !== void 0)
                    return nt.exports;
                var it = $[rt] = {
                    exports: {}
                };
                return _[rt](it, it.exports, et),
                it.exports
            }
            et.n = rt=>{
                var nt = rt && rt.__esModule ? ()=>rt.default : ()=>rt;
                return et.d(nt, {
                    a: nt
                }),
                nt
            }
            ,
            et.d = (rt,nt)=>{
                for (var it in nt)
                    et.o(nt, it) && !et.o(rt, it) && Object.defineProperty(rt, it, {
                        enumerable: !0,
                        get: nt[it]
                    })
            }
            ,
            et.o = (rt,nt)=>Object.prototype.hasOwnProperty.call(rt, nt),
            et.r = rt=>{
                typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(rt, Symbol.toStringTag, {
                    value: "Module"
                }),
                Object.defineProperty(rt, "__esModule", {
                    value: !0
                })
            }
            ;
            var tt = {};
            return (()=>{
                et.r(tt),
                et.d(tt, {
                    default: ()=>Jp
                });
                var rt = et(297)
                  , nt = et.n(rt);
                const it = mt=>mt;
                let ot = it;
                const at = {
                    some: 0,
                    all: 1
                }
                  , st = mt=>/^\-?\d*\.?\d+$/.test(mt)
                  , dt = mt=>/^0[^.\s]+$/.test(mt)
                  , ft = mt=>Array.isArray(mt);
                function ht(mt, gt) {
                    mt.indexOf(gt) === -1 && mt.push(gt)
                }
                function xt(mt, gt) {
                    const Tt = mt.indexOf(gt);
                    Tt > -1 && mt.splice(Tt, 1)
                }
                class lt {
                    constructor() {
                        this.subscriptions = []
                    }
                    add(gt) {
                        return ht(this.subscriptions, gt),
                        ()=>xt(this.subscriptions, gt)
                    }
                    notify(gt, Tt, Bt) {
                        const Nt = this.subscriptions.length;
                        if (Nt)
                            if (Nt === 1)
                                this.subscriptions[0](gt, Tt, Bt);
                            else
                                for (let Ot = 0; Ot < Nt; Ot++) {
                                    const Yt = this.subscriptions[Ot];
                                    Yt && Yt(gt, Tt, Bt)
                                }
                    }
                    getSize() {
                        return this.subscriptions.length
                    }
                    clear() {
                        this.subscriptions.length = 0
                    }
                }
                function ct(mt, gt) {
                    return gt ? mt * (1e3 / gt) : 0
                }
                class ut {
                    constructor() {
                        this.order = [],
                        this.scheduled = new Set
                    }
                    add(gt) {
                        if (!this.scheduled.has(gt))
                            return this.scheduled.add(gt),
                            this.order.push(gt),
                            !0
                    }
                    remove(gt) {
                        const Tt = this.order.indexOf(gt);
                        Tt !== -1 && (this.order.splice(Tt, 1),
                        this.scheduled.delete(gt))
                    }
                    clear() {
                        this.order.length = 0,
                        this.scheduled.clear()
                    }
                }
                const pt = ["prepare", "read", "update", "preRender", "render", "postRender"]
                  , {schedule: vt, cancel: _t, state: Pt, steps: kt} = function(mt, gt) {
                    let Tt = !1
                      , Bt = !0;
                    const Nt = {
                        delta: 0,
                        timestamp: 0,
                        isProcessing: !1
                    }
                      , Ot = pt.reduce((Jt,nr)=>(Jt[nr] = function(sr) {
                        let or = new ut
                          , ur = new ut
                          , yr = 0
                          , mr = !1
                          , Ar = !1;
                        const br = new WeakSet
                          , Rr = {
                            schedule: (_r,Sr=!1,Vr=!1)=>{
                                const qr = Vr && mr
                                  , an = qr ? or : ur;
                                return Sr && br.add(_r),
                                an.add(_r) && qr && mr && (yr = or.order.length),
                                _r
                            }
                            ,
                            cancel: _r=>{
                                ur.remove(_r),
                                br.delete(_r)
                            }
                            ,
                            process: _r=>{
                                if (mr)
                                    Ar = !0;
                                else {
                                    if (mr = !0,
                                    [or,ur] = [ur, or],
                                    ur.clear(),
                                    yr = or.order.length,
                                    yr)
                                        for (let Sr = 0; Sr < yr; Sr++) {
                                            const Vr = or.order[Sr];
                                            Vr(_r),
                                            br.has(Vr) && (Rr.schedule(Vr),
                                            sr())
                                        }
                                    mr = !1,
                                    Ar && (Ar = !1,
                                    Rr.process(_r))
                                }
                            }
                        };
                        return Rr
                    }(()=>Tt = !0),
                    Jt), {})
                      , Yt = Jt=>Ot[Jt].process(Nt)
                      , Zt = ()=>{
                        const Jt = performance.now();
                        Tt = !1,
                        Nt.delta = Bt ? 1e3 / 60 : Math.max(Math.min(Jt - Nt.timestamp, 40), 1),
                        Nt.timestamp = Jt,
                        Nt.isProcessing = !0,
                        pt.forEach(Yt),
                        Nt.isProcessing = !1,
                        Tt && (Bt = !1,
                        mt(Zt))
                    }
                    ;
                    return {
                        schedule: pt.reduce((Jt,nr)=>{
                            const sr = Ot[nr];
                            return Jt[nr] = (or,ur=!1,yr=!1)=>(Tt || (Tt = !0,
                            Bt = !0,
                            Nt.isProcessing || mt(Zt)),
                            sr.schedule(or, ur, yr)),
                            Jt
                        }
                        , {}),
                        cancel: Jt=>pt.forEach(nr=>Ot[nr].cancel(Jt)),
                        state: Nt,
                        steps: Ot
                    }
                }(typeof requestAnimationFrame < "u" ? requestAnimationFrame : it);
                class $t {
                    constructor(gt, Tt={}) {
                        var Bt;
                        this.version = "10.16.5",
                        this.timeDelta = 0,
                        this.lastUpdated = 0,
                        this.canTrackVelocity = !1,
                        this.events = {},
                        this.updateAndNotify = (Nt,Ot=!0)=>{
                            this.prev = this.current,
                            this.current = Nt;
                            const {delta: Yt, timestamp: Zt} = Pt;
                            this.lastUpdated !== Zt && (this.timeDelta = Yt,
                            this.lastUpdated = Zt,
                            vt.postRender(this.scheduleVelocityCheck)),
                            this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
                            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
                            Ot && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                        }
                        ,
                        this.scheduleVelocityCheck = ()=>vt.postRender(this.velocityCheck),
                        this.velocityCheck = ({timestamp: Nt})=>{
                            Nt !== this.lastUpdated && (this.prev = this.current,
                            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
                        }
                        ,
                        this.hasAnimated = !1,
                        this.prev = this.current = gt,
                        this.canTrackVelocity = (Bt = this.current,
                        !isNaN(parseFloat(Bt))),
                        this.owner = Tt.owner
                    }
                    onChange(gt) {
                        return this.on("change", gt)
                    }
                    on(gt, Tt) {
                        this.events[gt] || (this.events[gt] = new lt);
                        const Bt = this.events[gt].add(Tt);
                        return gt === "change" ? ()=>{
                            Bt(),
                            vt.read(()=>{
                                this.events.change.getSize() || this.stop()
                            }
                            )
                        }
                        : Bt
                    }
                    clearListeners() {
                        for (const gt in this.events)
                            this.events[gt].clear()
                    }
                    attach(gt, Tt) {
                        this.passiveEffect = gt,
                        this.stopPassiveEffect = Tt
                    }
                    set(gt, Tt=!0) {
                        Tt && this.passiveEffect ? this.passiveEffect(gt, this.updateAndNotify) : this.updateAndNotify(gt, Tt)
                    }
                    setWithVelocity(gt, Tt, Bt) {
                        this.set(Tt),
                        this.prev = gt,
                        this.timeDelta = Bt
                    }
                    jump(gt) {
                        this.updateAndNotify(gt),
                        this.prev = gt,
                        this.stop(),
                        this.stopPassiveEffect && this.stopPassiveEffect()
                    }
                    get() {
                        return this.current
                    }
                    getPrevious() {
                        return this.prev
                    }
                    getVelocity() {
                        return this.canTrackVelocity ? ct(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
                    }
                    start(gt) {
                        return this.stop(),
                        new Promise(Tt=>{
                            this.hasAnimated = !0,
                            this.animation = gt(Tt),
                            this.events.animationStart && this.events.animationStart.notify()
                        }
                        ).then(()=>{
                            this.events.animationComplete && this.events.animationComplete.notify(),
                            this.clearAnimation()
                        }
                        )
                    }
                    stop() {
                        this.animation && (this.animation.stop(),
                        this.events.animationCancel && this.events.animationCancel.notify()),
                        this.clearAnimation()
                    }
                    isAnimating() {
                        return !!this.animation
                    }
                    clearAnimation() {
                        delete this.animation
                    }
                    destroy() {
                        this.clearListeners(),
                        this.stop(),
                        this.stopPassiveEffect && this.stopPassiveEffect()
                    }
                }
                function Wt(mt, gt) {
                    return new $t(mt,gt)
                }
                const Ht = mt=>gt=>typeof gt == "string" && gt.startsWith(mt)
                  , Dt = Ht("--")
                  , Vt = Ht("var(--")
                  , Ft = mt=>Math.round(1e5 * mt) / 1e5
                  , Kt = /(-)?([\d]*\.?[\d])+/g
                  , Rt = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
                  , qt = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
                function Et(mt) {
                    return typeof mt == "string"
                }
                const St = (mt,gt,Tt)=>Math.min(Math.max(Tt, mt), gt)
                  , Lt = {
                    test: mt=>typeof mt == "number",
                    parse: parseFloat,
                    transform: mt=>mt
                }
                  , Mt = {
                    ...Lt,
                    transform: mt=>St(0, 1, mt)
                }
                  , ar = {
                    ...Lt,
                    default: 1
                }
                  , wr = (mt,gt)=>Tt=>!!(Et(Tt) && qt.test(Tt) && Tt.startsWith(mt) || gt && Object.prototype.hasOwnProperty.call(Tt, gt))
                  , Tr = (mt,gt,Tt)=>Bt=>{
                    if (!Et(Bt))
                        return Bt;
                    const [Nt,Ot,Yt,Zt] = Bt.match(Kt);
                    return {
                        [mt]: parseFloat(Nt),
                        [gt]: parseFloat(Ot),
                        [Tt]: parseFloat(Yt),
                        alpha: Zt !== void 0 ? parseFloat(Zt) : 1
                    }
                }
                  , Pr = {
                    ...Lt,
                    transform: mt=>Math.round((gt=>St(0, 255, gt))(mt))
                }
                  , kr = {
                    test: wr("rgb", "red"),
                    parse: Tr("red", "green", "blue"),
                    transform: ({red: mt, green: gt, blue: Tt, alpha: Bt=1})=>"rgba(" + Pr.transform(mt) + ", " + Pr.transform(gt) + ", " + Pr.transform(Tt) + ", " + Ft(Mt.transform(Bt)) + ")"
                }
                  , jr = {
                    test: wr("#"),
                    parse: function(mt) {
                        let gt = ""
                          , Tt = ""
                          , Bt = ""
                          , Nt = "";
                        return mt.length > 5 ? (gt = mt.substring(1, 3),
                        Tt = mt.substring(3, 5),
                        Bt = mt.substring(5, 7),
                        Nt = mt.substring(7, 9)) : (gt = mt.substring(1, 2),
                        Tt = mt.substring(2, 3),
                        Bt = mt.substring(3, 4),
                        Nt = mt.substring(4, 5),
                        gt += gt,
                        Tt += Tt,
                        Bt += Bt,
                        Nt += Nt),
                        {
                            red: parseInt(gt, 16),
                            green: parseInt(Tt, 16),
                            blue: parseInt(Bt, 16),
                            alpha: Nt ? parseInt(Nt, 16) / 255 : 1
                        }
                    },
                    transform: kr.transform
                }
                  , cr = mt=>({
                    test: gt=>Et(gt) && gt.endsWith(mt) && gt.split(" ").length === 1,
                    parse: parseFloat,
                    transform: gt=>`${gt}${mt}`
                })
                  , dr = cr("deg")
                  , lr = cr("%")
                  , ir = cr("px")
                  , gr = cr("vh")
                  , Cr = cr("vw")
                  , hr = {
                    ...lr,
                    parse: mt=>lr.parse(mt) / 100,
                    transform: mt=>lr.transform(100 * mt)
                }
                  , zr = {
                    test: wr("hsl", "hue"),
                    parse: Tr("hue", "saturation", "lightness"),
                    transform: ({hue: mt, saturation: gt, lightness: Tt, alpha: Bt=1})=>"hsla(" + Math.round(mt) + ", " + lr.transform(Ft(gt)) + ", " + lr.transform(Ft(Tt)) + ", " + Ft(Mt.transform(Bt)) + ")"
                }
                  , Zr = {
                    test: mt=>kr.test(mt) || jr.test(mt) || zr.test(mt),
                    parse: mt=>kr.test(mt) ? kr.parse(mt) : zr.test(mt) ? zr.parse(mt) : jr.parse(mt),
                    transform: mt=>Et(mt) ? mt : mt.hasOwnProperty("red") ? kr.transform(mt) : zr.transform(mt)
                }
                  , ln = {
                    regex: /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
                    countKey: "Vars",
                    token: "${v}",
                    parse: it
                }
                  , Gr = {
                    regex: Rt,
                    countKey: "Colors",
                    token: "${c}",
                    parse: Zr.parse
                }
                  , vn = {
                    regex: Kt,
                    countKey: "Numbers",
                    token: "${n}",
                    parse: Lt.parse
                };
                function fn(mt, {regex: gt, countKey: Tt, token: Bt, parse: Nt}) {
                    const Ot = mt.tokenised.match(gt);
                    Ot && (mt["num" + Tt] = Ot.length,
                    mt.tokenised = mt.tokenised.replace(gt, Bt),
                    mt.values.push(...Ot.map(Nt)))
                }
                function Rn(mt) {
                    const gt = mt.toString()
                      , Tt = {
                        value: gt,
                        tokenised: gt,
                        values: [],
                        numVars: 0,
                        numColors: 0,
                        numNumbers: 0
                    };
                    return Tt.value.includes("var(--") && fn(Tt, ln),
                    fn(Tt, Gr),
                    fn(Tt, vn),
                    Tt
                }
                function bn(mt) {
                    return Rn(mt).values
                }
                function Un(mt) {
                    const {values: gt, numColors: Tt, numVars: Bt, tokenised: Nt} = Rn(mt)
                      , Ot = gt.length;
                    return Yt=>{
                        let Zt = Nt;
                        for (let Jt = 0; Jt < Ot; Jt++)
                            Zt = Jt < Bt ? Zt.replace(ln.token, Yt[Jt]) : Jt < Bt + Tt ? Zt.replace(Gr.token, Zr.transform(Yt[Jt])) : Zt.replace(vn.token, Ft(Yt[Jt]));
                        return Zt
                    }
                }
                const zn = mt=>typeof mt == "number" ? 0 : mt
                  , er = {
                    test: function(mt) {
                        var gt, Tt;
                        return isNaN(mt) && Et(mt) && (((gt = mt.match(Kt)) === null || gt === void 0 ? void 0 : gt.length) || 0) + (((Tt = mt.match(Rt)) === null || Tt === void 0 ? void 0 : Tt.length) || 0) > 0
                    },
                    parse: bn,
                    createTransformer: Un,
                    getAnimatableNone: function(mt) {
                        const gt = bn(mt);
                        return Un(mt)(gt.map(zn))
                    }
                }
                  , Ut = new Set(["brightness", "contrast", "saturate", "opacity"]);
                function Ct(mt) {
                    const [gt,Tt] = mt.slice(0, -1).split("(");
                    if (gt === "drop-shadow")
                        return mt;
                    const [Bt] = Tt.match(Kt) || [];
                    if (!Bt)
                        return mt;
                    const Nt = Tt.replace(Bt, "");
                    let Ot = Ut.has(gt) ? 1 : 0;
                    return Bt !== Tt && (Ot *= 100),
                    gt + "(" + Ot + Nt + ")"
                }
                const yt = /([a-z-]*)\(.*?\)/g
                  , bt = {
                    ...er,
                    getAnimatableNone: mt=>{
                        const gt = mt.match(yt);
                        return gt ? gt.map(Ct).join(" ") : mt
                    }
                }
                  , At = {
                    ...Lt,
                    transform: Math.round
                }
                  , Gt = {
                    borderWidth: ir,
                    borderTopWidth: ir,
                    borderRightWidth: ir,
                    borderBottomWidth: ir,
                    borderLeftWidth: ir,
                    borderRadius: ir,
                    radius: ir,
                    borderTopLeftRadius: ir,
                    borderTopRightRadius: ir,
                    borderBottomRightRadius: ir,
                    borderBottomLeftRadius: ir,
                    width: ir,
                    maxWidth: ir,
                    height: ir,
                    maxHeight: ir,
                    size: ir,
                    top: ir,
                    right: ir,
                    bottom: ir,
                    left: ir,
                    padding: ir,
                    paddingTop: ir,
                    paddingRight: ir,
                    paddingBottom: ir,
                    paddingLeft: ir,
                    margin: ir,
                    marginTop: ir,
                    marginRight: ir,
                    marginBottom: ir,
                    marginLeft: ir,
                    rotate: dr,
                    rotateX: dr,
                    rotateY: dr,
                    rotateZ: dr,
                    scale: ar,
                    scaleX: ar,
                    scaleY: ar,
                    scaleZ: ar,
                    skew: dr,
                    skewX: dr,
                    skewY: dr,
                    distance: ir,
                    translateX: ir,
                    translateY: ir,
                    translateZ: ir,
                    x: ir,
                    y: ir,
                    z: ir,
                    perspective: ir,
                    transformPerspective: ir,
                    opacity: Mt,
                    originX: hr,
                    originY: hr,
                    originZ: ir,
                    zIndex: At,
                    fillOpacity: Mt,
                    strokeOpacity: Mt,
                    numOctaves: At
                }
                  , Qt = {
                    ...Gt,
                    color: Zr,
                    backgroundColor: Zr,
                    outlineColor: Zr,
                    fill: Zr,
                    stroke: Zr,
                    borderColor: Zr,
                    borderTopColor: Zr,
                    borderRightColor: Zr,
                    borderBottomColor: Zr,
                    borderLeftColor: Zr,
                    filter: bt,
                    WebkitFilter: bt
                }
                  , rr = mt=>Qt[mt];
                function Er(mt, gt) {
                    let Tt = rr(mt);
                    return Tt !== bt && (Tt = er),
                    Tt.getAnimatableNone ? Tt.getAnimatableNone(gt) : void 0
                }
                const Ur = mt=>gt=>gt.test(mt)
                  , Mr = [Lt, ir, lr, dr, Cr, gr, {
                    test: mt=>mt === "auto",
                    parse: mt=>mt
                }]
                  , Lr = mt=>Mr.find(Ur(mt))
                  , Kr = [...Mr, Zr, er];
                function Fr(mt, gt, Tt, Bt={}, Nt={}) {
                    return typeof gt == "function" && (gt = gt(Tt !== void 0 ? Tt : mt.custom, Bt, Nt)),
                    typeof gt == "string" && (gt = mt.variants && mt.variants[gt]),
                    typeof gt == "function" && (gt = gt(Tt !== void 0 ? Tt : mt.custom, Bt, Nt)),
                    gt
                }
                function Mn(mt, gt, Tt) {
                    const Bt = mt.getProps();
                    return Fr(Bt, gt, Tt !== void 0 ? Tt : Bt.custom, function(Nt) {
                        const Ot = {};
                        return Nt.values.forEach((Yt,Zt)=>Ot[Zt] = Yt.get()),
                        Ot
                    }(mt), function(Nt) {
                        const Ot = {};
                        return Nt.values.forEach((Yt,Zt)=>Ot[Zt] = Yt.getVelocity()),
                        Ot
                    }(mt))
                }
                function Bn(mt, gt, Tt) {
                    mt.hasValue(gt) ? mt.getValue(gt).set(Tt) : mt.addValue(gt, Wt(Tt))
                }
                function jn(mt, gt) {
                    const Tt = Mn(mt, gt);
                    let {transitionEnd: Bt={}, transition: Nt={}, ...Ot} = Tt ? mt.makeTargetAnimatable(Tt, !1) : {};
                    Ot = {
                        ...Ot,
                        ...Bt
                    };
                    for (const Zt in Ot)
                        Bn(mt, Zt, (Yt = Ot[Zt],
                        ft(Yt) ? Yt[Yt.length - 1] || 0 : Yt));
                    var Yt
                }
                function Hn(mt, gt) {
                    [...gt].reverse().forEach(Tt=>{
                        const Bt = mt.getVariant(Tt);
                        Bt && jn(mt, Bt),
                        mt.variantChildren && mt.variantChildren.forEach(Nt=>{
                            Hn(Nt, gt)
                        }
                        )
                    }
                    )
                }
                function eo(mt, gt) {
                    if (gt)
                        return (gt[mt] || gt.default || gt).from
                }
                const Gn = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
                  , Kn = new Set(Gn)
                  , ho = mt=>mt.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
                  , mo = "data-" + ho("framerAppearId")
                  , ao = mt=>1e3 * mt
                  , lo = mt=>mt / 1e3
                  , no = mt=>Array.isArray(mt) && typeof mt[0] == "number";
                function Ro(mt) {
                    return !!(!mt || typeof mt == "string" && zt[mt] || no(mt) || Array.isArray(mt) && mt.every(Ro))
                }
                const It = ([mt,gt,Tt,Bt])=>`cubic-bezier(${mt}, ${gt}, ${Tt}, ${Bt})`
                  , zt = {
                    linear: "linear",
                    ease: "ease",
                    easeIn: "ease-in",
                    easeOut: "ease-out",
                    easeInOut: "ease-in-out",
                    circIn: It([0, .65, .55, 1]),
                    circOut: It([.55, 0, 1, .45]),
                    backIn: It([.31, .01, .66, -.59]),
                    backOut: It([.33, 1.53, .69, .99])
                };
                function jt(mt) {
                    if (mt)
                        return no(mt) ? It(mt) : Array.isArray(mt) ? mt.map(jt) : zt[mt]
                }
                const wt = (mt,gt,Tt)=>(((1 - 3 * Tt + 3 * gt) * mt + (3 * Tt - 6 * gt)) * mt + 3 * gt) * mt;
                function Xt(mt, gt, Tt, Bt) {
                    return mt === gt && Tt === Bt ? it : Nt=>Nt === 0 || Nt === 1 ? Nt : wt(function(Ot, Yt, Zt, Jt, nr) {
                        let sr, or, ur = 0;
                        do
                            or = Yt + (Zt - Yt) / 2,
                            sr = wt(or, Jt, nr) - Ot,
                            sr > 0 ? Zt = or : Yt = or;
                        while (Math.abs(sr) > 1e-7 && ++ur < 12);
                        return or
                    }(Nt, 0, 1, mt, Tt), gt, Bt)
                }
                const fr = Xt(.42, 0, 1, 1)
                  , pr = Xt(0, 0, .58, 1)
                  , Ir = Xt(.42, 0, .58, 1)
                  , Nr = mt=>gt=>gt <= .5 ? mt(2 * gt) / 2 : (2 - mt(2 * (1 - gt))) / 2
                  , nn = mt=>gt=>1 - mt(1 - gt)
                  , Yr = mt=>1 - Math.sin(Math.acos(mt))
                  , Ln = nn(Yr)
                  , Qr = Nr(Ln)
                  , pn = Xt(.33, 1.53, .69, .99)
                  , mn = nn(pn)
                  , En = Nr(mn)
                  , Sn = {
                    linear: it,
                    easeIn: fr,
                    easeInOut: Ir,
                    easeOut: pr,
                    circIn: Yr,
                    circInOut: Qr,
                    circOut: Ln,
                    backIn: mn,
                    backInOut: En,
                    backOut: pn,
                    anticipate: mt=>(mt *= 2) < 1 ? .5 * mn(mt) : .5 * (2 - Math.pow(2, -10 * (mt - 1)))
                }
                  , yn = mt=>{
                    if (Array.isArray(mt)) {
                        ot(mt.length === 4);
                        const [gt,Tt,Bt,Nt] = mt;
                        return Xt(gt, Tt, Bt, Nt)
                    }
                    return typeof mt == "string" ? Sn[mt] : mt
                }
                  , Jr = (mt,gt,Tt)=>-Tt * mt + Tt * gt + mt;
                function gn(mt, gt, Tt) {
                    return Tt < 0 && (Tt += 1),
                    Tt > 1 && (Tt -= 1),
                    Tt < 1 / 6 ? mt + 6 * (gt - mt) * Tt : Tt < .5 ? gt : Tt < 2 / 3 ? mt + (gt - mt) * (2 / 3 - Tt) * 6 : mt
                }
                const tn = (mt,gt,Tt)=>{
                    const Bt = mt * mt;
                    return Math.sqrt(Math.max(0, Tt * (gt * gt - Bt) + Bt))
                }
                  , cn = [jr, kr, zr];
                function Xr(mt) {
                    const gt = (Tt = mt,
                    cn.find(Nt=>Nt.test(Tt)));
                    var Tt;
                    let Bt = gt.parse(mt);
                    return gt === zr && (Bt = function({hue: Nt, saturation: Ot, lightness: Yt, alpha: Zt}) {
                        Nt /= 360,
                        Yt /= 100;
                        let Jt = 0
                          , nr = 0
                          , sr = 0;
                        if (Ot /= 100) {
                            const or = Yt < .5 ? Yt * (1 + Ot) : Yt + Ot - Yt * Ot
                              , ur = 2 * Yt - or;
                            Jt = gn(ur, or, Nt + 1 / 3),
                            nr = gn(ur, or, Nt),
                            sr = gn(ur, or, Nt - 1 / 3)
                        } else
                            Jt = nr = sr = Yt;
                        return {
                            red: Math.round(255 * Jt),
                            green: Math.round(255 * nr),
                            blue: Math.round(255 * sr),
                            alpha: Zt
                        }
                    }(Bt)),
                    Bt
                }
                const rn = (mt,gt)=>{
                    const Tt = Xr(mt)
                      , Bt = Xr(gt)
                      , Nt = {
                        ...Tt
                    };
                    return Ot=>(Nt.red = tn(Tt.red, Bt.red, Ot),
                    Nt.green = tn(Tt.green, Bt.green, Ot),
                    Nt.blue = tn(Tt.blue, Bt.blue, Ot),
                    Nt.alpha = Jr(Tt.alpha, Bt.alpha, Ot),
                    kr.transform(Nt))
                }
                  , sn = (mt,gt)=>Tt=>gt(mt(Tt))
                  , Hr = (...mt)=>mt.reduce(sn)
                  , vr = (mt,gt)=>Tt=>`${Tt > 0 ? gt : mt}`;
                function xr(mt, gt) {
                    return typeof mt == "number" ? Tt=>Jr(mt, gt, Tt) : Zr.test(mt) ? rn(mt, gt) : mt.startsWith("var(") ? vr(mt, gt) : $r(mt, gt)
                }
                const Dr = (mt,gt)=>{
                    const Tt = [...mt]
                      , Bt = Tt.length
                      , Nt = mt.map((Ot,Yt)=>xr(Ot, gt[Yt]));
                    return Ot=>{
                        for (let Yt = 0; Yt < Bt; Yt++)
                            Tt[Yt] = Nt[Yt](Ot);
                        return Tt
                    }
                }
                  , Br = (mt,gt)=>{
                    const Tt = {
                        ...mt,
                        ...gt
                    }
                      , Bt = {};
                    for (const Nt in Tt)
                        mt[Nt] !== void 0 && gt[Nt] !== void 0 && (Bt[Nt] = xr(mt[Nt], gt[Nt]));
                    return Nt=>{
                        for (const Ot in Bt)
                            Tt[Ot] = Bt[Ot](Nt);
                        return Tt
                    }
                }
                  , $r = (mt,gt)=>{
                    const Tt = er.createTransformer(gt)
                      , Bt = Rn(mt)
                      , Nt = Rn(gt);
                    return Bt.numVars === Nt.numVars && Bt.numColors === Nt.numColors && Bt.numNumbers >= Nt.numNumbers ? Hr(Dr(Bt.values, Nt.values), Tt) : vr(mt, gt)
                }
                  , Or = (mt,gt,Tt)=>{
                    const Bt = gt - mt;
                    return Bt === 0 ? 1 : (Tt - mt) / Bt
                }
                  , dn = (mt,gt)=>Tt=>Jr(mt, gt, Tt);
                function Cn(mt, gt, {clamp: Tt=!0, ease: Bt, mixer: Nt}={}) {
                    const Ot = mt.length;
                    if (ot(Ot === gt.length),
                    Ot === 1)
                        return ()=>gt[0];
                    mt[0] > mt[Ot - 1] && (mt = [...mt].reverse(),
                    gt = [...gt].reverse());
                    const Yt = function(nr, sr, or) {
                        const ur = []
                          , yr = or || (typeof (mr = nr[0]) == "number" ? dn : typeof mr == "string" ? Zr.test(mr) ? rn : $r : Array.isArray(mr) ? Dr : typeof mr == "object" ? Br : dn);
                        var mr;
                        const Ar = nr.length - 1;
                        for (let br = 0; br < Ar; br++) {
                            let Rr = yr(nr[br], nr[br + 1]);
                            if (sr) {
                                const _r = Array.isArray(sr) ? sr[br] || it : sr;
                                Rr = Hr(_r, Rr)
                            }
                            ur.push(Rr)
                        }
                        return ur
                    }(gt, Bt, Nt)
                      , Zt = Yt.length
                      , Jt = nr=>{
                        let sr = 0;
                        if (Zt > 1)
                            for (; sr < mt.length - 2 && !(nr < mt[sr + 1]); sr++)
                                ;
                        const or = Or(mt[sr], mt[sr + 1], nr);
                        return Yt[sr](or)
                    }
                    ;
                    return Tt ? nr=>Jt(St(mt[0], mt[Ot - 1], nr)) : Jt
                }
                function wn({duration: mt=300, keyframes: gt, times: Tt, ease: Bt="easeInOut"}) {
                    const Nt = (nr=>Array.isArray(nr) && typeof nr[0] != "number")(Bt) ? Bt.map(yn) : yn(Bt)
                      , Ot = {
                        done: !1,
                        value: gt[0]
                    }
                      , Yt = Cn(function(nr, sr) {
                        return nr.map(or=>or * sr)
                    }(Tt && Tt.length === gt.length ? Tt : function(nr) {
                        const sr = [0];
                        return function(or, ur) {
                            const yr = or[or.length - 1];
                            for (let mr = 1; mr <= ur; mr++) {
                                const Ar = Or(0, ur, mr);
                                or.push(Jr(yr, 1, Ar))
                            }
                        }(sr, nr.length - 1),
                        sr
                    }(gt), mt), gt, {
                        ease: Array.isArray(Nt) ? Nt : (Zt = gt,
                        Jt = Nt,
                        Zt.map(()=>Jt || Ir).splice(0, Zt.length - 1))
                    });
                    var Zt, Jt;
                    return {
                        calculatedDuration: mt,
                        next: nr=>(Ot.value = Yt(nr),
                        Ot.done = nr >= mt,
                        Ot)
                    }
                }
                function _n(mt, gt, Tt) {
                    const Bt = Math.max(gt - 5, 0);
                    return ct(Tt - mt(Bt), gt - Bt)
                }
                function tr(mt, gt) {
                    return mt * Math.sqrt(1 - gt * gt)
                }
                const In = ["duration", "bounce"]
                  , Nn = ["stiffness", "damping", "mass"];
                function On(mt, gt) {
                    return gt.some(Tt=>mt[Tt] !== void 0)
                }
                function Pn({keyframes: mt, restDelta: gt, restSpeed: Tt, ...Bt}) {
                    const Nt = mt[0]
                      , Ot = mt[mt.length - 1]
                      , Yt = {
                        done: !1,
                        value: Nt
                    }
                      , {stiffness: Zt, damping: Jt, mass: nr, velocity: sr, duration: or, isResolvedFromDuration: ur} = function(Sr) {
                        let Vr = {
                            velocity: 0,
                            stiffness: 100,
                            damping: 10,
                            mass: 1,
                            isResolvedFromDuration: !1,
                            ...Sr
                        };
                        if (!On(Sr, Nn) && On(Sr, In)) {
                            const qr = function({duration: an=800, bounce: Wr=.25, velocity: un=0, mass: $n=1}) {
                                let Yn, _i, Tn = 1 - Wr;
                                Tn = St(.05, 1, Tn),
                                an = St(.01, 10, lo(an)),
                                Tn < 1 ? (Yn = kn=>{
                                    const xn = kn * Tn
                                      , hn = xn * an;
                                    return .001 - (xn - un) / tr(kn, Tn) * Math.exp(-hn)
                                }
                                ,
                                _i = kn=>{
                                    const xn = kn * Tn * an
                                      , hn = xn * un + un
                                      , An = Math.pow(Tn, 2) * Math.pow(kn, 2) * an
                                      , Vn = Math.exp(-xn)
                                      , po = tr(Math.pow(kn, 2), Tn);
                                    return (.001 - Yn(kn) > 0 ? -1 : 1) * ((hn - An) * Vn) / po
                                }
                                ) : (Yn = kn=>Math.exp(-kn * an) * ((kn - un) * an + 1) - .001,
                                _i = kn=>Math.exp(-kn * an) * (an * an * (un - kn)));
                                const ro = function(kn, xn, hn) {
                                    let An = hn;
                                    for (let Vn = 1; Vn < 12; Vn++)
                                        An -= kn(An) / xn(An);
                                    return An
                                }(Yn, _i, 5 / an);
                                if (an = ao(an),
                                isNaN(ro))
                                    return {
                                        stiffness: 100,
                                        damping: 10,
                                        duration: an
                                    };
                                {
                                    const kn = Math.pow(ro, 2) * $n;
                                    return {
                                        stiffness: kn,
                                        damping: 2 * Tn * Math.sqrt($n * kn),
                                        duration: an
                                    }
                                }
                            }(Sr);
                            Vr = {
                                ...Vr,
                                ...qr,
                                velocity: 0,
                                mass: 1
                            },
                            Vr.isResolvedFromDuration = !0
                        }
                        return Vr
                    }(Bt)
                      , yr = sr ? -lo(sr) : 0
                      , mr = Jt / (2 * Math.sqrt(Zt * nr))
                      , Ar = Ot - Nt
                      , br = lo(Math.sqrt(Zt / nr))
                      , Rr = Math.abs(Ar) < 5;
                    let _r;
                    if (Tt || (Tt = Rr ? .01 : 2),
                    gt || (gt = Rr ? .005 : .5),
                    mr < 1) {
                        const Sr = tr(br, mr);
                        _r = Vr=>{
                            const qr = Math.exp(-mr * br * Vr);
                            return Ot - qr * ((yr + mr * br * Ar) / Sr * Math.sin(Sr * Vr) + Ar * Math.cos(Sr * Vr))
                        }
                    } else if (mr === 1)
                        _r = Sr=>Ot - Math.exp(-br * Sr) * (Ar + (yr + br * Ar) * Sr);
                    else {
                        const Sr = br * Math.sqrt(mr * mr - 1);
                        _r = Vr=>{
                            const qr = Math.exp(-mr * br * Vr)
                              , an = Math.min(Sr * Vr, 300);
                            return Ot - qr * ((yr + mr * br * Ar) * Math.sinh(an) + Sr * Ar * Math.cosh(an)) / Sr
                        }
                    }
                    return {
                        calculatedDuration: ur && or || null,
                        next: Sr=>{
                            const Vr = _r(Sr);
                            if (ur)
                                Yt.done = Sr >= or;
                            else {
                                let qr = yr;
                                Sr !== 0 && (qr = mr < 1 ? _n(_r, Sr, Vr) : 0);
                                const an = Math.abs(qr) <= Tt
                                  , Wr = Math.abs(Ot - Vr) <= gt;
                                Yt.done = an && Wr
                            }
                            return Yt.value = Yt.done ? Ot : Vr,
                            Yt
                        }
                    }
                }
                function Dn({keyframes: mt, velocity: gt=0, power: Tt=.8, timeConstant: Bt=325, bounceDamping: Nt=10, bounceStiffness: Ot=500, modifyTarget: Yt, min: Zt, max: Jt, restDelta: nr=.5, restSpeed: sr}) {
                    const or = mt[0]
                      , ur = {
                        done: !1,
                        value: or
                    }
                      , yr = Wr=>Zt === void 0 ? Jt : Jt === void 0 || Math.abs(Zt - Wr) < Math.abs(Jt - Wr) ? Zt : Jt;
                    let mr = Tt * gt;
                    const Ar = or + mr
                      , br = Yt === void 0 ? Ar : Yt(Ar);
                    br !== Ar && (mr = br - or);
                    const Rr = Wr=>-mr * Math.exp(-Wr / Bt)
                      , _r = Wr=>br + Rr(Wr)
                      , Sr = Wr=>{
                        const un = Rr(Wr)
                          , $n = _r(Wr);
                        ur.done = Math.abs(un) <= nr,
                        ur.value = ur.done ? br : $n
                    }
                    ;
                    let Vr, qr;
                    const an = Wr=>{
                        var un;
                        un = ur.value,
                        (Zt !== void 0 && un < Zt || Jt !== void 0 && un > Jt) && (Vr = Wr,
                        qr = Pn({
                            keyframes: [ur.value, yr(ur.value)],
                            velocity: _n(_r, Wr, ur.value),
                            damping: Nt,
                            stiffness: Ot,
                            restDelta: nr,
                            restSpeed: sr
                        }))
                    }
                    ;
                    return an(0),
                    {
                        calculatedDuration: null,
                        next: Wr=>{
                            let un = !1;
                            return qr || Vr !== void 0 || (un = !0,
                            Sr(Wr),
                            an(Wr)),
                            Vr !== void 0 && Wr > Vr ? qr.next(Wr - Vr) : (!un && Sr(Wr),
                            ur)
                        }
                    }
                }
                const Fn = mt=>{
                    const gt = ({timestamp: Tt})=>mt(Tt);
                    return {
                        start: ()=>vt.update(gt, !0),
                        stop: ()=>_t(gt),
                        now: ()=>Pt.isProcessing ? Pt.timestamp : performance.now()
                    }
                }
                ;
                function Zn(mt) {
                    let gt = 0
                      , Tt = mt.next(gt);
                    for (; !Tt.done && gt < 2e4; )
                        gt += 50,
                        Tt = mt.next(gt);
                    return gt >= 2e4 ? 1 / 0 : gt
                }
                const Wn = {
                    decay: Dn,
                    inertia: Dn,
                    tween: wn,
                    keyframes: wn,
                    spring: Pn
                };
                function qn({autoplay: mt=!0, delay: gt=0, driver: Tt=Fn, keyframes: Bt, type: Nt="keyframes", repeat: Ot=0, repeatDelay: Yt=0, repeatType: Zt="loop", onPlay: Jt, onStop: nr, onComplete: sr, onUpdate: or, ...ur}) {
                    let yr, mr, Ar = 1, br = !1;
                    const Rr = ()=>{
                        mr = new Promise(Xn=>{
                            yr = Xn
                        }
                        )
                    }
                    ;
                    let _r;
                    Rr();
                    const Sr = Wn[Nt] || wn;
                    let Vr;
                    Sr !== wn && typeof Bt[0] != "number" && (Vr = Cn([0, 100], Bt, {
                        clamp: !1
                    }),
                    Bt = [0, 100]);
                    const qr = Sr({
                        ...ur,
                        keyframes: Bt
                    });
                    let an;
                    Zt === "mirror" && (an = Sr({
                        ...ur,
                        keyframes: [...Bt].reverse(),
                        velocity: -(ur.velocity || 0)
                    }));
                    let Wr = "idle"
                      , un = null
                      , $n = null
                      , Yn = null;
                    qr.calculatedDuration === null && Ot && (qr.calculatedDuration = Zn(qr));
                    const {calculatedDuration: _i} = qr;
                    let Tn = 1 / 0
                      , ro = 1 / 0;
                    _i !== null && (Tn = _i + Yt,
                    ro = Tn * (Ot + 1) - Yt);
                    let kn = 0;
                    const xn = Xn=>{
                        if ($n === null)
                            return;
                        Ar > 0 && ($n = Math.min($n, Xn)),
                        Ar < 0 && ($n = Math.min(Xn - ro / Ar, $n)),
                        kn = un !== null ? un : Math.round(Xn - $n) * Ar;
                        const Po = kn - gt * (Ar >= 0 ? 1 : -1)
                          , jo = Ar >= 0 ? Po < 0 : Po > ro;
                        kn = Math.max(Po, 0),
                        Wr === "finished" && un === null && (kn = ro);
                        let $o = kn
                          , ko = qr;
                        if (Ot) {
                            const ks = kn / Tn;
                            let rs = Math.floor(ks)
                              , Ao = ks % 1;
                            !Ao && ks >= 1 && (Ao = 1),
                            Ao === 1 && rs--,
                            rs = Math.min(rs, Ot + 1);
                            const Pu = !!(rs % 2);
                            Pu && (Zt === "reverse" ? (Ao = 1 - Ao,
                            Yt && (Ao -= Yt / Tn)) : Zt === "mirror" && (ko = an));
                            let ku = St(0, 1, Ao);
                            kn > ro && (ku = Zt === "reverse" && Pu ? 1 : 0),
                            $o = ku * Tn
                        }
                        const No = jo ? {
                            done: !1,
                            value: Bt[0]
                        } : ko.next($o);
                        Vr && (No.value = Vr(No.value));
                        let {done: Tu} = No;
                        jo || _i === null || (Tu = Ar >= 0 ? kn >= ro : kn <= 0);
                        const em = un === null && (Wr === "finished" || Wr === "running" && Tu);
                        return or && or(No.value),
                        em && Vn(),
                        No
                    }
                      , hn = ()=>{
                        _r && _r.stop(),
                        _r = void 0
                    }
                      , An = ()=>{
                        Wr = "idle",
                        hn(),
                        yr(),
                        Rr(),
                        $n = Yn = null
                    }
                      , Vn = ()=>{
                        Wr = "finished",
                        sr && sr(),
                        hn(),
                        yr()
                    }
                      , po = ()=>{
                        if (br)
                            return;
                        _r || (_r = Tt(xn));
                        const Xn = _r.now();
                        Jt && Jt(),
                        un !== null ? $n = Xn - un : $n && Wr !== "finished" || ($n = Xn),
                        Wr === "finished" && Rr(),
                        Yn = $n,
                        un = null,
                        Wr = "running",
                        _r.start()
                    }
                    ;
                    mt && po();
                    const To = {
                        then: (Xn,Po)=>mr.then(Xn, Po),
                        get time() {
                            return lo(kn)
                        },
                        set time(Xn) {
                            Xn = ao(Xn),
                            kn = Xn,
                            un === null && _r && Ar !== 0 ? $n = _r.now() - Xn / Ar : un = Xn
                        },
                        get duration() {
                            const Xn = qr.calculatedDuration === null ? Zn(qr) : qr.calculatedDuration;
                            return lo(Xn)
                        },
                        get speed() {
                            return Ar
                        },
                        set speed(Xn) {
                            Xn !== Ar && _r && (Ar = Xn,
                            To.time = lo(kn))
                        },
                        get state() {
                            return Wr
                        },
                        play: po,
                        pause: ()=>{
                            Wr = "paused",
                            un = kn
                        }
                        ,
                        stop: ()=>{
                            br = !0,
                            Wr !== "idle" && (Wr = "idle",
                            nr && nr(),
                            An())
                        }
                        ,
                        cancel: ()=>{
                            Yn !== null && xn(Yn),
                            An()
                        }
                        ,
                        complete: ()=>{
                            Wr = "finished"
                        }
                        ,
                        sample: Xn=>($n = 0,
                        xn(Xn))
                    };
                    return To
                }
                const Qn = function(mt) {
                    let gt;
                    return ()=>(gt === void 0 && (gt = Object.hasOwnProperty.call(Element.prototype, "animate")),
                    gt)
                }()
                  , Jn = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"])
                  , to = {
                    type: "spring",
                    stiffness: 500,
                    damping: 25,
                    restSpeed: 10
                }
                  , io = {
                    type: "keyframes",
                    duration: .8
                }
                  , oo = {
                    type: "keyframes",
                    ease: [.25, .1, .35, 1],
                    duration: .3
                }
                  , so = (mt,{keyframes: gt})=>gt.length > 2 ? io : Kn.has(mt) ? mt.startsWith("scale") ? {
                    type: "spring",
                    stiffness: 550,
                    damping: gt[1] === 0 ? 2 * Math.sqrt(550) : 30,
                    restSpeed: 10
                } : to : oo
                  , is = (mt,gt)=>!(mt === "zIndex" || typeof gt != "number" && !Array.isArray(gt) && (typeof gt != "string" || !er.test(gt) && gt !== "0" || gt.startsWith("url(")));
                function Iu(mt) {
                    return typeof mt == "number" ? mt === 0 : mt !== null ? mt === "none" || mt === "0" || dt(mt) : void 0
                }
                function Ms(mt, gt) {
                    return mt[gt] || mt.default || mt
                }
                const os = (mt,gt,Tt,Bt={})=>Nt=>{
                    const Ot = Ms(Bt, mt) || {}
                      , Yt = Ot.delay || Bt.delay || 0;
                    let {elapsed: Zt=0} = Bt;
                    Zt -= ao(Yt);
                    const Jt = function(mr, Ar, br, Rr) {
                        const _r = is(Ar, br);
                        let Sr;
                        Sr = Array.isArray(br) ? [...br] : [null, br];
                        const Vr = Rr.from !== void 0 ? Rr.from : mr.get();
                        let qr;
                        const an = [];
                        for (let Wr = 0; Wr < Sr.length; Wr++)
                            Sr[Wr] === null && (Sr[Wr] = Wr === 0 ? Vr : Sr[Wr - 1]),
                            Iu(Sr[Wr]) && an.push(Wr),
                            typeof Sr[Wr] == "string" && Sr[Wr] !== "none" && Sr[Wr] !== "0" && (qr = Sr[Wr]);
                        if (_r && an.length && qr)
                            for (let Wr = 0; Wr < an.length; Wr++)
                                Sr[an[Wr]] = Er(Ar, qr);
                        return Sr
                    }(gt, mt, Tt, Ot)
                      , nr = Jt[0]
                      , sr = Jt[Jt.length - 1]
                      , or = is(mt, nr)
                      , ur = is(mt, sr);
                    let yr = {
                        keyframes: Jt,
                        velocity: gt.getVelocity(),
                        ease: "easeOut",
                        ...Ot,
                        delay: -Zt,
                        onUpdate: mr=>{
                            gt.set(mr),
                            Ot.onUpdate && Ot.onUpdate(mr)
                        }
                        ,
                        onComplete: ()=>{
                            Nt(),
                            Ot.onComplete && Ot.onComplete()
                        }
                    };
                    if (function({when: mr, delay: Ar, delayChildren: br, staggerChildren: Rr, staggerDirection: _r, repeat: Sr, repeatType: Vr, repeatDelay: qr, from: an, elapsed: Wr, ...un}) {
                        return !!Object.keys(un).length
                    }(Ot) || (yr = {
                        ...yr,
                        ...so(mt, yr)
                    }),
                    yr.duration && (yr.duration = ao(yr.duration)),
                    yr.repeatDelay && (yr.repeatDelay = ao(yr.repeatDelay)),
                    !or || !ur || Ot.type === !1)
                        return function({keyframes: mr, delay: Ar, onUpdate: br, onComplete: Rr}) {
                            const _r = ()=>(br && br(mr[mr.length - 1]),
                            Rr && Rr(),
                            {
                                time: 0,
                                speed: 1,
                                duration: 0,
                                play: it,
                                pause: it,
                                stop: it,
                                then: Sr=>(Sr(),
                                Promise.resolve()),
                                cancel: it,
                                complete: it
                            });
                            return Ar ? qn({
                                keyframes: [0, 1],
                                duration: 0,
                                delay: Ar,
                                onComplete: _r
                            }) : _r()
                        }(yr);
                    if (gt.owner && gt.owner.current instanceof HTMLElement && !gt.owner.getProps().onUpdate) {
                        const mr = function(Ar, br, {onUpdate: Rr, onComplete: _r, ...Sr}) {
                            if (!Qn() || !Jn.has(br) || Sr.repeatDelay || Sr.repeatType === "mirror" || Sr.damping === 0 || Sr.type === "inertia")
                                return !1;
                            let Vr, qr, an = !1;
                            const Wr = ()=>{
                                qr = new Promise(xn=>{
                                    Vr = xn
                                }
                                )
                            }
                            ;
                            Wr();
                            let {keyframes: un, duration: $n=300, ease: Yn, times: _i} = Sr;
                            if (((xn,hn)=>hn.type === "spring" || xn === "backgroundColor" || !Ro(hn.ease))(br, Sr)) {
                                const xn = qn({
                                    ...Sr,
                                    repeat: 0,
                                    delay: 0
                                });
                                let hn = {
                                    done: !1,
                                    value: un[0]
                                };
                                const An = [];
                                let Vn = 0;
                                for (; !hn.done && Vn < 2e4; )
                                    hn = xn.sample(Vn),
                                    An.push(hn.value),
                                    Vn += 10;
                                _i = void 0,
                                un = An,
                                $n = Vn - 10,
                                Yn = "linear"
                            }
                            const Tn = function(xn, hn, An, {delay: Vn=0, duration: po, repeat: To=0, repeatType: Xn="loop", ease: Po, times: jo}={}) {
                                const $o = {
                                    [hn]: An
                                };
                                jo && ($o.offset = jo);
                                const ko = jt(Po);
                                return Array.isArray(ko) && ($o.easing = ko),
                                xn.animate($o, {
                                    delay: Vn,
                                    duration: po,
                                    easing: Array.isArray(ko) ? "linear" : ko,
                                    fill: "both",
                                    iterations: To + 1,
                                    direction: Xn === "reverse" ? "alternate" : "normal"
                                })
                            }(Ar.owner.current, br, un, {
                                ...Sr,
                                duration: $n,
                                ease: Yn,
                                times: _i
                            });
                            Sr.syncStart && (Tn.startTime = Pt.isProcessing ? Pt.timestamp : document.timeline ? document.timeline.currentTime : performance.now());
                            const ro = ()=>Tn.cancel()
                              , kn = ()=>{
                                vt.update(ro),
                                Vr(),
                                Wr()
                            }
                            ;
                            return Tn.onfinish = ()=>{
                                Ar.set(function(xn, {repeat: hn, repeatType: An="loop"}) {
                                    return xn[hn && An !== "loop" && hn % 2 == 1 ? 0 : xn.length - 1]
                                }(un, Sr)),
                                _r && _r(),
                                kn()
                            }
                            ,
                            {
                                then: (xn,hn)=>qr.then(xn, hn),
                                attachTimeline: xn=>(Tn.timeline = xn,
                                Tn.onfinish = null,
                                it),
                                get time() {
                                    return lo(Tn.currentTime || 0)
                                },
                                set time(xn) {
                                    Tn.currentTime = ao(xn)
                                },
                                get speed() {
                                    return Tn.playbackRate
                                },
                                set speed(xn) {
                                    Tn.playbackRate = xn
                                },
                                get duration() {
                                    return lo($n)
                                },
                                play: ()=>{
                                    an || (Tn.play(),
                                    _t(ro))
                                }
                                ,
                                pause: ()=>Tn.pause(),
                                stop: ()=>{
                                    if (an = !0,
                                    Tn.playState === "idle")
                                        return;
                                    const {currentTime: xn} = Tn;
                                    if (xn) {
                                        const hn = qn({
                                            ...Sr,
                                            autoplay: !1
                                        });
                                        Ar.setWithVelocity(hn.sample(xn - 10).value, hn.sample(xn).value, 10)
                                    }
                                    kn()
                                }
                                ,
                                complete: ()=>Tn.finish(),
                                cancel: kn
                            }
                        }(gt, mt, yr);
                        if (mr)
                            return mr
                    }
                    return qn(yr)
                }
                  , co = mt=>!!(mt && mt.getVelocity);
                function zo(mt) {
                    return !!(co(mt) && mt.add)
                }
                function Bu({protectedKeys: mt, needsAnimating: gt}, Tt) {
                    const Bt = mt.hasOwnProperty(Tt) && gt[Tt] !== !0;
                    return gt[Tt] = !1,
                    Bt
                }
                function Is(mt, gt, {delay: Tt=0, transitionOverride: Bt, type: Nt}={}) {
                    let {transition: Ot=mt.getDefaultTransition(), transitionEnd: Yt, ...Zt} = mt.makeTargetAnimatable(gt);
                    const Jt = mt.getValue("willChange");
                    Bt && (Ot = Bt);
                    const nr = []
                      , sr = Nt && mt.animationState && mt.animationState.getState()[Nt];
                    for (const or in Zt) {
                        const ur = mt.getValue(or)
                          , yr = Zt[or];
                        if (!ur || yr === void 0 || sr && Bu(sr, or))
                            continue;
                        const mr = {
                            delay: Tt,
                            elapsed: 0,
                            ...Ot
                        };
                        if (window.HandoffAppearAnimations && !ur.hasAnimated) {
                            const br = mt.getProps()[mo];
                            br && (mr.elapsed = window.HandoffAppearAnimations(br, or, ur, vt),
                            mr.syncStart = !0)
                        }
                        ur.start(os(or, ur, yr, mt.shouldReduceMotion && Kn.has(or) ? {
                            type: !1
                        } : mr));
                        const Ar = ur.animation;
                        zo(Jt) && (Jt.add(or),
                        Ar.then(()=>Jt.remove(or))),
                        nr.push(Ar)
                    }
                    return Yt && Promise.all(nr).then(()=>{
                        Yt && jn(mt, Yt)
                    }
                    ),
                    nr
                }
                function ss(mt, gt, Tt={}) {
                    const Bt = Mn(mt, gt, Tt.custom);
                    let {transition: Nt=mt.getDefaultTransition() || {}} = Bt || {};
                    Tt.transitionOverride && (Nt = Tt.transitionOverride);
                    const Ot = Bt ? ()=>Promise.all(Is(mt, Bt, Tt)) : ()=>Promise.resolve()
                      , Yt = mt.variantChildren && mt.variantChildren.size ? (Jt=0)=>{
                        const {delayChildren: nr=0, staggerChildren: sr, staggerDirection: or} = Nt;
                        return function(ur, yr, mr=0, Ar=0, br=1, Rr) {
                            const _r = []
                              , Sr = (ur.variantChildren.size - 1) * Ar
                              , Vr = br === 1 ? (qr=0)=>qr * Ar : (qr=0)=>Sr - qr * Ar;
                            return Array.from(ur.variantChildren).sort($u).forEach((qr,an)=>{
                                qr.notify("AnimationStart", yr),
                                _r.push(ss(qr, yr, {
                                    ...Rr,
                                    delay: mr + Vr(an)
                                }).then(()=>qr.notify("AnimationComplete", yr)))
                            }
                            ),
                            Promise.all(_r)
                        }(mt, gt, nr + Jt, sr, or, Tt)
                    }
                    : ()=>Promise.resolve()
                      , {when: Zt} = Nt;
                    if (Zt) {
                        const [Jt,nr] = Zt === "beforeChildren" ? [Ot, Yt] : [Yt, Ot];
                        return Jt().then(()=>nr())
                    }
                    return Promise.all([Ot(), Yt(Tt.delay)])
                }
                function $u(mt, gt) {
                    return mt.sortNodePosition(gt)
                }
                function Bs(mt, gt, Tt={}) {
                    let Bt;
                    if (mt.notify("AnimationStart", gt),
                    Array.isArray(gt)) {
                        const Nt = gt.map(Ot=>ss(mt, Ot, Tt));
                        Bt = Promise.all(Nt)
                    } else if (typeof gt == "string")
                        Bt = ss(mt, gt, Tt);
                    else {
                        const Nt = typeof gt == "function" ? Mn(mt, gt, Tt.custom) : gt;
                        Bt = Promise.all(Is(mt, Nt, Tt))
                    }
                    return Bt.then(()=>mt.notify("AnimationComplete", gt))
                }
                function Ru() {
                    const mt = new Set
                      , gt = {
                        subscribe: Tt=>(mt.add(Tt),
                        ()=>{
                            mt.delete(Tt)
                        }
                        ),
                        start(Tt, Bt) {
                            const Nt = [];
                            return mt.forEach(Ot=>{
                                Nt.push(Bs(Ot, Tt, {
                                    transitionOverride: Bt
                                }))
                            }
                            ),
                            Promise.all(Nt)
                        },
                        set: Tt=>mt.forEach(Bt=>{
                            (function(Nt, Ot) {
                                Array.isArray(Ot) ? Hn(Nt, Ot) : typeof Ot == "string" ? Hn(Nt, [Ot]) : jn(Nt, Ot)
                            }
                            )(Bt, Tt)
                        }
                        ),
                        stop() {
                            mt.forEach(Tt=>{
                                (function(Bt) {
                                    Bt.values.forEach(Nt=>Nt.stop())
                                }
                                )(Tt)
                            }
                            )
                        },
                        mount: ()=>()=>{
                            gt.stop()
                        }
                    };
                    return gt
                }
                function $s(mt) {
                    const gt = (0,
                    rt.useRef)(null);
                    return gt.current === null && (gt.current = mt()),
                    gt.current
                }
                const Wo = typeof document < "u"
                  , Rs = Wo ? rt.useLayoutEffect : rt.useEffect
                  , Ls = (0,
                rt.createContext)({
                    transformPagePoint: mt=>mt,
                    isStatic: !1,
                    reducedMotion: "never"
                })
                  , Ho = (0,
                rt.createContext)({})
                  , as = (0,
                rt.createContext)(null)
                  , Ds = (0,
                rt.createContext)({
                    strict: !1
                });
                function Mo(mt) {
                    return typeof mt == "object" && Object.prototype.hasOwnProperty.call(mt, "current")
                }
                function Lo(mt) {
                    return typeof mt == "string" || Array.isArray(mt)
                }
                function Go(mt) {
                    return typeof mt == "object" && typeof mt.start == "function"
                }
                const ls = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
                  , cs = ["initial", ...ls];
                function qo(mt) {
                    return Go(mt.animate) || cs.some(gt=>Lo(mt[gt]))
                }
                function Os(mt) {
                    return !!(qo(mt) || mt.variants)
                }
                function Fs(mt) {
                    return Array.isArray(mt) ? mt.join(" ") : mt
                }
                const Vs = {
                    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
                    exit: ["exit"],
                    drag: ["drag", "dragControls"],
                    focus: ["whileFocus"],
                    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
                    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
                    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
                    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
                    layout: ["layout", "layoutId"]
                }
                  , Do = {};
                for (const mt in Vs)
                    Do[mt] = {
                        isEnabled: gt=>Vs[mt].some(Tt=>!!gt[Tt])
                    };
                const js = (0,
                rt.createContext)({})
                  , Ns = (0,
                rt.createContext)({})
                  , Lu = Symbol.for("motionComponentSymbol");
                function Du({preloadedFeatures: mt, createVisualElement: gt, useRender: Tt, useVisualState: Bt, Component: Nt}) {
                    mt && function(Yt) {
                        for (const Zt in Yt)
                            Do[Zt] = {
                                ...Do[Zt],
                                ...Yt[Zt]
                            }
                    }(mt);
                    const Ot = (0,
                    rt.forwardRef)(function(Yt, Zt) {
                        let Jt;
                        const nr = {
                            ...(0,
                            rt.useContext)(Ls),
                            ...Yt,
                            layoutId: Ou(Yt)
                        }
                          , {isStatic: sr} = nr
                          , or = function(yr) {
                            const {initial: mr, animate: Ar} = function(br, Rr) {
                                if (qo(br)) {
                                    const {initial: _r, animate: Sr} = br;
                                    return {
                                        initial: _r === !1 || Lo(_r) ? _r : void 0,
                                        animate: Lo(Sr) ? Sr : void 0
                                    }
                                }
                                return br.inherit !== !1 ? Rr : {}
                            }(yr, (0,
                            rt.useContext)(Ho));
                            return (0,
                            rt.useMemo)(()=>({
                                initial: mr,
                                animate: Ar
                            }), [Fs(mr), Fs(Ar)])
                        }(Yt)
                          , ur = Bt(Yt, sr);
                        if (!sr && Wo) {
                            or.visualElement = function(Ar, br, Rr, _r) {
                                const {visualElement: Sr} = (0,
                                rt.useContext)(Ho)
                                  , Vr = (0,
                                rt.useContext)(Ds)
                                  , qr = (0,
                                rt.useContext)(as)
                                  , an = (0,
                                rt.useContext)(Ls).reducedMotion
                                  , Wr = (0,
                                rt.useRef)();
                                _r = _r || Vr.renderer,
                                !Wr.current && _r && (Wr.current = _r(Ar, {
                                    visualState: br,
                                    parent: Sr,
                                    props: Rr,
                                    presenceContext: qr,
                                    blockInitialAnimation: !!qr && qr.initial === !1,
                                    reducedMotionConfig: an
                                }));
                                const un = Wr.current;
                                (0,
                                rt.useInsertionEffect)(()=>{
                                    un && un.update(Rr, qr)
                                }
                                );
                                const $n = (0,
                                rt.useRef)(!!window.HandoffAppearAnimations);
                                return Rs(()=>{
                                    un && (un.render(),
                                    $n.current && un.animationState && un.animationState.animateChanges())
                                }
                                ),
                                (0,
                                rt.useEffect)(()=>{
                                    un && (un.updateFeatures(),
                                    !$n.current && un.animationState && un.animationState.animateChanges(),
                                    window.HandoffAppearAnimations = void 0,
                                    $n.current = !1)
                                }
                                ),
                                un
                            }(Nt, ur, nr, gt);
                            const yr = (0,
                            rt.useContext)(Ns)
                              , mr = (0,
                            rt.useContext)(Ds).strict;
                            or.visualElement && (Jt = or.visualElement.loadFeatures(nr, mr, mt, yr))
                        }
                        return rt.createElement(Ho.Provider, {
                            value: or
                        }, Jt && or.visualElement ? rt.createElement(Jt, {
                            visualElement: or.visualElement,
                            ...nr
                        }) : null, Tt(Nt, Yt, function(yr, mr, Ar) {
                            return (0,
                            rt.useCallback)(br=>{
                                br && yr.mount && yr.mount(br),
                                mr && (br ? mr.mount(br) : mr.unmount()),
                                Ar && (typeof Ar == "function" ? Ar(br) : Mo(Ar) && (Ar.current = br))
                            }
                            , [mr])
                        }(ur, or.visualElement, Zt), ur, sr, or.visualElement))
                    });
                    return Ot[Lu] = Nt,
                    Ot
                }
                function Ou({layoutId: mt}) {
                    const gt = (0,
                    rt.useContext)(js).id;
                    return gt && mt !== void 0 ? gt + "-" + mt : mt
                }
                function Fu(mt) {
                    function gt(Bt, Nt={}) {
                        return Du(mt(Bt, Nt))
                    }
                    if (typeof Proxy > "u")
                        return gt;
                    const Tt = new Map;
                    return new Proxy(gt,{
                        get: (Bt,Nt)=>(Tt.has(Nt) || Tt.set(Nt, gt(Nt)),
                        Tt.get(Nt))
                    })
                }
                const Vu = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
                function us(mt) {
                    return typeof mt == "string" && !mt.includes("-") && !!(Vu.indexOf(mt) > -1 || /[A-Z]/.test(mt))
                }
                const Ko = {};
                function Us(mt, {layout: gt, layoutId: Tt}) {
                    return Kn.has(mt) || mt.startsWith("origin") || (gt || Tt !== void 0) && (!!Ko[mt] || mt === "opacity")
                }
                const ju = {
                    x: "translateX",
                    y: "translateY",
                    z: "translateZ",
                    transformPerspective: "perspective"
                }
                  , Nu = Gn.length
                  , Uu = (mt,gt)=>gt && typeof mt == "number" ? gt.transform(mt) : mt;
                function ds(mt, gt, Tt, Bt) {
                    const {style: Nt, vars: Ot, transform: Yt, transformOrigin: Zt} = mt;
                    let Jt = !1
                      , nr = !1
                      , sr = !0;
                    for (const or in gt) {
                        const ur = gt[or];
                        if (Dt(or)) {
                            Ot[or] = ur;
                            continue
                        }
                        const yr = Gt[or]
                          , mr = Uu(ur, yr);
                        if (Kn.has(or)) {
                            if (Jt = !0,
                            Yt[or] = mr,
                            !sr)
                                continue;
                            ur !== (yr.default || 0) && (sr = !1)
                        } else
                            or.startsWith("origin") ? (nr = !0,
                            Zt[or] = mr) : Nt[or] = mr
                    }
                    if (gt.transform || (Jt || Bt ? Nt.transform = function(or, {enableHardwareAcceleration: ur=!0, allowTransformNone: yr=!0}, mr, Ar) {
                        let br = "";
                        for (let Rr = 0; Rr < Nu; Rr++) {
                            const _r = Gn[Rr];
                            or[_r] !== void 0 && (br += `${ju[_r] || _r}(${or[_r]}) `)
                        }
                        return ur && !or.z && (br += "translateZ(0)"),
                        br = br.trim(),
                        Ar ? br = Ar(or, mr ? "" : br) : yr && mr && (br = "none"),
                        br
                    }(mt.transform, Tt, sr, Bt) : Nt.transform && (Nt.transform = "none")),
                    nr) {
                        const {originX: or="50%", originY: ur="50%", originZ: yr=0} = Zt;
                        Nt.transformOrigin = `${or} ${ur} ${yr}`
                    }
                }
                function zs(mt, gt, Tt) {
                    for (const Bt in gt)
                        co(gt[Bt]) || Us(Bt, Tt) || (mt[Bt] = gt[Bt])
                }
                function zu(mt, gt, Tt) {
                    const Bt = {}
                      , Nt = function(Ot, Yt, Zt) {
                        const Jt = {};
                        return zs(Jt, Ot.style || {}, Ot),
                        Object.assign(Jt, function({transformTemplate: nr}, sr, or) {
                            return (0,
                            rt.useMemo)(()=>{
                                const ur = {
                                    style: {},
                                    transform: {},
                                    transformOrigin: {},
                                    vars: {}
                                };
                                return ds(ur, sr, {
                                    enableHardwareAcceleration: !or
                                }, nr),
                                Object.assign({}, ur.vars, ur.style)
                            }
                            , [sr])
                        }(Ot, Yt, Zt)),
                        Ot.transformValues ? Ot.transformValues(Jt) : Jt
                    }(mt, gt, Tt);
                    return mt.drag && mt.dragListener !== !1 && (Bt.draggable = !1,
                    Nt.userSelect = Nt.WebkitUserSelect = Nt.WebkitTouchCallout = "none",
                    Nt.touchAction = mt.drag === !0 ? "none" : "pan-" + (mt.drag === "x" ? "y" : "x")),
                    mt.tabIndex === void 0 && (mt.onTap || mt.onTapStart || mt.whileTap) && (Bt.tabIndex = 0),
                    Bt.style = Nt,
                    Bt
                }
                const Wu = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onLayoutAnimationStart", "onLayoutAnimationComplete", "onLayoutMeasure", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "ignoreStrict", "viewport"]);
                function Yo(mt) {
                    return mt.startsWith("while") || mt.startsWith("drag") && mt !== "draggable" || mt.startsWith("layout") || mt.startsWith("onTap") || mt.startsWith("onPan") || Wu.has(mt)
                }
                let Ws = mt=>!Yo(mt);
                try {
                    (Hs = require$$1.default) && (Ws = mt=>mt.startsWith("on") ? !Yo(mt) : Hs(mt))
                } catch {}
                var Hs;
                function Gs(mt, gt, Tt) {
                    return typeof mt == "string" ? mt : ir.transform(gt + Tt * mt)
                }
                const Hu = {
                    offset: "stroke-dashoffset",
                    array: "stroke-dasharray"
                }
                  , Gu = {
                    offset: "strokeDashoffset",
                    array: "strokeDasharray"
                };
                function fs(mt, {attrX: gt, attrY: Tt, attrScale: Bt, originX: Nt, originY: Ot, pathLength: Yt, pathSpacing: Zt=1, pathOffset: Jt=0, ...nr}, sr, or, ur) {
                    if (ds(mt, nr, sr, ur),
                    or)
                        return void (mt.style.viewBox && (mt.attrs.viewBox = mt.style.viewBox));
                    mt.attrs = mt.style,
                    mt.style = {};
                    const {attrs: yr, style: mr, dimensions: Ar} = mt;
                    yr.transform && (Ar && (mr.transform = yr.transform),
                    delete yr.transform),
                    Ar && (Nt !== void 0 || Ot !== void 0 || mr.transform) && (mr.transformOrigin = function(br, Rr, _r) {
                        return `${Gs(Rr, br.x, br.width)} ${Gs(_r, br.y, br.height)}`
                    }(Ar, Nt !== void 0 ? Nt : .5, Ot !== void 0 ? Ot : .5)),
                    gt !== void 0 && (yr.x = gt),
                    Tt !== void 0 && (yr.y = Tt),
                    Bt !== void 0 && (yr.scale = Bt),
                    Yt !== void 0 && function(br, Rr, _r=1, Sr=0, Vr=!0) {
                        br.pathLength = 1;
                        const qr = Vr ? Hu : Gu;
                        br[qr.offset] = ir.transform(-Sr);
                        const an = ir.transform(Rr)
                          , Wr = ir.transform(_r);
                        br[qr.array] = `${an} ${Wr}`
                    }(yr, Yt, Zt, Jt, !1)
                }
                const hs = mt=>typeof mt == "string" && mt.toLowerCase() === "svg";
                function qu(mt, gt, Tt, Bt) {
                    const Nt = (0,
                    rt.useMemo)(()=>{
                        const Ot = {
                            style: {},
                            transform: {},
                            transformOrigin: {},
                            vars: {},
                            attrs: {}
                        };
                        return fs(Ot, gt, {
                            enableHardwareAcceleration: !1
                        }, hs(Bt), mt.transformTemplate),
                        {
                            ...Ot.attrs,
                            style: {
                                ...Ot.style
                            }
                        }
                    }
                    , [gt]);
                    if (mt.style) {
                        const Ot = {};
                        zs(Ot, mt.style, mt),
                        Nt.style = {
                            ...Ot,
                            ...Nt.style
                        }
                    }
                    return Nt
                }
                function Ku(mt=!1) {
                    return (gt,Tt,Bt,{latestValues: Nt},Ot)=>{
                        const Yt = (us(gt) ? qu : zu)(Tt, Nt, Ot, gt)
                          , Zt = {
                            ...function(sr, or, ur) {
                                const yr = {};
                                for (const mr in sr)
                                    mr === "values" && typeof sr.values == "object" || (Ws(mr) || ur === !0 && Yo(mr) || !or && !Yo(mr) || sr.draggable && mr.startsWith("onDrag")) && (yr[mr] = sr[mr]);
                                return yr
                            }(Tt, typeof gt == "string", mt),
                            ...Yt,
                            ref: Bt
                        }
                          , {children: Jt} = Tt
                          , nr = (0,
                        rt.useMemo)(()=>co(Jt) ? Jt.get() : Jt, [Jt]);
                        return (0,
                        rt.createElement)(gt, {
                            ...Zt,
                            children: nr
                        })
                    }
                }
                function qs(mt, {style: gt, vars: Tt}, Bt, Nt) {
                    Object.assign(mt.style, gt, Nt && Nt.getProjectionStyles(Bt));
                    for (const Ot in Tt)
                        mt.style.setProperty(Ot, Tt[Ot])
                }
                const Ks = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
                function Ys(mt, gt, Tt, Bt) {
                    qs(mt, gt, void 0, Bt);
                    for (const Nt in gt.attrs)
                        mt.setAttribute(Ks.has(Nt) ? Nt : ho(Nt), gt.attrs[Nt])
                }
                function ps(mt, gt) {
                    const {style: Tt} = mt
                      , Bt = {};
                    for (const Nt in Tt)
                        (co(Tt[Nt]) || gt.style && co(gt.style[Nt]) || Us(Nt, mt)) && (Bt[Nt] = Tt[Nt]);
                    return Bt
                }
                function Xs(mt, gt) {
                    const Tt = ps(mt, gt);
                    for (const Bt in mt)
                        (co(mt[Bt]) || co(gt[Bt])) && (Tt[Gn.indexOf(Bt) !== -1 ? "attr" + Bt.charAt(0).toUpperCase() + Bt.substring(1) : Bt] = mt[Bt]);
                    return Tt
                }
                function Xo(mt) {
                    const gt = co(mt) ? mt.get() : mt;
                    return Tt = gt,
                    Tt && typeof Tt == "object" && Tt.mix && Tt.toValue ? gt.toValue() : gt;
                    var Tt
                }
                const Zs = mt=>(gt,Tt)=>{
                    const Bt = (0,
                    rt.useContext)(Ho)
                      , Nt = (0,
                    rt.useContext)(as)
                      , Ot = ()=>function({scrapeMotionValuesFromProps: Yt, createRenderState: Zt, onMount: Jt}, nr, sr, or) {
                        const ur = {
                            latestValues: Yu(nr, sr, or, Yt),
                            renderState: Zt()
                        };
                        return Jt && (ur.mount = yr=>Jt(nr, yr, ur)),
                        ur
                    }(mt, gt, Bt, Nt);
                    return Tt ? Ot() : $s(Ot)
                }
                ;
                function Yu(mt, gt, Tt, Bt) {
                    const Nt = {}
                      , Ot = Bt(mt, {});
                    for (const ur in Ot)
                        Nt[ur] = Xo(Ot[ur]);
                    let {initial: Yt, animate: Zt} = mt;
                    const Jt = qo(mt)
                      , nr = Os(mt);
                    gt && nr && !Jt && mt.inherit !== !1 && (Yt === void 0 && (Yt = gt.initial),
                    Zt === void 0 && (Zt = gt.animate));
                    let sr = !!Tt && Tt.initial === !1;
                    sr = sr || Yt === !1;
                    const or = sr ? Zt : Yt;
                    return or && typeof or != "boolean" && !Go(or) && (Array.isArray(or) ? or : [or]).forEach(ur=>{
                        const yr = Fr(mt, ur);
                        if (!yr)
                            return;
                        const {transitionEnd: mr, transition: Ar, ...br} = yr;
                        for (const Rr in br) {
                            let _r = br[Rr];
                            Array.isArray(_r) && (_r = _r[sr ? _r.length - 1 : 0]),
                            _r !== null && (Nt[Rr] = _r)
                        }
                        for (const Rr in mr)
                            Nt[Rr] = mr[Rr]
                    }
                    ),
                    Nt
                }
                const Xu = {
                    useVisualState: Zs({
                        scrapeMotionValuesFromProps: Xs,
                        createRenderState: ()=>({
                            style: {},
                            transform: {},
                            transformOrigin: {},
                            vars: {},
                            attrs: {}
                        }),
                        onMount: (mt,gt,{renderState: Tt, latestValues: Bt})=>{
                            vt.read(()=>{
                                try {
                                    Tt.dimensions = typeof gt.getBBox == "function" ? gt.getBBox() : gt.getBoundingClientRect()
                                } catch {
                                    Tt.dimensions = {
                                        x: 0,
                                        y: 0,
                                        width: 0,
                                        height: 0
                                    }
                                }
                            }
                            ),
                            vt.render(()=>{
                                fs(Tt, Bt, {
                                    enableHardwareAcceleration: !1
                                }, hs(gt.tagName), mt.transformTemplate),
                                Ys(gt, Tt)
                            }
                            )
                        }
                    })
                }
                  , Zu = {
                    useVisualState: Zs({
                        scrapeMotionValuesFromProps: ps,
                        createRenderState: ()=>({
                            style: {},
                            transform: {},
                            transformOrigin: {},
                            vars: {}
                        })
                    })
                };
                function yo(mt, gt, Tt, Bt={
                    passive: !0
                }) {
                    return mt.addEventListener(gt, Tt, Bt),
                    ()=>mt.removeEventListener(gt, Tt)
                }
                const Qs = mt=>mt.pointerType === "mouse" ? typeof mt.button != "number" || mt.button <= 0 : mt.isPrimary !== !1;
                function Zo(mt, gt="page") {
                    return {
                        point: {
                            x: mt[gt + "X"],
                            y: mt[gt + "Y"]
                        }
                    }
                }
                function vo(mt, gt, Tt, Bt) {
                    return yo(mt, gt, (Nt=>Ot=>Qs(Ot) && Nt(Ot, Zo(Ot)))(Tt), Bt)
                }
                function Js(mt) {
                    let gt = null;
                    return ()=>gt === null && (gt = mt,
                    ()=>{
                        gt = null
                    }
                    )
                }
                const na = Js("dragHorizontal")
                  , ga = Js("dragVertical");
                function ba(mt) {
                    let gt = !1;
                    if (mt === "y")
                        gt = ga();
                    else if (mt === "x")
                        gt = na();
                    else {
                        const Tt = na()
                          , Bt = ga();
                        Tt && Bt ? gt = ()=>{
                            Tt(),
                            Bt()
                        }
                        : (Tt && Tt(),
                        Bt && Bt())
                    }
                    return gt
                }
                function xa() {
                    const mt = ba(!0);
                    return !mt || (mt(),
                    !1)
                }
                class wo {
                    constructor(gt) {
                        this.isMounted = !1,
                        this.node = gt
                    }
                    update() {}
                }
                function $a(mt, gt) {
                    const Tt = "pointer" + (gt ? "enter" : "leave")
                      , Bt = "onHover" + (gt ? "Start" : "End");
                    return vo(mt.current, Tt, (Nt,Ot)=>{
                        if (Nt.type === "touch" || xa())
                            return;
                        const Yt = mt.getProps();
                        mt.animationState && Yt.whileHover && mt.animationState.setActive("whileHover", gt),
                        Yt[Bt] && vt.update(()=>Yt[Bt](Nt, Ot))
                    }
                    , {
                        passive: !mt.getProps()[Bt]
                    })
                }
                const yl = (mt,gt)=>!!gt && (mt === gt || yl(mt, gt.parentElement));
                function ms(mt, gt) {
                    if (!gt)
                        return;
                    const Tt = new PointerEvent("pointer" + mt);
                    gt(Tt, Zo(Tt))
                }
                const gs = new WeakMap
                  , ys = new WeakMap
                  , Qu = mt=>{
                    const gt = gs.get(mt.target);
                    gt && gt(mt)
                }
                  , Ju = mt=>{
                    mt.forEach(Qu)
                }
                  , ep = {
                    some: 0,
                    all: 1
                }
                  , tp = {
                    inView: {
                        Feature: class extends wo {
                            constructor() {
                                super(...arguments),
                                this.hasEnteredView = !1,
                                this.isInView = !1
                            }
                            startObserver() {
                                this.unmount();
                                const {viewport: mt={}} = this.node.getProps()
                                  , {root: gt, margin: Tt, amount: Bt="some", once: Nt} = mt
                                  , Ot = {
                                    root: gt ? gt.current : void 0,
                                    rootMargin: Tt,
                                    threshold: typeof Bt == "number" ? Bt : ep[Bt]
                                };
                                return function(Yt, Zt, Jt) {
                                    const nr = function({root: sr, ...or}) {
                                        const ur = sr || document;
                                        ys.has(ur) || ys.set(ur, {});
                                        const yr = ys.get(ur)
                                          , mr = JSON.stringify(or);
                                        return yr[mr] || (yr[mr] = new IntersectionObserver(Ju,{
                                            root: sr,
                                            ...or
                                        })),
                                        yr[mr]
                                    }(Zt);
                                    return gs.set(Yt, Jt),
                                    nr.observe(Yt),
                                    ()=>{
                                        gs.delete(Yt),
                                        nr.unobserve(Yt)
                                    }
                                }(this.node.current, Ot, Yt=>{
                                    const {isIntersecting: Zt} = Yt;
                                    if (this.isInView === Zt || (this.isInView = Zt,
                                    Nt && !Zt && this.hasEnteredView))
                                        return;
                                    Zt && (this.hasEnteredView = !0),
                                    this.node.animationState && this.node.animationState.setActive("whileInView", Zt);
                                    const {onViewportEnter: Jt, onViewportLeave: nr} = this.node.getProps()
                                      , sr = Zt ? Jt : nr;
                                    sr && sr(Yt)
                                }
                                )
                            }
                            mount() {
                                this.startObserver()
                            }
                            update() {
                                if (typeof IntersectionObserver > "u")
                                    return;
                                const {props: mt, prevProps: gt} = this.node;
                                ["amount", "margin", "root"].some(function({viewport: Tt={}}, {viewport: Bt={}}={}) {
                                    return Nt=>Tt[Nt] !== Bt[Nt]
                                }(mt, gt)) && this.startObserver()
                            }
                            unmount() {}
                        }
                    },
                    tap: {
                        Feature: class extends wo {
                            constructor() {
                                super(...arguments),
                                this.removeStartListeners = it,
                                this.removeEndListeners = it,
                                this.removeAccessibleListeners = it,
                                this.startPointerPress = (mt,gt)=>{
                                    if (this.removeEndListeners(),
                                    this.isPressing)
                                        return;
                                    const Tt = this.node.getProps()
                                      , Bt = vo(window, "pointerup", (Ot,Yt)=>{
                                        if (!this.checkPressEnd())
                                            return;
                                        const {onTap: Zt, onTapCancel: Jt} = this.node.getProps();
                                        vt.update(()=>{
                                            yl(this.node.current, Ot.target) ? Zt && Zt(Ot, Yt) : Jt && Jt(Ot, Yt)
                                        }
                                        )
                                    }
                                    , {
                                        passive: !(Tt.onTap || Tt.onPointerUp)
                                    })
                                      , Nt = vo(window, "pointercancel", (Ot,Yt)=>this.cancelPress(Ot, Yt), {
                                        passive: !(Tt.onTapCancel || Tt.onPointerCancel)
                                    });
                                    this.removeEndListeners = Hr(Bt, Nt),
                                    this.startPress(mt, gt)
                                }
                                ,
                                this.startAccessiblePress = ()=>{
                                    const mt = yo(this.node.current, "keydown", Tt=>{
                                        Tt.key !== "Enter" || this.isPressing || (this.removeEndListeners(),
                                        this.removeEndListeners = yo(this.node.current, "keyup", Bt=>{
                                            Bt.key === "Enter" && this.checkPressEnd() && ms("up", (Nt,Ot)=>{
                                                const {onTap: Yt} = this.node.getProps();
                                                Yt && vt.update(()=>Yt(Nt, Ot))
                                            }
                                            )
                                        }
                                        ),
                                        ms("down", (Bt,Nt)=>{
                                            this.startPress(Bt, Nt)
                                        }
                                        ))
                                    }
                                    )
                                      , gt = yo(this.node.current, "blur", ()=>{
                                        this.isPressing && ms("cancel", (Tt,Bt)=>this.cancelPress(Tt, Bt))
                                    }
                                    );
                                    this.removeAccessibleListeners = Hr(mt, gt)
                                }
                            }
                            startPress(mt, gt) {
                                this.isPressing = !0;
                                const {onTapStart: Tt, whileTap: Bt} = this.node.getProps();
                                Bt && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
                                Tt && vt.update(()=>Tt(mt, gt))
                            }
                            checkPressEnd() {
                                return this.removeEndListeners(),
                                this.isPressing = !1,
                                this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
                                !xa()
                            }
                            cancelPress(mt, gt) {
                                if (!this.checkPressEnd())
                                    return;
                                const {onTapCancel: Tt} = this.node.getProps();
                                Tt && vt.update(()=>Tt(mt, gt))
                            }
                            mount() {
                                const mt = this.node.getProps()
                                  , gt = vo(this.node.current, "pointerdown", this.startPointerPress, {
                                    passive: !(mt.onTapStart || mt.onPointerStart)
                                })
                                  , Tt = yo(this.node.current, "focus", this.startAccessiblePress);
                                this.removeStartListeners = Hr(gt, Tt)
                            }
                            unmount() {
                                this.removeStartListeners(),
                                this.removeEndListeners(),
                                this.removeAccessibleListeners()
                            }
                        }
                    },
                    focus: {
                        Feature: class extends wo {
                            constructor() {
                                super(...arguments),
                                this.isActive = !1
                            }
                            onFocus() {
                                let mt = !1;
                                try {
                                    mt = this.node.current.matches(":focus-visible")
                                } catch {
                                    mt = !0
                                }
                                mt && this.node.animationState && (this.node.animationState.setActive("whileFocus", !0),
                                this.isActive = !0)
                            }
                            onBlur() {
                                this.isActive && this.node.animationState && (this.node.animationState.setActive("whileFocus", !1),
                                this.isActive = !1)
                            }
                            mount() {
                                this.unmount = Hr(yo(this.node.current, "focus", ()=>this.onFocus()), yo(this.node.current, "blur", ()=>this.onBlur()))
                            }
                            unmount() {}
                        }
                    },
                    hover: {
                        Feature: class extends wo {
                            mount() {
                                this.unmount = Hr($a(this.node, !0), $a(this.node, !1))
                            }
                            unmount() {}
                        }
                    }
                };
                function wl(mt, gt) {
                    if (!Array.isArray(gt))
                        return !1;
                    const Tt = gt.length;
                    if (Tt !== mt.length)
                        return !1;
                    for (let Bt = 0; Bt < Tt; Bt++)
                        if (gt[Bt] !== mt[Bt])
                            return !1;
                    return !0
                }
                const rp = [...ls].reverse()
                  , np = ls.length;
                function Co(mt=!1) {
                    return {
                        isActive: mt,
                        protectedKeys: {},
                        needsAnimating: {},
                        prevResolvedValues: {}
                    }
                }
                let ip = 0;
                const op = {
                    animation: {
                        Feature: class extends wo {
                            constructor(mt) {
                                super(mt),
                                mt.animationState || (mt.animationState = function(gt) {
                                    let Tt = function(Zt) {
                                        return Jt=>Promise.all(Jt.map(({animation: nr, options: sr})=>Bs(Zt, nr, sr)))
                                    }(gt);
                                    const Bt = {
                                        animate: Co(!0),
                                        whileInView: Co(),
                                        whileHover: Co(),
                                        whileTap: Co(),
                                        whileDrag: Co(),
                                        whileFocus: Co(),
                                        exit: Co()
                                    };
                                    let Nt = !0;
                                    const Ot = (Zt,Jt)=>{
                                        const nr = Mn(gt, Jt);
                                        if (nr) {
                                            const {transition: sr, transitionEnd: or, ...ur} = nr;
                                            Zt = {
                                                ...Zt,
                                                ...ur,
                                                ...or
                                            }
                                        }
                                        return Zt
                                    }
                                    ;
                                    function Yt(Zt, Jt) {
                                        const nr = gt.getProps()
                                          , sr = gt.getVariantContext(!0) || {}
                                          , or = []
                                          , ur = new Set;
                                        let yr = {}
                                          , mr = 1 / 0;
                                        for (let _r = 0; _r < np; _r++) {
                                            const Sr = rp[_r]
                                              , Vr = Bt[Sr]
                                              , qr = nr[Sr] !== void 0 ? nr[Sr] : sr[Sr]
                                              , an = Lo(qr)
                                              , Wr = Sr === Jt ? Vr.isActive : null;
                                            Wr === !1 && (mr = _r);
                                            let un = qr === sr[Sr] && qr !== nr[Sr] && an;
                                            if (un && Nt && gt.manuallyAnimateOnMount && (un = !1),
                                            Vr.protectedKeys = {
                                                ...yr
                                            },
                                            !Vr.isActive && Wr === null || !qr && !Vr.prevProp || Go(qr) || typeof qr == "boolean")
                                                continue;
                                            const $n = (Ar = Vr.prevProp,
                                            typeof (br = qr) == "string" ? br !== Ar : !!Array.isArray(br) && !wl(br, Ar));
                                            let Yn = $n || Sr === Jt && Vr.isActive && !un && an || _r > mr && an;
                                            const _i = Array.isArray(qr) ? qr : [qr];
                                            let Tn = _i.reduce(Ot, {});
                                            Wr === !1 && (Tn = {});
                                            const {prevResolvedValues: ro={}} = Vr
                                              , kn = {
                                                ...ro,
                                                ...Tn
                                            }
                                              , xn = hn=>{
                                                Yn = !0,
                                                ur.delete(hn),
                                                Vr.needsAnimating[hn] = !0
                                            }
                                            ;
                                            for (const hn in kn) {
                                                const An = Tn[hn]
                                                  , Vn = ro[hn];
                                                yr.hasOwnProperty(hn) || (An !== Vn ? ft(An) && ft(Vn) ? !wl(An, Vn) || $n ? xn(hn) : Vr.protectedKeys[hn] = !0 : An !== void 0 ? xn(hn) : ur.add(hn) : An !== void 0 && ur.has(hn) ? xn(hn) : Vr.protectedKeys[hn] = !0)
                                            }
                                            Vr.prevProp = qr,
                                            Vr.prevResolvedValues = Tn,
                                            Vr.isActive && (yr = {
                                                ...yr,
                                                ...Tn
                                            }),
                                            Nt && gt.blockInitialAnimation && (Yn = !1),
                                            Yn && !un && or.push(..._i.map(hn=>({
                                                animation: hn,
                                                options: {
                                                    type: Sr,
                                                    ...Zt
                                                }
                                            })))
                                        }
                                        var Ar, br;
                                        if (ur.size) {
                                            const _r = {};
                                            ur.forEach(Sr=>{
                                                const Vr = gt.getBaseTarget(Sr);
                                                Vr !== void 0 && (_r[Sr] = Vr)
                                            }
                                            ),
                                            or.push({
                                                animation: _r
                                            })
                                        }
                                        let Rr = !!or.length;
                                        return Nt && nr.initial === !1 && !gt.manuallyAnimateOnMount && (Rr = !1),
                                        Nt = !1,
                                        Rr ? Tt(or) : Promise.resolve()
                                    }
                                    return {
                                        animateChanges: Yt,
                                        setActive: function(Zt, Jt, nr) {
                                            var sr;
                                            if (Bt[Zt].isActive === Jt)
                                                return Promise.resolve();
                                            (sr = gt.variantChildren) === null || sr === void 0 || sr.forEach(ur=>{
                                                var yr;
                                                return (yr = ur.animationState) === null || yr === void 0 ? void 0 : yr.setActive(Zt, Jt)
                                            }
                                            ),
                                            Bt[Zt].isActive = Jt;
                                            const or = Yt(nr, Zt);
                                            for (const ur in Bt)
                                                Bt[ur].protectedKeys = {};
                                            return or
                                        },
                                        setAnimateFunction: function(Zt) {
                                            Tt = Zt(gt)
                                        },
                                        getState: ()=>Bt
                                    }
                                }(mt))
                            }
                            updateAnimationControlsSubscription() {
                                const {animate: mt} = this.node.getProps();
                                this.unmount(),
                                Go(mt) && (this.unmount = mt.subscribe(this.node))
                            }
                            mount() {
                                this.updateAnimationControlsSubscription()
                            }
                            update() {
                                const {animate: mt} = this.node.getProps()
                                  , {animate: gt} = this.node.prevProps || {};
                                mt !== gt && this.updateAnimationControlsSubscription()
                            }
                            unmount() {}
                        }
                    },
                    exit: {
                        Feature: class extends wo {
                            constructor() {
                                super(...arguments),
                                this.id = ip++
                            }
                            update() {
                                if (!this.node.presenceContext)
                                    return;
                                const {isPresent: mt, onExitComplete: gt, custom: Tt} = this.node.presenceContext
                                  , {isPresent: Bt} = this.node.prevPresenceContext || {};
                                if (!this.node.animationState || mt === Bt)
                                    return;
                                const Nt = this.node.animationState.setActive("exit", !mt, {
                                    custom: Tt ?? this.node.getProps().custom
                                });
                                gt && !mt && Nt.then(()=>gt(this.id))
                            }
                            mount() {
                                const {register: mt} = this.node.presenceContext || {};
                                mt && (this.unmount = mt(this.id))
                            }
                            unmount() {}
                        }
                    }
                }
                  , xl = (mt,gt)=>Math.abs(mt - gt);
                class Sl {
                    constructor(gt, Tt, {transformPagePoint: Bt}={}) {
                        if (this.startEvent = null,
                        this.lastMoveEvent = null,
                        this.lastMoveEventInfo = null,
                        this.handlers = {},
                        this.updatePoint = ()=>{
                            if (!this.lastMoveEvent || !this.lastMoveEventInfo)
                                return;
                            const Jt = bs(this.lastMoveEventInfo, this.history)
                              , nr = this.startEvent !== null
                              , sr = function(Ar, br) {
                                const Rr = xl(Ar.x, br.x)
                                  , _r = xl(Ar.y, br.y);
                                return Math.sqrt(Rr ** 2 + _r ** 2)
                            }(Jt.offset, {
                                x: 0,
                                y: 0
                            }) >= 3;
                            if (!nr && !sr)
                                return;
                            const {point: or} = Jt
                              , {timestamp: ur} = Pt;
                            this.history.push({
                                ...or,
                                timestamp: ur
                            });
                            const {onStart: yr, onMove: mr} = this.handlers;
                            nr || (yr && yr(this.lastMoveEvent, Jt),
                            this.startEvent = this.lastMoveEvent),
                            mr && mr(this.lastMoveEvent, Jt)
                        }
                        ,
                        this.handlePointerMove = (Jt,nr)=>{
                            this.lastMoveEvent = Jt,
                            this.lastMoveEventInfo = vs(nr, this.transformPagePoint),
                            vt.update(this.updatePoint, !0)
                        }
                        ,
                        this.handlePointerUp = (Jt,nr)=>{
                            if (this.end(),
                            !this.lastMoveEvent || !this.lastMoveEventInfo)
                                return;
                            const {onEnd: sr, onSessionEnd: or} = this.handlers
                              , ur = bs(Jt.type === "pointercancel" ? this.lastMoveEventInfo : vs(nr, this.transformPagePoint), this.history);
                            this.startEvent && sr && sr(Jt, ur),
                            or && or(Jt, ur)
                        }
                        ,
                        !Qs(gt))
                            return;
                        this.handlers = Tt,
                        this.transformPagePoint = Bt;
                        const Nt = vs(Zo(gt), this.transformPagePoint)
                          , {point: Ot} = Nt
                          , {timestamp: Yt} = Pt;
                        this.history = [{
                            ...Ot,
                            timestamp: Yt
                        }];
                        const {onSessionStart: Zt} = Tt;
                        Zt && Zt(gt, bs(Nt, this.history)),
                        this.removeListeners = Hr(vo(window, "pointermove", this.handlePointerMove), vo(window, "pointerup", this.handlePointerUp), vo(window, "pointercancel", this.handlePointerUp))
                    }
                    updateHandlers(gt) {
                        this.handlers = gt
                    }
                    end() {
                        this.removeListeners && this.removeListeners(),
                        _t(this.updatePoint)
                    }
                }
                function vs(mt, gt) {
                    return gt ? {
                        point: gt(mt.point)
                    } : mt
                }
                function Cl(mt, gt) {
                    return {
                        x: mt.x - gt.x,
                        y: mt.y - gt.y
                    }
                }
                function bs({point: mt}, gt) {
                    return {
                        point: mt,
                        delta: Cl(mt, _l(gt)),
                        offset: Cl(mt, sp(gt)),
                        velocity: ap(gt, .1)
                    }
                }
                function sp(mt) {
                    return mt[0]
                }
                function _l(mt) {
                    return mt[mt.length - 1]
                }
                function ap(mt, gt) {
                    if (mt.length < 2)
                        return {
                            x: 0,
                            y: 0
                        };
                    let Tt = mt.length - 1
                      , Bt = null;
                    const Nt = _l(mt);
                    for (; Tt >= 0 && (Bt = mt[Tt],
                    !(Nt.timestamp - Bt.timestamp > ao(gt))); )
                        Tt--;
                    if (!Bt)
                        return {
                            x: 0,
                            y: 0
                        };
                    const Ot = lo(Nt.timestamp - Bt.timestamp);
                    if (Ot === 0)
                        return {
                            x: 0,
                            y: 0
                        };
                    const Yt = {
                        x: (Nt.x - Bt.x) / Ot,
                        y: (Nt.y - Bt.y) / Ot
                    };
                    return Yt.x === 1 / 0 && (Yt.x = 0),
                    Yt.y === 1 / 0 && (Yt.y = 0),
                    Yt
                }
                function uo(mt) {
                    return mt.max - mt.min
                }
                function ws(mt, gt=0, Tt=.01) {
                    return Math.abs(mt - gt) <= Tt
                }
                function El(mt, gt, Tt, Bt=.5) {
                    mt.origin = Bt,
                    mt.originPoint = Jr(gt.min, gt.max, mt.origin),
                    mt.scale = uo(Tt) / uo(gt),
                    (ws(mt.scale, 1, 1e-4) || isNaN(mt.scale)) && (mt.scale = 1),
                    mt.translate = Jr(Tt.min, Tt.max, mt.origin) - mt.originPoint,
                    (ws(mt.translate) || isNaN(mt.translate)) && (mt.translate = 0)
                }
                function Oo(mt, gt, Tt, Bt) {
                    El(mt.x, gt.x, Tt.x, Bt ? Bt.originX : void 0),
                    El(mt.y, gt.y, Tt.y, Bt ? Bt.originY : void 0)
                }
                function Tl(mt, gt, Tt) {
                    mt.min = Tt.min + gt.min,
                    mt.max = mt.min + uo(gt)
                }
                function Pl(mt, gt, Tt) {
                    mt.min = gt.min - Tt.min,
                    mt.max = mt.min + uo(gt)
                }
                function Fo(mt, gt, Tt) {
                    Pl(mt.x, gt.x, Tt.x),
                    Pl(mt.y, gt.y, Tt.y)
                }
                function Al(mt, gt, Tt) {
                    return {
                        min: gt !== void 0 ? mt.min + gt : void 0,
                        max: Tt !== void 0 ? mt.max + Tt - (mt.max - mt.min) : void 0
                    }
                }
                function Ml(mt, gt) {
                    let Tt = gt.min - mt.min
                      , Bt = gt.max - mt.max;
                    return gt.max - gt.min < mt.max - mt.min && ([Tt,Bt] = [Bt, Tt]),
                    {
                        min: Tt,
                        max: Bt
                    }
                }
                const xs = .35;
                function Il(mt, gt, Tt) {
                    return {
                        min: Bl(mt, gt),
                        max: Bl(mt, Tt)
                    }
                }
                function Bl(mt, gt) {
                    return typeof mt == "number" ? mt : mt[gt] || 0
                }
                function go(mt) {
                    return [mt("x"), mt("y")]
                }
                function $l({top: mt, left: gt, right: Tt, bottom: Bt}) {
                    return {
                        x: {
                            min: gt,
                            max: Tt
                        },
                        y: {
                            min: mt,
                            max: Bt
                        }
                    }
                }
                function Ss(mt) {
                    return mt === void 0 || mt === 1
                }
                function Cs({scale: mt, scaleX: gt, scaleY: Tt}) {
                    return !Ss(mt) || !Ss(gt) || !Ss(Tt)
                }
                function _o(mt) {
                    return Cs(mt) || Rl(mt) || mt.z || mt.rotate || mt.rotateX || mt.rotateY
                }
                function Rl(mt) {
                    return Ll(mt.x) || Ll(mt.y)
                }
                function Ll(mt) {
                    return mt && mt !== "0%"
                }
                function Qo(mt, gt, Tt) {
                    return Tt + gt * (mt - Tt)
                }
                function Dl(mt, gt, Tt, Bt, Nt) {
                    return Nt !== void 0 && (mt = Qo(mt, Nt, Bt)),
                    Qo(mt, Tt, Bt) + gt
                }
                function _s(mt, gt=0, Tt=1, Bt, Nt) {
                    mt.min = Dl(mt.min, gt, Tt, Bt, Nt),
                    mt.max = Dl(mt.max, gt, Tt, Bt, Nt)
                }
                function Ol(mt, {x: gt, y: Tt}) {
                    _s(mt.x, gt.translate, gt.scale, gt.originPoint),
                    _s(mt.y, Tt.translate, Tt.scale, Tt.originPoint)
                }
                function Fl(mt) {
                    return Number.isInteger(mt) || mt > 1.0000000000001 || mt < .999999999999 ? mt : 1
                }
                function xo(mt, gt) {
                    mt.min = mt.min + gt,
                    mt.max = mt.max + gt
                }
                function Vl(mt, gt, [Tt,Bt,Nt]) {
                    const Ot = gt[Nt] !== void 0 ? gt[Nt] : .5
                      , Yt = Jr(mt.min, mt.max, Ot);
                    _s(mt, gt[Tt], gt[Bt], Yt, gt.scale)
                }
                const lp = ["x", "scaleX", "originX"]
                  , cp = ["y", "scaleY", "originY"];
                function Io(mt, gt) {
                    Vl(mt.x, gt, lp),
                    Vl(mt.y, gt, cp)
                }
                function Nl(mt, gt) {
                    return $l(function(Tt, Bt) {
                        if (!Bt)
                            return Tt;
                        const Nt = Bt({
                            x: Tt.left,
                            y: Tt.top
                        })
                          , Ot = Bt({
                            x: Tt.right,
                            y: Tt.bottom
                        });
                        return {
                            top: Nt.y,
                            left: Nt.x,
                            bottom: Ot.y,
                            right: Ot.x
                        }
                    }(mt.getBoundingClientRect(), gt))
                }
                const up = new WeakMap;
                class dp {
                    constructor(gt) {
                        this.openGlobalLock = null,
                        this.isDragging = !1,
                        this.currentDirection = null,
                        this.originPoint = {
                            x: 0,
                            y: 0
                        },
                        this.constraints = !1,
                        this.hasMutatedConstraints = !1,
                        this.elastic = {
                            x: {
                                min: 0,
                                max: 0
                            },
                            y: {
                                min: 0,
                                max: 0
                            }
                        },
                        this.visualElement = gt
                    }
                    start(gt, {snapToCursor: Tt=!1}={}) {
                        const {presenceContext: Bt} = this.visualElement;
                        Bt && Bt.isPresent === !1 || (this.panSession = new Sl(gt,{
                            onSessionStart: Nt=>{
                                this.stopAnimation(),
                                Tt && this.snapToCursor(Zo(Nt, "page").point)
                            }
                            ,
                            onStart: (Nt,Ot)=>{
                                const {drag: Yt, dragPropagation: Zt, onDragStart: Jt} = this.getProps();
                                if (Yt && !Zt && (this.openGlobalLock && this.openGlobalLock(),
                                this.openGlobalLock = ba(Yt),
                                !this.openGlobalLock))
                                    return;
                                this.isDragging = !0,
                                this.currentDirection = null,
                                this.resolveConstraints(),
                                this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
                                this.visualElement.projection.target = void 0),
                                go(sr=>{
                                    let or = this.getAxisMotionValue(sr).get() || 0;
                                    if (lr.test(or)) {
                                        const {projection: ur} = this.visualElement;
                                        if (ur && ur.layout) {
                                            const yr = ur.layout.layoutBox[sr];
                                            yr && (or = uo(yr) * (parseFloat(or) / 100))
                                        }
                                    }
                                    this.originPoint[sr] = or
                                }
                                ),
                                Jt && vt.update(()=>Jt(Nt, Ot), !1, !0);
                                const {animationState: nr} = this.visualElement;
                                nr && nr.setActive("whileDrag", !0)
                            }
                            ,
                            onMove: (Nt,Ot)=>{
                                const {dragPropagation: Yt, dragDirectionLock: Zt, onDirectionLock: Jt, onDrag: nr} = this.getProps();
                                if (!Yt && !this.openGlobalLock)
                                    return;
                                const {offset: sr} = Ot;
                                if (Zt && this.currentDirection === null)
                                    return this.currentDirection = function(or, ur=10) {
                                        let yr = null;
                                        return Math.abs(or.y) > ur ? yr = "y" : Math.abs(or.x) > ur && (yr = "x"),
                                        yr
                                    }(sr),
                                    void (this.currentDirection !== null && Jt && Jt(this.currentDirection));
                                this.updateAxis("x", Ot.point, sr),
                                this.updateAxis("y", Ot.point, sr),
                                this.visualElement.render(),
                                nr && nr(Nt, Ot)
                            }
                            ,
                            onSessionEnd: (Nt,Ot)=>this.stop(Nt, Ot)
                        },{
                            transformPagePoint: this.visualElement.getTransformPagePoint()
                        }))
                    }
                    stop(gt, Tt) {
                        const Bt = this.isDragging;
                        if (this.cancel(),
                        !Bt)
                            return;
                        const {velocity: Nt} = Tt;
                        this.startAnimation(Nt);
                        const {onDragEnd: Ot} = this.getProps();
                        Ot && vt.update(()=>Ot(gt, Tt))
                    }
                    cancel() {
                        this.isDragging = !1;
                        const {projection: gt, animationState: Tt} = this.visualElement;
                        gt && (gt.isAnimationBlocked = !1),
                        this.panSession && this.panSession.end(),
                        this.panSession = void 0;
                        const {dragPropagation: Bt} = this.getProps();
                        !Bt && this.openGlobalLock && (this.openGlobalLock(),
                        this.openGlobalLock = null),
                        Tt && Tt.setActive("whileDrag", !1)
                    }
                    updateAxis(gt, Tt, Bt) {
                        const {drag: Nt} = this.getProps();
                        if (!Bt || !Jo(gt, Nt, this.currentDirection))
                            return;
                        const Ot = this.getAxisMotionValue(gt);
                        let Yt = this.originPoint[gt] + Bt[gt];
                        this.constraints && this.constraints[gt] && (Yt = function(Zt, {min: Jt, max: nr}, sr) {
                            return Jt !== void 0 && Zt < Jt ? Zt = sr ? Jr(Jt, Zt, sr.min) : Math.max(Zt, Jt) : nr !== void 0 && Zt > nr && (Zt = sr ? Jr(nr, Zt, sr.max) : Math.min(Zt, nr)),
                            Zt
                        }(Yt, this.constraints[gt], this.elastic[gt])),
                        Ot.set(Yt)
                    }
                    resolveConstraints() {
                        const {dragConstraints: gt, dragElastic: Tt} = this.getProps()
                          , {layout: Bt} = this.visualElement.projection || {}
                          , Nt = this.constraints;
                        gt && Mo(gt) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : this.constraints = !(!gt || !Bt) && function(Ot, {top: Yt, left: Zt, bottom: Jt, right: nr}) {
                            return {
                                x: Al(Ot.x, Zt, nr),
                                y: Al(Ot.y, Yt, Jt)
                            }
                        }(Bt.layoutBox, gt),
                        this.elastic = function(Ot=xs) {
                            return Ot === !1 ? Ot = 0 : Ot === !0 && (Ot = xs),
                            {
                                x: Il(Ot, "left", "right"),
                                y: Il(Ot, "top", "bottom")
                            }
                        }(Tt),
                        Nt !== this.constraints && Bt && this.constraints && !this.hasMutatedConstraints && go(Ot=>{
                            this.getAxisMotionValue(Ot) && (this.constraints[Ot] = function(Yt, Zt) {
                                const Jt = {};
                                return Zt.min !== void 0 && (Jt.min = Zt.min - Yt.min),
                                Zt.max !== void 0 && (Jt.max = Zt.max - Yt.min),
                                Jt
                            }(Bt.layoutBox[Ot], this.constraints[Ot]))
                        }
                        )
                    }
                    resolveRefConstraints() {
                        const {dragConstraints: gt, onMeasureDragConstraints: Tt} = this.getProps();
                        if (!gt || !Mo(gt))
                            return !1;
                        const Bt = gt.current
                          , {projection: Nt} = this.visualElement;
                        if (!Nt || !Nt.layout)
                            return !1;
                        const Ot = function(Zt, Jt, nr) {
                            const sr = Nl(Zt, nr)
                              , {scroll: or} = Jt;
                            return or && (xo(sr.x, or.offset.x),
                            xo(sr.y, or.offset.y)),
                            sr
                        }(Bt, Nt.root, this.visualElement.getTransformPagePoint());
                        let Yt = function(Zt, Jt) {
                            return {
                                x: Ml(Zt.x, Jt.x),
                                y: Ml(Zt.y, Jt.y)
                            }
                        }(Nt.layout.layoutBox, Ot);
                        if (Tt) {
                            const Zt = Tt(function({x: Jt, y: nr}) {
                                return {
                                    top: nr.min,
                                    right: Jt.max,
                                    bottom: nr.max,
                                    left: Jt.min
                                }
                            }(Yt));
                            this.hasMutatedConstraints = !!Zt,
                            Zt && (Yt = $l(Zt))
                        }
                        return Yt
                    }
                    startAnimation(gt) {
                        const {drag: Tt, dragMomentum: Bt, dragElastic: Nt, dragTransition: Ot, dragSnapToOrigin: Yt, onDragTransitionEnd: Zt} = this.getProps()
                          , Jt = this.constraints || {}
                          , nr = go(sr=>{
                            if (!Jo(sr, Tt, this.currentDirection))
                                return;
                            let or = Jt && Jt[sr] || {};
                            Yt && (or = {
                                min: 0,
                                max: 0
                            });
                            const ur = Nt ? 200 : 1e6
                              , yr = Nt ? 40 : 1e7
                              , mr = {
                                type: "inertia",
                                velocity: Bt ? gt[sr] : 0,
                                bounceStiffness: ur,
                                bounceDamping: yr,
                                timeConstant: 750,
                                restDelta: 1,
                                restSpeed: 10,
                                ...Ot,
                                ...or
                            };
                            return this.startAxisValueAnimation(sr, mr)
                        }
                        );
                        return Promise.all(nr).then(Zt)
                    }
                    startAxisValueAnimation(gt, Tt) {
                        const Bt = this.getAxisMotionValue(gt);
                        return Bt.start(os(gt, Bt, 0, Tt))
                    }
                    stopAnimation() {
                        go(gt=>this.getAxisMotionValue(gt).stop())
                    }
                    getAxisMotionValue(gt) {
                        const Tt = "_drag" + gt.toUpperCase()
                          , Bt = this.visualElement.getProps();
                        return Bt[Tt] || this.visualElement.getValue(gt, (Bt.initial ? Bt.initial[gt] : void 0) || 0)
                    }
                    snapToCursor(gt) {
                        go(Tt=>{
                            const {drag: Bt} = this.getProps();
                            if (!Jo(Tt, Bt, this.currentDirection))
                                return;
                            const {projection: Nt} = this.visualElement
                              , Ot = this.getAxisMotionValue(Tt);
                            if (Nt && Nt.layout) {
                                const {min: Yt, max: Zt} = Nt.layout.layoutBox[Tt];
                                Ot.set(gt[Tt] - Jr(Yt, Zt, .5))
                            }
                        }
                        )
                    }
                    scalePositionWithinConstraints() {
                        if (!this.visualElement.current)
                            return;
                        const {drag: gt, dragConstraints: Tt} = this.getProps()
                          , {projection: Bt} = this.visualElement;
                        if (!Mo(Tt) || !Bt || !this.constraints)
                            return;
                        this.stopAnimation();
                        const Nt = {
                            x: 0,
                            y: 0
                        };
                        go(Yt=>{
                            const Zt = this.getAxisMotionValue(Yt);
                            if (Zt) {
                                const Jt = Zt.get();
                                Nt[Yt] = function(nr, sr) {
                                    let or = .5;
                                    const ur = uo(nr)
                                      , yr = uo(sr);
                                    return yr > ur ? or = Or(sr.min, sr.max - ur, nr.min) : ur > yr && (or = Or(nr.min, nr.max - yr, sr.min)),
                                    St(0, 1, or)
                                }({
                                    min: Jt,
                                    max: Jt
                                }, this.constraints[Yt])
                            }
                        }
                        );
                        const {transformTemplate: Ot} = this.visualElement.getProps();
                        this.visualElement.current.style.transform = Ot ? Ot({}, "") : "none",
                        Bt.root && Bt.root.updateScroll(),
                        Bt.updateLayout(),
                        this.resolveConstraints(),
                        go(Yt=>{
                            if (!Jo(Yt, gt, null))
                                return;
                            const Zt = this.getAxisMotionValue(Yt)
                              , {min: Jt, max: nr} = this.constraints[Yt];
                            Zt.set(Jr(Jt, nr, Nt[Yt]))
                        }
                        )
                    }
                    addListeners() {
                        if (!this.visualElement.current)
                            return;
                        up.set(this.visualElement, this);
                        const gt = vo(this.visualElement.current, "pointerdown", Zt=>{
                            const {drag: Jt, dragListener: nr=!0} = this.getProps();
                            Jt && nr && this.start(Zt)
                        }
                        )
                          , Tt = ()=>{
                            const {dragConstraints: Zt} = this.getProps();
                            Mo(Zt) && (this.constraints = this.resolveRefConstraints())
                        }
                          , {projection: Bt} = this.visualElement
                          , Nt = Bt.addEventListener("measure", Tt);
                        Bt && !Bt.layout && (Bt.root && Bt.root.updateScroll(),
                        Bt.updateLayout()),
                        Tt();
                        const Ot = yo(window, "resize", ()=>this.scalePositionWithinConstraints())
                          , Yt = Bt.addEventListener("didUpdate", ({delta: Zt, hasLayoutChanged: Jt})=>{
                            this.isDragging && Jt && (go(nr=>{
                                const sr = this.getAxisMotionValue(nr);
                                sr && (this.originPoint[nr] += Zt[nr].translate,
                                sr.set(sr.get() + Zt[nr].translate))
                            }
                            ),
                            this.visualElement.render())
                        }
                        );
                        return ()=>{
                            Ot(),
                            gt(),
                            Nt(),
                            Yt && Yt()
                        }
                    }
                    getProps() {
                        const gt = this.visualElement.getProps()
                          , {drag: Tt=!1, dragDirectionLock: Bt=!1, dragPropagation: Nt=!1, dragConstraints: Ot=!1, dragElastic: Yt=xs, dragMomentum: Zt=!0} = gt;
                        return {
                            ...gt,
                            drag: Tt,
                            dragDirectionLock: Bt,
                            dragPropagation: Nt,
                            dragConstraints: Ot,
                            dragElastic: Yt,
                            dragMomentum: Zt
                        }
                    }
                }
                function Jo(mt, gt, Tt) {
                    return !(gt !== !0 && gt !== mt || Tt !== null && Tt !== mt)
                }
                const Ul = mt=>(gt,Tt)=>{
                    mt && vt.update(()=>mt(gt, Tt))
                }
                  , es = {
                    hasAnimatedSinceResize: !0,
                    hasEverUpdated: !1
                };
                function zl(mt, gt) {
                    return gt.max === gt.min ? 0 : mt / (gt.max - gt.min) * 100
                }
                const Vo = {
                    correct: (mt,gt)=>{
                        if (!gt.target)
                            return mt;
                        if (typeof mt == "string") {
                            if (!ir.test(mt))
                                return mt;
                            mt = parseFloat(mt)
                        }
                        return `${zl(mt, gt.target.x)}% ${zl(mt, gt.target.y)}%`
                    }
                }
                  , fp = {
                    correct: (mt,{treeScale: gt, projectionDelta: Tt})=>{
                        const Bt = mt
                          , Nt = er.parse(mt);
                        if (Nt.length > 5)
                            return Bt;
                        const Ot = er.createTransformer(mt)
                          , Yt = typeof Nt[0] != "number" ? 1 : 0
                          , Zt = Tt.x.scale * gt.x
                          , Jt = Tt.y.scale * gt.y;
                        Nt[0 + Yt] /= Zt,
                        Nt[1 + Yt] /= Jt;
                        const nr = Jr(Zt, Jt, .5);
                        return typeof Nt[2 + Yt] == "number" && (Nt[2 + Yt] /= nr),
                        typeof Nt[3 + Yt] == "number" && (Nt[3 + Yt] /= nr),
                        Ot(Nt)
                    }
                };
                class hp extends rt.Component {
                    componentDidMount() {
                        const {visualElement: gt, layoutGroup: Tt, switchLayoutGroup: Bt, layoutId: Nt} = this.props
                          , {projection: Ot} = gt;
                        var Yt;
                        Yt = pp,
                        Object.assign(Ko, Yt),
                        Ot && (Tt.group && Tt.group.add(Ot),
                        Bt && Bt.register && Nt && Bt.register(Ot),
                        Ot.root.didUpdate(),
                        Ot.addEventListener("animationComplete", ()=>{
                            this.safeToRemove()
                        }
                        ),
                        Ot.setOptions({
                            ...Ot.options,
                            onExitComplete: ()=>this.safeToRemove()
                        })),
                        es.hasEverUpdated = !0
                    }
                    getSnapshotBeforeUpdate(gt) {
                        const {layoutDependency: Tt, visualElement: Bt, drag: Nt, isPresent: Ot} = this.props
                          , Yt = Bt.projection;
                        return Yt && (Yt.isPresent = Ot,
                        Nt || gt.layoutDependency !== Tt || Tt === void 0 ? Yt.willUpdate() : this.safeToRemove(),
                        gt.isPresent !== Ot && (Ot ? Yt.promote() : Yt.relegate() || vt.postRender(()=>{
                            const Zt = Yt.getStack();
                            Zt && Zt.members.length || this.safeToRemove()
                        }
                        ))),
                        null
                    }
                    componentDidUpdate() {
                        const {projection: gt} = this.props.visualElement;
                        gt && (gt.root.didUpdate(),
                        queueMicrotask(()=>{
                            !gt.currentAnimation && gt.isLead() && this.safeToRemove()
                        }
                        ))
                    }
                    componentWillUnmount() {
                        const {visualElement: gt, layoutGroup: Tt, switchLayoutGroup: Bt} = this.props
                          , {projection: Nt} = gt;
                        Nt && (Nt.scheduleCheckAfterUnmount(),
                        Tt && Tt.group && Tt.group.remove(Nt),
                        Bt && Bt.deregister && Bt.deregister(Nt))
                    }
                    safeToRemove() {
                        const {safeToRemove: gt} = this.props;
                        gt && gt()
                    }
                    render() {
                        return null
                    }
                }
                function Wl(mt) {
                    const [gt,Tt] = function() {
                        const Nt = (0,
                        rt.useContext)(as);
                        if (Nt === null)
                            return [!0, null];
                        const {isPresent: Ot, onExitComplete: Yt, register: Zt} = Nt
                          , Jt = (0,
                        rt.useId)();
                        return (0,
                        rt.useEffect)(()=>Zt(Jt), []),
                        !Ot && Yt ? [!1, ()=>Yt && Yt(Jt)] : [!0]
                    }()
                      , Bt = (0,
                    rt.useContext)(js);
                    return rt.createElement(hp, {
                        ...mt,
                        layoutGroup: Bt,
                        switchLayoutGroup: (0,
                        rt.useContext)(Ns),
                        isPresent: gt,
                        safeToRemove: Tt
                    })
                }
                const pp = {
                    borderRadius: {
                        ...Vo,
                        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
                    },
                    borderTopLeftRadius: Vo,
                    borderTopRightRadius: Vo,
                    borderBottomLeftRadius: Vo,
                    borderBottomRightRadius: Vo,
                    boxShadow: fp
                }
                  , Hl = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
                  , mp = Hl.length
                  , Gl = mt=>typeof mt == "string" ? parseFloat(mt) : mt
                  , Kl = mt=>typeof mt == "number" || ir.test(mt);
                function Yl(mt, gt) {
                    return mt[gt] !== void 0 ? mt[gt] : mt.borderRadius
                }
                const gp = Xl(0, .5, Ln)
                  , yp = Xl(.5, .95, it);
                function Xl(mt, gt, Tt) {
                    return Bt=>Bt < mt ? 0 : Bt > gt ? 1 : Tt(Or(mt, gt, Bt))
                }
                function Zl(mt, gt) {
                    mt.min = gt.min,
                    mt.max = gt.max
                }
                function fo(mt, gt) {
                    Zl(mt.x, gt.x),
                    Zl(mt.y, gt.y)
                }
                function Ql(mt, gt, Tt, Bt, Nt) {
                    return mt = Qo(mt -= gt, 1 / Tt, Bt),
                    Nt !== void 0 && (mt = Qo(mt, 1 / Nt, Bt)),
                    mt
                }
                function Jl(mt, gt, [Tt,Bt,Nt], Ot, Yt) {
                    (function(Zt, Jt=0, nr=1, sr=.5, or, ur=Zt, yr=Zt) {
                        if (lr.test(Jt) && (Jt = parseFloat(Jt),
                        Jt = Jr(yr.min, yr.max, Jt / 100) - yr.min),
                        typeof Jt != "number")
                            return;
                        let mr = Jr(ur.min, ur.max, sr);
                        Zt === ur && (mr -= Jt),
                        Zt.min = Ql(Zt.min, Jt, nr, mr, or),
                        Zt.max = Ql(Zt.max, Jt, nr, mr, or)
                    }
                    )(mt, gt[Tt], gt[Bt], gt[Nt], gt.scale, Ot, Yt)
                }
                const vp = ["x", "scaleX", "originX"]
                  , bp = ["y", "scaleY", "originY"];
                function eu(mt, gt, Tt, Bt) {
                    Jl(mt.x, gt, vp, Tt ? Tt.x : void 0, Bt ? Bt.x : void 0),
                    Jl(mt.y, gt, bp, Tt ? Tt.y : void 0, Bt ? Bt.y : void 0)
                }
                function tu(mt) {
                    return mt.translate === 0 && mt.scale === 1
                }
                function nu(mt) {
                    return tu(mt.x) && tu(mt.y)
                }
                function iu(mt, gt) {
                    return Math.round(mt.x.min) === Math.round(gt.x.min) && Math.round(mt.x.max) === Math.round(gt.x.max) && Math.round(mt.y.min) === Math.round(gt.y.min) && Math.round(mt.y.max) === Math.round(gt.y.max)
                }
                function ou(mt) {
                    return uo(mt.x) / uo(mt.y)
                }
                class wp {
                    constructor() {
                        this.members = []
                    }
                    add(gt) {
                        ht(this.members, gt),
                        gt.scheduleRender()
                    }
                    remove(gt) {
                        if (xt(this.members, gt),
                        gt === this.prevLead && (this.prevLead = void 0),
                        gt === this.lead) {
                            const Tt = this.members[this.members.length - 1];
                            Tt && this.promote(Tt)
                        }
                    }
                    relegate(gt) {
                        const Tt = this.members.findIndex(Nt=>gt === Nt);
                        if (Tt === 0)
                            return !1;
                        let Bt;
                        for (let Nt = Tt; Nt >= 0; Nt--) {
                            const Ot = this.members[Nt];
                            if (Ot.isPresent !== !1) {
                                Bt = Ot;
                                break
                            }
                        }
                        return !!Bt && (this.promote(Bt),
                        !0)
                    }
                    promote(gt, Tt) {
                        const Bt = this.lead;
                        if (gt !== Bt && (this.prevLead = Bt,
                        this.lead = gt,
                        gt.show(),
                        Bt)) {
                            Bt.instance && Bt.scheduleRender(),
                            gt.scheduleRender(),
                            gt.resumeFrom = Bt,
                            Tt && (gt.resumeFrom.preserveOpacity = !0),
                            Bt.snapshot && (gt.snapshot = Bt.snapshot,
                            gt.snapshot.latestValues = Bt.animationValues || Bt.latestValues),
                            gt.root && gt.root.isUpdating && (gt.isLayoutDirty = !0);
                            const {crossfade: Nt} = gt.options;
                            Nt === !1 && Bt.hide()
                        }
                    }
                    exitAnimationComplete() {
                        this.members.forEach(gt=>{
                            const {options: Tt, resumingFrom: Bt} = gt;
                            Tt.onExitComplete && Tt.onExitComplete(),
                            Bt && Bt.options.onExitComplete && Bt.options.onExitComplete()
                        }
                        )
                    }
                    scheduleRender() {
                        this.members.forEach(gt=>{
                            gt.instance && gt.scheduleRender(!1)
                        }
                        )
                    }
                    removeLeadSnapshot() {
                        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
                    }
                }
                function su(mt, gt, Tt) {
                    let Bt = "";
                    const Nt = mt.x.translate / gt.x
                      , Ot = mt.y.translate / gt.y;
                    if ((Nt || Ot) && (Bt = `translate3d(${Nt}px, ${Ot}px, 0) `),
                    gt.x === 1 && gt.y === 1 || (Bt += `scale(${1 / gt.x}, ${1 / gt.y}) `),
                    Tt) {
                        const {rotate: Jt, rotateX: nr, rotateY: sr} = Tt;
                        Jt && (Bt += `rotate(${Jt}deg) `),
                        nr && (Bt += `rotateX(${nr}deg) `),
                        sr && (Bt += `rotateY(${sr}deg) `)
                    }
                    const Yt = mt.x.scale * gt.x
                      , Zt = mt.y.scale * gt.y;
                    return Yt === 1 && Zt === 1 || (Bt += `scale(${Yt}, ${Zt})`),
                    Bt || "none"
                }
                const xp = (mt,gt)=>mt.depth - gt.depth;
                class Sp {
                    constructor() {
                        this.children = [],
                        this.isDirty = !1
                    }
                    add(gt) {
                        ht(this.children, gt),
                        this.isDirty = !0
                    }
                    remove(gt) {
                        xt(this.children, gt),
                        this.isDirty = !0
                    }
                    forEach(gt) {
                        this.isDirty && this.children.sort(xp),
                        this.isDirty = !1,
                        this.children.forEach(gt)
                    }
                }
                const au = ["", "X", "Y", "Z"];
                let Cp = 0;
                const Eo = {
                    type: "projectionFrame",
                    totalNodes: 0,
                    resolvedTargetDeltas: 0,
                    recalculatedProjection: 0
                };
                function lu({attachResizeListener: mt, defaultParent: gt, measureScroll: Tt, checkIsScrollRoot: Bt, resetTransform: Nt}) {
                    return class {
                        constructor(Ot={}, Yt=gt == null ? void 0 : gt()) {
                            this.id = Cp++,
                            this.animationId = 0,
                            this.children = new Set,
                            this.options = {},
                            this.isTreeAnimating = !1,
                            this.isAnimationBlocked = !1,
                            this.isLayoutDirty = !1,
                            this.isProjectionDirty = !1,
                            this.isSharedProjectionDirty = !1,
                            this.isTransformDirty = !1,
                            this.updateManuallyBlocked = !1,
                            this.updateBlockedByResize = !1,
                            this.isUpdating = !1,
                            this.isSVG = !1,
                            this.needsReset = !1,
                            this.shouldResetTransform = !1,
                            this.treeScale = {
                                x: 1,
                                y: 1
                            },
                            this.eventHandlers = new Map,
                            this.hasTreeAnimated = !1,
                            this.updateScheduled = !1,
                            this.checkUpdateFailed = ()=>{
                                this.isUpdating && (this.isUpdating = !1,
                                this.clearAllSnapshots())
                            }
                            ,
                            this.updateProjection = ()=>{
                                var Zt;
                                Eo.totalNodes = Eo.resolvedTargetDeltas = Eo.recalculatedProjection = 0,
                                this.nodes.forEach(Tp),
                                this.nodes.forEach(Ip),
                                this.nodes.forEach(Bp),
                                this.nodes.forEach(Pp),
                                Zt = Eo,
                                window.MotionDebug && window.MotionDebug.record(Zt)
                            }
                            ,
                            this.hasProjected = !1,
                            this.isVisible = !0,
                            this.animationProgress = 0,
                            this.sharedNodes = new Map,
                            this.latestValues = Ot,
                            this.root = Yt ? Yt.root || Yt : this,
                            this.path = Yt ? [...Yt.path, Yt] : [],
                            this.parent = Yt,
                            this.depth = Yt ? Yt.depth + 1 : 0;
                            for (let Zt = 0; Zt < this.path.length; Zt++)
                                this.path[Zt].shouldResetTransform = !0;
                            this.root === this && (this.nodes = new Sp)
                        }
                        addEventListener(Ot, Yt) {
                            return this.eventHandlers.has(Ot) || this.eventHandlers.set(Ot, new lt),
                            this.eventHandlers.get(Ot).add(Yt)
                        }
                        notifyListeners(Ot, ...Yt) {
                            const Zt = this.eventHandlers.get(Ot);
                            Zt && Zt.notify(...Yt)
                        }
                        hasListeners(Ot) {
                            return this.eventHandlers.has(Ot)
                        }
                        mount(Ot, Yt=this.root.hasTreeAnimated) {
                            if (this.instance)
                                return;
                            var Zt;
                            this.isSVG = (Zt = Ot)instanceof SVGElement && Zt.tagName !== "svg",
                            this.instance = Ot;
                            const {layoutId: Jt, layout: nr, visualElement: sr} = this.options;
                            if (sr && !sr.current && sr.mount(Ot),
                            this.root.nodes.add(this),
                            this.parent && this.parent.children.add(this),
                            Yt && (nr || Jt) && (this.isLayoutDirty = !0),
                            mt) {
                                let or;
                                const ur = ()=>this.root.updateBlockedByResize = !1;
                                mt(Ot, ()=>{
                                    this.root.updateBlockedByResize = !0,
                                    or && or(),
                                    or = function(yr, mr) {
                                        const Ar = performance.now()
                                          , br = ({timestamp: Rr})=>{
                                            const _r = Rr - Ar;
                                            _r >= 250 && (_t(br),
                                            yr(_r - 250))
                                        }
                                        ;
                                        return vt.read(br, !0),
                                        ()=>_t(br)
                                    }(ur),
                                    es.hasAnimatedSinceResize && (es.hasAnimatedSinceResize = !1,
                                    this.nodes.forEach(uu))
                                }
                                )
                            }
                            Jt && this.root.registerSharedNode(Jt, this),
                            this.options.animate !== !1 && sr && (Jt || nr) && this.addEventListener("didUpdate", ({delta: or, hasLayoutChanged: ur, hasRelativeTargetChanged: yr, layout: mr})=>{
                                if (this.isTreeAnimationBlocked())
                                    return this.target = void 0,
                                    void (this.relativeTarget = void 0);
                                const Ar = this.options.transition || sr.getDefaultTransition() || Dp
                                  , {onLayoutAnimationStart: br, onLayoutAnimationComplete: Rr} = sr.getProps()
                                  , _r = !this.targetLayout || !iu(this.targetLayout, mr) || yr
                                  , Sr = !ur && yr;
                                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || Sr || ur && (_r || !this.currentAnimation)) {
                                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                                    this.resumingFrom.resumingFrom = void 0),
                                    this.setAnimationOrigin(or, Sr);
                                    const Vr = {
                                        ...Ms(Ar, "layout"),
                                        onPlay: br,
                                        onComplete: Rr
                                    };
                                    (sr.shouldReduceMotion || this.options.layoutRoot) && (Vr.delay = 0,
                                    Vr.type = !1),
                                    this.startAnimation(Vr)
                                } else
                                    ur || uu(this),
                                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                                this.targetLayout = mr
                            }
                            )
                        }
                        unmount() {
                            this.options.layoutId && this.willUpdate(),
                            this.root.nodes.remove(this);
                            const Ot = this.getStack();
                            Ot && Ot.remove(this),
                            this.parent && this.parent.children.delete(this),
                            this.instance = void 0,
                            _t(this.updateProjection)
                        }
                        blockUpdate() {
                            this.updateManuallyBlocked = !0
                        }
                        unblockUpdate() {
                            this.updateManuallyBlocked = !1
                        }
                        isUpdateBlocked() {
                            return this.updateManuallyBlocked || this.updateBlockedByResize
                        }
                        isTreeAnimationBlocked() {
                            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
                        }
                        startUpdate() {
                            this.isUpdateBlocked() || (this.isUpdating = !0,
                            this.nodes && this.nodes.forEach($p),
                            this.animationId++)
                        }
                        getTransformTemplate() {
                            const {visualElement: Ot} = this.options;
                            return Ot && Ot.getProps().transformTemplate
                        }
                        willUpdate(Ot=!0) {
                            if (this.root.hasTreeAnimated = !0,
                            this.root.isUpdateBlocked())
                                return void (this.options.onExitComplete && this.options.onExitComplete());
                            if (!this.root.isUpdating && this.root.startUpdate(),
                            this.isLayoutDirty)
                                return;
                            this.isLayoutDirty = !0;
                            for (let nr = 0; nr < this.path.length; nr++) {
                                const sr = this.path[nr];
                                sr.shouldResetTransform = !0,
                                sr.updateScroll("snapshot"),
                                sr.options.layoutRoot && sr.willUpdate(!1)
                            }
                            const {layoutId: Yt, layout: Zt} = this.options;
                            if (Yt === void 0 && !Zt)
                                return;
                            const Jt = this.getTransformTemplate();
                            this.prevTransformTemplateValue = Jt ? Jt(this.latestValues, "") : void 0,
                            this.updateSnapshot(),
                            Ot && this.notifyListeners("willUpdate")
                        }
                        update() {
                            if (this.updateScheduled = !1,
                            this.isUpdateBlocked())
                                return this.unblockUpdate(),
                                this.clearAllSnapshots(),
                                void this.nodes.forEach(cu);
                            this.isUpdating || this.nodes.forEach(Ap),
                            this.isUpdating = !1,
                            this.nodes.forEach(Mp),
                            this.nodes.forEach(_p),
                            this.nodes.forEach(Ep),
                            this.clearAllSnapshots();
                            const Ot = performance.now();
                            Pt.delta = St(0, 1e3 / 60, Ot - Pt.timestamp),
                            Pt.timestamp = Ot,
                            Pt.isProcessing = !0,
                            kt.update.process(Pt),
                            kt.preRender.process(Pt),
                            kt.render.process(Pt),
                            Pt.isProcessing = !1
                        }
                        didUpdate() {
                            this.updateScheduled || (this.updateScheduled = !0,
                            queueMicrotask(()=>this.update()))
                        }
                        clearAllSnapshots() {
                            this.nodes.forEach(kp),
                            this.sharedNodes.forEach(Rp)
                        }
                        scheduleUpdateProjection() {
                            vt.preRender(this.updateProjection, !1, !0)
                        }
                        scheduleCheckAfterUnmount() {
                            vt.postRender(()=>{
                                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
                            }
                            )
                        }
                        updateSnapshot() {
                            !this.snapshot && this.instance && (this.snapshot = this.measure())
                        }
                        updateLayout() {
                            if (!this.instance || (this.updateScroll(),
                            !(this.options.alwaysMeasureLayout && this.isLead() || this.isLayoutDirty)))
                                return;
                            if (this.resumeFrom && !this.resumeFrom.instance)
                                for (let Zt = 0; Zt < this.path.length; Zt++)
                                    this.path[Zt].updateScroll();
                            const Ot = this.layout;
                            this.layout = this.measure(!1),
                            this.layoutCorrected = {
                                x: {
                                    min: 0,
                                    max: 0
                                },
                                y: {
                                    min: 0,
                                    max: 0
                                }
                            },
                            this.isLayoutDirty = !1,
                            this.projectionDelta = void 0,
                            this.notifyListeners("measure", this.layout.layoutBox);
                            const {visualElement: Yt} = this.options;
                            Yt && Yt.notify("LayoutMeasure", this.layout.layoutBox, Ot ? Ot.layoutBox : void 0)
                        }
                        updateScroll(Ot="measure") {
                            let Yt = !!(this.options.layoutScroll && this.instance);
                            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === Ot && (Yt = !1),
                            Yt && (this.scroll = {
                                animationId: this.root.animationId,
                                phase: Ot,
                                isRoot: Bt(this.instance),
                                offset: Tt(this.instance)
                            })
                        }
                        resetTransform() {
                            if (!Nt)
                                return;
                            const Ot = this.isLayoutDirty || this.shouldResetTransform
                              , Yt = this.projectionDelta && !nu(this.projectionDelta)
                              , Zt = this.getTransformTemplate()
                              , Jt = Zt ? Zt(this.latestValues, "") : void 0
                              , nr = Jt !== this.prevTransformTemplateValue;
                            Ot && (Yt || _o(this.latestValues) || nr) && (Nt(this.instance, Jt),
                            this.shouldResetTransform = !1,
                            this.scheduleRender())
                        }
                        measure(Ot=!0) {
                            const Yt = this.measurePageBox();
                            let Zt = this.removeElementScroll(Yt);
                            var Jt;
                            return Ot && (Zt = this.removeTransform(Zt)),
                            mu((Jt = Zt).x),
                            mu(Jt.y),
                            {
                                animationId: this.root.animationId,
                                measuredBox: Yt,
                                layoutBox: Zt,
                                latestValues: {},
                                source: this.id
                            }
                        }
                        measurePageBox() {
                            const {visualElement: Ot} = this.options;
                            if (!Ot)
                                return {
                                    x: {
                                        min: 0,
                                        max: 0
                                    },
                                    y: {
                                        min: 0,
                                        max: 0
                                    }
                                };
                            const Yt = Ot.measureViewportBox()
                              , {scroll: Zt} = this.root;
                            return Zt && (xo(Yt.x, Zt.offset.x),
                            xo(Yt.y, Zt.offset.y)),
                            Yt
                        }
                        removeElementScroll(Ot) {
                            const Yt = {
                                x: {
                                    min: 0,
                                    max: 0
                                },
                                y: {
                                    min: 0,
                                    max: 0
                                }
                            };
                            fo(Yt, Ot);
                            for (let Zt = 0; Zt < this.path.length; Zt++) {
                                const Jt = this.path[Zt]
                                  , {scroll: nr, options: sr} = Jt;
                                if (Jt !== this.root && nr && sr.layoutScroll) {
                                    if (nr.isRoot) {
                                        fo(Yt, Ot);
                                        const {scroll: or} = this.root;
                                        or && (xo(Yt.x, -or.offset.x),
                                        xo(Yt.y, -or.offset.y))
                                    }
                                    xo(Yt.x, nr.offset.x),
                                    xo(Yt.y, nr.offset.y)
                                }
                            }
                            return Yt
                        }
                        applyTransform(Ot, Yt=!1) {
                            const Zt = {
                                x: {
                                    min: 0,
                                    max: 0
                                },
                                y: {
                                    min: 0,
                                    max: 0
                                }
                            };
                            fo(Zt, Ot);
                            for (let Jt = 0; Jt < this.path.length; Jt++) {
                                const nr = this.path[Jt];
                                !Yt && nr.options.layoutScroll && nr.scroll && nr !== nr.root && Io(Zt, {
                                    x: -nr.scroll.offset.x,
                                    y: -nr.scroll.offset.y
                                }),
                                _o(nr.latestValues) && Io(Zt, nr.latestValues)
                            }
                            return _o(this.latestValues) && Io(Zt, this.latestValues),
                            Zt
                        }
                        removeTransform(Ot) {
                            const Yt = {
                                x: {
                                    min: 0,
                                    max: 0
                                },
                                y: {
                                    min: 0,
                                    max: 0
                                }
                            };
                            fo(Yt, Ot);
                            for (let Zt = 0; Zt < this.path.length; Zt++) {
                                const Jt = this.path[Zt];
                                if (!Jt.instance || !_o(Jt.latestValues))
                                    continue;
                                Cs(Jt.latestValues) && Jt.updateSnapshot();
                                const nr = {
                                    x: {
                                        min: 0,
                                        max: 0
                                    },
                                    y: {
                                        min: 0,
                                        max: 0
                                    }
                                };
                                fo(nr, Jt.measurePageBox()),
                                eu(Yt, Jt.latestValues, Jt.snapshot ? Jt.snapshot.layoutBox : void 0, nr)
                            }
                            return _o(this.latestValues) && eu(Yt, this.latestValues),
                            Yt
                        }
                        setTargetDelta(Ot) {
                            this.targetDelta = Ot,
                            this.root.scheduleUpdateProjection(),
                            this.isProjectionDirty = !0
                        }
                        setOptions(Ot) {
                            this.options = {
                                ...this.options,
                                ...Ot,
                                crossfade: Ot.crossfade === void 0 || Ot.crossfade
                            }
                        }
                        clearMeasurements() {
                            this.scroll = void 0,
                            this.layout = void 0,
                            this.snapshot = void 0,
                            this.prevTransformTemplateValue = void 0,
                            this.targetDelta = void 0,
                            this.target = void 0,
                            this.isLayoutDirty = !1
                        }
                        forceRelativeParentToResolveTarget() {
                            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Pt.timestamp && this.relativeParent.resolveTargetDelta(!0)
                        }
                        resolveTargetDelta(Ot=!1) {
                            var Yt;
                            const Zt = this.getLead();
                            this.isProjectionDirty || (this.isProjectionDirty = Zt.isProjectionDirty),
                            this.isTransformDirty || (this.isTransformDirty = Zt.isTransformDirty),
                            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = Zt.isSharedProjectionDirty);
                            const Jt = !!this.resumingFrom || this !== Zt;
                            if (!(Ot || Jt && this.isSharedProjectionDirty || this.isProjectionDirty || !((Yt = this.parent) === null || Yt === void 0) && Yt.isProjectionDirty || this.attemptToResolveRelativeTarget))
                                return;
                            const {layout: nr, layoutId: sr} = this.options;
                            if (this.layout && (nr || sr)) {
                                if (this.resolvedRelativeTargetAt = Pt.timestamp,
                                !this.targetDelta && !this.relativeTarget) {
                                    const mr = this.getClosestProjectingParent();
                                    mr && mr.layout && this.animationProgress !== 1 ? (this.relativeParent = mr,
                                    this.forceRelativeParentToResolveTarget(),
                                    this.relativeTarget = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    },
                                    this.relativeTargetOrigin = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    },
                                    Fo(this.relativeTargetOrigin, this.layout.layoutBox, mr.layout.layoutBox),
                                    fo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                                }
                                if (this.relativeTarget || this.targetDelta) {
                                    var or, ur, yr;
                                    if (this.target || (this.target = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    },
                                    this.targetWithTransforms = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    }),
                                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                                    or = this.target,
                                    ur = this.relativeTarget,
                                    yr = this.relativeParent.target,
                                    Tl(or.x, ur.x, yr.x),
                                    Tl(or.y, ur.y, yr.y)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : fo(this.target, this.layout.layoutBox),
                                    Ol(this.target, this.targetDelta)) : fo(this.target, this.layout.layoutBox),
                                    this.attemptToResolveRelativeTarget) {
                                        this.attemptToResolveRelativeTarget = !1;
                                        const mr = this.getClosestProjectingParent();
                                        mr && !!mr.resumingFrom == !!this.resumingFrom && !mr.options.layoutScroll && mr.target && this.animationProgress !== 1 ? (this.relativeParent = mr,
                                        this.forceRelativeParentToResolveTarget(),
                                        this.relativeTarget = {
                                            x: {
                                                min: 0,
                                                max: 0
                                            },
                                            y: {
                                                min: 0,
                                                max: 0
                                            }
                                        },
                                        this.relativeTargetOrigin = {
                                            x: {
                                                min: 0,
                                                max: 0
                                            },
                                            y: {
                                                min: 0,
                                                max: 0
                                            }
                                        },
                                        Fo(this.relativeTargetOrigin, this.target, mr.target),
                                        fo(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                                    }
                                    Eo.resolvedTargetDeltas++
                                }
                            }
                        }
                        getClosestProjectingParent() {
                            if (this.parent && !Cs(this.parent.latestValues) && !Rl(this.parent.latestValues))
                                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
                        }
                        isProjecting() {
                            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
                        }
                        calcProjection() {
                            var Ot;
                            const Yt = this.getLead()
                              , Zt = !!this.resumingFrom || this !== Yt;
                            let Jt = !0;
                            if ((this.isProjectionDirty || !((Ot = this.parent) === null || Ot === void 0) && Ot.isProjectionDirty) && (Jt = !1),
                            Zt && (this.isSharedProjectionDirty || this.isTransformDirty) && (Jt = !1),
                            this.resolvedRelativeTargetAt === Pt.timestamp && (Jt = !1),
                            Jt)
                                return;
                            const {layout: nr, layoutId: sr} = this.options;
                            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
                            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
                            !this.layout || !nr && !sr)
                                return;
                            fo(this.layoutCorrected, this.layout.layoutBox);
                            const or = this.treeScale.x
                              , ur = this.treeScale.y;
                            (function(Ar, br, Rr, _r=!1) {
                                const Sr = Rr.length;
                                if (!Sr)
                                    return;
                                let Vr, qr;
                                br.x = br.y = 1;
                                for (let an = 0; an < Sr; an++) {
                                    Vr = Rr[an],
                                    qr = Vr.projectionDelta;
                                    const Wr = Vr.instance;
                                    Wr && Wr.style && Wr.style.display === "contents" || (_r && Vr.options.layoutScroll && Vr.scroll && Vr !== Vr.root && Io(Ar, {
                                        x: -Vr.scroll.offset.x,
                                        y: -Vr.scroll.offset.y
                                    }),
                                    qr && (br.x *= qr.x.scale,
                                    br.y *= qr.y.scale,
                                    Ol(Ar, qr)),
                                    _r && _o(Vr.latestValues) && Io(Ar, Vr.latestValues))
                                }
                                br.x = Fl(br.x),
                                br.y = Fl(br.y)
                            }
                            )(this.layoutCorrected, this.treeScale, this.path, Zt),
                            !Yt.layout || Yt.target || this.treeScale.x === 1 && this.treeScale.y === 1 || (Yt.target = Yt.layout.layoutBox);
                            const {target: yr} = Yt;
                            if (!yr)
                                return void (this.projectionTransform && (this.projectionDelta = {
                                    x: {
                                        translate: 0,
                                        scale: 1,
                                        origin: 0,
                                        originPoint: 0
                                    },
                                    y: {
                                        translate: 0,
                                        scale: 1,
                                        origin: 0,
                                        originPoint: 0
                                    }
                                },
                                this.projectionTransform = "none",
                                this.scheduleRender()));
                            this.projectionDelta || (this.projectionDelta = {
                                x: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                },
                                y: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                }
                            },
                            this.projectionDeltaWithTransform = {
                                x: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                },
                                y: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                }
                            });
                            const mr = this.projectionTransform;
                            Oo(this.projectionDelta, this.layoutCorrected, yr, this.latestValues),
                            this.projectionTransform = su(this.projectionDelta, this.treeScale),
                            this.projectionTransform === mr && this.treeScale.x === or && this.treeScale.y === ur || (this.hasProjected = !0,
                            this.scheduleRender(),
                            this.notifyListeners("projectionUpdate", yr)),
                            Eo.recalculatedProjection++
                        }
                        hide() {
                            this.isVisible = !1
                        }
                        show() {
                            this.isVisible = !0
                        }
                        scheduleRender(Ot=!0) {
                            if (this.options.scheduleRender && this.options.scheduleRender(),
                            Ot) {
                                const Yt = this.getStack();
                                Yt && Yt.scheduleRender()
                            }
                            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
                        }
                        setAnimationOrigin(Ot, Yt=!1) {
                            const Zt = this.snapshot
                              , Jt = Zt ? Zt.latestValues : {}
                              , nr = {
                                ...this.latestValues
                            }
                              , sr = {
                                x: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                },
                                y: {
                                    translate: 0,
                                    scale: 1,
                                    origin: 0,
                                    originPoint: 0
                                }
                            };
                            this.relativeParent && this.relativeParent.options.layoutRoot || (this.relativeTarget = this.relativeTargetOrigin = void 0),
                            this.attemptToResolveRelativeTarget = !Yt;
                            const or = {
                                x: {
                                    min: 0,
                                    max: 0
                                },
                                y: {
                                    min: 0,
                                    max: 0
                                }
                            }
                              , ur = (Zt ? Zt.source : void 0) !== (this.layout ? this.layout.source : void 0)
                              , yr = this.getStack()
                              , mr = !yr || yr.members.length <= 1
                              , Ar = !!(ur && !mr && this.options.crossfade === !0 && !this.path.some(Lp));
                            let br;
                            this.animationProgress = 0,
                            this.mixTargetDelta = Rr=>{
                                const _r = Rr / 1e3;
                                var Sr, Vr, qr, an, Wr, un;
                                du(sr.x, Ot.x, _r),
                                du(sr.y, Ot.y, _r),
                                this.setTargetDelta(sr),
                                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Fo(or, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                                qr = this.relativeTarget,
                                an = this.relativeTargetOrigin,
                                Wr = or,
                                un = _r,
                                fu(qr.x, an.x, Wr.x, un),
                                fu(qr.y, an.y, Wr.y, un),
                                br && (Sr = this.relativeTarget,
                                Vr = br,
                                Sr.x.min === Vr.x.min && Sr.x.max === Vr.x.max && Sr.y.min === Vr.y.min && Sr.y.max === Vr.y.max) && (this.isProjectionDirty = !1),
                                br || (br = {
                                    x: {
                                        min: 0,
                                        max: 0
                                    },
                                    y: {
                                        min: 0,
                                        max: 0
                                    }
                                }),
                                fo(br, this.relativeTarget)),
                                ur && (this.animationValues = nr,
                                function($n, Yn, _i, Tn, ro, kn) {
                                    ro ? ($n.opacity = Jr(0, _i.opacity !== void 0 ? _i.opacity : 1, gp(Tn)),
                                    $n.opacityExit = Jr(Yn.opacity !== void 0 ? Yn.opacity : 1, 0, yp(Tn))) : kn && ($n.opacity = Jr(Yn.opacity !== void 0 ? Yn.opacity : 1, _i.opacity !== void 0 ? _i.opacity : 1, Tn));
                                    for (let xn = 0; xn < mp; xn++) {
                                        const hn = `border${Hl[xn]}Radius`;
                                        let An = Yl(Yn, hn)
                                          , Vn = Yl(_i, hn);
                                        An === void 0 && Vn === void 0 || (An || (An = 0),
                                        Vn || (Vn = 0),
                                        An === 0 || Vn === 0 || Kl(An) === Kl(Vn) ? ($n[hn] = Math.max(Jr(Gl(An), Gl(Vn), Tn), 0),
                                        (lr.test(Vn) || lr.test(An)) && ($n[hn] += "%")) : $n[hn] = Vn)
                                    }
                                    (Yn.rotate || _i.rotate) && ($n.rotate = Jr(Yn.rotate || 0, _i.rotate || 0, Tn))
                                }(nr, Jt, this.latestValues, _r, Ar, mr)),
                                this.root.scheduleUpdateProjection(),
                                this.scheduleRender(),
                                this.animationProgress = _r
                            }
                            ,
                            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
                        }
                        startAnimation(Ot) {
                            this.notifyListeners("animationStart"),
                            this.currentAnimation && this.currentAnimation.stop(),
                            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
                            this.pendingAnimation && (_t(this.pendingAnimation),
                            this.pendingAnimation = void 0),
                            this.pendingAnimation = vt.update(()=>{
                                es.hasAnimatedSinceResize = !0,
                                this.currentAnimation = function(Yt, Zt, Jt) {
                                    const nr = co(0) ? 0 : Wt(0);
                                    return nr.start(os("", nr, 1e3, Jt)),
                                    nr.animation
                                }(0, 0, {
                                    ...Ot,
                                    onUpdate: Yt=>{
                                        this.mixTargetDelta(Yt),
                                        Ot.onUpdate && Ot.onUpdate(Yt)
                                    }
                                    ,
                                    onComplete: ()=>{
                                        Ot.onComplete && Ot.onComplete(),
                                        this.completeAnimation()
                                    }
                                }),
                                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                                this.pendingAnimation = void 0
                            }
                            )
                        }
                        completeAnimation() {
                            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
                            this.resumingFrom.preserveOpacity = void 0);
                            const Ot = this.getStack();
                            Ot && Ot.exitAnimationComplete(),
                            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
                            this.notifyListeners("animationComplete")
                        }
                        finishAnimation() {
                            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(1e3),
                            this.currentAnimation.stop()),
                            this.completeAnimation()
                        }
                        applyTransformsToTarget() {
                            const Ot = this.getLead();
                            let {targetWithTransforms: Yt, target: Zt, layout: Jt, latestValues: nr} = Ot;
                            if (Yt && Zt && Jt) {
                                if (this !== Ot && this.layout && Jt && gu(this.options.animationType, this.layout.layoutBox, Jt.layoutBox)) {
                                    Zt = this.target || {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    };
                                    const sr = uo(this.layout.layoutBox.x);
                                    Zt.x.min = Ot.target.x.min,
                                    Zt.x.max = Zt.x.min + sr;
                                    const or = uo(this.layout.layoutBox.y);
                                    Zt.y.min = Ot.target.y.min,
                                    Zt.y.max = Zt.y.min + or
                                }
                                fo(Yt, Zt),
                                Io(Yt, nr),
                                Oo(this.projectionDeltaWithTransform, this.layoutCorrected, Yt, nr)
                            }
                        }
                        registerSharedNode(Ot, Yt) {
                            this.sharedNodes.has(Ot) || this.sharedNodes.set(Ot, new wp),
                            this.sharedNodes.get(Ot).add(Yt);
                            const Zt = Yt.options.initialPromotionConfig;
                            Yt.promote({
                                transition: Zt ? Zt.transition : void 0,
                                preserveFollowOpacity: Zt && Zt.shouldPreserveFollowOpacity ? Zt.shouldPreserveFollowOpacity(Yt) : void 0
                            })
                        }
                        isLead() {
                            const Ot = this.getStack();
                            return !Ot || Ot.lead === this
                        }
                        getLead() {
                            var Ot;
                            const {layoutId: Yt} = this.options;
                            return Yt && ((Ot = this.getStack()) === null || Ot === void 0 ? void 0 : Ot.lead) || this
                        }
                        getPrevLead() {
                            var Ot;
                            const {layoutId: Yt} = this.options;
                            return Yt ? (Ot = this.getStack()) === null || Ot === void 0 ? void 0 : Ot.prevLead : void 0
                        }
                        getStack() {
                            const {layoutId: Ot} = this.options;
                            if (Ot)
                                return this.root.sharedNodes.get(Ot)
                        }
                        promote({needsReset: Ot, transition: Yt, preserveFollowOpacity: Zt}={}) {
                            const Jt = this.getStack();
                            Jt && Jt.promote(this, Zt),
                            Ot && (this.projectionDelta = void 0,
                            this.needsReset = !0),
                            Yt && this.setOptions({
                                transition: Yt
                            })
                        }
                        relegate() {
                            const Ot = this.getStack();
                            return !!Ot && Ot.relegate(this)
                        }
                        resetRotation() {
                            const {visualElement: Ot} = this.options;
                            if (!Ot)
                                return;
                            let Yt = !1;
                            const {latestValues: Zt} = Ot;
                            if ((Zt.rotate || Zt.rotateX || Zt.rotateY || Zt.rotateZ) && (Yt = !0),
                            !Yt)
                                return;
                            const Jt = {};
                            for (let nr = 0; nr < au.length; nr++) {
                                const sr = "rotate" + au[nr];
                                Zt[sr] && (Jt[sr] = Zt[sr],
                                Ot.setStaticValue(sr, 0))
                            }
                            Ot.render();
                            for (const nr in Jt)
                                Ot.setStaticValue(nr, Jt[nr]);
                            Ot.scheduleRender()
                        }
                        getProjectionStyles(Ot={}) {
                            var Yt, Zt;
                            const Jt = {};
                            if (!this.instance || this.isSVG)
                                return Jt;
                            if (!this.isVisible)
                                return {
                                    visibility: "hidden"
                                };
                            Jt.visibility = "";
                            const nr = this.getTransformTemplate();
                            if (this.needsReset)
                                return this.needsReset = !1,
                                Jt.opacity = "",
                                Jt.pointerEvents = Xo(Ot.pointerEvents) || "",
                                Jt.transform = nr ? nr(this.latestValues, "") : "none",
                                Jt;
                            const sr = this.getLead();
                            if (!this.projectionDelta || !this.layout || !sr.target) {
                                const mr = {};
                                return this.options.layoutId && (mr.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                                mr.pointerEvents = Xo(Ot.pointerEvents) || ""),
                                this.hasProjected && !_o(this.latestValues) && (mr.transform = nr ? nr({}, "") : "none",
                                this.hasProjected = !1),
                                mr
                            }
                            const or = sr.animationValues || sr.latestValues;
                            this.applyTransformsToTarget(),
                            Jt.transform = su(this.projectionDeltaWithTransform, this.treeScale, or),
                            nr && (Jt.transform = nr(or, Jt.transform));
                            const {x: ur, y: yr} = this.projectionDelta;
                            Jt.transformOrigin = `${100 * ur.origin}% ${100 * yr.origin}% 0`,
                            sr.animationValues ? Jt.opacity = sr === this ? (Zt = (Yt = or.opacity) !== null && Yt !== void 0 ? Yt : this.latestValues.opacity) !== null && Zt !== void 0 ? Zt : 1 : this.preserveOpacity ? this.latestValues.opacity : or.opacityExit : Jt.opacity = sr === this ? or.opacity !== void 0 ? or.opacity : "" : or.opacityExit !== void 0 ? or.opacityExit : 0;
                            for (const mr in Ko) {
                                if (or[mr] === void 0)
                                    continue;
                                const {correct: Ar, applyTo: br} = Ko[mr]
                                  , Rr = Jt.transform === "none" ? or[mr] : Ar(or[mr], sr);
                                if (br) {
                                    const _r = br.length;
                                    for (let Sr = 0; Sr < _r; Sr++)
                                        Jt[br[Sr]] = Rr
                                } else
                                    Jt[mr] = Rr
                            }
                            return this.options.layoutId && (Jt.pointerEvents = sr === this ? Xo(Ot.pointerEvents) || "" : "none"),
                            Jt
                        }
                        clearSnapshot() {
                            this.resumeFrom = this.snapshot = void 0
                        }
                        resetTree() {
                            this.root.nodes.forEach(Ot=>{
                                var Yt;
                                return (Yt = Ot.currentAnimation) === null || Yt === void 0 ? void 0 : Yt.stop()
                            }
                            ),
                            this.root.nodes.forEach(cu),
                            this.root.sharedNodes.clear()
                        }
                    }
                }
                function _p(mt) {
                    mt.updateLayout()
                }
                function Ep(mt) {
                    var gt;
                    const Tt = ((gt = mt.resumeFrom) === null || gt === void 0 ? void 0 : gt.snapshot) || mt.snapshot;
                    if (mt.isLead() && mt.layout && Tt && mt.hasListeners("didUpdate")) {
                        const {layoutBox: Bt, measuredBox: Nt} = mt.layout
                          , {animationType: Ot} = mt.options
                          , Yt = Tt.source !== mt.layout.source;
                        Ot === "size" ? go(or=>{
                            const ur = Yt ? Tt.measuredBox[or] : Tt.layoutBox[or]
                              , yr = uo(ur);
                            ur.min = Bt[or].min,
                            ur.max = ur.min + yr
                        }
                        ) : gu(Ot, Tt.layoutBox, Bt) && go(or=>{
                            const ur = Yt ? Tt.measuredBox[or] : Tt.layoutBox[or]
                              , yr = uo(Bt[or]);
                            ur.max = ur.min + yr,
                            mt.relativeTarget && !mt.currentAnimation && (mt.isProjectionDirty = !0,
                            mt.relativeTarget[or].max = mt.relativeTarget[or].min + yr)
                        }
                        );
                        const Zt = {
                            x: {
                                translate: 0,
                                scale: 1,
                                origin: 0,
                                originPoint: 0
                            },
                            y: {
                                translate: 0,
                                scale: 1,
                                origin: 0,
                                originPoint: 0
                            }
                        };
                        Oo(Zt, Bt, Tt.layoutBox);
                        const Jt = {
                            x: {
                                translate: 0,
                                scale: 1,
                                origin: 0,
                                originPoint: 0
                            },
                            y: {
                                translate: 0,
                                scale: 1,
                                origin: 0,
                                originPoint: 0
                            }
                        };
                        Yt ? Oo(Jt, mt.applyTransform(Nt, !0), Tt.measuredBox) : Oo(Jt, Bt, Tt.layoutBox);
                        const nr = !nu(Zt);
                        let sr = !1;
                        if (!mt.resumeFrom) {
                            const or = mt.getClosestProjectingParent();
                            if (or && !or.resumeFrom) {
                                const {snapshot: ur, layout: yr} = or;
                                if (ur && yr) {
                                    const mr = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    };
                                    Fo(mr, Tt.layoutBox, ur.layoutBox);
                                    const Ar = {
                                        x: {
                                            min: 0,
                                            max: 0
                                        },
                                        y: {
                                            min: 0,
                                            max: 0
                                        }
                                    };
                                    Fo(Ar, Bt, yr.layoutBox),
                                    iu(mr, Ar) || (sr = !0),
                                    or.options.layoutRoot && (mt.relativeTarget = Ar,
                                    mt.relativeTargetOrigin = mr,
                                    mt.relativeParent = or)
                                }
                            }
                        }
                        mt.notifyListeners("didUpdate", {
                            layout: Bt,
                            snapshot: Tt,
                            delta: Jt,
                            layoutDelta: Zt,
                            hasLayoutChanged: nr,
                            hasRelativeTargetChanged: sr
                        })
                    } else if (mt.isLead()) {
                        const {onExitComplete: Bt} = mt.options;
                        Bt && Bt()
                    }
                    mt.options.transition = void 0
                }
                function Tp(mt) {
                    Eo.totalNodes++,
                    mt.parent && (mt.isProjecting() || (mt.isProjectionDirty = mt.parent.isProjectionDirty),
                    mt.isSharedProjectionDirty || (mt.isSharedProjectionDirty = !!(mt.isProjectionDirty || mt.parent.isProjectionDirty || mt.parent.isSharedProjectionDirty)),
                    mt.isTransformDirty || (mt.isTransformDirty = mt.parent.isTransformDirty))
                }
                function Pp(mt) {
                    mt.isProjectionDirty = mt.isSharedProjectionDirty = mt.isTransformDirty = !1
                }
                function kp(mt) {
                    mt.clearSnapshot()
                }
                function cu(mt) {
                    mt.clearMeasurements()
                }
                function Ap(mt) {
                    mt.isLayoutDirty = !1
                }
                function Mp(mt) {
                    const {visualElement: gt} = mt.options;
                    gt && gt.getProps().onBeforeLayoutMeasure && gt.notify("BeforeLayoutMeasure"),
                    mt.resetTransform()
                }
                function uu(mt) {
                    mt.finishAnimation(),
                    mt.targetDelta = mt.relativeTarget = mt.target = void 0,
                    mt.isProjectionDirty = !0
                }
                function Ip(mt) {
                    mt.resolveTargetDelta()
                }
                function Bp(mt) {
                    mt.calcProjection()
                }
                function $p(mt) {
                    mt.resetRotation()
                }
                function Rp(mt) {
                    mt.removeLeadSnapshot()
                }
                function du(mt, gt, Tt) {
                    mt.translate = Jr(gt.translate, 0, Tt),
                    mt.scale = Jr(gt.scale, 1, Tt),
                    mt.origin = gt.origin,
                    mt.originPoint = gt.originPoint
                }
                function fu(mt, gt, Tt, Bt) {
                    mt.min = Jr(gt.min, Tt.min, Bt),
                    mt.max = Jr(gt.max, Tt.max, Bt)
                }
                function Lp(mt) {
                    return mt.animationValues && mt.animationValues.opacityExit !== void 0
                }
                const Dp = {
                    duration: .45,
                    ease: [.4, 0, .1, 1]
                }
                  , hu = mt=>typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(mt)
                  , pu = hu("applewebkit/") && !hu("chrome/") ? Math.round : it;
                function mu(mt) {
                    mt.min = pu(mt.min),
                    mt.max = pu(mt.max)
                }
                function gu(mt, gt, Tt) {
                    return mt === "position" || mt === "preserve-aspect" && !ws(ou(gt), ou(Tt), .2)
                }
                const Op = lu({
                    attachResizeListener: (mt,gt)=>yo(mt, "resize", gt),
                    measureScroll: ()=>({
                        x: document.documentElement.scrollLeft || document.body.scrollLeft,
                        y: document.documentElement.scrollTop || document.body.scrollTop
                    }),
                    checkIsScrollRoot: ()=>!0
                })
                  , Es = {
                    current: void 0
                }
                  , yu = lu({
                    measureScroll: mt=>({
                        x: mt.scrollLeft,
                        y: mt.scrollTop
                    }),
                    defaultParent: ()=>{
                        if (!Es.current) {
                            const mt = new Op({});
                            mt.mount(window),
                            mt.setOptions({
                                layoutScroll: !0
                            }),
                            Es.current = mt
                        }
                        return Es.current
                    }
                    ,
                    resetTransform: (mt,gt)=>{
                        mt.style.transform = gt !== void 0 ? gt : "none"
                    }
                    ,
                    checkIsScrollRoot: mt=>window.getComputedStyle(mt).position === "fixed"
                })
                  , Fp = {
                    pan: {
                        Feature: class extends wo {
                            constructor() {
                                super(...arguments),
                                this.removePointerDownListener = it
                            }
                            onPointerDown(mt) {
                                this.session = new Sl(mt,this.createPanHandlers(),{
                                    transformPagePoint: this.node.getTransformPagePoint()
                                })
                            }
                            createPanHandlers() {
                                const {onPanSessionStart: mt, onPanStart: gt, onPan: Tt, onPanEnd: Bt} = this.node.getProps();
                                return {
                                    onSessionStart: Ul(mt),
                                    onStart: Ul(gt),
                                    onMove: Tt,
                                    onEnd: (Nt,Ot)=>{
                                        delete this.session,
                                        Bt && vt.update(()=>Bt(Nt, Ot))
                                    }
                                }
                            }
                            mount() {
                                this.removePointerDownListener = vo(this.node.current, "pointerdown", mt=>this.onPointerDown(mt))
                            }
                            update() {
                                this.session && this.session.updateHandlers(this.createPanHandlers())
                            }
                            unmount() {
                                this.removePointerDownListener(),
                                this.session && this.session.end()
                            }
                        }
                    },
                    drag: {
                        Feature: class extends wo {
                            constructor(mt) {
                                super(mt),
                                this.removeGroupControls = it,
                                this.removeListeners = it,
                                this.controls = new dp(mt)
                            }
                            mount() {
                                const {dragControls: mt} = this.node.getProps();
                                mt && (this.removeGroupControls = mt.subscribe(this.controls)),
                                this.removeListeners = this.controls.addListeners() || it
                            }
                            unmount() {
                                this.removeGroupControls(),
                                this.removeListeners()
                            }
                        }
                        ,
                        ProjectionNode: yu,
                        MeasureLayout: Wl
                    }
                }
                  , Vp = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
                function Ts(mt, gt, Tt=1) {
                    const [Bt,Nt] = function(Yt) {
                        const Zt = Vp.exec(Yt);
                        if (!Zt)
                            return [, ];
                        const [,Jt,nr] = Zt;
                        return [Jt, nr]
                    }(mt);
                    if (!Bt)
                        return;
                    const Ot = window.getComputedStyle(gt).getPropertyValue(Bt);
                    if (Ot) {
                        const Yt = Ot.trim();
                        return st(Yt) ? parseFloat(Yt) : Yt
                    }
                    return Vt(Nt) ? Ts(Nt, gt, Tt + 1) : Nt
                }
                const jp = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
                  , vu = mt=>jp.has(mt)
                  , ts = mt=>mt === Lt || mt === ir
                  , bu = (mt,gt)=>parseFloat(mt.split(", ")[gt])
                  , wu = (mt,gt)=>(Tt,{transform: Bt})=>{
                    if (Bt === "none" || !Bt)
                        return 0;
                    const Nt = Bt.match(/^matrix3d\((.+)\)$/);
                    if (Nt)
                        return bu(Nt[1], gt);
                    {
                        const Ot = Bt.match(/^matrix\((.+)\)$/);
                        return Ot ? bu(Ot[1], mt) : 0
                    }
                }
                  , Np = new Set(["x", "y", "z"])
                  , Up = Gn.filter(mt=>!Np.has(mt))
                  , Bo = {
                    width: ({x: mt},{paddingLeft: gt="0", paddingRight: Tt="0"})=>mt.max - mt.min - parseFloat(gt) - parseFloat(Tt),
                    height: ({y: mt},{paddingTop: gt="0", paddingBottom: Tt="0"})=>mt.max - mt.min - parseFloat(gt) - parseFloat(Tt),
                    top: (mt,{top: gt})=>parseFloat(gt),
                    left: (mt,{left: gt})=>parseFloat(gt),
                    bottom: ({y: mt},{top: gt})=>parseFloat(gt) + (mt.max - mt.min),
                    right: ({x: mt},{left: gt})=>parseFloat(gt) + (mt.max - mt.min),
                    x: wu(4, 13),
                    y: wu(5, 14)
                };
                Bo.translateX = Bo.x,
                Bo.translateY = Bo.y;
                function zp(mt, gt, Tt, Bt) {
                    return (Nt=>Object.keys(Nt).some(vu))(gt) ? ((Nt,Ot,Yt={},Zt={})=>{
                        Ot = {
                            ...Ot
                        },
                        Zt = {
                            ...Zt
                        };
                        const Jt = Object.keys(Ot).filter(vu);
                        let nr = []
                          , sr = !1;
                        const or = [];
                        if (Jt.forEach(ur=>{
                            const yr = Nt.getValue(ur);
                            if (!Nt.hasValue(ur))
                                return;
                            let mr = Yt[ur]
                              , Ar = Lr(mr);
                            const br = Ot[ur];
                            let Rr;
                            if (ft(br)) {
                                const _r = br.length
                                  , Sr = br[0] === null ? 1 : 0;
                                mr = br[Sr],
                                Ar = Lr(mr);
                                for (let Vr = Sr; Vr < _r && br[Vr] !== null; Vr++)
                                    Rr ? ot(Lr(br[Vr]) === Rr) : (Rr = Lr(br[Vr]),
                                    ot(Rr === Ar || ts(Ar) && ts(Rr)))
                            } else
                                Rr = Lr(br);
                            if (Ar !== Rr)
                                if (ts(Ar) && ts(Rr)) {
                                    const _r = yr.get();
                                    typeof _r == "string" && yr.set(parseFloat(_r)),
                                    typeof br == "string" ? Ot[ur] = parseFloat(br) : Array.isArray(br) && Rr === ir && (Ot[ur] = br.map(parseFloat))
                                } else
                                    Ar != null && Ar.transform && (Rr != null && Rr.transform) && (mr === 0 || br === 0) ? mr === 0 ? yr.set(Rr.transform(mr)) : Ot[ur] = Ar.transform(br) : (sr || (nr = function(_r) {
                                        const Sr = [];
                                        return Up.forEach(Vr=>{
                                            const qr = _r.getValue(Vr);
                                            qr !== void 0 && (Sr.push([Vr, qr.get()]),
                                            qr.set(Vr.startsWith("scale") ? 1 : 0))
                                        }
                                        ),
                                        Sr.length && _r.render(),
                                        Sr
                                    }(Nt),
                                    sr = !0),
                                    or.push(ur),
                                    Zt[ur] = Zt[ur] !== void 0 ? Zt[ur] : Ot[ur],
                                    yr.jump(br))
                        }
                        ),
                        or.length) {
                            const ur = or.indexOf("height") >= 0 ? window.pageYOffset : null
                              , yr = ((mr,Ar,br)=>{
                                const Rr = Ar.measureViewportBox()
                                  , _r = Ar.current
                                  , Sr = getComputedStyle(_r)
                                  , {display: Vr} = Sr
                                  , qr = {};
                                Vr === "none" && Ar.setStaticValue("display", mr.display || "block"),
                                br.forEach(Wr=>{
                                    qr[Wr] = Bo[Wr](Rr, Sr)
                                }
                                ),
                                Ar.render();
                                const an = Ar.measureViewportBox();
                                return br.forEach(Wr=>{
                                    const un = Ar.getValue(Wr);
                                    un && un.jump(qr[Wr]),
                                    mr[Wr] = Bo[Wr](an, Sr)
                                }
                                ),
                                mr
                            }
                            )(Ot, Nt, or);
                            return nr.length && nr.forEach(([mr,Ar])=>{
                                Nt.getValue(mr).set(Ar)
                            }
                            ),
                            Nt.render(),
                            Wo && ur !== null && window.scrollTo({
                                top: ur
                            }),
                            {
                                target: yr,
                                transitionEnd: Zt
                            }
                        }
                        return {
                            target: Ot,
                            transitionEnd: Zt
                        }
                    }
                    )(mt, gt, Tt, Bt) : {
                        target: gt,
                        transitionEnd: Bt
                    }
                }
                const Ps = {
                    current: null
                }
                  , xu = {
                    current: !1
                }
                  , Su = new WeakMap
                  , Cu = Object.keys(Do)
                  , Wp = Cu.length
                  , _u = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
                  , Hp = cs.length;
                class Eu extends class {
                    constructor({parent: gt, props: Tt, presenceContext: Bt, reducedMotionConfig: Nt, visualState: Ot}, Yt={}) {
                        this.current = null,
                        this.children = new Set,
                        this.isVariantNode = !1,
                        this.isControllingVariants = !1,
                        this.shouldReduceMotion = null,
                        this.values = new Map,
                        this.features = {},
                        this.valueSubscriptions = new Map,
                        this.prevMotionValues = {},
                        this.events = {},
                        this.propEventSubscriptions = {},
                        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
                        this.render = ()=>{
                            this.current && (this.triggerBuild(),
                            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                        }
                        ,
                        this.scheduleRender = ()=>vt.render(this.render, !1, !0);
                        const {latestValues: Zt, renderState: Jt} = Ot;
                        this.latestValues = Zt,
                        this.baseTarget = {
                            ...Zt
                        },
                        this.initialValues = Tt.initial ? {
                            ...Zt
                        } : {},
                        this.renderState = Jt,
                        this.parent = gt,
                        this.props = Tt,
                        this.presenceContext = Bt,
                        this.depth = gt ? gt.depth + 1 : 0,
                        this.reducedMotionConfig = Nt,
                        this.options = Yt,
                        this.isControllingVariants = qo(Tt),
                        this.isVariantNode = Os(Tt),
                        this.isVariantNode && (this.variantChildren = new Set),
                        this.manuallyAnimateOnMount = !!(gt && gt.current);
                        const {willChange: nr, ...sr} = this.scrapeMotionValuesFromProps(Tt, {});
                        for (const or in sr) {
                            const ur = sr[or];
                            Zt[or] !== void 0 && co(ur) && (ur.set(Zt[or], !1),
                            zo(nr) && nr.add(or))
                        }
                    }
                    scrapeMotionValuesFromProps(gt, Tt) {
                        return {}
                    }
                    mount(gt) {
                        this.current = gt,
                        Su.set(gt, this),
                        this.projection && !this.projection.instance && this.projection.mount(gt),
                        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
                        this.values.forEach((Tt,Bt)=>this.bindToMotionValue(Bt, Tt)),
                        xu.current || function() {
                            if (xu.current = !0,
                            Wo)
                                if (window.matchMedia) {
                                    const Tt = window.matchMedia("(prefers-reduced-motion)")
                                      , Bt = ()=>Ps.current = Tt.matches;
                                    Tt.addListener(Bt),
                                    Bt()
                                } else
                                    Ps.current = !1
                        }(),
                        this.shouldReduceMotion = this.reducedMotionConfig !== "never" && (this.reducedMotionConfig === "always" || Ps.current),
                        this.parent && this.parent.children.add(this),
                        this.update(this.props, this.presenceContext)
                    }
                    unmount() {
                        Su.delete(this.current),
                        this.projection && this.projection.unmount(),
                        _t(this.notifyUpdate),
                        _t(this.render),
                        this.valueSubscriptions.forEach(gt=>gt()),
                        this.removeFromVariantTree && this.removeFromVariantTree(),
                        this.parent && this.parent.children.delete(this);
                        for (const gt in this.events)
                            this.events[gt].clear();
                        for (const gt in this.features)
                            this.features[gt].unmount();
                        this.current = null
                    }
                    bindToMotionValue(gt, Tt) {
                        const Bt = Kn.has(gt)
                          , Nt = Tt.on("change", Yt=>{
                            this.latestValues[gt] = Yt,
                            this.props.onUpdate && vt.update(this.notifyUpdate, !1, !0),
                            Bt && this.projection && (this.projection.isTransformDirty = !0)
                        }
                        )
                          , Ot = Tt.on("renderRequest", this.scheduleRender);
                        this.valueSubscriptions.set(gt, ()=>{
                            Nt(),
                            Ot()
                        }
                        )
                    }
                    sortNodePosition(gt) {
                        return this.current && this.sortInstanceNodePosition && this.type === gt.type ? this.sortInstanceNodePosition(this.current, gt.current) : 0
                    }
                    loadFeatures({children: gt, ...Tt}, Bt, Nt, Ot) {
                        let Yt, Zt;
                        for (let Jt = 0; Jt < Wp; Jt++) {
                            const nr = Cu[Jt]
                              , {isEnabled: sr, Feature: or, ProjectionNode: ur, MeasureLayout: yr} = Do[nr];
                            ur && (Yt = ur),
                            sr(Tt) && (!this.features[nr] && or && (this.features[nr] = new or(this)),
                            yr && (Zt = yr))
                        }
                        if (!this.projection && Yt) {
                            this.projection = new Yt(this.latestValues,this.parent && this.parent.projection);
                            const {layoutId: Jt, layout: nr, drag: sr, dragConstraints: or, layoutScroll: ur, layoutRoot: yr} = Tt;
                            this.projection.setOptions({
                                layoutId: Jt,
                                layout: nr,
                                alwaysMeasureLayout: !!sr || or && Mo(or),
                                visualElement: this,
                                scheduleRender: ()=>this.scheduleRender(),
                                animationType: typeof nr == "string" ? nr : "both",
                                initialPromotionConfig: Ot,
                                layoutScroll: ur,
                                layoutRoot: yr
                            })
                        }
                        return Zt
                    }
                    updateFeatures() {
                        for (const gt in this.features) {
                            const Tt = this.features[gt];
                            Tt.isMounted ? Tt.update() : (Tt.mount(),
                            Tt.isMounted = !0)
                        }
                    }
                    triggerBuild() {
                        this.build(this.renderState, this.latestValues, this.options, this.props)
                    }
                    measureViewportBox() {
                        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {
                            x: {
                                min: 0,
                                max: 0
                            },
                            y: {
                                min: 0,
                                max: 0
                            }
                        }
                    }
                    getStaticValue(gt) {
                        return this.latestValues[gt]
                    }
                    setStaticValue(gt, Tt) {
                        this.latestValues[gt] = Tt
                    }
                    makeTargetAnimatable(gt, Tt=!0) {
                        return this.makeTargetAnimatableFromInstance(gt, this.props, Tt)
                    }
                    update(gt, Tt) {
                        (gt.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
                        this.prevProps = this.props,
                        this.props = gt,
                        this.prevPresenceContext = this.presenceContext,
                        this.presenceContext = Tt;
                        for (let Bt = 0; Bt < _u.length; Bt++) {
                            const Nt = _u[Bt];
                            this.propEventSubscriptions[Nt] && (this.propEventSubscriptions[Nt](),
                            delete this.propEventSubscriptions[Nt]);
                            const Ot = gt["on" + Nt];
                            Ot && (this.propEventSubscriptions[Nt] = this.on(Nt, Ot))
                        }
                        this.prevMotionValues = function(Bt, Nt, Ot) {
                            const {willChange: Yt} = Nt;
                            for (const Zt in Nt) {
                                const Jt = Nt[Zt]
                                  , nr = Ot[Zt];
                                if (co(Jt))
                                    Bt.addValue(Zt, Jt),
                                    zo(Yt) && Yt.add(Zt);
                                else if (co(nr))
                                    Bt.addValue(Zt, Wt(Jt, {
                                        owner: Bt
                                    })),
                                    zo(Yt) && Yt.remove(Zt);
                                else if (nr !== Jt)
                                    if (Bt.hasValue(Zt)) {
                                        const sr = Bt.getValue(Zt);
                                        !sr.hasAnimated && sr.set(Jt)
                                    } else {
                                        const sr = Bt.getStaticValue(Zt);
                                        Bt.addValue(Zt, Wt(sr !== void 0 ? sr : Jt, {
                                            owner: Bt
                                        }))
                                    }
                            }
                            for (const Zt in Ot)
                                Nt[Zt] === void 0 && Bt.removeValue(Zt);
                            return Nt
                        }(this, this.scrapeMotionValuesFromProps(gt, this.prevProps), this.prevMotionValues),
                        this.handleChildMotionValue && this.handleChildMotionValue()
                    }
                    getProps() {
                        return this.props
                    }
                    getVariant(gt) {
                        return this.props.variants ? this.props.variants[gt] : void 0
                    }
                    getDefaultTransition() {
                        return this.props.transition
                    }
                    getTransformPagePoint() {
                        return this.props.transformPagePoint
                    }
                    getClosestVariantNode() {
                        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
                    }
                    getVariantContext(gt=!1) {
                        if (gt)
                            return this.parent ? this.parent.getVariantContext() : void 0;
                        if (!this.isControllingVariants) {
                            const Bt = this.parent && this.parent.getVariantContext() || {};
                            return this.props.initial !== void 0 && (Bt.initial = this.props.initial),
                            Bt
                        }
                        const Tt = {};
                        for (let Bt = 0; Bt < Hp; Bt++) {
                            const Nt = cs[Bt]
                              , Ot = this.props[Nt];
                            (Lo(Ot) || Ot === !1) && (Tt[Nt] = Ot)
                        }
                        return Tt
                    }
                    addVariantChild(gt) {
                        const Tt = this.getClosestVariantNode();
                        if (Tt)
                            return Tt.variantChildren && Tt.variantChildren.add(gt),
                            ()=>Tt.variantChildren.delete(gt)
                    }
                    addValue(gt, Tt) {
                        Tt !== this.values.get(gt) && (this.removeValue(gt),
                        this.bindToMotionValue(gt, Tt)),
                        this.values.set(gt, Tt),
                        this.latestValues[gt] = Tt.get()
                    }
                    removeValue(gt) {
                        this.values.delete(gt);
                        const Tt = this.valueSubscriptions.get(gt);
                        Tt && (Tt(),
                        this.valueSubscriptions.delete(gt)),
                        delete this.latestValues[gt],
                        this.removeValueFromRenderState(gt, this.renderState)
                    }
                    hasValue(gt) {
                        return this.values.has(gt)
                    }
                    getValue(gt, Tt) {
                        if (this.props.values && this.props.values[gt])
                            return this.props.values[gt];
                        let Bt = this.values.get(gt);
                        return Bt === void 0 && Tt !== void 0 && (Bt = Wt(Tt, {
                            owner: this
                        }),
                        this.addValue(gt, Bt)),
                        Bt
                    }
                    readValue(gt) {
                        var Tt;
                        return this.latestValues[gt] === void 0 && this.current ? (Tt = this.getBaseTargetFromProps(this.props, gt)) !== null && Tt !== void 0 ? Tt : this.readValueFromInstance(this.current, gt, this.options) : this.latestValues[gt]
                    }
                    setBaseTarget(gt, Tt) {
                        this.baseTarget[gt] = Tt
                    }
                    getBaseTarget(gt) {
                        var Tt;
                        const {initial: Bt} = this.props
                          , Nt = typeof Bt == "string" || typeof Bt == "object" ? (Tt = Fr(this.props, Bt)) === null || Tt === void 0 ? void 0 : Tt[gt] : void 0;
                        if (Bt && Nt !== void 0)
                            return Nt;
                        const Ot = this.getBaseTargetFromProps(this.props, gt);
                        return Ot === void 0 || co(Ot) ? this.initialValues[gt] !== void 0 && Nt === void 0 ? void 0 : this.baseTarget[gt] : Ot
                    }
                    on(gt, Tt) {
                        return this.events[gt] || (this.events[gt] = new lt),
                        this.events[gt].add(Tt)
                    }
                    notify(gt, ...Tt) {
                        this.events[gt] && this.events[gt].notify(...Tt)
                    }
                }
                {
                    sortInstanceNodePosition(gt, Tt) {
                        return 2 & gt.compareDocumentPosition(Tt) ? 1 : -1
                    }
                    getBaseTargetFromProps(gt, Tt) {
                        return gt.style ? gt.style[Tt] : void 0
                    }
                    removeValueFromRenderState(gt, {vars: Tt, style: Bt}) {
                        delete Tt[gt],
                        delete Bt[gt]
                    }
                    makeTargetAnimatableFromInstance({transition: gt, transitionEnd: Tt, ...Bt}, {transformValues: Nt}, Ot) {
                        let Yt = function(Zt, Jt, nr) {
                            const sr = {};
                            for (const or in Zt) {
                                const ur = eo(or, Jt);
                                if (ur !== void 0)
                                    sr[or] = ur;
                                else {
                                    const yr = nr.getValue(or);
                                    yr && (sr[or] = yr.get())
                                }
                            }
                            return sr
                        }(Bt, gt || {}, this);
                        if (Nt && (Tt && (Tt = Nt(Tt)),
                        Bt && (Bt = Nt(Bt)),
                        Yt && (Yt = Nt(Yt))),
                        Ot) {
                            (function(Jt, nr, sr) {
                                var or, ur;
                                const yr = Object.keys(nr).filter(br=>!Jt.hasValue(br))
                                  , mr = yr.length;
                                var Ar;
                                if (mr)
                                    for (let br = 0; br < mr; br++) {
                                        const Rr = yr[br]
                                          , _r = nr[Rr];
                                        let Sr = null;
                                        Array.isArray(_r) && (Sr = _r[0]),
                                        Sr === null && (Sr = (ur = (or = sr[Rr]) !== null && or !== void 0 ? or : Jt.readValue(Rr)) !== null && ur !== void 0 ? ur : nr[Rr]),
                                        Sr != null && (typeof Sr == "string" && (st(Sr) || dt(Sr)) ? Sr = parseFloat(Sr) : (Ar = Sr,
                                        !Kr.find(Ur(Ar)) && er.test(_r) && (Sr = Er(Rr, _r))),
                                        Jt.addValue(Rr, Wt(Sr, {
                                            owner: Jt
                                        })),
                                        sr[Rr] === void 0 && (sr[Rr] = Sr),
                                        Sr !== null && Jt.setBaseTarget(Rr, Sr))
                                    }
                            }
                            )(this, Bt, Yt);
                            const Zt = ((Jt,nr,sr,or)=>{
                                const ur = function(yr, {...mr}, Ar) {
                                    const br = yr.current;
                                    if (!(br instanceof Element))
                                        return {
                                            target: mr,
                                            transitionEnd: Ar
                                        };
                                    Ar && (Ar = {
                                        ...Ar
                                    }),
                                    yr.values.forEach(Rr=>{
                                        const _r = Rr.get();
                                        if (!Vt(_r))
                                            return;
                                        const Sr = Ts(_r, br);
                                        Sr && Rr.set(Sr)
                                    }
                                    );
                                    for (const Rr in mr) {
                                        const _r = mr[Rr];
                                        if (!Vt(_r))
                                            continue;
                                        const Sr = Ts(_r, br);
                                        Sr && (mr[Rr] = Sr,
                                        Ar || (Ar = {}),
                                        Ar[Rr] === void 0 && (Ar[Rr] = _r))
                                    }
                                    return {
                                        target: mr,
                                        transitionEnd: Ar
                                    }
                                }(Jt, nr, or);
                                return zp(Jt, nr = ur.target, sr, or = ur.transitionEnd)
                            }
                            )(this, Bt, Yt, Tt);
                            Tt = Zt.transitionEnd,
                            Bt = Zt.target
                        }
                        return {
                            transition: gt,
                            transitionEnd: Tt,
                            ...Bt
                        }
                    }
                }
                class Gp extends Eu {
                    readValueFromInstance(gt, Tt) {
                        if (Kn.has(Tt)) {
                            const Nt = rr(Tt);
                            return Nt && Nt.default || 0
                        }
                        {
                            const Nt = (Bt = gt,
                            window.getComputedStyle(Bt))
                              , Ot = (Dt(Tt) ? Nt.getPropertyValue(Tt) : Nt[Tt]) || 0;
                            return typeof Ot == "string" ? Ot.trim() : Ot
                        }
                        var Bt
                    }
                    measureInstanceViewportBox(gt, {transformPagePoint: Tt}) {
                        return Nl(gt, Tt)
                    }
                    build(gt, Tt, Bt, Nt) {
                        ds(gt, Tt, Bt, Nt.transformTemplate)
                    }
                    scrapeMotionValuesFromProps(gt, Tt) {
                        return ps(gt, Tt)
                    }
                    handleChildMotionValue() {
                        this.childSubscription && (this.childSubscription(),
                        delete this.childSubscription);
                        const {children: gt} = this.props;
                        co(gt) && (this.childSubscription = gt.on("change", Tt=>{
                            this.current && (this.current.textContent = `${Tt}`)
                        }
                        ))
                    }
                    renderInstance(gt, Tt, Bt, Nt) {
                        qs(gt, Tt, Bt, Nt)
                    }
                }
                class qp extends Eu {
                    constructor() {
                        super(...arguments),
                        this.isSVGTag = !1
                    }
                    getBaseTargetFromProps(gt, Tt) {
                        return gt[Tt]
                    }
                    readValueFromInstance(gt, Tt) {
                        if (Kn.has(Tt)) {
                            const Bt = rr(Tt);
                            return Bt && Bt.default || 0
                        }
                        return Tt = Ks.has(Tt) ? Tt : ho(Tt),
                        gt.getAttribute(Tt)
                    }
                    measureInstanceViewportBox() {
                        return {
                            x: {
                                min: 0,
                                max: 0
                            },
                            y: {
                                min: 0,
                                max: 0
                            }
                        }
                    }
                    scrapeMotionValuesFromProps(gt, Tt) {
                        return Xs(gt, Tt)
                    }
                    build(gt, Tt, Bt, Nt) {
                        fs(gt, Tt, Bt, this.isSVGTag, Nt.transformTemplate)
                    }
                    renderInstance(gt, Tt, Bt, Nt) {
                        Ys(gt, Tt, 0, Nt)
                    }
                    mount(gt) {
                        this.isSVGTag = hs(gt.tagName),
                        super.mount(gt)
                    }
                }
                const Kp = (mt,gt)=>us(mt) ? new qp(gt,{
                    enableHardwareAcceleration: !1
                }) : new Gp(gt,{
                    enableHardwareAcceleration: !0
                })
                  , Yp = {
                    ...op,
                    ...tp,
                    ...Fp,
                    layout: {
                        ProjectionNode: yu,
                        MeasureLayout: Wl
                    }
                }
                  , Xp = Fu((mt,gt)=>function(Tt, {forwardMotionProps: Bt=!1}, Nt, Ot) {
                    return {
                        ...us(Tt) ? Xu : Zu,
                        preloadedFeatures: Nt,
                        useRender: Ku(Bt),
                        createVisualElement: Ot,
                        Component: Tt
                    }
                }(mt, gt, Yp, Kp))
                  , Zp = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
                  , Qp = ({className: mt, animateToNumber: gt, fontStyle: Tt, transitions: Bt, includeComma: Nt, locale: Ot})=>{
                    const Yt = nt().useRef(null)
                      , Zt = function(Rr, {root: _r, margin: Sr, amount: Vr, once: qr=!1}={}) {
                        const [an,Wr] = (0,
                        rt.useState)(!1);
                        return (0,
                        rt.useEffect)(()=>{
                            if (!Rr.current || qr && an)
                                return;
                            const un = {
                                root: _r && _r.current || void 0,
                                margin: Sr,
                                amount: Vr
                            };
                            return function($n, Yn, {root: _i, margin: Tn, amount: ro="some"}={}) {
                                const kn = function(An, Vn, po) {
                                    return typeof An == "string" ? An = document.querySelectorAll(An) : An instanceof Element && (An = [An]),
                                    Array.from(An || [])
                                }($n)
                                  , xn = new WeakMap
                                  , hn = new IntersectionObserver(An=>{
                                    An.forEach(Vn=>{
                                        const po = xn.get(Vn.target);
                                        if (Vn.isIntersecting !== !!po)
                                            if (Vn.isIntersecting) {
                                                const To = Yn(Vn);
                                                typeof To == "function" ? xn.set(Vn.target, To) : hn.unobserve(Vn.target)
                                            } else
                                                po && (po(Vn),
                                                xn.delete(Vn.target))
                                    }
                                    )
                                }
                                ,{
                                    root: _i,
                                    rootMargin: Tn,
                                    threshold: typeof ro == "number" ? ro : at[ro]
                                });
                                return kn.forEach(An=>hn.observe(An)),
                                ()=>hn.disconnect()
                            }(Rr.current, ()=>(Wr(!0),
                            qr ? void 0 : ()=>Wr(!1)), un)
                        }
                        , [_r, Rr, Sr, qr]),
                        an
                    }(Yt, {
                        once: !0
                    })
                      , Jt = function() {
                        const Rr = $s(Ru);
                        return Rs(Rr.mount, []),
                        Rr
                    }()
                      , nr = nt().useRef(0)
                      , sr = Nt ? Math.abs(gt).toLocaleString(Ot || "en-US") : String(Math.abs(gt))
                      , or = Array.from(sr, Number).map((Rr,_r)=>isNaN(Rr) ? sr[_r] : Rr)
                      , [ur,yr] = nt().useState(0)
                      , [mr,Ar] = nt().useState(0)
                      , br = nt().useRef(null);
                    return nt().useEffect(()=>{
                        var Rr;
                        const _r = (Rr = br.current.getClientRects()) === null || Rr === void 0 ? void 0 : Rr[0];
                        _r && (yr(_r.height),
                        Ar(_r.width))
                    }
                    , [gt, Tt]),
                    nt().useEffect(()=>{
                        Zt && Jt.start("visible")
                    }
                    , [Zt, gt]),
                    nt().createElement("span", {
                        ref: Yt
                    }, ur !== 0 && nt().createElement("div", {
                        style: {
                            display: "flex",
                            flexDirection: "row",
                            overflow: "hidden"
                        },
                        className: mt
                    }, or.map((Rr,_r)=>typeof Rr == "string" ? nt().createElement("div", {
                        key: _r,
                        style: {
                            ...Tt,
                            fontVariantNumeric: "tabular-nums"
                        }
                    }, Rr) : nt().createElement("div", {
                        key: _r,
                        style: {
                            height: ur,
                            width: mr
                        }
                    }, Zp.map(Sr=>nt().createElement(Xp.div, {
                        style: {
                            ...Tt,
                            fontVariantNumeric: "tabular-nums"
                        },
                        key: "" + nr.current++,
                        initial: "hidden",
                        variants: {
                            hidden: {
                                y: 0
                            },
                            visible: {
                                y: ur * or[_r] * -1 - 20 * ur
                            }
                        },
                        animate: Jt,
                        transition: Bt == null ? void 0 : Bt(_r)
                    }, Sr))))), nt().createElement("div", {
                        ref: br,
                        style: {
                            position: "absolute",
                            top: -9999,
                            ...Tt
                        }
                    }, 0))
                }
                  , Jp = nt().memo(Qp, (mt,gt)=>mt.animateToNumber === gt.animateToNumber && mt.fontStyle === gt.fontStyle && mt.includeComma === gt.includeComma)
            }
            )(),
            tt
        }
        )()
    })
}
)(dist$4);
var distExports = dist$4.exports;
const AnimatedNumbers = getDefaultExportFromCjs(distExports);
var dist$3 = {}
  , bufferPolyfill = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
    lookup$1[i$2] = code[i$2],
    revLookup[code.charCodeAt(i$2)] = i$2;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(d) {
    var g = d.length;
    if (g % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var b = d.indexOf("=");
    b === -1 && (b = g);
    var _ = b === g ? 0 : 4 - b % 4;
    return [b, _]
}
function byteLength(d) {
    var g = getLens(d)
      , b = g[0]
      , _ = g[1];
    return (b + _) * 3 / 4 - _
}
function _byteLength(d, g, b) {
    return (g + b) * 3 / 4 - b
}
function toByteArray(d) {
    var g, b = getLens(d), _ = b[0], $ = b[1], et = new Arr(_byteLength(d, _, $)), tt = 0, rt = $ > 0 ? _ - 4 : _, nt;
    for (nt = 0; nt < rt; nt += 4)
        g = revLookup[d.charCodeAt(nt)] << 18 | revLookup[d.charCodeAt(nt + 1)] << 12 | revLookup[d.charCodeAt(nt + 2)] << 6 | revLookup[d.charCodeAt(nt + 3)],
        et[tt++] = g >> 16 & 255,
        et[tt++] = g >> 8 & 255,
        et[tt++] = g & 255;
    return $ === 2 && (g = revLookup[d.charCodeAt(nt)] << 2 | revLookup[d.charCodeAt(nt + 1)] >> 4,
    et[tt++] = g & 255),
    $ === 1 && (g = revLookup[d.charCodeAt(nt)] << 10 | revLookup[d.charCodeAt(nt + 1)] << 4 | revLookup[d.charCodeAt(nt + 2)] >> 2,
    et[tt++] = g >> 8 & 255,
    et[tt++] = g & 255),
    et
}
function tripletToBase64(d) {
    return lookup$1[d >> 18 & 63] + lookup$1[d >> 12 & 63] + lookup$1[d >> 6 & 63] + lookup$1[d & 63]
}
function encodeChunk(d, g, b) {
    for (var _, $ = [], et = g; et < b; et += 3)
        _ = (d[et] << 16 & 16711680) + (d[et + 1] << 8 & 65280) + (d[et + 2] & 255),
        $.push(tripletToBase64(_));
    return $.join("")
}
function fromByteArray(d) {
    for (var g, b = d.length, _ = b % 3, $ = [], et = 16383, tt = 0, rt = b - _; tt < rt; tt += et)
        $.push(encodeChunk(d, tt, tt + et > rt ? rt : tt + et));
    return _ === 1 ? (g = d[b - 1],
    $.push(lookup$1[g >> 2] + lookup$1[g << 4 & 63] + "==")) : _ === 2 && (g = (d[b - 2] << 8) + d[b - 1],
    $.push(lookup$1[g >> 10] + lookup$1[g >> 4 & 63] + lookup$1[g << 2 & 63] + "=")),
    $.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(d, g, b, _, $) {
    var et, tt, rt = $ * 8 - _ - 1, nt = (1 << rt) - 1, it = nt >> 1, ot = -7, at = b ? $ - 1 : 0, st = b ? -1 : 1, dt = d[g + at];
    for (at += st,
    et = dt & (1 << -ot) - 1,
    dt >>= -ot,
    ot += rt; ot > 0; et = et * 256 + d[g + at],
    at += st,
    ot -= 8)
        ;
    for (tt = et & (1 << -ot) - 1,
    et >>= -ot,
    ot += _; ot > 0; tt = tt * 256 + d[g + at],
    at += st,
    ot -= 8)
        ;
    if (et === 0)
        et = 1 - it;
    else {
        if (et === nt)
            return tt ? NaN : (dt ? -1 : 1) * (1 / 0);
        tt = tt + Math.pow(2, _),
        et = et - it
    }
    return (dt ? -1 : 1) * tt * Math.pow(2, et - _)
}
;
ieee754.write = function(d, g, b, _, $, et) {
    var tt, rt, nt, it = et * 8 - $ - 1, ot = (1 << it) - 1, at = ot >> 1, st = $ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, dt = _ ? 0 : et - 1, ft = _ ? 1 : -1, ht = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;
    for (g = Math.abs(g),
    isNaN(g) || g === 1 / 0 ? (rt = isNaN(g) ? 1 : 0,
    tt = ot) : (tt = Math.floor(Math.log(g) / Math.LN2),
    g * (nt = Math.pow(2, -tt)) < 1 && (tt--,
    nt *= 2),
    tt + at >= 1 ? g += st / nt : g += st * Math.pow(2, 1 - at),
    g * nt >= 2 && (tt++,
    nt /= 2),
    tt + at >= ot ? (rt = 0,
    tt = ot) : tt + at >= 1 ? (rt = (g * nt - 1) * Math.pow(2, $),
    tt = tt + at) : (rt = g * Math.pow(2, at - 1) * Math.pow(2, $),
    tt = 0)); $ >= 8; d[b + dt] = rt & 255,
    dt += ft,
    rt /= 256,
    $ -= 8)
        ;
    for (tt = tt << $ | rt,
    it += $; it > 0; d[b + dt] = tt & 255,
    dt += ft,
    tt /= 256,
    it -= 8)
        ;
    d[b + dt - ft] |= ht * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(d) {
    const g = base64Js
      , b = ieee754
      , _ = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    d.Buffer = rt,
    d.SlowBuffer = ct,
    d.INSPECT_MAX_BYTES = 50;
    const $ = 2147483647;
    d.kMaxLength = $,
    rt.TYPED_ARRAY_SUPPORT = et(),
    !rt.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function et() {
        try {
            const Ct = new Uint8Array(1)
              , yt = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(yt, Uint8Array.prototype),
            Object.setPrototypeOf(Ct, yt),
            Ct.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(rt.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (rt.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(rt.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (rt.isBuffer(this))
                return this.byteOffset
        }
    });
    function tt(Ct) {
        if (Ct > $)
            throw new RangeError('The value "' + Ct + '" is invalid for option "size"');
        const yt = new Uint8Array(Ct);
        return Object.setPrototypeOf(yt, rt.prototype),
        yt
    }
    function rt(Ct, yt, bt) {
        if (typeof Ct == "number") {
            if (typeof yt == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return at(Ct)
        }
        return nt(Ct, yt, bt)
    }
    rt.poolSize = 8192;
    function nt(Ct, yt, bt) {
        if (typeof Ct == "string")
            return st(Ct, yt);
        if (ArrayBuffer.isView(Ct))
            return ft(Ct);
        if (Ct == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ct);
        if (bn(Ct, ArrayBuffer) || Ct && bn(Ct.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (bn(Ct, SharedArrayBuffer) || Ct && bn(Ct.buffer, SharedArrayBuffer)))
            return ht(Ct, yt, bt);
        if (typeof Ct == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const At = Ct.valueOf && Ct.valueOf();
        if (At != null && At !== Ct)
            return rt.from(At, yt, bt);
        const Gt = xt(Ct);
        if (Gt)
            return Gt;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ct[Symbol.toPrimitive] == "function")
            return rt.from(Ct[Symbol.toPrimitive]("string"), yt, bt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ct)
    }
    rt.from = function(Ct, yt, bt) {
        return nt(Ct, yt, bt)
    }
    ,
    Object.setPrototypeOf(rt.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(rt, Uint8Array);
    function it(Ct) {
        if (typeof Ct != "number")
            throw new TypeError('"size" argument must be of type number');
        if (Ct < 0)
            throw new RangeError('The value "' + Ct + '" is invalid for option "size"')
    }
    function ot(Ct, yt, bt) {
        return it(Ct),
        Ct <= 0 ? tt(Ct) : yt !== void 0 ? typeof bt == "string" ? tt(Ct).fill(yt, bt) : tt(Ct).fill(yt) : tt(Ct)
    }
    rt.alloc = function(Ct, yt, bt) {
        return ot(Ct, yt, bt)
    }
    ;
    function at(Ct) {
        return it(Ct),
        tt(Ct < 0 ? 0 : lt(Ct) | 0)
    }
    rt.allocUnsafe = function(Ct) {
        return at(Ct)
    }
    ,
    rt.allocUnsafeSlow = function(Ct) {
        return at(Ct)
    }
    ;
    function st(Ct, yt) {
        if ((typeof yt != "string" || yt === "") && (yt = "utf8"),
        !rt.isEncoding(yt))
            throw new TypeError("Unknown encoding: " + yt);
        const bt = ut(Ct, yt) | 0;
        let At = tt(bt);
        const Gt = At.write(Ct, yt);
        return Gt !== bt && (At = At.slice(0, Gt)),
        At
    }
    function dt(Ct) {
        const yt = Ct.length < 0 ? 0 : lt(Ct.length) | 0
          , bt = tt(yt);
        for (let At = 0; At < yt; At += 1)
            bt[At] = Ct[At] & 255;
        return bt
    }
    function ft(Ct) {
        if (bn(Ct, Uint8Array)) {
            const yt = new Uint8Array(Ct);
            return ht(yt.buffer, yt.byteOffset, yt.byteLength)
        }
        return dt(Ct)
    }
    function ht(Ct, yt, bt) {
        if (yt < 0 || Ct.byteLength < yt)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (Ct.byteLength < yt + (bt || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let At;
        return yt === void 0 && bt === void 0 ? At = new Uint8Array(Ct) : bt === void 0 ? At = new Uint8Array(Ct,yt) : At = new Uint8Array(Ct,yt,bt),
        Object.setPrototypeOf(At, rt.prototype),
        At
    }
    function xt(Ct) {
        if (rt.isBuffer(Ct)) {
            const yt = lt(Ct.length) | 0
              , bt = tt(yt);
            return bt.length === 0 || Ct.copy(bt, 0, 0, yt),
            bt
        }
        if (Ct.length !== void 0)
            return typeof Ct.length != "number" || Un(Ct.length) ? tt(0) : dt(Ct);
        if (Ct.type === "Buffer" && Array.isArray(Ct.data))
            return dt(Ct.data)
    }
    function lt(Ct) {
        if (Ct >= $)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $.toString(16) + " bytes");
        return Ct | 0
    }
    function ct(Ct) {
        return +Ct != Ct && (Ct = 0),
        rt.alloc(+Ct)
    }
    rt.isBuffer = function(yt) {
        return yt != null && yt._isBuffer === !0 && yt !== rt.prototype
    }
    ,
    rt.compare = function(yt, bt) {
        if (bn(yt, Uint8Array) && (yt = rt.from(yt, yt.offset, yt.byteLength)),
        bn(bt, Uint8Array) && (bt = rt.from(bt, bt.offset, bt.byteLength)),
        !rt.isBuffer(yt) || !rt.isBuffer(bt))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (yt === bt)
            return 0;
        let At = yt.length
          , Gt = bt.length;
        for (let Qt = 0, rr = Math.min(At, Gt); Qt < rr; ++Qt)
            if (yt[Qt] !== bt[Qt]) {
                At = yt[Qt],
                Gt = bt[Qt];
                break
            }
        return At < Gt ? -1 : Gt < At ? 1 : 0
    }
    ,
    rt.isEncoding = function(yt) {
        switch (String(yt).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    rt.concat = function(yt, bt) {
        if (!Array.isArray(yt))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (yt.length === 0)
            return rt.alloc(0);
        let At;
        if (bt === void 0)
            for (bt = 0,
            At = 0; At < yt.length; ++At)
                bt += yt[At].length;
        const Gt = rt.allocUnsafe(bt);
        let Qt = 0;
        for (At = 0; At < yt.length; ++At) {
            let rr = yt[At];
            if (bn(rr, Uint8Array))
                Qt + rr.length > Gt.length ? (rt.isBuffer(rr) || (rr = rt.from(rr)),
                rr.copy(Gt, Qt)) : Uint8Array.prototype.set.call(Gt, rr, Qt);
            else if (rt.isBuffer(rr))
                rr.copy(Gt, Qt);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            Qt += rr.length
        }
        return Gt
    }
    ;
    function ut(Ct, yt) {
        if (rt.isBuffer(Ct))
            return Ct.length;
        if (ArrayBuffer.isView(Ct) || bn(Ct, ArrayBuffer))
            return Ct.byteLength;
        if (typeof Ct != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ct);
        const bt = Ct.length
          , At = arguments.length > 2 && arguments[2] === !0;
        if (!At && bt === 0)
            return 0;
        let Gt = !1;
        for (; ; )
            switch (yt) {
            case "ascii":
            case "latin1":
            case "binary":
                return bt;
            case "utf8":
            case "utf-8":
                return ln(Ct).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return bt * 2;
            case "hex":
                return bt >>> 1;
            case "base64":
                return fn(Ct).length;
            default:
                if (Gt)
                    return At ? -1 : ln(Ct).length;
                yt = ("" + yt).toLowerCase(),
                Gt = !0
            }
    }
    rt.byteLength = ut;
    function pt(Ct, yt, bt) {
        let At = !1;
        if ((yt === void 0 || yt < 0) && (yt = 0),
        yt > this.length || ((bt === void 0 || bt > this.length) && (bt = this.length),
        bt <= 0) || (bt >>>= 0,
        yt >>>= 0,
        bt <= yt))
            return "";
        for (Ct || (Ct = "utf8"); ; )
            switch (Ct) {
            case "hex":
                return St(this, yt, bt);
            case "utf8":
            case "utf-8":
                return Ft(this, yt, bt);
            case "ascii":
                return qt(this, yt, bt);
            case "latin1":
            case "binary":
                return Et(this, yt, bt);
            case "base64":
                return Vt(this, yt, bt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Lt(this, yt, bt);
            default:
                if (At)
                    throw new TypeError("Unknown encoding: " + Ct);
                Ct = (Ct + "").toLowerCase(),
                At = !0
            }
    }
    rt.prototype._isBuffer = !0;
    function vt(Ct, yt, bt) {
        const At = Ct[yt];
        Ct[yt] = Ct[bt],
        Ct[bt] = At
    }
    rt.prototype.swap16 = function() {
        const yt = this.length;
        if (yt % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let bt = 0; bt < yt; bt += 2)
            vt(this, bt, bt + 1);
        return this
    }
    ,
    rt.prototype.swap32 = function() {
        const yt = this.length;
        if (yt % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let bt = 0; bt < yt; bt += 4)
            vt(this, bt, bt + 3),
            vt(this, bt + 1, bt + 2);
        return this
    }
    ,
    rt.prototype.swap64 = function() {
        const yt = this.length;
        if (yt % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let bt = 0; bt < yt; bt += 8)
            vt(this, bt, bt + 7),
            vt(this, bt + 1, bt + 6),
            vt(this, bt + 2, bt + 5),
            vt(this, bt + 3, bt + 4);
        return this
    }
    ,
    rt.prototype.toString = function() {
        const yt = this.length;
        return yt === 0 ? "" : arguments.length === 0 ? Ft(this, 0, yt) : pt.apply(this, arguments)
    }
    ,
    rt.prototype.toLocaleString = rt.prototype.toString,
    rt.prototype.equals = function(yt) {
        if (!rt.isBuffer(yt))
            throw new TypeError("Argument must be a Buffer");
        return this === yt ? !0 : rt.compare(this, yt) === 0
    }
    ,
    rt.prototype.inspect = function() {
        let yt = "";
        const bt = d.INSPECT_MAX_BYTES;
        return yt = this.toString("hex", 0, bt).replace(/(.{2})/g, "$1 ").trim(),
        this.length > bt && (yt += " ... "),
        "<Buffer " + yt + ">"
    }
    ,
    _ && (rt.prototype[_] = rt.prototype.inspect),
    rt.prototype.compare = function(yt, bt, At, Gt, Qt) {
        if (bn(yt, Uint8Array) && (yt = rt.from(yt, yt.offset, yt.byteLength)),
        !rt.isBuffer(yt))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof yt);
        if (bt === void 0 && (bt = 0),
        At === void 0 && (At = yt ? yt.length : 0),
        Gt === void 0 && (Gt = 0),
        Qt === void 0 && (Qt = this.length),
        bt < 0 || At > yt.length || Gt < 0 || Qt > this.length)
            throw new RangeError("out of range index");
        if (Gt >= Qt && bt >= At)
            return 0;
        if (Gt >= Qt)
            return -1;
        if (bt >= At)
            return 1;
        if (bt >>>= 0,
        At >>>= 0,
        Gt >>>= 0,
        Qt >>>= 0,
        this === yt)
            return 0;
        let rr = Qt - Gt
          , Er = At - bt;
        const Ur = Math.min(rr, Er)
          , Mr = this.slice(Gt, Qt)
          , Lr = yt.slice(bt, At);
        for (let Kr = 0; Kr < Ur; ++Kr)
            if (Mr[Kr] !== Lr[Kr]) {
                rr = Mr[Kr],
                Er = Lr[Kr];
                break
            }
        return rr < Er ? -1 : Er < rr ? 1 : 0
    }
    ;
    function _t(Ct, yt, bt, At, Gt) {
        if (Ct.length === 0)
            return -1;
        if (typeof bt == "string" ? (At = bt,
        bt = 0) : bt > 2147483647 ? bt = 2147483647 : bt < -2147483648 && (bt = -2147483648),
        bt = +bt,
        Un(bt) && (bt = Gt ? 0 : Ct.length - 1),
        bt < 0 && (bt = Ct.length + bt),
        bt >= Ct.length) {
            if (Gt)
                return -1;
            bt = Ct.length - 1
        } else if (bt < 0)
            if (Gt)
                bt = 0;
            else
                return -1;
        if (typeof yt == "string" && (yt = rt.from(yt, At)),
        rt.isBuffer(yt))
            return yt.length === 0 ? -1 : Pt(Ct, yt, bt, At, Gt);
        if (typeof yt == "number")
            return yt = yt & 255,
            typeof Uint8Array.prototype.indexOf == "function" ? Gt ? Uint8Array.prototype.indexOf.call(Ct, yt, bt) : Uint8Array.prototype.lastIndexOf.call(Ct, yt, bt) : Pt(Ct, [yt], bt, At, Gt);
        throw new TypeError("val must be string, number or Buffer")
    }
    function Pt(Ct, yt, bt, At, Gt) {
        let Qt = 1
          , rr = Ct.length
          , Er = yt.length;
        if (At !== void 0 && (At = String(At).toLowerCase(),
        At === "ucs2" || At === "ucs-2" || At === "utf16le" || At === "utf-16le")) {
            if (Ct.length < 2 || yt.length < 2)
                return -1;
            Qt = 2,
            rr /= 2,
            Er /= 2,
            bt /= 2
        }
        function Ur(Lr, Kr) {
            return Qt === 1 ? Lr[Kr] : Lr.readUInt16BE(Kr * Qt)
        }
        let Mr;
        if (Gt) {
            let Lr = -1;
            for (Mr = bt; Mr < rr; Mr++)
                if (Ur(Ct, Mr) === Ur(yt, Lr === -1 ? 0 : Mr - Lr)) {
                    if (Lr === -1 && (Lr = Mr),
                    Mr - Lr + 1 === Er)
                        return Lr * Qt
                } else
                    Lr !== -1 && (Mr -= Mr - Lr),
                    Lr = -1
        } else
            for (bt + Er > rr && (bt = rr - Er),
            Mr = bt; Mr >= 0; Mr--) {
                let Lr = !0;
                for (let Kr = 0; Kr < Er; Kr++)
                    if (Ur(Ct, Mr + Kr) !== Ur(yt, Kr)) {
                        Lr = !1;
                        break
                    }
                if (Lr)
                    return Mr
            }
        return -1
    }
    rt.prototype.includes = function(yt, bt, At) {
        return this.indexOf(yt, bt, At) !== -1
    }
    ,
    rt.prototype.indexOf = function(yt, bt, At) {
        return _t(this, yt, bt, At, !0)
    }
    ,
    rt.prototype.lastIndexOf = function(yt, bt, At) {
        return _t(this, yt, bt, At, !1)
    }
    ;
    function kt(Ct, yt, bt, At) {
        bt = Number(bt) || 0;
        const Gt = Ct.length - bt;
        At ? (At = Number(At),
        At > Gt && (At = Gt)) : At = Gt;
        const Qt = yt.length;
        At > Qt / 2 && (At = Qt / 2);
        let rr;
        for (rr = 0; rr < At; ++rr) {
            const Er = parseInt(yt.substr(rr * 2, 2), 16);
            if (Un(Er))
                return rr;
            Ct[bt + rr] = Er
        }
        return rr
    }
    function $t(Ct, yt, bt, At) {
        return Rn(ln(yt, Ct.length - bt), Ct, bt, At)
    }
    function Wt(Ct, yt, bt, At) {
        return Rn(Gr(yt), Ct, bt, At)
    }
    function Ht(Ct, yt, bt, At) {
        return Rn(fn(yt), Ct, bt, At)
    }
    function Dt(Ct, yt, bt, At) {
        return Rn(vn(yt, Ct.length - bt), Ct, bt, At)
    }
    rt.prototype.write = function(yt, bt, At, Gt) {
        if (bt === void 0)
            Gt = "utf8",
            At = this.length,
            bt = 0;
        else if (At === void 0 && typeof bt == "string")
            Gt = bt,
            At = this.length,
            bt = 0;
        else if (isFinite(bt))
            bt = bt >>> 0,
            isFinite(At) ? (At = At >>> 0,
            Gt === void 0 && (Gt = "utf8")) : (Gt = At,
            At = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const Qt = this.length - bt;
        if ((At === void 0 || At > Qt) && (At = Qt),
        yt.length > 0 && (At < 0 || bt < 0) || bt > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        Gt || (Gt = "utf8");
        let rr = !1;
        for (; ; )
            switch (Gt) {
            case "hex":
                return kt(this, yt, bt, At);
            case "utf8":
            case "utf-8":
                return $t(this, yt, bt, At);
            case "ascii":
            case "latin1":
            case "binary":
                return Wt(this, yt, bt, At);
            case "base64":
                return Ht(this, yt, bt, At);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Dt(this, yt, bt, At);
            default:
                if (rr)
                    throw new TypeError("Unknown encoding: " + Gt);
                Gt = ("" + Gt).toLowerCase(),
                rr = !0
            }
    }
    ,
    rt.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function Vt(Ct, yt, bt) {
        return yt === 0 && bt === Ct.length ? g.fromByteArray(Ct) : g.fromByteArray(Ct.slice(yt, bt))
    }
    function Ft(Ct, yt, bt) {
        bt = Math.min(Ct.length, bt);
        const At = [];
        let Gt = yt;
        for (; Gt < bt; ) {
            const Qt = Ct[Gt];
            let rr = null
              , Er = Qt > 239 ? 4 : Qt > 223 ? 3 : Qt > 191 ? 2 : 1;
            if (Gt + Er <= bt) {
                let Ur, Mr, Lr, Kr;
                switch (Er) {
                case 1:
                    Qt < 128 && (rr = Qt);
                    break;
                case 2:
                    Ur = Ct[Gt + 1],
                    (Ur & 192) === 128 && (Kr = (Qt & 31) << 6 | Ur & 63,
                    Kr > 127 && (rr = Kr));
                    break;
                case 3:
                    Ur = Ct[Gt + 1],
                    Mr = Ct[Gt + 2],
                    (Ur & 192) === 128 && (Mr & 192) === 128 && (Kr = (Qt & 15) << 12 | (Ur & 63) << 6 | Mr & 63,
                    Kr > 2047 && (Kr < 55296 || Kr > 57343) && (rr = Kr));
                    break;
                case 4:
                    Ur = Ct[Gt + 1],
                    Mr = Ct[Gt + 2],
                    Lr = Ct[Gt + 3],
                    (Ur & 192) === 128 && (Mr & 192) === 128 && (Lr & 192) === 128 && (Kr = (Qt & 15) << 18 | (Ur & 63) << 12 | (Mr & 63) << 6 | Lr & 63,
                    Kr > 65535 && Kr < 1114112 && (rr = Kr))
                }
            }
            rr === null ? (rr = 65533,
            Er = 1) : rr > 65535 && (rr -= 65536,
            At.push(rr >>> 10 & 1023 | 55296),
            rr = 56320 | rr & 1023),
            At.push(rr),
            Gt += Er
        }
        return Rt(At)
    }
    const Kt = 4096;
    function Rt(Ct) {
        const yt = Ct.length;
        if (yt <= Kt)
            return String.fromCharCode.apply(String, Ct);
        let bt = ""
          , At = 0;
        for (; At < yt; )
            bt += String.fromCharCode.apply(String, Ct.slice(At, At += Kt));
        return bt
    }
    function qt(Ct, yt, bt) {
        let At = "";
        bt = Math.min(Ct.length, bt);
        for (let Gt = yt; Gt < bt; ++Gt)
            At += String.fromCharCode(Ct[Gt] & 127);
        return At
    }
    function Et(Ct, yt, bt) {
        let At = "";
        bt = Math.min(Ct.length, bt);
        for (let Gt = yt; Gt < bt; ++Gt)
            At += String.fromCharCode(Ct[Gt]);
        return At
    }
    function St(Ct, yt, bt) {
        const At = Ct.length;
        (!yt || yt < 0) && (yt = 0),
        (!bt || bt < 0 || bt > At) && (bt = At);
        let Gt = "";
        for (let Qt = yt; Qt < bt; ++Qt)
            Gt += zn[Ct[Qt]];
        return Gt
    }
    function Lt(Ct, yt, bt) {
        const At = Ct.slice(yt, bt);
        let Gt = "";
        for (let Qt = 0; Qt < At.length - 1; Qt += 2)
            Gt += String.fromCharCode(At[Qt] + At[Qt + 1] * 256);
        return Gt
    }
    rt.prototype.slice = function(yt, bt) {
        const At = this.length;
        yt = ~~yt,
        bt = bt === void 0 ? At : ~~bt,
        yt < 0 ? (yt += At,
        yt < 0 && (yt = 0)) : yt > At && (yt = At),
        bt < 0 ? (bt += At,
        bt < 0 && (bt = 0)) : bt > At && (bt = At),
        bt < yt && (bt = yt);
        const Gt = this.subarray(yt, bt);
        return Object.setPrototypeOf(Gt, rt.prototype),
        Gt
    }
    ;
    function Mt(Ct, yt, bt) {
        if (Ct % 1 !== 0 || Ct < 0)
            throw new RangeError("offset is not uint");
        if (Ct + yt > bt)
            throw new RangeError("Trying to access beyond buffer length")
    }
    rt.prototype.readUintLE = rt.prototype.readUIntLE = function(yt, bt, At) {
        yt = yt >>> 0,
        bt = bt >>> 0,
        At || Mt(yt, bt, this.length);
        let Gt = this[yt]
          , Qt = 1
          , rr = 0;
        for (; ++rr < bt && (Qt *= 256); )
            Gt += this[yt + rr] * Qt;
        return Gt
    }
    ,
    rt.prototype.readUintBE = rt.prototype.readUIntBE = function(yt, bt, At) {
        yt = yt >>> 0,
        bt = bt >>> 0,
        At || Mt(yt, bt, this.length);
        let Gt = this[yt + --bt]
          , Qt = 1;
        for (; bt > 0 && (Qt *= 256); )
            Gt += this[yt + --bt] * Qt;
        return Gt
    }
    ,
    rt.prototype.readUint8 = rt.prototype.readUInt8 = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 1, this.length),
        this[yt]
    }
    ,
    rt.prototype.readUint16LE = rt.prototype.readUInt16LE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 2, this.length),
        this[yt] | this[yt + 1] << 8
    }
    ,
    rt.prototype.readUint16BE = rt.prototype.readUInt16BE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 2, this.length),
        this[yt] << 8 | this[yt + 1]
    }
    ,
    rt.prototype.readUint32LE = rt.prototype.readUInt32LE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        (this[yt] | this[yt + 1] << 8 | this[yt + 2] << 16) + this[yt + 3] * 16777216
    }
    ,
    rt.prototype.readUint32BE = rt.prototype.readUInt32BE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        this[yt] * 16777216 + (this[yt + 1] << 16 | this[yt + 2] << 8 | this[yt + 3])
    }
    ,
    rt.prototype.readBigUInt64LE = er(function(yt) {
        yt = yt >>> 0,
        Cr(yt, "offset");
        const bt = this[yt]
          , At = this[yt + 7];
        (bt === void 0 || At === void 0) && hr(yt, this.length - 8);
        const Gt = bt + this[++yt] * 2 ** 8 + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 24
          , Qt = this[++yt] + this[++yt] * 2 ** 8 + this[++yt] * 2 ** 16 + At * 2 ** 24;
        return BigInt(Gt) + (BigInt(Qt) << BigInt(32))
    }),
    rt.prototype.readBigUInt64BE = er(function(yt) {
        yt = yt >>> 0,
        Cr(yt, "offset");
        const bt = this[yt]
          , At = this[yt + 7];
        (bt === void 0 || At === void 0) && hr(yt, this.length - 8);
        const Gt = bt * 2 ** 24 + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 8 + this[++yt]
          , Qt = this[++yt] * 2 ** 24 + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 8 + At;
        return (BigInt(Gt) << BigInt(32)) + BigInt(Qt)
    }),
    rt.prototype.readIntLE = function(yt, bt, At) {
        yt = yt >>> 0,
        bt = bt >>> 0,
        At || Mt(yt, bt, this.length);
        let Gt = this[yt]
          , Qt = 1
          , rr = 0;
        for (; ++rr < bt && (Qt *= 256); )
            Gt += this[yt + rr] * Qt;
        return Qt *= 128,
        Gt >= Qt && (Gt -= Math.pow(2, 8 * bt)),
        Gt
    }
    ,
    rt.prototype.readIntBE = function(yt, bt, At) {
        yt = yt >>> 0,
        bt = bt >>> 0,
        At || Mt(yt, bt, this.length);
        let Gt = bt
          , Qt = 1
          , rr = this[yt + --Gt];
        for (; Gt > 0 && (Qt *= 256); )
            rr += this[yt + --Gt] * Qt;
        return Qt *= 128,
        rr >= Qt && (rr -= Math.pow(2, 8 * bt)),
        rr
    }
    ,
    rt.prototype.readInt8 = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 1, this.length),
        this[yt] & 128 ? (255 - this[yt] + 1) * -1 : this[yt]
    }
    ,
    rt.prototype.readInt16LE = function(yt, bt) {
        yt = yt >>> 0,
        bt || Mt(yt, 2, this.length);
        const At = this[yt] | this[yt + 1] << 8;
        return At & 32768 ? At | 4294901760 : At
    }
    ,
    rt.prototype.readInt16BE = function(yt, bt) {
        yt = yt >>> 0,
        bt || Mt(yt, 2, this.length);
        const At = this[yt + 1] | this[yt] << 8;
        return At & 32768 ? At | 4294901760 : At
    }
    ,
    rt.prototype.readInt32LE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        this[yt] | this[yt + 1] << 8 | this[yt + 2] << 16 | this[yt + 3] << 24
    }
    ,
    rt.prototype.readInt32BE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        this[yt] << 24 | this[yt + 1] << 16 | this[yt + 2] << 8 | this[yt + 3]
    }
    ,
    rt.prototype.readBigInt64LE = er(function(yt) {
        yt = yt >>> 0,
        Cr(yt, "offset");
        const bt = this[yt]
          , At = this[yt + 7];
        (bt === void 0 || At === void 0) && hr(yt, this.length - 8);
        const Gt = this[yt + 4] + this[yt + 5] * 2 ** 8 + this[yt + 6] * 2 ** 16 + (At << 24);
        return (BigInt(Gt) << BigInt(32)) + BigInt(bt + this[++yt] * 2 ** 8 + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 24)
    }),
    rt.prototype.readBigInt64BE = er(function(yt) {
        yt = yt >>> 0,
        Cr(yt, "offset");
        const bt = this[yt]
          , At = this[yt + 7];
        (bt === void 0 || At === void 0) && hr(yt, this.length - 8);
        const Gt = (bt << 24) + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 8 + this[++yt];
        return (BigInt(Gt) << BigInt(32)) + BigInt(this[++yt] * 2 ** 24 + this[++yt] * 2 ** 16 + this[++yt] * 2 ** 8 + At)
    }),
    rt.prototype.readFloatLE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        b.read(this, yt, !0, 23, 4)
    }
    ,
    rt.prototype.readFloatBE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 4, this.length),
        b.read(this, yt, !1, 23, 4)
    }
    ,
    rt.prototype.readDoubleLE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 8, this.length),
        b.read(this, yt, !0, 52, 8)
    }
    ,
    rt.prototype.readDoubleBE = function(yt, bt) {
        return yt = yt >>> 0,
        bt || Mt(yt, 8, this.length),
        b.read(this, yt, !1, 52, 8)
    }
    ;
    function ar(Ct, yt, bt, At, Gt, Qt) {
        if (!rt.isBuffer(Ct))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (yt > Gt || yt < Qt)
            throw new RangeError('"value" argument is out of bounds');
        if (bt + At > Ct.length)
            throw new RangeError("Index out of range")
    }
    rt.prototype.writeUintLE = rt.prototype.writeUIntLE = function(yt, bt, At, Gt) {
        if (yt = +yt,
        bt = bt >>> 0,
        At = At >>> 0,
        !Gt) {
            const Er = Math.pow(2, 8 * At) - 1;
            ar(this, yt, bt, At, Er, 0)
        }
        let Qt = 1
          , rr = 0;
        for (this[bt] = yt & 255; ++rr < At && (Qt *= 256); )
            this[bt + rr] = yt / Qt & 255;
        return bt + At
    }
    ,
    rt.prototype.writeUintBE = rt.prototype.writeUIntBE = function(yt, bt, At, Gt) {
        if (yt = +yt,
        bt = bt >>> 0,
        At = At >>> 0,
        !Gt) {
            const Er = Math.pow(2, 8 * At) - 1;
            ar(this, yt, bt, At, Er, 0)
        }
        let Qt = At - 1
          , rr = 1;
        for (this[bt + Qt] = yt & 255; --Qt >= 0 && (rr *= 256); )
            this[bt + Qt] = yt / rr & 255;
        return bt + At
    }
    ,
    rt.prototype.writeUint8 = rt.prototype.writeUInt8 = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 1, 255, 0),
        this[bt] = yt & 255,
        bt + 1
    }
    ,
    rt.prototype.writeUint16LE = rt.prototype.writeUInt16LE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 2, 65535, 0),
        this[bt] = yt & 255,
        this[bt + 1] = yt >>> 8,
        bt + 2
    }
    ,
    rt.prototype.writeUint16BE = rt.prototype.writeUInt16BE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 2, 65535, 0),
        this[bt] = yt >>> 8,
        this[bt + 1] = yt & 255,
        bt + 2
    }
    ,
    rt.prototype.writeUint32LE = rt.prototype.writeUInt32LE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 4, 4294967295, 0),
        this[bt + 3] = yt >>> 24,
        this[bt + 2] = yt >>> 16,
        this[bt + 1] = yt >>> 8,
        this[bt] = yt & 255,
        bt + 4
    }
    ,
    rt.prototype.writeUint32BE = rt.prototype.writeUInt32BE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 4, 4294967295, 0),
        this[bt] = yt >>> 24,
        this[bt + 1] = yt >>> 16,
        this[bt + 2] = yt >>> 8,
        this[bt + 3] = yt & 255,
        bt + 4
    }
    ;
    function wr(Ct, yt, bt, At, Gt) {
        gr(yt, At, Gt, Ct, bt, 7);
        let Qt = Number(yt & BigInt(4294967295));
        Ct[bt++] = Qt,
        Qt = Qt >> 8,
        Ct[bt++] = Qt,
        Qt = Qt >> 8,
        Ct[bt++] = Qt,
        Qt = Qt >> 8,
        Ct[bt++] = Qt;
        let rr = Number(yt >> BigInt(32) & BigInt(4294967295));
        return Ct[bt++] = rr,
        rr = rr >> 8,
        Ct[bt++] = rr,
        rr = rr >> 8,
        Ct[bt++] = rr,
        rr = rr >> 8,
        Ct[bt++] = rr,
        bt
    }
    function Tr(Ct, yt, bt, At, Gt) {
        gr(yt, At, Gt, Ct, bt, 7);
        let Qt = Number(yt & BigInt(4294967295));
        Ct[bt + 7] = Qt,
        Qt = Qt >> 8,
        Ct[bt + 6] = Qt,
        Qt = Qt >> 8,
        Ct[bt + 5] = Qt,
        Qt = Qt >> 8,
        Ct[bt + 4] = Qt;
        let rr = Number(yt >> BigInt(32) & BigInt(4294967295));
        return Ct[bt + 3] = rr,
        rr = rr >> 8,
        Ct[bt + 2] = rr,
        rr = rr >> 8,
        Ct[bt + 1] = rr,
        rr = rr >> 8,
        Ct[bt] = rr,
        bt + 8
    }
    rt.prototype.writeBigUInt64LE = er(function(yt, bt=0) {
        return wr(this, yt, bt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    rt.prototype.writeBigUInt64BE = er(function(yt, bt=0) {
        return Tr(this, yt, bt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    rt.prototype.writeIntLE = function(yt, bt, At, Gt) {
        if (yt = +yt,
        bt = bt >>> 0,
        !Gt) {
            const Ur = Math.pow(2, 8 * At - 1);
            ar(this, yt, bt, At, Ur - 1, -Ur)
        }
        let Qt = 0
          , rr = 1
          , Er = 0;
        for (this[bt] = yt & 255; ++Qt < At && (rr *= 256); )
            yt < 0 && Er === 0 && this[bt + Qt - 1] !== 0 && (Er = 1),
            this[bt + Qt] = (yt / rr >> 0) - Er & 255;
        return bt + At
    }
    ,
    rt.prototype.writeIntBE = function(yt, bt, At, Gt) {
        if (yt = +yt,
        bt = bt >>> 0,
        !Gt) {
            const Ur = Math.pow(2, 8 * At - 1);
            ar(this, yt, bt, At, Ur - 1, -Ur)
        }
        let Qt = At - 1
          , rr = 1
          , Er = 0;
        for (this[bt + Qt] = yt & 255; --Qt >= 0 && (rr *= 256); )
            yt < 0 && Er === 0 && this[bt + Qt + 1] !== 0 && (Er = 1),
            this[bt + Qt] = (yt / rr >> 0) - Er & 255;
        return bt + At
    }
    ,
    rt.prototype.writeInt8 = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 1, 127, -128),
        yt < 0 && (yt = 255 + yt + 1),
        this[bt] = yt & 255,
        bt + 1
    }
    ,
    rt.prototype.writeInt16LE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 2, 32767, -32768),
        this[bt] = yt & 255,
        this[bt + 1] = yt >>> 8,
        bt + 2
    }
    ,
    rt.prototype.writeInt16BE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 2, 32767, -32768),
        this[bt] = yt >>> 8,
        this[bt + 1] = yt & 255,
        bt + 2
    }
    ,
    rt.prototype.writeInt32LE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 4, 2147483647, -2147483648),
        this[bt] = yt & 255,
        this[bt + 1] = yt >>> 8,
        this[bt + 2] = yt >>> 16,
        this[bt + 3] = yt >>> 24,
        bt + 4
    }
    ,
    rt.prototype.writeInt32BE = function(yt, bt, At) {
        return yt = +yt,
        bt = bt >>> 0,
        At || ar(this, yt, bt, 4, 2147483647, -2147483648),
        yt < 0 && (yt = 4294967295 + yt + 1),
        this[bt] = yt >>> 24,
        this[bt + 1] = yt >>> 16,
        this[bt + 2] = yt >>> 8,
        this[bt + 3] = yt & 255,
        bt + 4
    }
    ,
    rt.prototype.writeBigInt64LE = er(function(yt, bt=0) {
        return wr(this, yt, bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    rt.prototype.writeBigInt64BE = er(function(yt, bt=0) {
        return Tr(this, yt, bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function Pr(Ct, yt, bt, At, Gt, Qt) {
        if (bt + At > Ct.length)
            throw new RangeError("Index out of range");
        if (bt < 0)
            throw new RangeError("Index out of range")
    }
    function kr(Ct, yt, bt, At, Gt) {
        return yt = +yt,
        bt = bt >>> 0,
        Gt || Pr(Ct, yt, bt, 4),
        b.write(Ct, yt, bt, At, 23, 4),
        bt + 4
    }
    rt.prototype.writeFloatLE = function(yt, bt, At) {
        return kr(this, yt, bt, !0, At)
    }
    ,
    rt.prototype.writeFloatBE = function(yt, bt, At) {
        return kr(this, yt, bt, !1, At)
    }
    ;
    function jr(Ct, yt, bt, At, Gt) {
        return yt = +yt,
        bt = bt >>> 0,
        Gt || Pr(Ct, yt, bt, 8),
        b.write(Ct, yt, bt, At, 52, 8),
        bt + 8
    }
    rt.prototype.writeDoubleLE = function(yt, bt, At) {
        return jr(this, yt, bt, !0, At)
    }
    ,
    rt.prototype.writeDoubleBE = function(yt, bt, At) {
        return jr(this, yt, bt, !1, At)
    }
    ,
    rt.prototype.copy = function(yt, bt, At, Gt) {
        if (!rt.isBuffer(yt))
            throw new TypeError("argument should be a Buffer");
        if (At || (At = 0),
        !Gt && Gt !== 0 && (Gt = this.length),
        bt >= yt.length && (bt = yt.length),
        bt || (bt = 0),
        Gt > 0 && Gt < At && (Gt = At),
        Gt === At || yt.length === 0 || this.length === 0)
            return 0;
        if (bt < 0)
            throw new RangeError("targetStart out of bounds");
        if (At < 0 || At >= this.length)
            throw new RangeError("Index out of range");
        if (Gt < 0)
            throw new RangeError("sourceEnd out of bounds");
        Gt > this.length && (Gt = this.length),
        yt.length - bt < Gt - At && (Gt = yt.length - bt + At);
        const Qt = Gt - At;
        return this === yt && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(bt, At, Gt) : Uint8Array.prototype.set.call(yt, this.subarray(At, Gt), bt),
        Qt
    }
    ,
    rt.prototype.fill = function(yt, bt, At, Gt) {
        if (typeof yt == "string") {
            if (typeof bt == "string" ? (Gt = bt,
            bt = 0,
            At = this.length) : typeof At == "string" && (Gt = At,
            At = this.length),
            Gt !== void 0 && typeof Gt != "string")
                throw new TypeError("encoding must be a string");
            if (typeof Gt == "string" && !rt.isEncoding(Gt))
                throw new TypeError("Unknown encoding: " + Gt);
            if (yt.length === 1) {
                const rr = yt.charCodeAt(0);
                (Gt === "utf8" && rr < 128 || Gt === "latin1") && (yt = rr)
            }
        } else
            typeof yt == "number" ? yt = yt & 255 : typeof yt == "boolean" && (yt = Number(yt));
        if (bt < 0 || this.length < bt || this.length < At)
            throw new RangeError("Out of range index");
        if (At <= bt)
            return this;
        bt = bt >>> 0,
        At = At === void 0 ? this.length : At >>> 0,
        yt || (yt = 0);
        let Qt;
        if (typeof yt == "number")
            for (Qt = bt; Qt < At; ++Qt)
                this[Qt] = yt;
        else {
            const rr = rt.isBuffer(yt) ? yt : rt.from(yt, Gt)
              , Er = rr.length;
            if (Er === 0)
                throw new TypeError('The value "' + yt + '" is invalid for argument "value"');
            for (Qt = 0; Qt < At - bt; ++Qt)
                this[Qt + bt] = rr[Qt % Er]
        }
        return this
    }
    ;
    const cr = {};
    function dr(Ct, yt, bt) {
        cr[Ct] = class extends bt {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: yt.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${Ct}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return Ct
            }
            set code(Gt) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: Gt,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${Ct}]: ${this.message}`
            }
        }
    }
    dr("ERR_BUFFER_OUT_OF_BOUNDS", function(Ct) {
        return Ct ? `${Ct} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    dr("ERR_INVALID_ARG_TYPE", function(Ct, yt) {
        return `The "${Ct}" argument must be of type number. Received type ${typeof yt}`
    }, TypeError),
    dr("ERR_OUT_OF_RANGE", function(Ct, yt, bt) {
        let At = `The value of "${Ct}" is out of range.`
          , Gt = bt;
        return Number.isInteger(bt) && Math.abs(bt) > 2 ** 32 ? Gt = lr(String(bt)) : typeof bt == "bigint" && (Gt = String(bt),
        (bt > BigInt(2) ** BigInt(32) || bt < -(BigInt(2) ** BigInt(32))) && (Gt = lr(Gt)),
        Gt += "n"),
        At += ` It must be ${yt}. Received ${Gt}`,
        At
    }, RangeError);
    function lr(Ct) {
        let yt = ""
          , bt = Ct.length;
        const At = Ct[0] === "-" ? 1 : 0;
        for (; bt >= At + 4; bt -= 3)
            yt = `_${Ct.slice(bt - 3, bt)}${yt}`;
        return `${Ct.slice(0, bt)}${yt}`
    }
    function ir(Ct, yt, bt) {
        Cr(yt, "offset"),
        (Ct[yt] === void 0 || Ct[yt + bt] === void 0) && hr(yt, Ct.length - (bt + 1))
    }
    function gr(Ct, yt, bt, At, Gt, Qt) {
        if (Ct > bt || Ct < yt) {
            const rr = typeof yt == "bigint" ? "n" : "";
            let Er;
            throw Qt > 3 ? yt === 0 || yt === BigInt(0) ? Er = `>= 0${rr} and < 2${rr} ** ${(Qt + 1) * 8}${rr}` : Er = `>= -(2${rr} ** ${(Qt + 1) * 8 - 1}${rr}) and < 2 ** ${(Qt + 1) * 8 - 1}${rr}` : Er = `>= ${yt}${rr} and <= ${bt}${rr}`,
            new cr.ERR_OUT_OF_RANGE("value",Er,Ct)
        }
        ir(At, Gt, Qt)
    }
    function Cr(Ct, yt) {
        if (typeof Ct != "number")
            throw new cr.ERR_INVALID_ARG_TYPE(yt,"number",Ct)
    }
    function hr(Ct, yt, bt) {
        throw Math.floor(Ct) !== Ct ? (Cr(Ct, bt),
        new cr.ERR_OUT_OF_RANGE(bt || "offset","an integer",Ct)) : yt < 0 ? new cr.ERR_BUFFER_OUT_OF_BOUNDS : new cr.ERR_OUT_OF_RANGE(bt || "offset",`>= ${bt ? 1 : 0} and <= ${yt}`,Ct)
    }
    const zr = /[^+/0-9A-Za-z-_]/g;
    function Zr(Ct) {
        if (Ct = Ct.split("=")[0],
        Ct = Ct.trim().replace(zr, ""),
        Ct.length < 2)
            return "";
        for (; Ct.length % 4 !== 0; )
            Ct = Ct + "=";
        return Ct
    }
    function ln(Ct, yt) {
        yt = yt || 1 / 0;
        let bt;
        const At = Ct.length;
        let Gt = null;
        const Qt = [];
        for (let rr = 0; rr < At; ++rr) {
            if (bt = Ct.charCodeAt(rr),
            bt > 55295 && bt < 57344) {
                if (!Gt) {
                    if (bt > 56319) {
                        (yt -= 3) > -1 && Qt.push(239, 191, 189);
                        continue
                    } else if (rr + 1 === At) {
                        (yt -= 3) > -1 && Qt.push(239, 191, 189);
                        continue
                    }
                    Gt = bt;
                    continue
                }
                if (bt < 56320) {
                    (yt -= 3) > -1 && Qt.push(239, 191, 189),
                    Gt = bt;
                    continue
                }
                bt = (Gt - 55296 << 10 | bt - 56320) + 65536
            } else
                Gt && (yt -= 3) > -1 && Qt.push(239, 191, 189);
            if (Gt = null,
            bt < 128) {
                if ((yt -= 1) < 0)
                    break;
                Qt.push(bt)
            } else if (bt < 2048) {
                if ((yt -= 2) < 0)
                    break;
                Qt.push(bt >> 6 | 192, bt & 63 | 128)
            } else if (bt < 65536) {
                if ((yt -= 3) < 0)
                    break;
                Qt.push(bt >> 12 | 224, bt >> 6 & 63 | 128, bt & 63 | 128)
            } else if (bt < 1114112) {
                if ((yt -= 4) < 0)
                    break;
                Qt.push(bt >> 18 | 240, bt >> 12 & 63 | 128, bt >> 6 & 63 | 128, bt & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return Qt
    }
    function Gr(Ct) {
        const yt = [];
        for (let bt = 0; bt < Ct.length; ++bt)
            yt.push(Ct.charCodeAt(bt) & 255);
        return yt
    }
    function vn(Ct, yt) {
        let bt, At, Gt;
        const Qt = [];
        for (let rr = 0; rr < Ct.length && !((yt -= 2) < 0); ++rr)
            bt = Ct.charCodeAt(rr),
            At = bt >> 8,
            Gt = bt % 256,
            Qt.push(Gt),
            Qt.push(At);
        return Qt
    }
    function fn(Ct) {
        return g.toByteArray(Zr(Ct))
    }
    function Rn(Ct, yt, bt, At) {
        let Gt;
        for (Gt = 0; Gt < At && !(Gt + bt >= yt.length || Gt >= Ct.length); ++Gt)
            yt[Gt + bt] = Ct[Gt];
        return Gt
    }
    function bn(Ct, yt) {
        return Ct instanceof yt || Ct != null && Ct.constructor != null && Ct.constructor.name != null && Ct.constructor.name === yt.name
    }
    function Un(Ct) {
        return Ct !== Ct
    }
    const zn = function() {
        const Ct = "0123456789abcdef"
          , yt = new Array(256);
        for (let bt = 0; bt < 16; ++bt) {
            const At = bt * 16;
            for (let Gt = 0; Gt < 16; ++Gt)
                yt[At + Gt] = Ct[bt] + Ct[Gt]
        }
        return yt
    }();
    function er(Ct) {
        return typeof BigInt > "u" ? Ut : Ct
    }
    function Ut() {
        throw new Error("BigInt not supported")
    }
}
)(bufferPolyfill);
var browser$2 = {
    exports: {}
}, process = browser$2.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}
(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
}
)();
function runTimeout(d) {
    if (cachedSetTimeout === setTimeout)
        return setTimeout(d, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
        return cachedSetTimeout = setTimeout,
        setTimeout(d, 0);
    try {
        return cachedSetTimeout(d, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, d, 0)
        } catch {
            return cachedSetTimeout.call(this, d, 0)
        }
    }
}
function runClearTimeout(d) {
    if (cachedClearTimeout === clearTimeout)
        return clearTimeout(d);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
        return cachedClearTimeout = clearTimeout,
        clearTimeout(d);
    try {
        return cachedClearTimeout(d)
    } catch {
        try {
            return cachedClearTimeout.call(null, d)
        } catch {
            return cachedClearTimeout.call(this, d)
        }
    }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1,
    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
    queue.length && drainQueue())
}
function drainQueue() {
    if (!draining) {
        var d = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var g = queue.length; g; ) {
            for (currentQueue = queue,
            queue = []; ++queueIndex < g; )
                currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1,
            g = queue.length
        }
        currentQueue = null,
        draining = !1,
        runClearTimeout(d)
    }
}
process.nextTick = function(d) {
    var g = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var b = 1; b < arguments.length; b++)
            g[b - 1] = arguments[b];
    queue.push(new Item(d,g)),
    queue.length === 1 && !draining && runTimeout(drainQueue)
}
;
function Item(d, g) {
    this.fun = d,
    this.array = g
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(d) {
    return []
}
;
process.binding = function(d) {
    throw new Error("process.binding is not supported")
}
;
process.cwd = function() {
    return "/"
}
;
process.chdir = function(d) {
    throw new Error("process.chdir is not supported")
}
;
process.umask = function() {
    return 0
}
;
var browserExports = browser$2.exports;
(function(d) {
    Object.defineProperty(d, Symbol.toStringTag, {
        value: "Module"
    });
    const g = bufferPolyfill
      , b = browserExports
      , _ = tt=>tt && tt.__esModule ? tt : {
        default: tt
    }
      , $ = _(b)
      , et = globalThis || void 0 || self;
    Object.defineProperty(d, "Buffer", {
        enumerable: !0,
        get: ()=>g.Buffer
    }),
    Object.defineProperty(d, "process", {
        enumerable: !0,
        get: ()=>$.default
    }),
    d.global = et
}
)(dist$3);
var naclUtil = {
    exports: {}
};
(function(d) {
    (function(g, b) {
        d.exports ? d.exports = b() : (g.nacl || (g.nacl = {}),
        g.nacl.util = b())
    }
    )(commonjsGlobal, function() {
        var g = {};
        function b(_) {
            if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(_))
                throw new TypeError("invalid encoding")
        }
        return g.decodeUTF8 = function(_) {
            if (typeof _ != "string")
                throw new TypeError("expected string");
            var $, et = unescape(encodeURIComponent(_)), tt = new Uint8Array(et.length);
            for ($ = 0; $ < et.length; $++)
                tt[$] = et.charCodeAt($);
            return tt
        }
        ,
        g.encodeUTF8 = function(_) {
            var $, et = [];
            for ($ = 0; $ < _.length; $++)
                et.push(String.fromCharCode(_[$]));
            return decodeURIComponent(escape(et.join("")))
        }
        ,
        typeof atob > "u" ? typeof dist$3.Buffer.from < "u" ? (g.encodeBase64 = function(_) {
            return dist$3.Buffer.from(_).toString("base64")
        }
        ,
        g.decodeBase64 = function(_) {
            return b(_),
            new Uint8Array(Array.prototype.slice.call(dist$3.Buffer.from(_, "base64"), 0))
        }
        ) : (g.encodeBase64 = function(_) {
            return new dist$3.Buffer(_).toString("base64")
        }
        ,
        g.decodeBase64 = function(_) {
            return b(_),
            new Uint8Array(Array.prototype.slice.call(new dist$3.Buffer(_,"base64"), 0))
        }
        ) : (g.encodeBase64 = function(_) {
            var $, et = [], tt = _.length;
            for ($ = 0; $ < tt; $++)
                et.push(String.fromCharCode(_[$]));
            return btoa(et.join(""))
        }
        ,
        g.decodeBase64 = function(_) {
            b(_);
            var $, et = atob(_), tt = new Uint8Array(et.length);
            for ($ = 0; $ < et.length; $++)
                tt[$] = et.charCodeAt($);
            return tt
        }
        ),
        g
    })
}
)(naclUtil);
var naclUtilExports = naclUtil.exports;
const nacl$2 = getDefaultExportFromCjs(naclUtilExports);
function commonjsRequire(d) {
    throw new Error('Could not dynamically require "' + d + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var naclFast = {
    exports: {}
};
const __viteBrowserExternal = {}
  , __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: __viteBrowserExternal
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$0 = getAugmentedNamespace(__viteBrowserExternal$1);
(function(d) {
    (function(g) {
        var b = function(It) {
            var zt, jt = new Float64Array(16);
            if (It)
                for (zt = 0; zt < It.length; zt++)
                    jt[zt] = It[zt];
            return jt
        }
          , _ = function() {
            throw new Error("no PRNG")
        }
          , $ = new Uint8Array(16)
          , et = new Uint8Array(32);
        et[0] = 9;
        var tt = b()
          , rt = b([1])
          , nt = b([56129, 1])
          , it = b([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995])
          , ot = b([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222])
          , at = b([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553])
          , st = b([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214])
          , dt = b([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ft(It, zt, jt, wt) {
            It[zt] = jt >> 24 & 255,
            It[zt + 1] = jt >> 16 & 255,
            It[zt + 2] = jt >> 8 & 255,
            It[zt + 3] = jt & 255,
            It[zt + 4] = wt >> 24 & 255,
            It[zt + 5] = wt >> 16 & 255,
            It[zt + 6] = wt >> 8 & 255,
            It[zt + 7] = wt & 255
        }
        function ht(It, zt, jt, wt, Xt) {
            var fr, pr = 0;
            for (fr = 0; fr < Xt; fr++)
                pr |= It[zt + fr] ^ jt[wt + fr];
            return (1 & pr - 1 >>> 8) - 1
        }
        function xt(It, zt, jt, wt) {
            return ht(It, zt, jt, wt, 16)
        }
        function lt(It, zt, jt, wt) {
            return ht(It, zt, jt, wt, 32)
        }
        function ct(It, zt, jt, wt) {
            for (var Xt = wt[0] & 255 | (wt[1] & 255) << 8 | (wt[2] & 255) << 16 | (wt[3] & 255) << 24, fr = jt[0] & 255 | (jt[1] & 255) << 8 | (jt[2] & 255) << 16 | (jt[3] & 255) << 24, pr = jt[4] & 255 | (jt[5] & 255) << 8 | (jt[6] & 255) << 16 | (jt[7] & 255) << 24, Ir = jt[8] & 255 | (jt[9] & 255) << 8 | (jt[10] & 255) << 16 | (jt[11] & 255) << 24, Nr = jt[12] & 255 | (jt[13] & 255) << 8 | (jt[14] & 255) << 16 | (jt[15] & 255) << 24, nn = wt[4] & 255 | (wt[5] & 255) << 8 | (wt[6] & 255) << 16 | (wt[7] & 255) << 24, Yr = zt[0] & 255 | (zt[1] & 255) << 8 | (zt[2] & 255) << 16 | (zt[3] & 255) << 24, Ln = zt[4] & 255 | (zt[5] & 255) << 8 | (zt[6] & 255) << 16 | (zt[7] & 255) << 24, Qr = zt[8] & 255 | (zt[9] & 255) << 8 | (zt[10] & 255) << 16 | (zt[11] & 255) << 24, pn = zt[12] & 255 | (zt[13] & 255) << 8 | (zt[14] & 255) << 16 | (zt[15] & 255) << 24, mn = wt[8] & 255 | (wt[9] & 255) << 8 | (wt[10] & 255) << 16 | (wt[11] & 255) << 24, En = jt[16] & 255 | (jt[17] & 255) << 8 | (jt[18] & 255) << 16 | (jt[19] & 255) << 24, Sn = jt[20] & 255 | (jt[21] & 255) << 8 | (jt[22] & 255) << 16 | (jt[23] & 255) << 24, yn = jt[24] & 255 | (jt[25] & 255) << 8 | (jt[26] & 255) << 16 | (jt[27] & 255) << 24, Jr = jt[28] & 255 | (jt[29] & 255) << 8 | (jt[30] & 255) << 16 | (jt[31] & 255) << 24, gn = wt[12] & 255 | (wt[13] & 255) << 8 | (wt[14] & 255) << 16 | (wt[15] & 255) << 24, tn = Xt, cn = fr, Xr = pr, rn = Ir, sn = Nr, Hr = nn, vr = Yr, xr = Ln, Dr = Qr, Br = pn, $r = mn, Or = En, dn = Sn, Cn = yn, wn = Jr, _n = gn, tr, In = 0; In < 20; In += 2)
                tr = tn + dn | 0,
                sn ^= tr << 7 | tr >>> 32 - 7,
                tr = sn + tn | 0,
                Dr ^= tr << 9 | tr >>> 32 - 9,
                tr = Dr + sn | 0,
                dn ^= tr << 13 | tr >>> 32 - 13,
                tr = dn + Dr | 0,
                tn ^= tr << 18 | tr >>> 32 - 18,
                tr = Hr + cn | 0,
                Br ^= tr << 7 | tr >>> 32 - 7,
                tr = Br + Hr | 0,
                Cn ^= tr << 9 | tr >>> 32 - 9,
                tr = Cn + Br | 0,
                cn ^= tr << 13 | tr >>> 32 - 13,
                tr = cn + Cn | 0,
                Hr ^= tr << 18 | tr >>> 32 - 18,
                tr = $r + vr | 0,
                wn ^= tr << 7 | tr >>> 32 - 7,
                tr = wn + $r | 0,
                Xr ^= tr << 9 | tr >>> 32 - 9,
                tr = Xr + wn | 0,
                vr ^= tr << 13 | tr >>> 32 - 13,
                tr = vr + Xr | 0,
                $r ^= tr << 18 | tr >>> 32 - 18,
                tr = _n + Or | 0,
                rn ^= tr << 7 | tr >>> 32 - 7,
                tr = rn + _n | 0,
                xr ^= tr << 9 | tr >>> 32 - 9,
                tr = xr + rn | 0,
                Or ^= tr << 13 | tr >>> 32 - 13,
                tr = Or + xr | 0,
                _n ^= tr << 18 | tr >>> 32 - 18,
                tr = tn + rn | 0,
                cn ^= tr << 7 | tr >>> 32 - 7,
                tr = cn + tn | 0,
                Xr ^= tr << 9 | tr >>> 32 - 9,
                tr = Xr + cn | 0,
                rn ^= tr << 13 | tr >>> 32 - 13,
                tr = rn + Xr | 0,
                tn ^= tr << 18 | tr >>> 32 - 18,
                tr = Hr + sn | 0,
                vr ^= tr << 7 | tr >>> 32 - 7,
                tr = vr + Hr | 0,
                xr ^= tr << 9 | tr >>> 32 - 9,
                tr = xr + vr | 0,
                sn ^= tr << 13 | tr >>> 32 - 13,
                tr = sn + xr | 0,
                Hr ^= tr << 18 | tr >>> 32 - 18,
                tr = $r + Br | 0,
                Or ^= tr << 7 | tr >>> 32 - 7,
                tr = Or + $r | 0,
                Dr ^= tr << 9 | tr >>> 32 - 9,
                tr = Dr + Or | 0,
                Br ^= tr << 13 | tr >>> 32 - 13,
                tr = Br + Dr | 0,
                $r ^= tr << 18 | tr >>> 32 - 18,
                tr = _n + wn | 0,
                dn ^= tr << 7 | tr >>> 32 - 7,
                tr = dn + _n | 0,
                Cn ^= tr << 9 | tr >>> 32 - 9,
                tr = Cn + dn | 0,
                wn ^= tr << 13 | tr >>> 32 - 13,
                tr = wn + Cn | 0,
                _n ^= tr << 18 | tr >>> 32 - 18;
            tn = tn + Xt | 0,
            cn = cn + fr | 0,
            Xr = Xr + pr | 0,
            rn = rn + Ir | 0,
            sn = sn + Nr | 0,
            Hr = Hr + nn | 0,
            vr = vr + Yr | 0,
            xr = xr + Ln | 0,
            Dr = Dr + Qr | 0,
            Br = Br + pn | 0,
            $r = $r + mn | 0,
            Or = Or + En | 0,
            dn = dn + Sn | 0,
            Cn = Cn + yn | 0,
            wn = wn + Jr | 0,
            _n = _n + gn | 0,
            It[0] = tn >>> 0 & 255,
            It[1] = tn >>> 8 & 255,
            It[2] = tn >>> 16 & 255,
            It[3] = tn >>> 24 & 255,
            It[4] = cn >>> 0 & 255,
            It[5] = cn >>> 8 & 255,
            It[6] = cn >>> 16 & 255,
            It[7] = cn >>> 24 & 255,
            It[8] = Xr >>> 0 & 255,
            It[9] = Xr >>> 8 & 255,
            It[10] = Xr >>> 16 & 255,
            It[11] = Xr >>> 24 & 255,
            It[12] = rn >>> 0 & 255,
            It[13] = rn >>> 8 & 255,
            It[14] = rn >>> 16 & 255,
            It[15] = rn >>> 24 & 255,
            It[16] = sn >>> 0 & 255,
            It[17] = sn >>> 8 & 255,
            It[18] = sn >>> 16 & 255,
            It[19] = sn >>> 24 & 255,
            It[20] = Hr >>> 0 & 255,
            It[21] = Hr >>> 8 & 255,
            It[22] = Hr >>> 16 & 255,
            It[23] = Hr >>> 24 & 255,
            It[24] = vr >>> 0 & 255,
            It[25] = vr >>> 8 & 255,
            It[26] = vr >>> 16 & 255,
            It[27] = vr >>> 24 & 255,
            It[28] = xr >>> 0 & 255,
            It[29] = xr >>> 8 & 255,
            It[30] = xr >>> 16 & 255,
            It[31] = xr >>> 24 & 255,
            It[32] = Dr >>> 0 & 255,
            It[33] = Dr >>> 8 & 255,
            It[34] = Dr >>> 16 & 255,
            It[35] = Dr >>> 24 & 255,
            It[36] = Br >>> 0 & 255,
            It[37] = Br >>> 8 & 255,
            It[38] = Br >>> 16 & 255,
            It[39] = Br >>> 24 & 255,
            It[40] = $r >>> 0 & 255,
            It[41] = $r >>> 8 & 255,
            It[42] = $r >>> 16 & 255,
            It[43] = $r >>> 24 & 255,
            It[44] = Or >>> 0 & 255,
            It[45] = Or >>> 8 & 255,
            It[46] = Or >>> 16 & 255,
            It[47] = Or >>> 24 & 255,
            It[48] = dn >>> 0 & 255,
            It[49] = dn >>> 8 & 255,
            It[50] = dn >>> 16 & 255,
            It[51] = dn >>> 24 & 255,
            It[52] = Cn >>> 0 & 255,
            It[53] = Cn >>> 8 & 255,
            It[54] = Cn >>> 16 & 255,
            It[55] = Cn >>> 24 & 255,
            It[56] = wn >>> 0 & 255,
            It[57] = wn >>> 8 & 255,
            It[58] = wn >>> 16 & 255,
            It[59] = wn >>> 24 & 255,
            It[60] = _n >>> 0 & 255,
            It[61] = _n >>> 8 & 255,
            It[62] = _n >>> 16 & 255,
            It[63] = _n >>> 24 & 255
        }
        function ut(It, zt, jt, wt) {
            for (var Xt = wt[0] & 255 | (wt[1] & 255) << 8 | (wt[2] & 255) << 16 | (wt[3] & 255) << 24, fr = jt[0] & 255 | (jt[1] & 255) << 8 | (jt[2] & 255) << 16 | (jt[3] & 255) << 24, pr = jt[4] & 255 | (jt[5] & 255) << 8 | (jt[6] & 255) << 16 | (jt[7] & 255) << 24, Ir = jt[8] & 255 | (jt[9] & 255) << 8 | (jt[10] & 255) << 16 | (jt[11] & 255) << 24, Nr = jt[12] & 255 | (jt[13] & 255) << 8 | (jt[14] & 255) << 16 | (jt[15] & 255) << 24, nn = wt[4] & 255 | (wt[5] & 255) << 8 | (wt[6] & 255) << 16 | (wt[7] & 255) << 24, Yr = zt[0] & 255 | (zt[1] & 255) << 8 | (zt[2] & 255) << 16 | (zt[3] & 255) << 24, Ln = zt[4] & 255 | (zt[5] & 255) << 8 | (zt[6] & 255) << 16 | (zt[7] & 255) << 24, Qr = zt[8] & 255 | (zt[9] & 255) << 8 | (zt[10] & 255) << 16 | (zt[11] & 255) << 24, pn = zt[12] & 255 | (zt[13] & 255) << 8 | (zt[14] & 255) << 16 | (zt[15] & 255) << 24, mn = wt[8] & 255 | (wt[9] & 255) << 8 | (wt[10] & 255) << 16 | (wt[11] & 255) << 24, En = jt[16] & 255 | (jt[17] & 255) << 8 | (jt[18] & 255) << 16 | (jt[19] & 255) << 24, Sn = jt[20] & 255 | (jt[21] & 255) << 8 | (jt[22] & 255) << 16 | (jt[23] & 255) << 24, yn = jt[24] & 255 | (jt[25] & 255) << 8 | (jt[26] & 255) << 16 | (jt[27] & 255) << 24, Jr = jt[28] & 255 | (jt[29] & 255) << 8 | (jt[30] & 255) << 16 | (jt[31] & 255) << 24, gn = wt[12] & 255 | (wt[13] & 255) << 8 | (wt[14] & 255) << 16 | (wt[15] & 255) << 24, tn = Xt, cn = fr, Xr = pr, rn = Ir, sn = Nr, Hr = nn, vr = Yr, xr = Ln, Dr = Qr, Br = pn, $r = mn, Or = En, dn = Sn, Cn = yn, wn = Jr, _n = gn, tr, In = 0; In < 20; In += 2)
                tr = tn + dn | 0,
                sn ^= tr << 7 | tr >>> 32 - 7,
                tr = sn + tn | 0,
                Dr ^= tr << 9 | tr >>> 32 - 9,
                tr = Dr + sn | 0,
                dn ^= tr << 13 | tr >>> 32 - 13,
                tr = dn + Dr | 0,
                tn ^= tr << 18 | tr >>> 32 - 18,
                tr = Hr + cn | 0,
                Br ^= tr << 7 | tr >>> 32 - 7,
                tr = Br + Hr | 0,
                Cn ^= tr << 9 | tr >>> 32 - 9,
                tr = Cn + Br | 0,
                cn ^= tr << 13 | tr >>> 32 - 13,
                tr = cn + Cn | 0,
                Hr ^= tr << 18 | tr >>> 32 - 18,
                tr = $r + vr | 0,
                wn ^= tr << 7 | tr >>> 32 - 7,
                tr = wn + $r | 0,
                Xr ^= tr << 9 | tr >>> 32 - 9,
                tr = Xr + wn | 0,
                vr ^= tr << 13 | tr >>> 32 - 13,
                tr = vr + Xr | 0,
                $r ^= tr << 18 | tr >>> 32 - 18,
                tr = _n + Or | 0,
                rn ^= tr << 7 | tr >>> 32 - 7,
                tr = rn + _n | 0,
                xr ^= tr << 9 | tr >>> 32 - 9,
                tr = xr + rn | 0,
                Or ^= tr << 13 | tr >>> 32 - 13,
                tr = Or + xr | 0,
                _n ^= tr << 18 | tr >>> 32 - 18,
                tr = tn + rn | 0,
                cn ^= tr << 7 | tr >>> 32 - 7,
                tr = cn + tn | 0,
                Xr ^= tr << 9 | tr >>> 32 - 9,
                tr = Xr + cn | 0,
                rn ^= tr << 13 | tr >>> 32 - 13,
                tr = rn + Xr | 0,
                tn ^= tr << 18 | tr >>> 32 - 18,
                tr = Hr + sn | 0,
                vr ^= tr << 7 | tr >>> 32 - 7,
                tr = vr + Hr | 0,
                xr ^= tr << 9 | tr >>> 32 - 9,
                tr = xr + vr | 0,
                sn ^= tr << 13 | tr >>> 32 - 13,
                tr = sn + xr | 0,
                Hr ^= tr << 18 | tr >>> 32 - 18,
                tr = $r + Br | 0,
                Or ^= tr << 7 | tr >>> 32 - 7,
                tr = Or + $r | 0,
                Dr ^= tr << 9 | tr >>> 32 - 9,
                tr = Dr + Or | 0,
                Br ^= tr << 13 | tr >>> 32 - 13,
                tr = Br + Dr | 0,
                $r ^= tr << 18 | tr >>> 32 - 18,
                tr = _n + wn | 0,
                dn ^= tr << 7 | tr >>> 32 - 7,
                tr = dn + _n | 0,
                Cn ^= tr << 9 | tr >>> 32 - 9,
                tr = Cn + dn | 0,
                wn ^= tr << 13 | tr >>> 32 - 13,
                tr = wn + Cn | 0,
                _n ^= tr << 18 | tr >>> 32 - 18;
            It[0] = tn >>> 0 & 255,
            It[1] = tn >>> 8 & 255,
            It[2] = tn >>> 16 & 255,
            It[3] = tn >>> 24 & 255,
            It[4] = Hr >>> 0 & 255,
            It[5] = Hr >>> 8 & 255,
            It[6] = Hr >>> 16 & 255,
            It[7] = Hr >>> 24 & 255,
            It[8] = $r >>> 0 & 255,
            It[9] = $r >>> 8 & 255,
            It[10] = $r >>> 16 & 255,
            It[11] = $r >>> 24 & 255,
            It[12] = _n >>> 0 & 255,
            It[13] = _n >>> 8 & 255,
            It[14] = _n >>> 16 & 255,
            It[15] = _n >>> 24 & 255,
            It[16] = vr >>> 0 & 255,
            It[17] = vr >>> 8 & 255,
            It[18] = vr >>> 16 & 255,
            It[19] = vr >>> 24 & 255,
            It[20] = xr >>> 0 & 255,
            It[21] = xr >>> 8 & 255,
            It[22] = xr >>> 16 & 255,
            It[23] = xr >>> 24 & 255,
            It[24] = Dr >>> 0 & 255,
            It[25] = Dr >>> 8 & 255,
            It[26] = Dr >>> 16 & 255,
            It[27] = Dr >>> 24 & 255,
            It[28] = Br >>> 0 & 255,
            It[29] = Br >>> 8 & 255,
            It[30] = Br >>> 16 & 255,
            It[31] = Br >>> 24 & 255
        }
        function pt(It, zt, jt, wt) {
            ct(It, zt, jt, wt)
        }
        function vt(It, zt, jt, wt) {
            ut(It, zt, jt, wt)
        }
        var _t = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function Pt(It, zt, jt, wt, Xt, fr, pr) {
            var Ir = new Uint8Array(16), Nr = new Uint8Array(64), nn, Yr;
            for (Yr = 0; Yr < 16; Yr++)
                Ir[Yr] = 0;
            for (Yr = 0; Yr < 8; Yr++)
                Ir[Yr] = fr[Yr];
            for (; Xt >= 64; ) {
                for (pt(Nr, Ir, pr, _t),
                Yr = 0; Yr < 64; Yr++)
                    It[zt + Yr] = jt[wt + Yr] ^ Nr[Yr];
                for (nn = 1,
                Yr = 8; Yr < 16; Yr++)
                    nn = nn + (Ir[Yr] & 255) | 0,
                    Ir[Yr] = nn & 255,
                    nn >>>= 8;
                Xt -= 64,
                zt += 64,
                wt += 64
            }
            if (Xt > 0)
                for (pt(Nr, Ir, pr, _t),
                Yr = 0; Yr < Xt; Yr++)
                    It[zt + Yr] = jt[wt + Yr] ^ Nr[Yr];
            return 0
        }
        function kt(It, zt, jt, wt, Xt) {
            var fr = new Uint8Array(16), pr = new Uint8Array(64), Ir, Nr;
            for (Nr = 0; Nr < 16; Nr++)
                fr[Nr] = 0;
            for (Nr = 0; Nr < 8; Nr++)
                fr[Nr] = wt[Nr];
            for (; jt >= 64; ) {
                for (pt(pr, fr, Xt, _t),
                Nr = 0; Nr < 64; Nr++)
                    It[zt + Nr] = pr[Nr];
                for (Ir = 1,
                Nr = 8; Nr < 16; Nr++)
                    Ir = Ir + (fr[Nr] & 255) | 0,
                    fr[Nr] = Ir & 255,
                    Ir >>>= 8;
                jt -= 64,
                zt += 64
            }
            if (jt > 0)
                for (pt(pr, fr, Xt, _t),
                Nr = 0; Nr < jt; Nr++)
                    It[zt + Nr] = pr[Nr];
            return 0
        }
        function $t(It, zt, jt, wt, Xt) {
            var fr = new Uint8Array(32);
            vt(fr, wt, Xt, _t);
            for (var pr = new Uint8Array(8), Ir = 0; Ir < 8; Ir++)
                pr[Ir] = wt[Ir + 16];
            return kt(It, zt, jt, pr, fr)
        }
        function Wt(It, zt, jt, wt, Xt, fr, pr) {
            var Ir = new Uint8Array(32);
            vt(Ir, fr, pr, _t);
            for (var Nr = new Uint8Array(8), nn = 0; nn < 8; nn++)
                Nr[nn] = fr[nn + 16];
            return Pt(It, zt, jt, wt, Xt, Nr, Ir)
        }
        var Ht = function(It) {
            this.buffer = new Uint8Array(16),
            this.r = new Uint16Array(10),
            this.h = new Uint16Array(10),
            this.pad = new Uint16Array(8),
            this.leftover = 0,
            this.fin = 0;
            var zt, jt, wt, Xt, fr, pr, Ir, Nr;
            zt = It[0] & 255 | (It[1] & 255) << 8,
            this.r[0] = zt & 8191,
            jt = It[2] & 255 | (It[3] & 255) << 8,
            this.r[1] = (zt >>> 13 | jt << 3) & 8191,
            wt = It[4] & 255 | (It[5] & 255) << 8,
            this.r[2] = (jt >>> 10 | wt << 6) & 7939,
            Xt = It[6] & 255 | (It[7] & 255) << 8,
            this.r[3] = (wt >>> 7 | Xt << 9) & 8191,
            fr = It[8] & 255 | (It[9] & 255) << 8,
            this.r[4] = (Xt >>> 4 | fr << 12) & 255,
            this.r[5] = fr >>> 1 & 8190,
            pr = It[10] & 255 | (It[11] & 255) << 8,
            this.r[6] = (fr >>> 14 | pr << 2) & 8191,
            Ir = It[12] & 255 | (It[13] & 255) << 8,
            this.r[7] = (pr >>> 11 | Ir << 5) & 8065,
            Nr = It[14] & 255 | (It[15] & 255) << 8,
            this.r[8] = (Ir >>> 8 | Nr << 8) & 8191,
            this.r[9] = Nr >>> 5 & 127,
            this.pad[0] = It[16] & 255 | (It[17] & 255) << 8,
            this.pad[1] = It[18] & 255 | (It[19] & 255) << 8,
            this.pad[2] = It[20] & 255 | (It[21] & 255) << 8,
            this.pad[3] = It[22] & 255 | (It[23] & 255) << 8,
            this.pad[4] = It[24] & 255 | (It[25] & 255) << 8,
            this.pad[5] = It[26] & 255 | (It[27] & 255) << 8,
            this.pad[6] = It[28] & 255 | (It[29] & 255) << 8,
            this.pad[7] = It[30] & 255 | (It[31] & 255) << 8
        };
        Ht.prototype.blocks = function(It, zt, jt) {
            for (var wt = this.fin ? 0 : 2048, Xt, fr, pr, Ir, Nr, nn, Yr, Ln, Qr, pn, mn, En, Sn, yn, Jr, gn, tn, cn, Xr, rn = this.h[0], sn = this.h[1], Hr = this.h[2], vr = this.h[3], xr = this.h[4], Dr = this.h[5], Br = this.h[6], $r = this.h[7], Or = this.h[8], dn = this.h[9], Cn = this.r[0], wn = this.r[1], _n = this.r[2], tr = this.r[3], In = this.r[4], Nn = this.r[5], On = this.r[6], Pn = this.r[7], Dn = this.r[8], Fn = this.r[9]; jt >= 16; )
                Xt = It[zt + 0] & 255 | (It[zt + 1] & 255) << 8,
                rn += Xt & 8191,
                fr = It[zt + 2] & 255 | (It[zt + 3] & 255) << 8,
                sn += (Xt >>> 13 | fr << 3) & 8191,
                pr = It[zt + 4] & 255 | (It[zt + 5] & 255) << 8,
                Hr += (fr >>> 10 | pr << 6) & 8191,
                Ir = It[zt + 6] & 255 | (It[zt + 7] & 255) << 8,
                vr += (pr >>> 7 | Ir << 9) & 8191,
                Nr = It[zt + 8] & 255 | (It[zt + 9] & 255) << 8,
                xr += (Ir >>> 4 | Nr << 12) & 8191,
                Dr += Nr >>> 1 & 8191,
                nn = It[zt + 10] & 255 | (It[zt + 11] & 255) << 8,
                Br += (Nr >>> 14 | nn << 2) & 8191,
                Yr = It[zt + 12] & 255 | (It[zt + 13] & 255) << 8,
                $r += (nn >>> 11 | Yr << 5) & 8191,
                Ln = It[zt + 14] & 255 | (It[zt + 15] & 255) << 8,
                Or += (Yr >>> 8 | Ln << 8) & 8191,
                dn += Ln >>> 5 | wt,
                Qr = 0,
                pn = Qr,
                pn += rn * Cn,
                pn += sn * (5 * Fn),
                pn += Hr * (5 * Dn),
                pn += vr * (5 * Pn),
                pn += xr * (5 * On),
                Qr = pn >>> 13,
                pn &= 8191,
                pn += Dr * (5 * Nn),
                pn += Br * (5 * In),
                pn += $r * (5 * tr),
                pn += Or * (5 * _n),
                pn += dn * (5 * wn),
                Qr += pn >>> 13,
                pn &= 8191,
                mn = Qr,
                mn += rn * wn,
                mn += sn * Cn,
                mn += Hr * (5 * Fn),
                mn += vr * (5 * Dn),
                mn += xr * (5 * Pn),
                Qr = mn >>> 13,
                mn &= 8191,
                mn += Dr * (5 * On),
                mn += Br * (5 * Nn),
                mn += $r * (5 * In),
                mn += Or * (5 * tr),
                mn += dn * (5 * _n),
                Qr += mn >>> 13,
                mn &= 8191,
                En = Qr,
                En += rn * _n,
                En += sn * wn,
                En += Hr * Cn,
                En += vr * (5 * Fn),
                En += xr * (5 * Dn),
                Qr = En >>> 13,
                En &= 8191,
                En += Dr * (5 * Pn),
                En += Br * (5 * On),
                En += $r * (5 * Nn),
                En += Or * (5 * In),
                En += dn * (5 * tr),
                Qr += En >>> 13,
                En &= 8191,
                Sn = Qr,
                Sn += rn * tr,
                Sn += sn * _n,
                Sn += Hr * wn,
                Sn += vr * Cn,
                Sn += xr * (5 * Fn),
                Qr = Sn >>> 13,
                Sn &= 8191,
                Sn += Dr * (5 * Dn),
                Sn += Br * (5 * Pn),
                Sn += $r * (5 * On),
                Sn += Or * (5 * Nn),
                Sn += dn * (5 * In),
                Qr += Sn >>> 13,
                Sn &= 8191,
                yn = Qr,
                yn += rn * In,
                yn += sn * tr,
                yn += Hr * _n,
                yn += vr * wn,
                yn += xr * Cn,
                Qr = yn >>> 13,
                yn &= 8191,
                yn += Dr * (5 * Fn),
                yn += Br * (5 * Dn),
                yn += $r * (5 * Pn),
                yn += Or * (5 * On),
                yn += dn * (5 * Nn),
                Qr += yn >>> 13,
                yn &= 8191,
                Jr = Qr,
                Jr += rn * Nn,
                Jr += sn * In,
                Jr += Hr * tr,
                Jr += vr * _n,
                Jr += xr * wn,
                Qr = Jr >>> 13,
                Jr &= 8191,
                Jr += Dr * Cn,
                Jr += Br * (5 * Fn),
                Jr += $r * (5 * Dn),
                Jr += Or * (5 * Pn),
                Jr += dn * (5 * On),
                Qr += Jr >>> 13,
                Jr &= 8191,
                gn = Qr,
                gn += rn * On,
                gn += sn * Nn,
                gn += Hr * In,
                gn += vr * tr,
                gn += xr * _n,
                Qr = gn >>> 13,
                gn &= 8191,
                gn += Dr * wn,
                gn += Br * Cn,
                gn += $r * (5 * Fn),
                gn += Or * (5 * Dn),
                gn += dn * (5 * Pn),
                Qr += gn >>> 13,
                gn &= 8191,
                tn = Qr,
                tn += rn * Pn,
                tn += sn * On,
                tn += Hr * Nn,
                tn += vr * In,
                tn += xr * tr,
                Qr = tn >>> 13,
                tn &= 8191,
                tn += Dr * _n,
                tn += Br * wn,
                tn += $r * Cn,
                tn += Or * (5 * Fn),
                tn += dn * (5 * Dn),
                Qr += tn >>> 13,
                tn &= 8191,
                cn = Qr,
                cn += rn * Dn,
                cn += sn * Pn,
                cn += Hr * On,
                cn += vr * Nn,
                cn += xr * In,
                Qr = cn >>> 13,
                cn &= 8191,
                cn += Dr * tr,
                cn += Br * _n,
                cn += $r * wn,
                cn += Or * Cn,
                cn += dn * (5 * Fn),
                Qr += cn >>> 13,
                cn &= 8191,
                Xr = Qr,
                Xr += rn * Fn,
                Xr += sn * Dn,
                Xr += Hr * Pn,
                Xr += vr * On,
                Xr += xr * Nn,
                Qr = Xr >>> 13,
                Xr &= 8191,
                Xr += Dr * In,
                Xr += Br * tr,
                Xr += $r * _n,
                Xr += Or * wn,
                Xr += dn * Cn,
                Qr += Xr >>> 13,
                Xr &= 8191,
                Qr = (Qr << 2) + Qr | 0,
                Qr = Qr + pn | 0,
                pn = Qr & 8191,
                Qr = Qr >>> 13,
                mn += Qr,
                rn = pn,
                sn = mn,
                Hr = En,
                vr = Sn,
                xr = yn,
                Dr = Jr,
                Br = gn,
                $r = tn,
                Or = cn,
                dn = Xr,
                zt += 16,
                jt -= 16;
            this.h[0] = rn,
            this.h[1] = sn,
            this.h[2] = Hr,
            this.h[3] = vr,
            this.h[4] = xr,
            this.h[5] = Dr,
            this.h[6] = Br,
            this.h[7] = $r,
            this.h[8] = Or,
            this.h[9] = dn
        }
        ,
        Ht.prototype.finish = function(It, zt) {
            var jt = new Uint16Array(10), wt, Xt, fr, pr;
            if (this.leftover) {
                for (pr = this.leftover,
                this.buffer[pr++] = 1; pr < 16; pr++)
                    this.buffer[pr] = 0;
                this.fin = 1,
                this.blocks(this.buffer, 0, 16)
            }
            for (wt = this.h[1] >>> 13,
            this.h[1] &= 8191,
            pr = 2; pr < 10; pr++)
                this.h[pr] += wt,
                wt = this.h[pr] >>> 13,
                this.h[pr] &= 8191;
            for (this.h[0] += wt * 5,
            wt = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += wt,
            wt = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += wt,
            jt[0] = this.h[0] + 5,
            wt = jt[0] >>> 13,
            jt[0] &= 8191,
            pr = 1; pr < 10; pr++)
                jt[pr] = this.h[pr] + wt,
                wt = jt[pr] >>> 13,
                jt[pr] &= 8191;
            for (jt[9] -= 8192,
            Xt = (wt ^ 1) - 1,
            pr = 0; pr < 10; pr++)
                jt[pr] &= Xt;
            for (Xt = ~Xt,
            pr = 0; pr < 10; pr++)
                this.h[pr] = this.h[pr] & Xt | jt[pr];
            for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535,
            this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535,
            this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535,
            this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535,
            this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535,
            this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535,
            this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535,
            this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535,
            fr = this.h[0] + this.pad[0],
            this.h[0] = fr & 65535,
            pr = 1; pr < 8; pr++)
                fr = (this.h[pr] + this.pad[pr] | 0) + (fr >>> 16) | 0,
                this.h[pr] = fr & 65535;
            It[zt + 0] = this.h[0] >>> 0 & 255,
            It[zt + 1] = this.h[0] >>> 8 & 255,
            It[zt + 2] = this.h[1] >>> 0 & 255,
            It[zt + 3] = this.h[1] >>> 8 & 255,
            It[zt + 4] = this.h[2] >>> 0 & 255,
            It[zt + 5] = this.h[2] >>> 8 & 255,
            It[zt + 6] = this.h[3] >>> 0 & 255,
            It[zt + 7] = this.h[3] >>> 8 & 255,
            It[zt + 8] = this.h[4] >>> 0 & 255,
            It[zt + 9] = this.h[4] >>> 8 & 255,
            It[zt + 10] = this.h[5] >>> 0 & 255,
            It[zt + 11] = this.h[5] >>> 8 & 255,
            It[zt + 12] = this.h[6] >>> 0 & 255,
            It[zt + 13] = this.h[6] >>> 8 & 255,
            It[zt + 14] = this.h[7] >>> 0 & 255,
            It[zt + 15] = this.h[7] >>> 8 & 255
        }
        ,
        Ht.prototype.update = function(It, zt, jt) {
            var wt, Xt;
            if (this.leftover) {
                for (Xt = 16 - this.leftover,
                Xt > jt && (Xt = jt),
                wt = 0; wt < Xt; wt++)
                    this.buffer[this.leftover + wt] = It[zt + wt];
                if (jt -= Xt,
                zt += Xt,
                this.leftover += Xt,
                this.leftover < 16)
                    return;
                this.blocks(this.buffer, 0, 16),
                this.leftover = 0
            }
            if (jt >= 16 && (Xt = jt - jt % 16,
            this.blocks(It, zt, Xt),
            zt += Xt,
            jt -= Xt),
            jt) {
                for (wt = 0; wt < jt; wt++)
                    this.buffer[this.leftover + wt] = It[zt + wt];
                this.leftover += jt
            }
        }
        ;
        function Dt(It, zt, jt, wt, Xt, fr) {
            var pr = new Ht(fr);
            return pr.update(jt, wt, Xt),
            pr.finish(It, zt),
            0
        }
        function Vt(It, zt, jt, wt, Xt, fr) {
            var pr = new Uint8Array(16);
            return Dt(pr, 0, jt, wt, Xt, fr),
            xt(It, zt, pr, 0)
        }
        function Ft(It, zt, jt, wt, Xt) {
            var fr;
            if (jt < 32)
                return -1;
            for (Wt(It, 0, zt, 0, jt, wt, Xt),
            Dt(It, 16, It, 32, jt - 32, It),
            fr = 0; fr < 16; fr++)
                It[fr] = 0;
            return 0
        }
        function Kt(It, zt, jt, wt, Xt) {
            var fr, pr = new Uint8Array(32);
            if (jt < 32 || ($t(pr, 0, 32, wt, Xt),
            Vt(zt, 16, zt, 32, jt - 32, pr) !== 0))
                return -1;
            for (Wt(It, 0, zt, 0, jt, wt, Xt),
            fr = 0; fr < 32; fr++)
                It[fr] = 0;
            return 0
        }
        function Rt(It, zt) {
            var jt;
            for (jt = 0; jt < 16; jt++)
                It[jt] = zt[jt] | 0
        }
        function qt(It) {
            var zt, jt, wt = 1;
            for (zt = 0; zt < 16; zt++)
                jt = It[zt] + wt + 65535,
                wt = Math.floor(jt / 65536),
                It[zt] = jt - wt * 65536;
            It[0] += wt - 1 + 37 * (wt - 1)
        }
        function Et(It, zt, jt) {
            for (var wt, Xt = ~(jt - 1), fr = 0; fr < 16; fr++)
                wt = Xt & (It[fr] ^ zt[fr]),
                It[fr] ^= wt,
                zt[fr] ^= wt
        }
        function St(It, zt) {
            var jt, wt, Xt, fr = b(), pr = b();
            for (jt = 0; jt < 16; jt++)
                pr[jt] = zt[jt];
            for (qt(pr),
            qt(pr),
            qt(pr),
            wt = 0; wt < 2; wt++) {
                for (fr[0] = pr[0] - 65517,
                jt = 1; jt < 15; jt++)
                    fr[jt] = pr[jt] - 65535 - (fr[jt - 1] >> 16 & 1),
                    fr[jt - 1] &= 65535;
                fr[15] = pr[15] - 32767 - (fr[14] >> 16 & 1),
                Xt = fr[15] >> 16 & 1,
                fr[14] &= 65535,
                Et(pr, fr, 1 - Xt)
            }
            for (jt = 0; jt < 16; jt++)
                It[2 * jt] = pr[jt] & 255,
                It[2 * jt + 1] = pr[jt] >> 8
        }
        function Lt(It, zt) {
            var jt = new Uint8Array(32)
              , wt = new Uint8Array(32);
            return St(jt, It),
            St(wt, zt),
            lt(jt, 0, wt, 0)
        }
        function Mt(It) {
            var zt = new Uint8Array(32);
            return St(zt, It),
            zt[0] & 1
        }
        function ar(It, zt) {
            var jt;
            for (jt = 0; jt < 16; jt++)
                It[jt] = zt[2 * jt] + (zt[2 * jt + 1] << 8);
            It[15] &= 32767
        }
        function wr(It, zt, jt) {
            for (var wt = 0; wt < 16; wt++)
                It[wt] = zt[wt] + jt[wt]
        }
        function Tr(It, zt, jt) {
            for (var wt = 0; wt < 16; wt++)
                It[wt] = zt[wt] - jt[wt]
        }
        function Pr(It, zt, jt) {
            var wt, Xt, fr = 0, pr = 0, Ir = 0, Nr = 0, nn = 0, Yr = 0, Ln = 0, Qr = 0, pn = 0, mn = 0, En = 0, Sn = 0, yn = 0, Jr = 0, gn = 0, tn = 0, cn = 0, Xr = 0, rn = 0, sn = 0, Hr = 0, vr = 0, xr = 0, Dr = 0, Br = 0, $r = 0, Or = 0, dn = 0, Cn = 0, wn = 0, _n = 0, tr = jt[0], In = jt[1], Nn = jt[2], On = jt[3], Pn = jt[4], Dn = jt[5], Fn = jt[6], Zn = jt[7], Wn = jt[8], qn = jt[9], Qn = jt[10], Jn = jt[11], to = jt[12], io = jt[13], oo = jt[14], so = jt[15];
            wt = zt[0],
            fr += wt * tr,
            pr += wt * In,
            Ir += wt * Nn,
            Nr += wt * On,
            nn += wt * Pn,
            Yr += wt * Dn,
            Ln += wt * Fn,
            Qr += wt * Zn,
            pn += wt * Wn,
            mn += wt * qn,
            En += wt * Qn,
            Sn += wt * Jn,
            yn += wt * to,
            Jr += wt * io,
            gn += wt * oo,
            tn += wt * so,
            wt = zt[1],
            pr += wt * tr,
            Ir += wt * In,
            Nr += wt * Nn,
            nn += wt * On,
            Yr += wt * Pn,
            Ln += wt * Dn,
            Qr += wt * Fn,
            pn += wt * Zn,
            mn += wt * Wn,
            En += wt * qn,
            Sn += wt * Qn,
            yn += wt * Jn,
            Jr += wt * to,
            gn += wt * io,
            tn += wt * oo,
            cn += wt * so,
            wt = zt[2],
            Ir += wt * tr,
            Nr += wt * In,
            nn += wt * Nn,
            Yr += wt * On,
            Ln += wt * Pn,
            Qr += wt * Dn,
            pn += wt * Fn,
            mn += wt * Zn,
            En += wt * Wn,
            Sn += wt * qn,
            yn += wt * Qn,
            Jr += wt * Jn,
            gn += wt * to,
            tn += wt * io,
            cn += wt * oo,
            Xr += wt * so,
            wt = zt[3],
            Nr += wt * tr,
            nn += wt * In,
            Yr += wt * Nn,
            Ln += wt * On,
            Qr += wt * Pn,
            pn += wt * Dn,
            mn += wt * Fn,
            En += wt * Zn,
            Sn += wt * Wn,
            yn += wt * qn,
            Jr += wt * Qn,
            gn += wt * Jn,
            tn += wt * to,
            cn += wt * io,
            Xr += wt * oo,
            rn += wt * so,
            wt = zt[4],
            nn += wt * tr,
            Yr += wt * In,
            Ln += wt * Nn,
            Qr += wt * On,
            pn += wt * Pn,
            mn += wt * Dn,
            En += wt * Fn,
            Sn += wt * Zn,
            yn += wt * Wn,
            Jr += wt * qn,
            gn += wt * Qn,
            tn += wt * Jn,
            cn += wt * to,
            Xr += wt * io,
            rn += wt * oo,
            sn += wt * so,
            wt = zt[5],
            Yr += wt * tr,
            Ln += wt * In,
            Qr += wt * Nn,
            pn += wt * On,
            mn += wt * Pn,
            En += wt * Dn,
            Sn += wt * Fn,
            yn += wt * Zn,
            Jr += wt * Wn,
            gn += wt * qn,
            tn += wt * Qn,
            cn += wt * Jn,
            Xr += wt * to,
            rn += wt * io,
            sn += wt * oo,
            Hr += wt * so,
            wt = zt[6],
            Ln += wt * tr,
            Qr += wt * In,
            pn += wt * Nn,
            mn += wt * On,
            En += wt * Pn,
            Sn += wt * Dn,
            yn += wt * Fn,
            Jr += wt * Zn,
            gn += wt * Wn,
            tn += wt * qn,
            cn += wt * Qn,
            Xr += wt * Jn,
            rn += wt * to,
            sn += wt * io,
            Hr += wt * oo,
            vr += wt * so,
            wt = zt[7],
            Qr += wt * tr,
            pn += wt * In,
            mn += wt * Nn,
            En += wt * On,
            Sn += wt * Pn,
            yn += wt * Dn,
            Jr += wt * Fn,
            gn += wt * Zn,
            tn += wt * Wn,
            cn += wt * qn,
            Xr += wt * Qn,
            rn += wt * Jn,
            sn += wt * to,
            Hr += wt * io,
            vr += wt * oo,
            xr += wt * so,
            wt = zt[8],
            pn += wt * tr,
            mn += wt * In,
            En += wt * Nn,
            Sn += wt * On,
            yn += wt * Pn,
            Jr += wt * Dn,
            gn += wt * Fn,
            tn += wt * Zn,
            cn += wt * Wn,
            Xr += wt * qn,
            rn += wt * Qn,
            sn += wt * Jn,
            Hr += wt * to,
            vr += wt * io,
            xr += wt * oo,
            Dr += wt * so,
            wt = zt[9],
            mn += wt * tr,
            En += wt * In,
            Sn += wt * Nn,
            yn += wt * On,
            Jr += wt * Pn,
            gn += wt * Dn,
            tn += wt * Fn,
            cn += wt * Zn,
            Xr += wt * Wn,
            rn += wt * qn,
            sn += wt * Qn,
            Hr += wt * Jn,
            vr += wt * to,
            xr += wt * io,
            Dr += wt * oo,
            Br += wt * so,
            wt = zt[10],
            En += wt * tr,
            Sn += wt * In,
            yn += wt * Nn,
            Jr += wt * On,
            gn += wt * Pn,
            tn += wt * Dn,
            cn += wt * Fn,
            Xr += wt * Zn,
            rn += wt * Wn,
            sn += wt * qn,
            Hr += wt * Qn,
            vr += wt * Jn,
            xr += wt * to,
            Dr += wt * io,
            Br += wt * oo,
            $r += wt * so,
            wt = zt[11],
            Sn += wt * tr,
            yn += wt * In,
            Jr += wt * Nn,
            gn += wt * On,
            tn += wt * Pn,
            cn += wt * Dn,
            Xr += wt * Fn,
            rn += wt * Zn,
            sn += wt * Wn,
            Hr += wt * qn,
            vr += wt * Qn,
            xr += wt * Jn,
            Dr += wt * to,
            Br += wt * io,
            $r += wt * oo,
            Or += wt * so,
            wt = zt[12],
            yn += wt * tr,
            Jr += wt * In,
            gn += wt * Nn,
            tn += wt * On,
            cn += wt * Pn,
            Xr += wt * Dn,
            rn += wt * Fn,
            sn += wt * Zn,
            Hr += wt * Wn,
            vr += wt * qn,
            xr += wt * Qn,
            Dr += wt * Jn,
            Br += wt * to,
            $r += wt * io,
            Or += wt * oo,
            dn += wt * so,
            wt = zt[13],
            Jr += wt * tr,
            gn += wt * In,
            tn += wt * Nn,
            cn += wt * On,
            Xr += wt * Pn,
            rn += wt * Dn,
            sn += wt * Fn,
            Hr += wt * Zn,
            vr += wt * Wn,
            xr += wt * qn,
            Dr += wt * Qn,
            Br += wt * Jn,
            $r += wt * to,
            Or += wt * io,
            dn += wt * oo,
            Cn += wt * so,
            wt = zt[14],
            gn += wt * tr,
            tn += wt * In,
            cn += wt * Nn,
            Xr += wt * On,
            rn += wt * Pn,
            sn += wt * Dn,
            Hr += wt * Fn,
            vr += wt * Zn,
            xr += wt * Wn,
            Dr += wt * qn,
            Br += wt * Qn,
            $r += wt * Jn,
            Or += wt * to,
            dn += wt * io,
            Cn += wt * oo,
            wn += wt * so,
            wt = zt[15],
            tn += wt * tr,
            cn += wt * In,
            Xr += wt * Nn,
            rn += wt * On,
            sn += wt * Pn,
            Hr += wt * Dn,
            vr += wt * Fn,
            xr += wt * Zn,
            Dr += wt * Wn,
            Br += wt * qn,
            $r += wt * Qn,
            Or += wt * Jn,
            dn += wt * to,
            Cn += wt * io,
            wn += wt * oo,
            _n += wt * so,
            fr += 38 * cn,
            pr += 38 * Xr,
            Ir += 38 * rn,
            Nr += 38 * sn,
            nn += 38 * Hr,
            Yr += 38 * vr,
            Ln += 38 * xr,
            Qr += 38 * Dr,
            pn += 38 * Br,
            mn += 38 * $r,
            En += 38 * Or,
            Sn += 38 * dn,
            yn += 38 * Cn,
            Jr += 38 * wn,
            gn += 38 * _n,
            Xt = 1,
            wt = fr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            fr = wt - Xt * 65536,
            wt = pr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            pr = wt - Xt * 65536,
            wt = Ir + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Ir = wt - Xt * 65536,
            wt = Nr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Nr = wt - Xt * 65536,
            wt = nn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            nn = wt - Xt * 65536,
            wt = Yr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Yr = wt - Xt * 65536,
            wt = Ln + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Ln = wt - Xt * 65536,
            wt = Qr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Qr = wt - Xt * 65536,
            wt = pn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            pn = wt - Xt * 65536,
            wt = mn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            mn = wt - Xt * 65536,
            wt = En + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            En = wt - Xt * 65536,
            wt = Sn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Sn = wt - Xt * 65536,
            wt = yn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            yn = wt - Xt * 65536,
            wt = Jr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Jr = wt - Xt * 65536,
            wt = gn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            gn = wt - Xt * 65536,
            wt = tn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            tn = wt - Xt * 65536,
            fr += Xt - 1 + 37 * (Xt - 1),
            Xt = 1,
            wt = fr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            fr = wt - Xt * 65536,
            wt = pr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            pr = wt - Xt * 65536,
            wt = Ir + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Ir = wt - Xt * 65536,
            wt = Nr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Nr = wt - Xt * 65536,
            wt = nn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            nn = wt - Xt * 65536,
            wt = Yr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Yr = wt - Xt * 65536,
            wt = Ln + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Ln = wt - Xt * 65536,
            wt = Qr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Qr = wt - Xt * 65536,
            wt = pn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            pn = wt - Xt * 65536,
            wt = mn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            mn = wt - Xt * 65536,
            wt = En + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            En = wt - Xt * 65536,
            wt = Sn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Sn = wt - Xt * 65536,
            wt = yn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            yn = wt - Xt * 65536,
            wt = Jr + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            Jr = wt - Xt * 65536,
            wt = gn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            gn = wt - Xt * 65536,
            wt = tn + Xt + 65535,
            Xt = Math.floor(wt / 65536),
            tn = wt - Xt * 65536,
            fr += Xt - 1 + 37 * (Xt - 1),
            It[0] = fr,
            It[1] = pr,
            It[2] = Ir,
            It[3] = Nr,
            It[4] = nn,
            It[5] = Yr,
            It[6] = Ln,
            It[7] = Qr,
            It[8] = pn,
            It[9] = mn,
            It[10] = En,
            It[11] = Sn,
            It[12] = yn,
            It[13] = Jr,
            It[14] = gn,
            It[15] = tn
        }
        function kr(It, zt) {
            Pr(It, zt, zt)
        }
        function jr(It, zt) {
            var jt = b(), wt;
            for (wt = 0; wt < 16; wt++)
                jt[wt] = zt[wt];
            for (wt = 253; wt >= 0; wt--)
                kr(jt, jt),
                wt !== 2 && wt !== 4 && Pr(jt, jt, zt);
            for (wt = 0; wt < 16; wt++)
                It[wt] = jt[wt]
        }
        function cr(It, zt) {
            var jt = b(), wt;
            for (wt = 0; wt < 16; wt++)
                jt[wt] = zt[wt];
            for (wt = 250; wt >= 0; wt--)
                kr(jt, jt),
                wt !== 1 && Pr(jt, jt, zt);
            for (wt = 0; wt < 16; wt++)
                It[wt] = jt[wt]
        }
        function dr(It, zt, jt) {
            var wt = new Uint8Array(32), Xt = new Float64Array(80), fr, pr, Ir = b(), Nr = b(), nn = b(), Yr = b(), Ln = b(), Qr = b();
            for (pr = 0; pr < 31; pr++)
                wt[pr] = zt[pr];
            for (wt[31] = zt[31] & 127 | 64,
            wt[0] &= 248,
            ar(Xt, jt),
            pr = 0; pr < 16; pr++)
                Nr[pr] = Xt[pr],
                Yr[pr] = Ir[pr] = nn[pr] = 0;
            for (Ir[0] = Yr[0] = 1,
            pr = 254; pr >= 0; --pr)
                fr = wt[pr >>> 3] >>> (pr & 7) & 1,
                Et(Ir, Nr, fr),
                Et(nn, Yr, fr),
                wr(Ln, Ir, nn),
                Tr(Ir, Ir, nn),
                wr(nn, Nr, Yr),
                Tr(Nr, Nr, Yr),
                kr(Yr, Ln),
                kr(Qr, Ir),
                Pr(Ir, nn, Ir),
                Pr(nn, Nr, Ln),
                wr(Ln, Ir, nn),
                Tr(Ir, Ir, nn),
                kr(Nr, Ir),
                Tr(nn, Yr, Qr),
                Pr(Ir, nn, nt),
                wr(Ir, Ir, Yr),
                Pr(nn, nn, Ir),
                Pr(Ir, Yr, Qr),
                Pr(Yr, Nr, Xt),
                kr(Nr, Ln),
                Et(Ir, Nr, fr),
                Et(nn, Yr, fr);
            for (pr = 0; pr < 16; pr++)
                Xt[pr + 16] = Ir[pr],
                Xt[pr + 32] = nn[pr],
                Xt[pr + 48] = Nr[pr],
                Xt[pr + 64] = Yr[pr];
            var pn = Xt.subarray(32)
              , mn = Xt.subarray(16);
            return jr(pn, pn),
            Pr(mn, mn, pn),
            St(It, mn),
            0
        }
        function lr(It, zt) {
            return dr(It, zt, et)
        }
        function ir(It, zt) {
            return _(zt, 32),
            lr(It, zt)
        }
        function gr(It, zt, jt) {
            var wt = new Uint8Array(32);
            return dr(wt, jt, zt),
            vt(It, $, wt, _t)
        }
        var Cr = Ft
          , hr = Kt;
        function zr(It, zt, jt, wt, Xt, fr) {
            var pr = new Uint8Array(32);
            return gr(pr, Xt, fr),
            Cr(It, zt, jt, wt, pr)
        }
        function Zr(It, zt, jt, wt, Xt, fr) {
            var pr = new Uint8Array(32);
            return gr(pr, Xt, fr),
            hr(It, zt, jt, wt, pr)
        }
        var ln = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
        function Gr(It, zt, jt, wt) {
            for (var Xt = new Int32Array(16), fr = new Int32Array(16), pr, Ir, Nr, nn, Yr, Ln, Qr, pn, mn, En, Sn, yn, Jr, gn, tn, cn, Xr, rn, sn, Hr, vr, xr, Dr, Br, $r, Or, dn = It[0], Cn = It[1], wn = It[2], _n = It[3], tr = It[4], In = It[5], Nn = It[6], On = It[7], Pn = zt[0], Dn = zt[1], Fn = zt[2], Zn = zt[3], Wn = zt[4], qn = zt[5], Qn = zt[6], Jn = zt[7], to = 0; wt >= 128; ) {
                for (sn = 0; sn < 16; sn++)
                    Hr = 8 * sn + to,
                    Xt[sn] = jt[Hr + 0] << 24 | jt[Hr + 1] << 16 | jt[Hr + 2] << 8 | jt[Hr + 3],
                    fr[sn] = jt[Hr + 4] << 24 | jt[Hr + 5] << 16 | jt[Hr + 6] << 8 | jt[Hr + 7];
                for (sn = 0; sn < 80; sn++)
                    if (pr = dn,
                    Ir = Cn,
                    Nr = wn,
                    nn = _n,
                    Yr = tr,
                    Ln = In,
                    Qr = Nn,
                    pn = On,
                    mn = Pn,
                    En = Dn,
                    Sn = Fn,
                    yn = Zn,
                    Jr = Wn,
                    gn = qn,
                    tn = Qn,
                    cn = Jn,
                    vr = On,
                    xr = Jn,
                    Dr = xr & 65535,
                    Br = xr >>> 16,
                    $r = vr & 65535,
                    Or = vr >>> 16,
                    vr = (tr >>> 14 | Wn << 32 - 14) ^ (tr >>> 18 | Wn << 32 - 18) ^ (Wn >>> 41 - 32 | tr << 32 - (41 - 32)),
                    xr = (Wn >>> 14 | tr << 32 - 14) ^ (Wn >>> 18 | tr << 32 - 18) ^ (tr >>> 41 - 32 | Wn << 32 - (41 - 32)),
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    vr = tr & In ^ ~tr & Nn,
                    xr = Wn & qn ^ ~Wn & Qn,
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    vr = ln[sn * 2],
                    xr = ln[sn * 2 + 1],
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    vr = Xt[sn % 16],
                    xr = fr[sn % 16],
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    Br += Dr >>> 16,
                    $r += Br >>> 16,
                    Or += $r >>> 16,
                    Xr = $r & 65535 | Or << 16,
                    rn = Dr & 65535 | Br << 16,
                    vr = Xr,
                    xr = rn,
                    Dr = xr & 65535,
                    Br = xr >>> 16,
                    $r = vr & 65535,
                    Or = vr >>> 16,
                    vr = (dn >>> 28 | Pn << 32 - 28) ^ (Pn >>> 34 - 32 | dn << 32 - (34 - 32)) ^ (Pn >>> 39 - 32 | dn << 32 - (39 - 32)),
                    xr = (Pn >>> 28 | dn << 32 - 28) ^ (dn >>> 34 - 32 | Pn << 32 - (34 - 32)) ^ (dn >>> 39 - 32 | Pn << 32 - (39 - 32)),
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    vr = dn & Cn ^ dn & wn ^ Cn & wn,
                    xr = Pn & Dn ^ Pn & Fn ^ Dn & Fn,
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    Br += Dr >>> 16,
                    $r += Br >>> 16,
                    Or += $r >>> 16,
                    pn = $r & 65535 | Or << 16,
                    cn = Dr & 65535 | Br << 16,
                    vr = nn,
                    xr = yn,
                    Dr = xr & 65535,
                    Br = xr >>> 16,
                    $r = vr & 65535,
                    Or = vr >>> 16,
                    vr = Xr,
                    xr = rn,
                    Dr += xr & 65535,
                    Br += xr >>> 16,
                    $r += vr & 65535,
                    Or += vr >>> 16,
                    Br += Dr >>> 16,
                    $r += Br >>> 16,
                    Or += $r >>> 16,
                    nn = $r & 65535 | Or << 16,
                    yn = Dr & 65535 | Br << 16,
                    Cn = pr,
                    wn = Ir,
                    _n = Nr,
                    tr = nn,
                    In = Yr,
                    Nn = Ln,
                    On = Qr,
                    dn = pn,
                    Dn = mn,
                    Fn = En,
                    Zn = Sn,
                    Wn = yn,
                    qn = Jr,
                    Qn = gn,
                    Jn = tn,
                    Pn = cn,
                    sn % 16 === 15)
                        for (Hr = 0; Hr < 16; Hr++)
                            vr = Xt[Hr],
                            xr = fr[Hr],
                            Dr = xr & 65535,
                            Br = xr >>> 16,
                            $r = vr & 65535,
                            Or = vr >>> 16,
                            vr = Xt[(Hr + 9) % 16],
                            xr = fr[(Hr + 9) % 16],
                            Dr += xr & 65535,
                            Br += xr >>> 16,
                            $r += vr & 65535,
                            Or += vr >>> 16,
                            Xr = Xt[(Hr + 1) % 16],
                            rn = fr[(Hr + 1) % 16],
                            vr = (Xr >>> 1 | rn << 32 - 1) ^ (Xr >>> 8 | rn << 32 - 8) ^ Xr >>> 7,
                            xr = (rn >>> 1 | Xr << 32 - 1) ^ (rn >>> 8 | Xr << 32 - 8) ^ (rn >>> 7 | Xr << 32 - 7),
                            Dr += xr & 65535,
                            Br += xr >>> 16,
                            $r += vr & 65535,
                            Or += vr >>> 16,
                            Xr = Xt[(Hr + 14) % 16],
                            rn = fr[(Hr + 14) % 16],
                            vr = (Xr >>> 19 | rn << 32 - 19) ^ (rn >>> 61 - 32 | Xr << 32 - (61 - 32)) ^ Xr >>> 6,
                            xr = (rn >>> 19 | Xr << 32 - 19) ^ (Xr >>> 61 - 32 | rn << 32 - (61 - 32)) ^ (rn >>> 6 | Xr << 32 - 6),
                            Dr += xr & 65535,
                            Br += xr >>> 16,
                            $r += vr & 65535,
                            Or += vr >>> 16,
                            Br += Dr >>> 16,
                            $r += Br >>> 16,
                            Or += $r >>> 16,
                            Xt[Hr] = $r & 65535 | Or << 16,
                            fr[Hr] = Dr & 65535 | Br << 16;
                vr = dn,
                xr = Pn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[0],
                xr = zt[0],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[0] = dn = $r & 65535 | Or << 16,
                zt[0] = Pn = Dr & 65535 | Br << 16,
                vr = Cn,
                xr = Dn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[1],
                xr = zt[1],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[1] = Cn = $r & 65535 | Or << 16,
                zt[1] = Dn = Dr & 65535 | Br << 16,
                vr = wn,
                xr = Fn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[2],
                xr = zt[2],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[2] = wn = $r & 65535 | Or << 16,
                zt[2] = Fn = Dr & 65535 | Br << 16,
                vr = _n,
                xr = Zn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[3],
                xr = zt[3],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[3] = _n = $r & 65535 | Or << 16,
                zt[3] = Zn = Dr & 65535 | Br << 16,
                vr = tr,
                xr = Wn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[4],
                xr = zt[4],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[4] = tr = $r & 65535 | Or << 16,
                zt[4] = Wn = Dr & 65535 | Br << 16,
                vr = In,
                xr = qn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[5],
                xr = zt[5],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[5] = In = $r & 65535 | Or << 16,
                zt[5] = qn = Dr & 65535 | Br << 16,
                vr = Nn,
                xr = Qn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[6],
                xr = zt[6],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[6] = Nn = $r & 65535 | Or << 16,
                zt[6] = Qn = Dr & 65535 | Br << 16,
                vr = On,
                xr = Jn,
                Dr = xr & 65535,
                Br = xr >>> 16,
                $r = vr & 65535,
                Or = vr >>> 16,
                vr = It[7],
                xr = zt[7],
                Dr += xr & 65535,
                Br += xr >>> 16,
                $r += vr & 65535,
                Or += vr >>> 16,
                Br += Dr >>> 16,
                $r += Br >>> 16,
                Or += $r >>> 16,
                It[7] = On = $r & 65535 | Or << 16,
                zt[7] = Jn = Dr & 65535 | Br << 16,
                to += 128,
                wt -= 128
            }
            return wt
        }
        function vn(It, zt, jt) {
            var wt = new Int32Array(8), Xt = new Int32Array(8), fr = new Uint8Array(256), pr, Ir = jt;
            for (wt[0] = 1779033703,
            wt[1] = 3144134277,
            wt[2] = 1013904242,
            wt[3] = 2773480762,
            wt[4] = 1359893119,
            wt[5] = 2600822924,
            wt[6] = 528734635,
            wt[7] = 1541459225,
            Xt[0] = 4089235720,
            Xt[1] = 2227873595,
            Xt[2] = 4271175723,
            Xt[3] = 1595750129,
            Xt[4] = 2917565137,
            Xt[5] = 725511199,
            Xt[6] = 4215389547,
            Xt[7] = 327033209,
            Gr(wt, Xt, zt, jt),
            jt %= 128,
            pr = 0; pr < jt; pr++)
                fr[pr] = zt[Ir - jt + pr];
            for (fr[jt] = 128,
            jt = 256 - 128 * (jt < 112 ? 1 : 0),
            fr[jt - 9] = 0,
            ft(fr, jt - 8, Ir / 536870912 | 0, Ir << 3),
            Gr(wt, Xt, fr, jt),
            pr = 0; pr < 8; pr++)
                ft(It, 8 * pr, wt[pr], Xt[pr]);
            return 0
        }
        function fn(It, zt) {
            var jt = b()
              , wt = b()
              , Xt = b()
              , fr = b()
              , pr = b()
              , Ir = b()
              , Nr = b()
              , nn = b()
              , Yr = b();
            Tr(jt, It[1], It[0]),
            Tr(Yr, zt[1], zt[0]),
            Pr(jt, jt, Yr),
            wr(wt, It[0], It[1]),
            wr(Yr, zt[0], zt[1]),
            Pr(wt, wt, Yr),
            Pr(Xt, It[3], zt[3]),
            Pr(Xt, Xt, ot),
            Pr(fr, It[2], zt[2]),
            wr(fr, fr, fr),
            Tr(pr, wt, jt),
            Tr(Ir, fr, Xt),
            wr(Nr, fr, Xt),
            wr(nn, wt, jt),
            Pr(It[0], pr, Ir),
            Pr(It[1], nn, Nr),
            Pr(It[2], Nr, Ir),
            Pr(It[3], pr, nn)
        }
        function Rn(It, zt, jt) {
            var wt;
            for (wt = 0; wt < 4; wt++)
                Et(It[wt], zt[wt], jt)
        }
        function bn(It, zt) {
            var jt = b()
              , wt = b()
              , Xt = b();
            jr(Xt, zt[2]),
            Pr(jt, zt[0], Xt),
            Pr(wt, zt[1], Xt),
            St(It, wt),
            It[31] ^= Mt(jt) << 7
        }
        function Un(It, zt, jt) {
            var wt, Xt;
            for (Rt(It[0], tt),
            Rt(It[1], rt),
            Rt(It[2], rt),
            Rt(It[3], tt),
            Xt = 255; Xt >= 0; --Xt)
                wt = jt[Xt / 8 | 0] >> (Xt & 7) & 1,
                Rn(It, zt, wt),
                fn(zt, It),
                fn(It, It),
                Rn(It, zt, wt)
        }
        function zn(It, zt) {
            var jt = [b(), b(), b(), b()];
            Rt(jt[0], at),
            Rt(jt[1], st),
            Rt(jt[2], rt),
            Pr(jt[3], at, st),
            Un(It, jt, zt)
        }
        function er(It, zt, jt) {
            var wt = new Uint8Array(64), Xt = [b(), b(), b(), b()], fr;
            for (jt || _(zt, 32),
            vn(wt, zt, 32),
            wt[0] &= 248,
            wt[31] &= 127,
            wt[31] |= 64,
            zn(Xt, wt),
            bn(It, Xt),
            fr = 0; fr < 32; fr++)
                zt[fr + 32] = It[fr];
            return 0
        }
        var Ut = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function Ct(It, zt) {
            var jt, wt, Xt, fr;
            for (wt = 63; wt >= 32; --wt) {
                for (jt = 0,
                Xt = wt - 32,
                fr = wt - 12; Xt < fr; ++Xt)
                    zt[Xt] += jt - 16 * zt[wt] * Ut[Xt - (wt - 32)],
                    jt = Math.floor((zt[Xt] + 128) / 256),
                    zt[Xt] -= jt * 256;
                zt[Xt] += jt,
                zt[wt] = 0
            }
            for (jt = 0,
            Xt = 0; Xt < 32; Xt++)
                zt[Xt] += jt - (zt[31] >> 4) * Ut[Xt],
                jt = zt[Xt] >> 8,
                zt[Xt] &= 255;
            for (Xt = 0; Xt < 32; Xt++)
                zt[Xt] -= jt * Ut[Xt];
            for (wt = 0; wt < 32; wt++)
                zt[wt + 1] += zt[wt] >> 8,
                It[wt] = zt[wt] & 255
        }
        function yt(It) {
            var zt = new Float64Array(64), jt;
            for (jt = 0; jt < 64; jt++)
                zt[jt] = It[jt];
            for (jt = 0; jt < 64; jt++)
                It[jt] = 0;
            Ct(It, zt)
        }
        function bt(It, zt, jt, wt) {
            var Xt = new Uint8Array(64), fr = new Uint8Array(64), pr = new Uint8Array(64), Ir, Nr, nn = new Float64Array(64), Yr = [b(), b(), b(), b()];
            vn(Xt, wt, 32),
            Xt[0] &= 248,
            Xt[31] &= 127,
            Xt[31] |= 64;
            var Ln = jt + 64;
            for (Ir = 0; Ir < jt; Ir++)
                It[64 + Ir] = zt[Ir];
            for (Ir = 0; Ir < 32; Ir++)
                It[32 + Ir] = Xt[32 + Ir];
            for (vn(pr, It.subarray(32), jt + 32),
            yt(pr),
            zn(Yr, pr),
            bn(It, Yr),
            Ir = 32; Ir < 64; Ir++)
                It[Ir] = wt[Ir];
            for (vn(fr, It, jt + 64),
            yt(fr),
            Ir = 0; Ir < 64; Ir++)
                nn[Ir] = 0;
            for (Ir = 0; Ir < 32; Ir++)
                nn[Ir] = pr[Ir];
            for (Ir = 0; Ir < 32; Ir++)
                for (Nr = 0; Nr < 32; Nr++)
                    nn[Ir + Nr] += fr[Ir] * Xt[Nr];
            return Ct(It.subarray(32), nn),
            Ln
        }
        function At(It, zt) {
            var jt = b()
              , wt = b()
              , Xt = b()
              , fr = b()
              , pr = b()
              , Ir = b()
              , Nr = b();
            return Rt(It[2], rt),
            ar(It[1], zt),
            kr(Xt, It[1]),
            Pr(fr, Xt, it),
            Tr(Xt, Xt, It[2]),
            wr(fr, It[2], fr),
            kr(pr, fr),
            kr(Ir, pr),
            Pr(Nr, Ir, pr),
            Pr(jt, Nr, Xt),
            Pr(jt, jt, fr),
            cr(jt, jt),
            Pr(jt, jt, Xt),
            Pr(jt, jt, fr),
            Pr(jt, jt, fr),
            Pr(It[0], jt, fr),
            kr(wt, It[0]),
            Pr(wt, wt, fr),
            Lt(wt, Xt) && Pr(It[0], It[0], dt),
            kr(wt, It[0]),
            Pr(wt, wt, fr),
            Lt(wt, Xt) ? -1 : (Mt(It[0]) === zt[31] >> 7 && Tr(It[0], tt, It[0]),
            Pr(It[3], It[0], It[1]),
            0)
        }
        function Gt(It, zt, jt, wt) {
            var Xt, fr = new Uint8Array(32), pr = new Uint8Array(64), Ir = [b(), b(), b(), b()], Nr = [b(), b(), b(), b()];
            if (jt < 64 || At(Nr, wt))
                return -1;
            for (Xt = 0; Xt < jt; Xt++)
                It[Xt] = zt[Xt];
            for (Xt = 0; Xt < 32; Xt++)
                It[Xt + 32] = wt[Xt];
            if (vn(pr, It, jt),
            yt(pr),
            Un(Ir, Nr, pr),
            zn(Nr, zt.subarray(32)),
            fn(Ir, Nr),
            bn(fr, Ir),
            jt -= 64,
            lt(zt, 0, fr, 0)) {
                for (Xt = 0; Xt < jt; Xt++)
                    It[Xt] = 0;
                return -1
            }
            for (Xt = 0; Xt < jt; Xt++)
                It[Xt] = zt[Xt + 64];
            return jt
        }
        var Qt = 32
          , rr = 24
          , Er = 32
          , Ur = 16
          , Mr = 32
          , Lr = 32
          , Kr = 32
          , Fr = 32
          , Mn = 32
          , Bn = rr
          , jn = Er
          , Hn = Ur
          , eo = 64
          , Gn = 32
          , Kn = 64
          , ho = 32
          , mo = 64;
        g.lowlevel = {
            crypto_core_hsalsa20: vt,
            crypto_stream_xor: Wt,
            crypto_stream: $t,
            crypto_stream_salsa20_xor: Pt,
            crypto_stream_salsa20: kt,
            crypto_onetimeauth: Dt,
            crypto_onetimeauth_verify: Vt,
            crypto_verify_16: xt,
            crypto_verify_32: lt,
            crypto_secretbox: Ft,
            crypto_secretbox_open: Kt,
            crypto_scalarmult: dr,
            crypto_scalarmult_base: lr,
            crypto_box_beforenm: gr,
            crypto_box_afternm: Cr,
            crypto_box: zr,
            crypto_box_open: Zr,
            crypto_box_keypair: ir,
            crypto_hash: vn,
            crypto_sign: bt,
            crypto_sign_keypair: er,
            crypto_sign_open: Gt,
            crypto_secretbox_KEYBYTES: Qt,
            crypto_secretbox_NONCEBYTES: rr,
            crypto_secretbox_ZEROBYTES: Er,
            crypto_secretbox_BOXZEROBYTES: Ur,
            crypto_scalarmult_BYTES: Mr,
            crypto_scalarmult_SCALARBYTES: Lr,
            crypto_box_PUBLICKEYBYTES: Kr,
            crypto_box_SECRETKEYBYTES: Fr,
            crypto_box_BEFORENMBYTES: Mn,
            crypto_box_NONCEBYTES: Bn,
            crypto_box_ZEROBYTES: jn,
            crypto_box_BOXZEROBYTES: Hn,
            crypto_sign_BYTES: eo,
            crypto_sign_PUBLICKEYBYTES: Gn,
            crypto_sign_SECRETKEYBYTES: Kn,
            crypto_sign_SEEDBYTES: ho,
            crypto_hash_BYTES: mo,
            gf: b,
            D: it,
            L: Ut,
            pack25519: St,
            unpack25519: ar,
            M: Pr,
            A: wr,
            S: kr,
            Z: Tr,
            pow2523: cr,
            add: fn,
            set25519: Rt,
            modL: Ct,
            scalarmult: Un,
            scalarbase: zn
        };
        function ao(It, zt) {
            if (It.length !== Qt)
                throw new Error("bad key size");
            if (zt.length !== rr)
                throw new Error("bad nonce size")
        }
        function lo(It, zt) {
            if (It.length !== Kr)
                throw new Error("bad public key size");
            if (zt.length !== Fr)
                throw new Error("bad secret key size")
        }
        function no() {
            for (var It = 0; It < arguments.length; It++)
                if (!(arguments[It]instanceof Uint8Array))
                    throw new TypeError("unexpected type, use Uint8Array")
        }
        function Ro(It) {
            for (var zt = 0; zt < It.length; zt++)
                It[zt] = 0
        }
        g.randomBytes = function(It) {
            var zt = new Uint8Array(It);
            return _(zt, It),
            zt
        }
        ,
        g.secretbox = function(It, zt, jt) {
            no(It, zt, jt),
            ao(jt, zt);
            for (var wt = new Uint8Array(Er + It.length), Xt = new Uint8Array(wt.length), fr = 0; fr < It.length; fr++)
                wt[fr + Er] = It[fr];
            return Ft(Xt, wt, wt.length, zt, jt),
            Xt.subarray(Ur)
        }
        ,
        g.secretbox.open = function(It, zt, jt) {
            no(It, zt, jt),
            ao(jt, zt);
            for (var wt = new Uint8Array(Ur + It.length), Xt = new Uint8Array(wt.length), fr = 0; fr < It.length; fr++)
                wt[fr + Ur] = It[fr];
            return wt.length < 32 || Kt(Xt, wt, wt.length, zt, jt) !== 0 ? null : Xt.subarray(Er)
        }
        ,
        g.secretbox.keyLength = Qt,
        g.secretbox.nonceLength = rr,
        g.secretbox.overheadLength = Ur,
        g.scalarMult = function(It, zt) {
            if (no(It, zt),
            It.length !== Lr)
                throw new Error("bad n size");
            if (zt.length !== Mr)
                throw new Error("bad p size");
            var jt = new Uint8Array(Mr);
            return dr(jt, It, zt),
            jt
        }
        ,
        g.scalarMult.base = function(It) {
            if (no(It),
            It.length !== Lr)
                throw new Error("bad n size");
            var zt = new Uint8Array(Mr);
            return lr(zt, It),
            zt
        }
        ,
        g.scalarMult.scalarLength = Lr,
        g.scalarMult.groupElementLength = Mr,
        g.box = function(It, zt, jt, wt) {
            var Xt = g.box.before(jt, wt);
            return g.secretbox(It, zt, Xt)
        }
        ,
        g.box.before = function(It, zt) {
            no(It, zt),
            lo(It, zt);
            var jt = new Uint8Array(Mn);
            return gr(jt, It, zt),
            jt
        }
        ,
        g.box.after = g.secretbox,
        g.box.open = function(It, zt, jt, wt) {
            var Xt = g.box.before(jt, wt);
            return g.secretbox.open(It, zt, Xt)
        }
        ,
        g.box.open.after = g.secretbox.open,
        g.box.keyPair = function() {
            var It = new Uint8Array(Kr)
              , zt = new Uint8Array(Fr);
            return ir(It, zt),
            {
                publicKey: It,
                secretKey: zt
            }
        }
        ,
        g.box.keyPair.fromSecretKey = function(It) {
            if (no(It),
            It.length !== Fr)
                throw new Error("bad secret key size");
            var zt = new Uint8Array(Kr);
            return lr(zt, It),
            {
                publicKey: zt,
                secretKey: new Uint8Array(It)
            }
        }
        ,
        g.box.publicKeyLength = Kr,
        g.box.secretKeyLength = Fr,
        g.box.sharedKeyLength = Mn,
        g.box.nonceLength = Bn,
        g.box.overheadLength = g.secretbox.overheadLength,
        g.sign = function(It, zt) {
            if (no(It, zt),
            zt.length !== Kn)
                throw new Error("bad secret key size");
            var jt = new Uint8Array(eo + It.length);
            return bt(jt, It, It.length, zt),
            jt
        }
        ,
        g.sign.open = function(It, zt) {
            if (no(It, zt),
            zt.length !== Gn)
                throw new Error("bad public key size");
            var jt = new Uint8Array(It.length)
              , wt = Gt(jt, It, It.length, zt);
            if (wt < 0)
                return null;
            for (var Xt = new Uint8Array(wt), fr = 0; fr < Xt.length; fr++)
                Xt[fr] = jt[fr];
            return Xt
        }
        ,
        g.sign.detached = function(It, zt) {
            for (var jt = g.sign(It, zt), wt = new Uint8Array(eo), Xt = 0; Xt < wt.length; Xt++)
                wt[Xt] = jt[Xt];
            return wt
        }
        ,
        g.sign.detached.verify = function(It, zt, jt) {
            if (no(It, zt, jt),
            zt.length !== eo)
                throw new Error("bad signature size");
            if (jt.length !== Gn)
                throw new Error("bad public key size");
            var wt = new Uint8Array(eo + It.length), Xt = new Uint8Array(eo + It.length), fr;
            for (fr = 0; fr < eo; fr++)
                wt[fr] = zt[fr];
            for (fr = 0; fr < It.length; fr++)
                wt[fr + eo] = It[fr];
            return Gt(Xt, wt, wt.length, jt) >= 0
        }
        ,
        g.sign.keyPair = function() {
            var It = new Uint8Array(Gn)
              , zt = new Uint8Array(Kn);
            return er(It, zt),
            {
                publicKey: It,
                secretKey: zt
            }
        }
        ,
        g.sign.keyPair.fromSecretKey = function(It) {
            if (no(It),
            It.length !== Kn)
                throw new Error("bad secret key size");
            for (var zt = new Uint8Array(Gn), jt = 0; jt < zt.length; jt++)
                zt[jt] = It[32 + jt];
            return {
                publicKey: zt,
                secretKey: new Uint8Array(It)
            }
        }
        ,
        g.sign.keyPair.fromSeed = function(It) {
            if (no(It),
            It.length !== ho)
                throw new Error("bad seed size");
            for (var zt = new Uint8Array(Gn), jt = new Uint8Array(Kn), wt = 0; wt < 32; wt++)
                jt[wt] = It[wt];
            return er(zt, jt, !0),
            {
                publicKey: zt,
                secretKey: jt
            }
        }
        ,
        g.sign.publicKeyLength = Gn,
        g.sign.secretKeyLength = Kn,
        g.sign.seedLength = ho,
        g.sign.signatureLength = eo,
        g.hash = function(It) {
            no(It);
            var zt = new Uint8Array(mo);
            return vn(zt, It, It.length),
            zt
        }
        ,
        g.hash.hashLength = mo,
        g.verify = function(It, zt) {
            return no(It, zt),
            It.length === 0 || zt.length === 0 || It.length !== zt.length ? !1 : ht(It, 0, zt, 0, It.length) === 0
        }
        ,
        g.setPRNG = function(It) {
            _ = It
        }
        ,
        function() {
            var It = typeof self < "u" ? self.crypto || self.msCrypto : null;
            if (It && It.getRandomValues) {
                var zt = 65536;
                g.setPRNG(function(jt, wt) {
                    var Xt, fr = new Uint8Array(wt);
                    for (Xt = 0; Xt < wt; Xt += zt)
                        It.getRandomValues(fr.subarray(Xt, Xt + Math.min(wt - Xt, zt)));
                    for (Xt = 0; Xt < wt; Xt++)
                        jt[Xt] = fr[Xt];
                    Ro(fr)
                })
            } else
                typeof commonjsRequire < "u" && (It = require$$0,
                It && It.randomBytes && g.setPRNG(function(jt, wt) {
                    var Xt, fr = It.randomBytes(wt);
                    for (Xt = 0; Xt < wt; Xt++)
                        jt[Xt] = fr[Xt];
                    Ro(fr)
                }))
        }()
    }
    )(d.exports ? d.exports : self.nacl = self.nacl || {})
}
)(naclFast);
var naclFastExports = naclFast.exports;
const nacl$1 = getDefaultExportFromCjs(naclFastExports);
var CONNECT_EVENT_ERROR_CODES;
(function(d) {
    d[d.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    d[d.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    d[d.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR",
    d[d.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR",
    d[d.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    d[d.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    d[d.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_EVENT_ERROR_CODES || (CONNECT_EVENT_ERROR_CODES = {}));
var CONNECT_ITEM_ERROR_CODES;
(function(d) {
    d[d.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    d[d.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(CONNECT_ITEM_ERROR_CODES || (CONNECT_ITEM_ERROR_CODES = {}));
var SEND_TRANSACTION_ERROR_CODES;
(function(d) {
    d[d.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    d[d.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    d[d.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    d[d.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    d[d.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SEND_TRANSACTION_ERROR_CODES || (SEND_TRANSACTION_ERROR_CODES = {}));
var SIGN_DATA_ERROR_CODES;
(function(d) {
    d[d.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    d[d.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    d[d.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    d[d.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR",
    d[d.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(SIGN_DATA_ERROR_CODES || (SIGN_DATA_ERROR_CODES = {}));
var DISCONNECT_ERROR_CODES;
(function(d) {
    d[d.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR",
    d[d.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR",
    d[d.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR",
    d[d.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED"
}
)(DISCONNECT_ERROR_CODES || (DISCONNECT_ERROR_CODES = {}));
var CHAIN;
(function(d) {
    d.MAINNET = "-239",
    d.TESTNET = "-3"
}
)(CHAIN || (CHAIN = {}));
function encodeUint8Array(d, g) {
    const b = nacl$2.encodeBase64(d);
    return g ? encodeURIComponent(b) : b
}
function decodeToUint8Array(d, g) {
    return g && (d = decodeURIComponent(d)),
    nacl$2.decodeBase64(d)
}
function encode(d, g=!1) {
    let b;
    return d instanceof Uint8Array ? b = d : (typeof d != "string" && (d = JSON.stringify(d)),
    b = nacl$2.decodeUTF8(d)),
    encodeUint8Array(b, g)
}
function decode(d, g=!1) {
    const b = decodeToUint8Array(d, g);
    return {
        toString() {
            return nacl$2.encodeUTF8(b)
        },
        toObject() {
            try {
                return JSON.parse(nacl$2.encodeUTF8(b))
            } catch {
                return null
            }
        },
        toUint8Array() {
            return b
        }
    }
}
const Base64 = {
    encode,
    decode
};
function concatUint8Arrays(d, g) {
    const b = new Uint8Array(d.length + g.length);
    return b.set(d),
    b.set(g, d.length),
    b
}
function splitToUint8Arrays(d, g) {
    if (g >= d.length)
        throw new Error("Index is out of buffer");
    const b = d.slice(0, g)
      , _ = d.slice(g);
    return [b, _]
}
function toHexString(d) {
    let g = "";
    return d.forEach(b=>{
        g += ("0" + (b & 255).toString(16)).slice(-2)
    }
    ),
    g
}
function hexToByteArray(d) {
    if (d.length % 2 !== 0)
        throw new Error(`Cannot convert ${d} to bytesArray`);
    const g = new Uint8Array(d.length / 2);
    for (let b = 0; b < d.length; b += 2)
        g[b / 2] = parseInt(d.slice(b, b + 2), 16);
    return g
}
class SessionCrypto {
    constructor(g) {
        this.nonceLength = 24,
        this.keyPair = g ? this.createKeypairFromString(g) : this.createKeypair(),
        this.sessionId = toHexString(this.keyPair.publicKey)
    }
    createKeypair() {
        return nacl$1.box.keyPair()
    }
    createKeypairFromString(g) {
        return {
            publicKey: hexToByteArray(g.publicKey),
            secretKey: hexToByteArray(g.secretKey)
        }
    }
    createNonce() {
        return nacl$1.randomBytes(this.nonceLength)
    }
    encrypt(g, b) {
        const _ = new TextEncoder().encode(g)
          , $ = this.createNonce()
          , et = nacl$1.box(_, $, b, this.keyPair.secretKey);
        return concatUint8Arrays($, et)
    }
    decrypt(g, b) {
        const [_,$] = splitToUint8Arrays(g, this.nonceLength)
          , et = nacl$1.box.open($, _, b, this.keyPair.secretKey);
        if (!et)
            throw new Error(`Decryption error: 
 message: ${g.toString()} 
 sender pubkey: ${b.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
        return new TextDecoder().decode(et)
    }
    stringifyKeypair() {
        return {
            publicKey: toHexString(this.keyPair.publicKey),
            secretKey: toHexString(this.keyPair.secretKey)
        }
    }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(d, g) {
    var b = {};
    for (var _ in d)
        Object.prototype.hasOwnProperty.call(d, _) && g.indexOf(_) < 0 && (b[_] = d[_]);
    if (d != null && typeof Object.getOwnPropertySymbols == "function")
        for (var $ = 0, _ = Object.getOwnPropertySymbols(d); $ < _.length; $++)
            g.indexOf(_[$]) < 0 && Object.prototype.propertyIsEnumerable.call(d, _[$]) && (b[_[$]] = d[_[$]]);
    return b
}
function __awaiter(d, g, b, _) {
    function $(et) {
        return et instanceof b ? et : new b(function(tt) {
            tt(et)
        }
        )
    }
    return new (b || (b = Promise))(function(et, tt) {
        function rt(ot) {
            try {
                it(_.next(ot))
            } catch (at) {
                tt(at)
            }
        }
        function nt(ot) {
            try {
                it(_.throw(ot))
            } catch (at) {
                tt(at)
            }
        }
        function it(ot) {
            ot.done ? et(ot.value) : $(ot.value).then(rt, nt)
        }
        it((_ = _.apply(d, g || [])).next())
    }
    )
}
class TonConnectError extends Error {
    constructor(g, b) {
        super(g, b),
        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${g ? `
` + g : ""}`,
        Object.setPrototypeOf(this, TonConnectError.prototype)
    }
    get info() {
        return ""
    }
}
TonConnectError.prefix = "[TON_CONNECT_SDK_ERROR]";
class DappMetadataError extends TonConnectError {
    get info() {
        return "Passed DappMetadata is in incorrect format."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, DappMetadataError.prototype)
    }
}
class ManifestContentErrorError extends TonConnectError {
    get info() {
        return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, ManifestContentErrorError.prototype)
    }
}
class ManifestNotFoundError extends TonConnectError {
    get info() {
        return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest"
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, ManifestNotFoundError.prototype)
    }
}
class WalletAlreadyConnectedError extends TonConnectError {
    get info() {
        return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype)
    }
}
class WalletNotConnectedError extends TonConnectError {
    get info() {
        return "Send transaction or other protocol methods called while wallet is not connected."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, WalletNotConnectedError.prototype)
    }
}
function isWalletConnectionSourceJS(d) {
    return "jsBridgeKey"in d
}
class UserRejectsError extends TonConnectError {
    get info() {
        return "User rejects the action in the wallet."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, UserRejectsError.prototype)
    }
}
class BadRequestError extends TonConnectError {
    get info() {
        return "Request to the wallet contains errors."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, BadRequestError.prototype)
    }
}
class UnknownAppError extends TonConnectError {
    get info() {
        return "App tries to send rpc request to the injected wallet while not connected."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, UnknownAppError.prototype)
    }
}
class WalletNotInjectedError extends TonConnectError {
    get info() {
        return "There is an attempt to connect to the injected wallet while it is not exists in the webpage."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, WalletNotInjectedError.prototype)
    }
}
class FetchWalletsError extends TonConnectError {
    get info() {
        return "An error occurred while fetching the wallets list."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, FetchWalletsError.prototype)
    }
}
class WrongAddressError extends TonConnectError {
    get info() {
        return "Passed address is in incorrect format."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, WrongAddressError.prototype)
    }
}
class ParseHexError extends TonConnectError {
    get info() {
        return "Passed hex is in incorrect format."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, ParseHexError.prototype)
    }
}
class UnknownError extends TonConnectError {
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, UnknownError.prototype)
    }
}
const connectEventErrorsCodes = {
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,
    [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError
};
class ConnectErrorsParser {
    parseError(g) {
        let b = UnknownError;
        return g.code in connectEventErrorsCodes && (b = connectEventErrorsCodes[g.code] || UnknownError),
        new b(g.message)
    }
}
const connectErrorsParser = new ConnectErrorsParser;
class RpcParser {
    isError(g) {
        return "error"in g
    }
}
const sendTransactionErrors = {
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,
    [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,
    [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,
    [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError
};
class SendTransactionParser extends RpcParser {
    convertToRpcRequest(g) {
        return {
            method: "sendTransaction",
            params: [JSON.stringify(g)]
        }
    }
    parseAndThrowError(g) {
        let b = UnknownError;
        throw g.error.code in sendTransactionErrors && (b = sendTransactionErrors[g.error.code] || UnknownError),
        new b(g.error.message)
    }
    convertFromRpcResponse(g) {
        return {
            boc: g.result
        }
    }
}
const sendTransactionParser = new SendTransactionParser;
class HttpBridgeGatewayStorage {
    constructor(g, b) {
        this.storage = g,
        this.storeKey = "ton-connect-storage_http-bridge-gateway::" + b
    }
    storeLastEventId(g) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.setItem(this.storeKey, g)
        })
    }
    removeLastEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getLastEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.storage.getItem(this.storeKey);
            return g || null
        })
    }
}
function removeUrlLastSlash(d) {
    return d.slice(-1) === "/" ? d.slice(0, -1) : d
}
function addPathToUrl(d, g) {
    return removeUrlLastSlash(d) + "/" + g
}
function isTelegramUrl(d) {
    if (!d)
        return !1;
    const g = new URL(d);
    return g.protocol === "tg:" || g.hostname === "t.me"
}
function encodeTelegramUrlParameters(d) {
    return d.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--")
}
function delay$2(d, g) {
    return __awaiter(this, void 0, void 0, function*() {
        return new Promise((b,_)=>{
            var $, et;
            if (!(($ = g == null ? void 0 : g.signal) === null || $ === void 0) && $.aborted) {
                _(new TonConnectError("Delay aborted"));
                return
            }
            const tt = setTimeout(()=>b(), d);
            (et = g == null ? void 0 : g.signal) === null || et === void 0 || et.addEventListener("abort", ()=>{
                clearTimeout(tt),
                _(new TonConnectError("Delay aborted"))
            }
            )
        }
        )
    })
}
function createAbortController(d) {
    const g = new AbortController;
    return d != null && d.aborted ? g.abort() : d == null || d.addEventListener("abort", ()=>g.abort(), {
        once: !0
    }),
    g
}
function callForSuccess(d, g) {
    var b, _;
    return __awaiter(this, void 0, void 0, function*() {
        const $ = (b = g == null ? void 0 : g.attempts) !== null && b !== void 0 ? b : 10
          , et = (_ = g == null ? void 0 : g.delayMs) !== null && _ !== void 0 ? _ : 200
          , tt = createAbortController(g == null ? void 0 : g.signal);
        if (typeof d != "function")
            throw new TonConnectError(`Expected a function, got ${typeof d}`);
        let rt = 0, nt;
        for (; rt < $; ) {
            if (tt.signal.aborted)
                throw new TonConnectError(`Aborted after attempts ${rt}`);
            try {
                return yield d({
                    signal: tt.signal
                })
            } catch (it) {
                nt = it,
                rt++,
                rt < $ && (yield delay$2(et))
            }
        }
        throw nt
    })
}
function logDebug$1(...d) {
    try {
        console.debug("[TON_CONNECT_SDK]", ...d)
    } catch {}
}
function logError$1(...d) {
    try {
        console.error("[TON_CONNECT_SDK]", ...d)
    } catch {}
}
function logWarning$1(...d) {
    try {
        console.warn("[TON_CONNECT_SDK]", ...d)
    } catch {}
}
function createResource$1(d, g) {
    let b = null
      , _ = null
      , $ = null
      , et = null
      , tt = null;
    const rt = (at,...st)=>__awaiter(this, void 0, void 0, function*() {
        if (et = at ?? null,
        tt == null || tt.abort(),
        tt = createAbortController(at),
        tt.signal.aborted)
            throw new TonConnectError("Resource creation was aborted");
        _ = st ?? null;
        const dt = d(tt.signal, ...st);
        $ = dt;
        const ft = yield dt;
        if ($ !== dt && ft !== b)
            throw yield g(ft),
            new TonConnectError("Resource creation was aborted by a new resource creation");
        return b = ft,
        b
    });
    return {
        create: rt,
        current: ()=>b ?? null,
        dispose: ()=>__awaiter(this, void 0, void 0, function*() {
            try {
                const at = b;
                b = null;
                const st = $;
                $ = null;
                try {
                    tt == null || tt.abort()
                } catch {}
                yield Promise.allSettled([at ? g(at) : Promise.resolve(), st ? g(yield st) : Promise.resolve()])
            } catch {}
        }),
        recreate: at=>__awaiter(this, void 0, void 0, function*() {
            const st = b
              , dt = $
              , ft = _
              , ht = et;
            if (yield delay$2(at),
            st === b && dt === $ && ft === _ && ht === et)
                return yield rt(et, ...ft ?? []);
            throw new TonConnectError("Resource recreation was aborted by a new resource creation")
        })
    }
}
function timeout$1(d, g) {
    const b = g == null ? void 0 : g.timeout
      , _ = g == null ? void 0 : g.signal
      , $ = createAbortController(_);
    return new Promise((et,tt)=>{
        if ($.signal.aborted) {
            tt(new TonConnectError("Operation aborted"));
            return
        }
        let rt;
        typeof b < "u" && (rt = setTimeout(()=>{
            $.abort(),
            tt(new TonConnectError(`Timeout after ${b}ms`))
        }
        , b)),
        $.signal.addEventListener("abort", ()=>{
            clearTimeout(rt),
            tt(new TonConnectError("Operation aborted"))
        }
        , {
            once: !0
        });
        const nt = {
            timeout: b,
            abort: $.signal
        };
        d(et, tt, nt).finally(()=>clearTimeout(rt))
    }
    )
}
class BridgeGateway {
    constructor(g, b, _, $, et) {
        this.bridgeUrl = b,
        this.sessionId = _,
        this.listener = $,
        this.errorsListener = et,
        this.ssePath = "events",
        this.postPath = "message",
        this.heartbeatMessage = "heartbeat",
        this.defaultTtl = 300,
        this.defaultReconnectDelay = 5e3,
        this.eventSource = createResource$1((tt,rt)=>__awaiter(this, void 0, void 0, function*() {
            const nt = {
                bridgeUrl: this.bridgeUrl,
                ssePath: this.ssePath,
                sessionId: this.sessionId,
                bridgeGatewayStorage: this.bridgeGatewayStorage,
                errorHandler: this.errorsHandler.bind(this),
                messageHandler: this.messagesHandler.bind(this),
                signal: tt,
                openingDeadlineMS: rt
            };
            return yield createEventSource(nt)
        }), tt=>__awaiter(this, void 0, void 0, function*() {
            tt.close()
        })),
        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(g,b)
    }
    get isReady() {
        const g = this.eventSource.current();
        return (g == null ? void 0 : g.readyState) === EventSource.OPEN
    }
    get isClosed() {
        const g = this.eventSource.current();
        return (g == null ? void 0 : g.readyState) !== EventSource.OPEN
    }
    get isConnecting() {
        const g = this.eventSource.current();
        return (g == null ? void 0 : g.readyState) === EventSource.CONNECTING
    }
    registerSession(g) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.create(g == null ? void 0 : g.signal, g == null ? void 0 : g.openingDeadlineMS)
        })
    }
    send(g, b, _, $) {
        var et;
        return __awaiter(this, void 0, void 0, function*() {
            const tt = {};
            typeof $ == "number" ? tt.ttl = $ : (tt.ttl = $ == null ? void 0 : $.ttl,
            tt.signal = $ == null ? void 0 : $.signal,
            tt.attempts = $ == null ? void 0 : $.attempts);
            const rt = new URL(addPathToUrl(this.bridgeUrl, this.postPath));
            rt.searchParams.append("client_id", this.sessionId),
            rt.searchParams.append("to", b),
            rt.searchParams.append("ttl", ((tt == null ? void 0 : tt.ttl) || this.defaultTtl).toString()),
            rt.searchParams.append("topic", _);
            const nt = Base64.encode(g);
            yield callForSuccess(it=>__awaiter(this, void 0, void 0, function*() {
                const ot = yield this.post(rt, nt, it.signal);
                if (!ot.ok)
                    throw new TonConnectError(`Bridge send failed, status ${ot.status}`)
            }), {
                attempts: (et = tt == null ? void 0 : tt.attempts) !== null && et !== void 0 ? et : Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: tt == null ? void 0 : tt.signal
            })
        })
    }
    pause() {
        this.eventSource.dispose().catch(g=>logError$1(`Bridge pause failed, ${g}`))
    }
    unPause() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.recreate(0)
        })
    }
    close() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventSource.dispose().catch(g=>logError$1(`Bridge close failed, ${g}`))
        })
    }
    setListener(g) {
        this.listener = g
    }
    setErrorsListener(g) {
        this.errorsListener = g
    }
    post(g, b, _) {
        return __awaiter(this, void 0, void 0, function*() {
            const $ = yield fetch(g, {
                method: "post",
                body: b,
                signal: _
            });
            if (!$.ok)
                throw new TonConnectError(`Bridge send failed, status ${$.status}`);
            return $
        })
    }
    errorsHandler(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.isConnecting) {
                logError$1("Bridge error", JSON.stringify(b));
                return
            }
            if (this.isReady) {
                try {
                    this.errorsListener(b)
                } catch {}
                return
            }
            if (this.isClosed)
                return g.close(),
                logDebug$1(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`),
                yield this.eventSource.recreate(this.defaultReconnectDelay);
            throw new TonConnectError("Bridge error, unknown state")
        })
    }
    messagesHandler(g) {
        return __awaiter(this, void 0, void 0, function*() {
            if (g.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(g.lastEventId),
            this.isClosed))
                return;
            let b;
            try {
                b = JSON.parse(g.data)
            } catch (_) {
                throw new TonConnectError(`Bridge message parse failed, message ${_.data}`)
            }
            this.listener(b)
        })
    }
}
function createEventSource(d) {
    return __awaiter(this, void 0, void 0, function*() {
        return yield timeout$1((g,b,_)=>__awaiter(this, void 0, void 0, function*() {
            var $;
            const tt = createAbortController(_.signal).signal;
            if (tt.aborted) {
                b(new TonConnectError("Bridge connection aborted"));
                return
            }
            const rt = new URL(addPathToUrl(d.bridgeUrl, d.ssePath));
            rt.searchParams.append("client_id", d.sessionId);
            const nt = yield d.bridgeGatewayStorage.getLastEventId();
            if (nt && rt.searchParams.append("last_event_id", nt),
            tt.aborted) {
                b(new TonConnectError("Bridge connection aborted"));
                return
            }
            const it = new EventSource(rt.toString());
            it.onerror = ot=>__awaiter(this, void 0, void 0, function*() {
                if (tt.aborted) {
                    it.close(),
                    b(new TonConnectError("Bridge connection aborted"));
                    return
                }
                try {
                    const at = yield d.errorHandler(it, ot);
                    at !== it && it.close(),
                    at && at !== it && g(at)
                } catch (at) {
                    it.close(),
                    b(at)
                }
            }),
            it.onopen = ()=>{
                if (tt.aborted) {
                    it.close(),
                    b(new TonConnectError("Bridge connection aborted"));
                    return
                }
                g(it)
            }
            ,
            it.onmessage = ot=>{
                if (tt.aborted) {
                    it.close(),
                    b(new TonConnectError("Bridge connection aborted"));
                    return
                }
                d.messageHandler(ot)
            }
            ,
            ($ = d.signal) === null || $ === void 0 || $.addEventListener("abort", ()=>{
                it.close(),
                b(new TonConnectError("Bridge connection aborted"))
            }
            )
        }), {
            timeout: d.openingDeadlineMS,
            signal: d.signal
        })
    })
}
function isPendingConnectionHttp(d) {
    return !("connectEvent"in d)
}
class BridgeConnectionStorage {
    constructor(g) {
        this.storage = g,
        this.storeKey = "ton-connect-storage_bridge-connection"
    }
    storeConnection(g) {
        return __awaiter(this, void 0, void 0, function*() {
            if (g.type === "injected")
                return this.storage.setItem(this.storeKey, JSON.stringify(g));
            if (!isPendingConnectionHttp(g)) {
                const _ = {
                    sessionKeyPair: g.session.sessionCrypto.stringifyKeypair(),
                    walletPublicKey: g.session.walletPublicKey,
                    bridgeUrl: g.session.bridgeUrl
                }
                  , $ = {
                    type: "http",
                    connectEvent: g.connectEvent,
                    session: _,
                    lastWalletEventId: g.lastWalletEventId,
                    nextRpcRequestId: g.nextRpcRequestId
                };
                return this.storage.setItem(this.storeKey, JSON.stringify($))
            }
            const b = {
                type: "http",
                connectionSource: g.connectionSource,
                sessionCrypto: g.sessionCrypto.stringifyKeypair()
            };
            return this.storage.setItem(this.storeKey, JSON.stringify(b))
        })
    }
    removeConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.storage.removeItem(this.storeKey)
        })
    }
    getConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.storage.getItem(this.storeKey);
            if (!g)
                return null;
            const b = JSON.parse(g);
            if (b.type === "injected")
                return b;
            if ("connectEvent"in b) {
                const _ = new SessionCrypto(b.session.sessionKeyPair);
                return {
                    type: "http",
                    connectEvent: b.connectEvent,
                    lastWalletEventId: b.lastWalletEventId,
                    nextRpcRequestId: b.nextRpcRequestId,
                    session: {
                        sessionCrypto: _,
                        bridgeUrl: b.session.bridgeUrl,
                        walletPublicKey: b.session.walletPublicKey
                    }
                }
            }
            return {
                type: "http",
                sessionCrypto: new SessionCrypto(b.sessionCrypto),
                connectionSource: b.connectionSource
            }
        })
    }
    getHttpConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            if (!g)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (g.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            return g
        })
    }
    getHttpPendingConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            if (!g)
                throw new TonConnectError("Trying to read HTTP connection source while nothing is stored");
            if (g.type === "injected")
                throw new TonConnectError("Trying to read HTTP connection source while injected connection is stored");
            if (!isPendingConnectionHttp(g))
                throw new TonConnectError("Trying to read HTTP-pending connection while http connection is stored");
            return g
        })
    }
    getInjectedConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            if (!g)
                throw new TonConnectError("Trying to read Injected bridge connection source while nothing is stored");
            if ((g == null ? void 0 : g.type) === "http")
                throw new TonConnectError("Trying to read Injected bridge connection source while HTTP connection is stored");
            return g
        })
    }
    storedConnectionType() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.storage.getItem(this.storeKey);
            return g ? JSON.parse(g).type : null
        })
    }
    storeLastWalletEventId(g) {
        return __awaiter(this, void 0, void 0, function*() {
            const b = yield this.getConnection();
            if (b && b.type === "http" && !isPendingConnectionHttp(b))
                return b.lastWalletEventId = g,
                this.storeConnection(b)
        })
    }
    getLastWalletEventId() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            if (g && "lastWalletEventId"in g)
                return g.lastWalletEventId
        })
    }
    increaseNextRpcRequestId() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            if (g && "nextRpcRequestId"in g) {
                const b = g.nextRpcRequestId || 0;
                return g.nextRpcRequestId = b + 1,
                this.storeConnection(g)
            }
        })
    }
    getNextRpcRequestId() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = yield this.getConnection();
            return g && "nextRpcRequestId"in g && g.nextRpcRequestId || 0
        })
    }
}
const PROTOCOL_VERSION = 2;
class BridgeProvider {
    constructor(g, b) {
        this.storage = g,
        this.walletConnectionSource = b,
        this.type = "http",
        this.standardUniversalLink = "tc://",
        this.pendingRequests = new Map,
        this.session = null,
        this.gateway = null,
        this.pendingGateways = [],
        this.listeners = [],
        this.defaultOpeningDeadlineMS = 5e3,
        this.connectionStorage = new BridgeConnectionStorage(g)
    }
    static fromStorage(g) {
        return __awaiter(this, void 0, void 0, function*() {
            const _ = yield new BridgeConnectionStorage(g).getHttpConnection();
            return isPendingConnectionHttp(_) ? new BridgeProvider(g,_.connectionSource) : new BridgeProvider(g,{
                bridgeUrl: _.session.bridgeUrl
            })
        })
    }
    connect(g, b) {
        var _;
        const $ = createAbortController(b == null ? void 0 : b.signal);
        (_ = this.abortController) === null || _ === void 0 || _.abort(),
        this.abortController = $,
        this.closeGateways();
        const et = new SessionCrypto;
        this.session = {
            sessionCrypto: et,
            bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        },
        this.connectionStorage.storeConnection({
            type: "http",
            connectionSource: this.walletConnectionSource,
            sessionCrypto: et
        }).then(()=>__awaiter(this, void 0, void 0, function*() {
            $.signal.aborted || (yield callForSuccess(rt=>this.openGateways(et, {
                openingDeadlineMS: b == null ? void 0 : b.openingDeadlineMS,
                signal: rt == null ? void 0 : rt.signal
            }), {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: $.signal
            }))
        }));
        const tt = "universalLink"in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
        return this.generateUniversalLink(tt, g)
    }
    restoreConnection(g) {
        var b, _;
        return __awaiter(this, void 0, void 0, function*() {
            const $ = createAbortController(g == null ? void 0 : g.signal);
            if ((b = this.abortController) === null || b === void 0 || b.abort(),
            this.abortController = $,
            $.signal.aborted)
                return;
            this.closeGateways();
            const et = yield this.connectionStorage.getHttpConnection();
            if (!et || $.signal.aborted)
                return;
            const tt = (_ = g == null ? void 0 : g.openingDeadlineMS) !== null && _ !== void 0 ? _ : this.defaultOpeningDeadlineMS;
            if (isPendingConnectionHttp(et))
                return this.session = {
                    sessionCrypto: et.sessionCrypto,
                    bridgeUrl: "bridgeUrl"in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
                },
                yield this.openGateways(et.sessionCrypto, {
                    openingDeadlineMS: tt,
                    signal: $ == null ? void 0 : $.signal
                });
            if (Array.isArray(this.walletConnectionSource))
                throw new TonConnectError("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
            if (this.session = et.session,
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,et.session.sessionCrypto.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
            !$.signal.aborted) {
                this.listeners.forEach(rt=>rt(et.connectEvent));
                try {
                    yield callForSuccess(rt=>this.gateway.registerSession({
                        openingDeadlineMS: tt,
                        signal: rt.signal
                    }), {
                        attempts: Number.MAX_SAFE_INTEGER,
                        delayMs: 5e3,
                        signal: $.signal
                    })
                } catch {
                    yield this.disconnect({
                        signal: $.signal
                    });
                    return
                }
            }
        })
    }
    sendRequest(g, b) {
        const _ = {};
        return typeof b == "function" ? _.onRequestSent = b : (_.onRequestSent = b == null ? void 0 : b.onRequestSent,
        _.signal = b == null ? void 0 : b.signal,
        _.attempts = b == null ? void 0 : b.attempts),
        new Promise(($,et)=>__awaiter(this, void 0, void 0, function*() {
            var tt;
            if (!this.gateway || !this.session || !("walletPublicKey"in this.session))
                throw new TonConnectError("Trying to send bridge request without session");
            const rt = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send http-bridge request:", Object.assign(Object.assign({}, g), {
                id: rt
            }));
            const nt = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, g), {
                id: rt
            })), hexToByteArray(this.session.walletPublicKey));
            try {
                yield this.gateway.send(nt, this.session.walletPublicKey, g.method, {
                    attempts: _ == null ? void 0 : _.attempts,
                    signal: _ == null ? void 0 : _.signal
                }),
                (tt = _ == null ? void 0 : _.onRequestSent) === null || tt === void 0 || tt.call(_),
                this.pendingRequests.set(rt.toString(), $)
            } catch (it) {
                et(it)
            }
        }))
    }
    closeConnection() {
        this.closeGateways(),
        this.listeners = [],
        this.session = null,
        this.gateway = null
    }
    disconnect(g) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise(b=>__awaiter(this, void 0, void 0, function*() {
                let _ = !1
                  , $ = null;
                const et = ()=>{
                    _ || (_ = !0,
                    this.removeBridgeAndSession().then(b))
                }
                ;
                try {
                    this.closeGateways();
                    const tt = createAbortController(g == null ? void 0 : g.signal);
                    $ = setTimeout(()=>{
                        tt.abort()
                    }
                    , this.defaultOpeningDeadlineMS),
                    yield this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, {
                        onRequestSent: et,
                        signal: tt.signal,
                        attempts: 1
                    })
                } catch (tt) {
                    logDebug$1("Disconnect error:", tt),
                    _ || this.removeBridgeAndSession().then(b)
                } finally {
                    $ && clearTimeout($),
                    et()
                }
            }))
        })
    }
    listen(g) {
        return this.listeners.push(g),
        ()=>this.listeners = this.listeners.filter(b=>b !== g)
    }
    pause() {
        var g;
        (g = this.gateway) === null || g === void 0 || g.pause(),
        this.pendingGateways.forEach(b=>b.pause())
    }
    unPause() {
        return __awaiter(this, void 0, void 0, function*() {
            const g = this.pendingGateways.map(b=>b.unPause());
            this.gateway && g.push(this.gateway.unPause()),
            yield Promise.all(g)
        })
    }
    pendingGatewaysListener(g, b, _) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.pendingGateways.includes(g)) {
                yield g.close();
                return
            }
            return this.closeGateways({
                except: g
            }),
            this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
            yield this.gateway.close()),
            this.session.bridgeUrl = b,
            this.gateway = g,
            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)),
            this.gateway.setListener(this.gatewayListener.bind(this)),
            this.gatewayListener(_)
        })
    }
    gatewayListener(g) {
        return __awaiter(this, void 0, void 0, function*() {
            const b = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(g.message).toUint8Array(), hexToByteArray(g.from)));
            if (logDebug$1("Wallet message received:", b),
            !("event"in b)) {
                const $ = b.id.toString()
                  , et = this.pendingRequests.get($);
                if (!et) {
                    logDebug$1(`Response id ${$} doesn't match any request's id`);
                    return
                }
                et(b),
                this.pendingRequests.delete($);
                return
            }
            if (b.id !== void 0) {
                const $ = yield this.connectionStorage.getLastWalletEventId();
                if ($ !== void 0 && b.id <= $) {
                    logError$1(`Received event id (=${b.id}) must be greater than stored last wallet event id (=${$}) `);
                    return
                }
                b.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(b.id))
            }
            const _ = this.listeners;
            b.event === "connect" && (yield this.updateSession(b, g.from)),
            b.event === "disconnect" && (logDebug$1("Removing bridge and session: received disconnect event"),
            yield this.removeBridgeAndSession()),
            _.forEach($=>$(b))
        })
    }
    gatewayErrorsListener(g) {
        return __awaiter(this, void 0, void 0, function*() {
            throw new TonConnectError(`Bridge error ${JSON.stringify(g)}`)
        })
    }
    updateSession(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            this.session = Object.assign(Object.assign({}, this.session), {
                walletPublicKey: b
            });
            const _ = g.payload.items.find(et=>et.name === "ton_addr")
              , $ = Object.assign(Object.assign({}, g), {
                payload: Object.assign(Object.assign({}, g.payload), {
                    items: [_]
                })
            });
            yield this.connectionStorage.storeConnection({
                type: "http",
                session: this.session,
                lastWalletEventId: g.id,
                connectEvent: $,
                nextRpcRequestId: 0
            })
        })
    }
    removeBridgeAndSession() {
        return __awaiter(this, void 0, void 0, function*() {
            this.closeConnection(),
            yield this.connectionStorage.removeConnection()
        })
    }
    generateUniversalLink(g, b) {
        return isTelegramUrl(g) ? this.generateTGUniversalLink(g, b) : this.generateRegularUniversalLink(g, b)
    }
    generateRegularUniversalLink(g, b) {
        const _ = new URL(g);
        return _.searchParams.append("v", PROTOCOL_VERSION.toString()),
        _.searchParams.append("id", this.session.sessionCrypto.sessionId),
        _.searchParams.append("r", JSON.stringify(b)),
        _.toString()
    }
    generateTGUniversalLink(g, b) {
        const $ = this.generateRegularUniversalLink("about:blank", b).split("?")[1]
          , et = "tonconnect-" + encodeTelegramUrlParameters($)
          , tt = this.convertToDirectLink(g)
          , rt = new URL(tt);
        return rt.searchParams.append("startapp", et),
        rt.toString()
    }
    convertToDirectLink(g) {
        const b = new URL(g);
        return b.searchParams.has("attach") && (b.searchParams.delete("attach"),
        b.pathname += "/start"),
        b.toString()
    }
    openGateways(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            if (Array.isArray(this.walletConnectionSource)) {
                this.pendingGateways.map(_=>_.close().catch()),
                this.pendingGateways = this.walletConnectionSource.map(_=>{
                    const $ = new BridgeGateway(this.storage,_.bridgeUrl,g.sessionId,()=>{}
                    ,()=>{}
                    );
                    return $.setListener(et=>this.pendingGatewaysListener($, _.bridgeUrl, et)),
                    $
                }
                ),
                yield Promise.allSettled(this.pendingGateways.map(_=>callForSuccess($=>this.pendingGateways.some(et=>et === _) ? _.registerSession({
                    openingDeadlineMS: b == null ? void 0 : b.openingDeadlineMS,
                    signal: $.signal
                }) : _.close(), {
                    attempts: Number.MAX_SAFE_INTEGER,
                    delayMs: 5e3,
                    signal: b == null ? void 0 : b.signal
                })));
                return
            } else
                return this.gateway && (logDebug$1("Gateway is already opened, closing previous gateway"),
                yield this.gateway.close()),
                this.gateway = new BridgeGateway(this.storage,this.walletConnectionSource.bridgeUrl,g.sessionId,this.gatewayListener.bind(this),this.gatewayErrorsListener.bind(this)),
                yield this.gateway.registerSession({
                    openingDeadlineMS: b == null ? void 0 : b.openingDeadlineMS,
                    signal: b == null ? void 0 : b.signal
                })
        })
    }
    closeGateways(g) {
        var b;
        (b = this.gateway) === null || b === void 0 || b.close(),
        this.pendingGateways.filter(_=>_ !== (g == null ? void 0 : g.except)).forEach(_=>_.close()),
        this.pendingGateways = []
    }
}
function hasProperty(d, g) {
    return hasProperties(d, [g])
}
function hasProperties(d, g) {
    return !d || typeof d != "object" ? !1 : g.every(b=>b in d)
}
function isJSBridgeWithMetadata(d) {
    try {
        return !hasProperty(d, "tonconnect") || !hasProperty(d.tonconnect, "walletInfo") ? !1 : hasProperties(d.tonconnect.walletInfo, ["name", "app_name", "image", "about_url", "platforms"])
    } catch {
        return !1
    }
}
let InMemoryStorage$1 = class Uo {
    constructor() {
        this.storage = {}
    }
    static getInstance() {
        return Uo.instance || (Uo.instance = new Uo),
        Uo.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(g) {
        var b;
        return (b = this.storage[g]) !== null && b !== void 0 ? b : null
    }
    key(g) {
        var b;
        const _ = Object.keys(this.storage);
        return g < 0 || g >= _.length ? null : (b = _[g]) !== null && b !== void 0 ? b : null
    }
    removeItem(g) {
        delete this.storage[g]
    }
    setItem(g, b) {
        this.storage[g] = b
    }
}
;
function getWindow$3() {
    if (!(typeof window > "u"))
        return window
}
function tryGetWindowKeys() {
    const d = getWindow$3();
    if (!d)
        return [];
    try {
        return Object.keys(d)
    } catch {
        return []
    }
}
function getDocument$1() {
    if (!(typeof document > "u"))
        return document
}
function getWebPageManifest() {
    var d;
    const g = (d = getWindow$3()) === null || d === void 0 ? void 0 : d.location.origin;
    return g ? g + "/tonconnect-manifest.json" : ""
}
function tryGetLocalStorage$1() {
    if (isLocalStorageAvailable$1())
        return localStorage;
    if (isNodeJs$1())
        throw new TonConnectError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage$1.getInstance()
}
function isLocalStorageAvailable$1() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs$1() {
    return typeof dist$3.process < "u" && dist$3.process.versions != null && dist$3.process.versions.node != null
}
class InjectedProvider {
    constructor(g, b) {
        this.injectedWalletKey = b,
        this.type = "injected",
        this.unsubscribeCallback = null,
        this.listenSubscriptions = !1,
        this.listeners = [];
        const _ = InjectedProvider.window;
        if (!InjectedProvider.isWindowContainsWallet(_, b))
            throw new WalletNotInjectedError;
        this.connectionStorage = new BridgeConnectionStorage(g),
        this.injectedWallet = _[b].tonconnect
    }
    static fromStorage(g) {
        return __awaiter(this, void 0, void 0, function*() {
            const _ = yield new BridgeConnectionStorage(g).getInjectedConnection();
            return new InjectedProvider(g,_.jsBridgeKey)
        })
    }
    static isWalletInjected(g) {
        return InjectedProvider.isWindowContainsWallet(this.window, g)
    }
    static isInsideWalletBrowser(g) {
        return InjectedProvider.isWindowContainsWallet(this.window, g) ? this.window[g].tonconnect.isWalletBrowser : !1
    }
    static getCurrentlyInjectedWallets() {
        return this.window ? tryGetWindowKeys().filter(([_,$])=>isJSBridgeWithMetadata($)).map(([_,$])=>({
            name: $.tonconnect.walletInfo.name,
            appName: $.tonconnect.walletInfo.app_name,
            aboutUrl: $.tonconnect.walletInfo.about_url,
            imageUrl: $.tonconnect.walletInfo.image,
            tondns: $.tonconnect.walletInfo.tondns,
            jsBridgeKey: _,
            injected: !0,
            embedded: $.tonconnect.isWalletBrowser,
            platforms: $.tonconnect.walletInfo.platforms
        })) : []
    }
    static isWindowContainsWallet(g, b) {
        return !!g && b in g && typeof g[b] == "object" && "tonconnect"in g[b]
    }
    connect(g) {
        this._connect(PROTOCOL_VERSION, g)
    }
    restoreConnection() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                logDebug$1("Injected Provider restoring connection...");
                const g = yield this.injectedWallet.restoreConnection();
                logDebug$1("Injected Provider restoring connection response", g),
                g.event === "connect" ? (this.makeSubscriptions(),
                this.listeners.forEach(b=>b(g))) : yield this.connectionStorage.removeConnection()
            } catch (g) {
                yield this.connectionStorage.removeConnection(),
                console.error(g)
            }
        })
    }
    closeConnection() {
        this.listenSubscriptions && this.injectedWallet.disconnect(),
        this.closeAllListeners()
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise(g=>{
                const b = ()=>{
                    this.closeAllListeners(),
                    this.connectionStorage.removeConnection().then(g)
                }
                ;
                try {
                    this.injectedWallet.disconnect(),
                    b()
                } catch (_) {
                    logDebug$1(_),
                    this.sendRequest({
                        method: "disconnect",
                        params: []
                    }, b)
                }
            }
            )
        })
    }
    closeAllListeners() {
        var g;
        this.listenSubscriptions = !1,
        this.listeners = [],
        (g = this.unsubscribeCallback) === null || g === void 0 || g.call(this)
    }
    listen(g) {
        return this.listeners.push(g),
        ()=>this.listeners = this.listeners.filter(b=>b !== g)
    }
    sendRequest(g, b) {
        var _;
        return __awaiter(this, void 0, void 0, function*() {
            const $ = {};
            typeof b == "function" ? $.onRequestSent = b : ($.onRequestSent = b == null ? void 0 : b.onRequestSent,
            $.signal = b == null ? void 0 : b.signal);
            const et = (yield this.connectionStorage.getNextRpcRequestId()).toString();
            yield this.connectionStorage.increaseNextRpcRequestId(),
            logDebug$1("Send injected-bridge request:", Object.assign(Object.assign({}, g), {
                id: et
            }));
            const tt = this.injectedWallet.send(Object.assign(Object.assign({}, g), {
                id: et
            }));
            return tt.then(rt=>logDebug$1("Wallet message received:", rt)),
            (_ = $ == null ? void 0 : $.onRequestSent) === null || _ === void 0 || _.call($),
            tt
        })
    }
    _connect(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                logDebug$1(`Injected Provider connect request: protocolVersion: ${g}, message:`, b);
                const _ = yield this.injectedWallet.connect(g, b);
                logDebug$1("Injected Provider connect response:", _),
                _.event === "connect" && (yield this.updateSession(),
                this.makeSubscriptions()),
                this.listeners.forEach($=>$(_))
            } catch (_) {
                logDebug$1("Injected Provider connect error:", _);
                const $ = {
                    event: "connect_error",
                    payload: {
                        code: 0,
                        message: _ == null ? void 0 : _.toString()
                    }
                };
                this.listeners.forEach(et=>et($))
            }
        })
    }
    makeSubscriptions() {
        this.listenSubscriptions = !0,
        this.unsubscribeCallback = this.injectedWallet.listen(g=>{
            logDebug$1("Wallet message received:", g),
            this.listenSubscriptions && this.listeners.forEach(b=>b(g)),
            g.event === "disconnect" && this.disconnect()
        }
        )
    }
    updateSession() {
        return this.connectionStorage.storeConnection({
            type: "injected",
            jsBridgeKey: this.injectedWalletKey,
            nextRpcRequestId: 0
        })
    }
}
InjectedProvider.window = getWindow$3();
class DefaultStorage {
    constructor() {
        this.localStorage = tryGetLocalStorage$1()
    }
    getItem(g) {
        return __awaiter(this, void 0, void 0, function*() {
            return this.localStorage.getItem(g)
        })
    }
    removeItem(g) {
        return __awaiter(this, void 0, void 0, function*() {
            this.localStorage.removeItem(g)
        })
    }
    setItem(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            this.localStorage.setItem(g, b)
        })
    }
}
function isWalletInfoCurrentlyInjected(d) {
    return isWalletInfoInjectable(d) && d.injected
}
function isWalletInfoCurrentlyEmbedded(d) {
    return isWalletInfoCurrentlyInjected(d) && d.embedded
}
function isWalletInfoInjectable(d) {
    return "jsBridgeKey"in d
}
function isWalletInfoRemote(d) {
    return "bridgeUrl"in d
}
const FALLBACK_WALLETS_LIST = [{
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }],
    platforms: ["ios", "android", "macos", "windows", "linux"]
}, {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [{
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
    }, {
        type: "js",
        key: "tonkeeper"
    }],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
}, {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [{
        type: "js",
        key: "mytonwallet"
    }, {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
    }],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
}, {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [{
        type: "js",
        key: "openmask"
    }],
    platforms: ["chrome"]
}, {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [{
        type: "js",
        key: "tonhub"
    }, {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
    }],
    platforms: ["ios", "android"]
}, {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://app.delabwallet.com/logo_black.png",
    about_url: "https://delabwallet.com",
    bridge: [{
        type: "js",
        key: "dewallet"
    }],
    platforms: ["chrome"]
}, {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [{
        type: "js",
        key: "xtonwallet"
    }],
    platforms: ["chrome", "firefox"]
}, {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [{
        type: "js",
        key: "tonwallet"
    }],
    platforms: ["chrome"]
}];
class WalletsListManager {
    constructor(g) {
        this.walletsListCache = null,
        this.walletsListCacheCreationTimestamp = null,
        this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json",
        g != null && g.walletsListSource && (this.walletsListSource = g.walletsListSource),
        g != null && g.cacheTTLMs && (this.cacheTTLMs = g.cacheTTLMs)
    }
    getWallets() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null),
            this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(),
            this.walletsListCache.then(()=>{
                this.walletsListCacheCreationTimestamp = Date.now()
            }
            ).catch(()=>{
                this.walletsListCache = null,
                this.walletsListCacheCreationTimestamp = null
            }
            )),
            this.walletsListCache
        })
    }
    getEmbeddedWallet() {
        return __awaiter(this, void 0, void 0, function*() {
            const b = (yield this.getWallets()).filter(isWalletInfoCurrentlyEmbedded);
            return b.length !== 1 ? null : b[0]
        })
    }
    fetchWalletsList() {
        return __awaiter(this, void 0, void 0, function*() {
            let g = [];
            try {
                if (g = yield(yield fetch(this.walletsListSource)).json(),
                !Array.isArray(g))
                    throw new FetchWalletsError("Wrong wallets list format, wallets list must be an array.");
                const $ = g.filter(et=>!this.isCorrectWalletConfigDTO(et));
                $.length && (logError$1(`Wallet(s) ${$.map(et=>et.name).join(", ")} config format is wrong. They were removed from the wallets list.`),
                g = g.filter(et=>this.isCorrectWalletConfigDTO(et)))
            } catch (_) {
                logError$1(_),
                g = FALLBACK_WALLETS_LIST
            }
            let b = [];
            try {
                b = InjectedProvider.getCurrentlyInjectedWallets()
            } catch (_) {
                logError$1(_)
            }
            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(g), b)
        })
    }
    walletConfigDTOListToWalletConfigList(g) {
        return g.map(b=>{
            const $ = {
                name: b.name,
                appName: b.app_name,
                imageUrl: b.image,
                aboutUrl: b.about_url,
                tondns: b.tondns,
                platforms: b.platforms
            };
            return b.bridge.forEach(et=>{
                if (et.type === "sse" && ($.bridgeUrl = et.url,
                $.universalLink = b.universal_url,
                $.deepLink = b.deepLink),
                et.type === "js") {
                    const tt = et.key;
                    $.jsBridgeKey = tt,
                    $.injected = InjectedProvider.isWalletInjected(tt),
                    $.embedded = InjectedProvider.isInsideWalletBrowser(tt)
                }
            }
            ),
            $
        }
        )
    }
    mergeWalletsLists(g, b) {
        return [...new Set(g.concat(b).map($=>$.name)).values()].map($=>{
            const et = g.find(rt=>rt.name === $)
              , tt = b.find(rt=>rt.name === $);
            return Object.assign(Object.assign({}, et && Object.assign({}, et)), tt && Object.assign({}, tt))
        }
        )
    }
    isCorrectWalletConfigDTO(g) {
        if (!g || typeof g != "object")
            return !1;
        const b = "name"in g
          , _ = "app_name"in g
          , $ = "image"in g
          , et = "about_url"in g
          , tt = "platforms"in g;
        if (!b || !$ || !et || !tt || !_ || !g.platforms || !Array.isArray(g.platforms) || !g.platforms.length || !("bridge"in g) || !Array.isArray(g.bridge) || !g.bridge.length)
            return !1;
        const rt = g.bridge;
        if (rt.some(ot=>!ot || typeof ot != "object" || !("type"in ot)))
            return !1;
        const nt = rt.find(ot=>ot.type === "sse");
        if (nt && (!("url"in nt) || !nt.url || !g.universal_url))
            return !1;
        const it = rt.find(ot=>ot.type === "js");
        return !(it && (!("key"in it) || !it.key))
    }
}
class WalletNotSupportFeatureError extends TonConnectError {
    get info() {
        return "Wallet doesn't support requested feature method."
    }
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype)
    }
}
function checkSendTransactionSupport(d, g) {
    const b = d.includes("SendTransaction")
      , _ = d.find($=>$ && typeof $ == "object" && $.name === "SendTransaction");
    if (!b && !_)
        throw new WalletNotSupportFeatureError("Wallet doesn't support SendTransaction feature.");
    if (_ && _.maxMessages !== void 0) {
        if (_.maxMessages < g.requiredMessagesNumber)
            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${_.maxMessages}, but ${g.requiredMessagesNumber} is required.`);
        return
    }
    logWarning$1("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.")
}
function createRequestVersionEvent() {
    return {
        type: "request-version"
    }
}
function createResponseVersionEvent(d) {
    return {
        type: "response-version",
        version: d
    }
}
function createVersionInfo(d) {
    return {
        ton_connect_sdk_lib: d.ton_connect_sdk_lib,
        ton_connect_ui_lib: d.ton_connect_ui_lib
    }
}
function createConnectionInfo(d, g) {
    var b, _, $, et, tt, rt, nt, it;
    const at = ((b = g == null ? void 0 : g.connectItems) === null || b === void 0 ? void 0 : b.tonProof) && "proof"in g.connectItems.tonProof ? "ton_proof" : "ton_addr";
    return {
        wallet_address: ($ = (_ = g == null ? void 0 : g.account) === null || _ === void 0 ? void 0 : _.address) !== null && $ !== void 0 ? $ : null,
        wallet_type: (et = g == null ? void 0 : g.device.appName) !== null && et !== void 0 ? et : null,
        wallet_version: (tt = g == null ? void 0 : g.device.appVersion) !== null && tt !== void 0 ? tt : null,
        auth_type: at,
        custom_data: Object.assign({
            chain_id: (nt = (rt = g == null ? void 0 : g.account) === null || rt === void 0 ? void 0 : rt.chain) !== null && nt !== void 0 ? nt : null,
            provider: (it = g == null ? void 0 : g.provider) !== null && it !== void 0 ? it : null
        }, createVersionInfo(d))
    }
}
function createConnectionStartedEvent(d) {
    return {
        type: "connection-started",
        custom_data: createVersionInfo(d)
    }
}
function createConnectionCompletedEvent(d, g) {
    return Object.assign({
        type: "connection-completed",
        is_success: !0
    }, createConnectionInfo(d, g))
}
function createConnectionErrorEvent(d, g, b) {
    return {
        type: "connection-error",
        is_success: !1,
        error_message: g,
        error_code: b ?? null,
        custom_data: createVersionInfo(d)
    }
}
function createConnectionRestoringStartedEvent(d) {
    return {
        type: "connection-restoring-started",
        custom_data: createVersionInfo(d)
    }
}
function createConnectionRestoringCompletedEvent(d, g) {
    return Object.assign({
        type: "connection-restoring-completed",
        is_success: !0
    }, createConnectionInfo(d, g))
}
function createConnectionRestoringErrorEvent(d, g) {
    return {
        type: "connection-restoring-error",
        is_success: !1,
        error_message: g,
        custom_data: createVersionInfo(d)
    }
}
function createTransactionInfo(d, g) {
    var b, _, $, et;
    return {
        valid_until: (b = String(g.validUntil)) !== null && b !== void 0 ? b : null,
        from: (et = (_ = g.from) !== null && _ !== void 0 ? _ : ($ = d == null ? void 0 : d.account) === null || $ === void 0 ? void 0 : $.address) !== null && et !== void 0 ? et : null,
        messages: g.messages.map(tt=>{
            var rt, nt;
            return {
                address: (rt = tt.address) !== null && rt !== void 0 ? rt : null,
                amount: (nt = tt.amount) !== null && nt !== void 0 ? nt : null
            }
        }
        )
    }
}
function createTransactionSentForSignatureEvent(d, g, b) {
    return Object.assign(Object.assign({
        type: "transaction-sent-for-signature"
    }, createConnectionInfo(d, g)), createTransactionInfo(g, b))
}
function createTransactionSignedEvent(d, g, b, _) {
    return Object.assign(Object.assign({
        type: "transaction-signed",
        is_success: !0,
        signed_transaction: _.boc
    }, createConnectionInfo(d, g)), createTransactionInfo(g, b))
}
function createTransactionSigningFailedEvent(d, g, b, _, $) {
    return Object.assign(Object.assign({
        type: "transaction-signing-failed",
        is_success: !1,
        error_message: _,
        error_code: $ ?? null
    }, createConnectionInfo(d, g)), createTransactionInfo(g, b))
}
function createDisconnectionEvent(d, g, b) {
    return Object.assign({
        type: "disconnection",
        scope: b
    }, createConnectionInfo(d, g))
}
class BrowserEventDispatcher {
    constructor() {
        this.window = getWindow$3()
    }
    dispatchEvent(g, b) {
        var _;
        return __awaiter(this, void 0, void 0, function*() {
            const $ = new CustomEvent(g,{
                detail: b
            });
            (_ = this.window) === null || _ === void 0 || _.dispatchEvent($)
        })
    }
    addEventListener(g, b, _) {
        var $;
        return __awaiter(this, void 0, void 0, function*() {
            return ($ = this.window) === null || $ === void 0 || $.addEventListener(g, b, _),
            ()=>{
                var et;
                return (et = this.window) === null || et === void 0 ? void 0 : et.removeEventListener(g, b)
            }
        })
    }
}
class TonConnectTracker {
    constructor(g) {
        var b;
        this.eventPrefix = "ton-connect-",
        this.tonConnectUiVersion = null,
        this.eventDispatcher = (b = g == null ? void 0 : g.eventDispatcher) !== null && b !== void 0 ? b : new BrowserEventDispatcher,
        this.tonConnectSdkVersion = g.tonConnectSdkVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectUiVersion = yield this.requestTonConnectUiVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-request-version", ()=>__awaiter(this, void 0, void 0, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", createResponseVersionEvent(this.tonConnectSdkVersion))
            }))
        })
    }
    requestTonConnectUiVersion() {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((g,b)=>__awaiter(this, void 0, void 0, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", _=>{
                        g(_.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", createRequestVersionEvent())
                } catch (_) {
                    b(_)
                }
            }))
        })
    }
    dispatchUserActionEvent(g) {
        try {
            this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${g.type}`, g).catch()
        } catch {}
    }
    trackConnectionStarted(...g) {
        try {
            const b = createConnectionStartedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionCompleted(...g) {
        try {
            const b = createConnectionCompletedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionError(...g) {
        try {
            const b = createConnectionErrorEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringStarted(...g) {
        try {
            const b = createConnectionRestoringStartedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringCompleted(...g) {
        try {
            const b = createConnectionRestoringCompletedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringError(...g) {
        try {
            const b = createConnectionRestoringErrorEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackDisconnection(...g) {
        try {
            const b = createDisconnectionEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSentForSignature(...g) {
        try {
            const b = createTransactionSentForSignatureEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSigned(...g) {
        try {
            const b = createTransactionSignedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSigningFailed(...g) {
        try {
            const b = createTransactionSigningFailedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
}
const tonConnectSdkVersion = "3.0.3";
class TonConnect {
    constructor(g) {
        if (this.walletsList = new WalletsListManager,
        this._wallet = null,
        this.provider = null,
        this.statusChangeSubscriptions = [],
        this.statusChangeErrorSubscriptions = [],
        this.dappSettings = {
            manifestUrl: (g == null ? void 0 : g.manifestUrl) || getWebPageManifest(),
            storage: (g == null ? void 0 : g.storage) || new DefaultStorage
        },
        this.walletsList = new WalletsListManager({
            walletsListSource: g == null ? void 0 : g.walletsListSource,
            cacheTTLMs: g == null ? void 0 : g.walletsListCacheTTLMs
        }),
        this.tracker = new TonConnectTracker({
            eventDispatcher: g == null ? void 0 : g.eventDispatcher,
            tonConnectSdkVersion
        }),
        !this.dappSettings.manifestUrl)
            throw new DappMetadataError("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage),
        g != null && g.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions()
    }
    static getWallets() {
        return this.walletsList.getWallets()
    }
    get connected() {
        return this._wallet !== null
    }
    get account() {
        var g;
        return ((g = this._wallet) === null || g === void 0 ? void 0 : g.account) || null
    }
    get wallet() {
        return this._wallet
    }
    set wallet(g) {
        this._wallet = g,
        this.statusChangeSubscriptions.forEach(b=>b(this._wallet))
    }
    getWallets() {
        return this.walletsList.getWallets()
    }
    onStatusChange(g, b) {
        return this.statusChangeSubscriptions.push(g),
        b && this.statusChangeErrorSubscriptions.push(b),
        ()=>{
            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(_=>_ !== g),
            b && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(_=>_ !== b))
        }
    }
    connect(g, b) {
        var _, $;
        const et = {};
        if (typeof b == "object" && "tonProof"in b && (et.request = b),
        typeof b == "object" && ("openingDeadlineMS"in b || "signal"in b || "request"in b) && (et.request = b == null ? void 0 : b.request,
        et.openingDeadlineMS = b == null ? void 0 : b.openingDeadlineMS,
        et.signal = b == null ? void 0 : b.signal),
        this.connected)
            throw new WalletAlreadyConnectedError;
        const tt = createAbortController(et == null ? void 0 : et.signal);
        if ((_ = this.abortController) === null || _ === void 0 || _.abort(),
        this.abortController = tt,
        tt.signal.aborted)
            throw new TonConnectError("Connection was aborted");
        return ($ = this.provider) === null || $ === void 0 || $.closeConnection(),
        this.provider = this.createProvider(g),
        tt.signal.addEventListener("abort", ()=>{
            var rt;
            (rt = this.provider) === null || rt === void 0 || rt.closeConnection(),
            this.provider = null
        }
        ),
        this.tracker.trackConnectionStarted(),
        this.provider.connect(this.createConnectRequest(et == null ? void 0 : et.request), {
            openingDeadlineMS: et == null ? void 0 : et.openingDeadlineMS,
            signal: tt.signal
        })
    }
    restoreConnection(g) {
        var b, _;
        return __awaiter(this, void 0, void 0, function*() {
            this.tracker.trackConnectionRestoringStarted();
            const $ = createAbortController(g == null ? void 0 : g.signal);
            if ((b = this.abortController) === null || b === void 0 || b.abort(),
            this.abortController = $,
            $.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            const [et,tt] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);
            if ($.signal.aborted) {
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            let rt = null;
            try {
                switch (et) {
                case "http":
                    rt = yield BridgeProvider.fromStorage(this.dappSettings.storage);
                    break;
                case "injected":
                    rt = yield InjectedProvider.fromStorage(this.dappSettings.storage);
                    break;
                default:
                    if (tt)
                        rt = this.createProvider(tt);
                    else
                        return
                }
            } catch {
                this.tracker.trackConnectionRestoringError("Provider is not restored"),
                yield this.bridgeConnectionStorage.removeConnection(),
                rt == null || rt.closeConnection(),
                rt = null;
                return
            }
            if ($.signal.aborted) {
                rt == null || rt.closeConnection(),
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
                return
            }
            if (!rt) {
                logError$1("Provider is not restored"),
                this.tracker.trackConnectionRestoringError("Provider is not restored");
                return
            }
            (_ = this.provider) === null || _ === void 0 || _.closeConnection(),
            this.provider = rt,
            rt.listen(this.walletEventsListener.bind(this));
            const nt = ()=>{
                this.tracker.trackConnectionRestoringError("Connection restoring was aborted"),
                rt == null || rt.closeConnection(),
                rt = null
            }
            ;
            return $.signal.addEventListener("abort", nt),
            yield callForSuccess(it=>__awaiter(this, void 0, void 0, function*() {
                yield rt == null ? void 0 : rt.restoreConnection({
                    openingDeadlineMS: g == null ? void 0 : g.openingDeadlineMS,
                    signal: it.signal
                }),
                $.signal.removeEventListener("abort", nt),
                this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed")
            }), {
                attempts: Number.MAX_SAFE_INTEGER,
                delayMs: 5e3,
                signal: g == null ? void 0 : g.signal
            })
        })
    }
    sendTransaction(g, b) {
        return __awaiter(this, void 0, void 0, function*() {
            const _ = {};
            typeof b == "function" ? _.onRequestSent = b : (_.onRequestSent = b == null ? void 0 : b.onRequestSent,
            _.signal = b == null ? void 0 : b.signal);
            const $ = createAbortController(_ == null ? void 0 : _.signal);
            if ($.signal.aborted)
                throw new TonConnectError("Transaction sending was aborted");
            this.checkConnection(),
            checkSendTransactionSupport(this.wallet.device.features, {
                requiredMessagesNumber: g.messages.length
            }),
            this.tracker.trackTransactionSentForSignature(this.wallet, g);
            const {validUntil: et} = g
              , tt = __rest(g, ["validUntil"])
              , rt = g.from || this.account.address
              , nt = g.network || this.account.chain
              , it = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tt), {
                valid_until: et,
                from: rt,
                network: nt
            })), {
                onRequestSent: _.onRequestSent,
                signal: $.signal
            });
            if (sendTransactionParser.isError(it))
                return this.tracker.trackTransactionSigningFailed(this.wallet, g, it.error.message, it.error.code),
                sendTransactionParser.parseAndThrowError(it);
            const ot = sendTransactionParser.convertFromRpcResponse(it);
            return this.tracker.trackTransactionSigned(this.wallet, g, ot),
            ot
        })
    }
    disconnect(g) {
        var b;
        return __awaiter(this, void 0, void 0, function*() {
            if (!this.connected)
                throw new WalletNotConnectedError;
            const _ = createAbortController(g == null ? void 0 : g.signal)
              , $ = this.abortController;
            if (this.abortController = _,
            _.signal.aborted)
                throw new TonConnectError("Disconnect was aborted");
            this.onWalletDisconnected("dapp"),
            yield(b = this.provider) === null || b === void 0 ? void 0 : b.disconnect({
                signal: _.signal
            }),
            $ == null || $.abort()
        })
    }
    pauseConnection() {
        var g;
        ((g = this.provider) === null || g === void 0 ? void 0 : g.type) === "http" && this.provider.pause()
    }
    unPauseConnection() {
        var g;
        return ((g = this.provider) === null || g === void 0 ? void 0 : g.type) !== "http" ? Promise.resolve() : this.provider.unPause()
    }
    addWindowFocusAndBlurSubscriptions() {
        const g = getDocument$1();
        if (g)
            try {
                g.addEventListener("visibilitychange", ()=>{
                    g.hidden ? this.pauseConnection() : this.unPauseConnection().catch()
                }
                )
            } catch (b) {
                logError$1("Cannot subscribe to the document.visibilitychange: ", b)
            }
    }
    createProvider(g) {
        let b;
        return !Array.isArray(g) && isWalletConnectionSourceJS(g) ? b = new InjectedProvider(this.dappSettings.storage,g.jsBridgeKey) : b = new BridgeProvider(this.dappSettings.storage,g),
        b.listen(this.walletEventsListener.bind(this)),
        b
    }
    walletEventsListener(g) {
        switch (g.event) {
        case "connect":
            this.onWalletConnected(g.payload);
            break;
        case "connect_error":
            this.onWalletConnectError(g.payload);
            break;
        case "disconnect":
            this.onWalletDisconnected("wallet")
        }
    }
    onWalletConnected(g) {
        const b = g.items.find(et=>et.name === "ton_addr")
          , _ = g.items.find(et=>et.name === "ton_proof");
        if (!b)
            throw new TonConnectError("ton_addr connection item was not found");
        const $ = {
            device: g.device,
            provider: this.provider.type,
            account: {
                address: b.address,
                chain: b.network,
                walletStateInit: b.walletStateInit,
                publicKey: b.publicKey
            }
        };
        _ && ($.connectItems = {
            tonProof: _
        }),
        this.wallet = $,
        this.tracker.trackConnectionCompleted($)
    }
    onWalletConnectError(g) {
        const b = connectErrorsParser.parseError(g);
        if (this.statusChangeErrorSubscriptions.forEach(_=>_(b)),
        logDebug$1(b),
        this.tracker.trackConnectionError(g.message, g.code),
        b instanceof ManifestNotFoundError || b instanceof ManifestContentErrorError)
            throw logError$1(b),
            b
    }
    onWalletDisconnected(g) {
        this.tracker.trackDisconnection(this.wallet, g),
        this.wallet = null
    }
    checkConnection() {
        if (!this.connected)
            throw new WalletNotConnectedError
    }
    createConnectRequest(g) {
        const b = [{
            name: "ton_addr"
        }];
        return g != null && g.tonProof && b.push({
            name: "ton_proof",
            payload: g.tonProof
        }),
        {
            manifestUrl: this.dappSettings.manifestUrl,
            items: b
        }
    }
}
TonConnect.walletsList = new WalletsListManager;
TonConnect.isWalletInjected = d=>InjectedProvider.isWalletInjected(d);
TonConnect.isInsideWalletBrowser = d=>InjectedProvider.isInsideWalletBrowser(d);
const noBounceableTag = 81
  , testOnlyTag = 128;
function toUserFriendlyAddress(d, g=!1) {
    const {wc: b, hex: _} = parseHexAddress(d);
    let $ = noBounceableTag;
    g && ($ |= testOnlyTag);
    const et = new Int8Array(34);
    et[0] = $,
    et[1] = b,
    et.set(_, 2);
    const tt = new Uint8Array(36);
    return tt.set(et),
    tt.set(crc16$3(et), 34),
    Base64.encode(tt).replace(/\+/g, "-").replace(/\//g, "_")
}
function parseHexAddress(d) {
    if (!d.includes(":"))
        throw new WrongAddressError(`Wrong address ${d}. Address must include ":".`);
    const g = d.split(":");
    if (g.length !== 2)
        throw new WrongAddressError(`Wrong address ${d}. Address must include ":" only once.`);
    const b = parseInt(g[0]);
    if (b !== 0 && b !== -1)
        throw new WrongAddressError(`Wrong address ${d}. WC must be eq 0 or -1, but ${b} received.`);
    const _ = g[1];
    if ((_ == null ? void 0 : _.length) !== 64)
        throw new WrongAddressError(`Wrong address ${d}. Hex part must be 64bytes length, but ${_ == null ? void 0 : _.length} received.`);
    return {
        wc: b,
        hex: hexToBytes(_)
    }
}
function crc16$3(d) {
    let b = 0;
    const _ = new Uint8Array(d.length + 2);
    _.set(d);
    for (let $ of _) {
        let et = 128;
        for (; et > 0; )
            b <<= 1,
            $ & et && (b += 1),
            et >>= 1,
            b > 65535 && (b &= 65535,
            b ^= 4129)
    }
    return new Uint8Array([Math.floor(b / 256), b % 256])
}
const toByteMap = {};
for (let d = 0; d <= 255; d++) {
    let g = d.toString(16);
    g.length < 2 && (g = "0" + g),
    toByteMap[g] = d
}
function hexToBytes(d) {
    d = d.toLowerCase();
    const g = d.length;
    if (g % 2 !== 0)
        throw new ParseHexError("Hex string must have length a multiple of 2: " + d);
    const b = g / 2
      , _ = new Uint8Array(b);
    for (let $ = 0; $ < b; $++) {
        const et = $ * 2
          , tt = d.substring(et, et + 2);
        if (!toByteMap.hasOwnProperty(tt))
            throw new ParseHexError("Invalid hex character: " + tt);
        _[$] = toByteMap[tt]
    }
    return _
}
var uaParser = {
    exports: {}
};
(function(d, g) {
    (function(b, _) {
        var $ = "1.0.38"
          , et = ""
          , tt = "?"
          , rt = "function"
          , nt = "undefined"
          , it = "object"
          , ot = "string"
          , at = "major"
          , st = "model"
          , dt = "name"
          , ft = "type"
          , ht = "vendor"
          , xt = "version"
          , lt = "architecture"
          , ct = "console"
          , ut = "mobile"
          , pt = "tablet"
          , vt = "smarttv"
          , _t = "wearable"
          , Pt = "embedded"
          , kt = 500
          , $t = "Amazon"
          , Wt = "Apple"
          , Ht = "ASUS"
          , Dt = "BlackBerry"
          , Vt = "Browser"
          , Ft = "Chrome"
          , Kt = "Edge"
          , Rt = "Firefox"
          , qt = "Google"
          , Et = "Huawei"
          , St = "LG"
          , Lt = "Microsoft"
          , Mt = "Motorola"
          , ar = "Opera"
          , wr = "Samsung"
          , Tr = "Sharp"
          , Pr = "Sony"
          , kr = "Xiaomi"
          , jr = "Zebra"
          , cr = "Facebook"
          , dr = "Chromium OS"
          , lr = "Mac OS"
          , ir = function(er, Ut) {
            var Ct = {};
            for (var yt in er)
                Ut[yt] && Ut[yt].length % 2 === 0 ? Ct[yt] = Ut[yt].concat(er[yt]) : Ct[yt] = er[yt];
            return Ct
        }
          , gr = function(er) {
            for (var Ut = {}, Ct = 0; Ct < er.length; Ct++)
                Ut[er[Ct].toUpperCase()] = er[Ct];
            return Ut
        }
          , Cr = function(er, Ut) {
            return typeof er === ot ? hr(Ut).indexOf(hr(er)) !== -1 : !1
        }
          , hr = function(er) {
            return er.toLowerCase()
        }
          , zr = function(er) {
            return typeof er === ot ? er.replace(/[^\d\.]/g, et).split(".")[0] : _
        }
          , Zr = function(er, Ut) {
            if (typeof er === ot)
                return er = er.replace(/^\s\s*/, et),
                typeof Ut === nt ? er : er.substring(0, kt)
        }
          , ln = function(er, Ut) {
            for (var Ct = 0, yt, bt, At, Gt, Qt, rr; Ct < Ut.length && !Qt; ) {
                var Er = Ut[Ct]
                  , Ur = Ut[Ct + 1];
                for (yt = bt = 0; yt < Er.length && !Qt && Er[yt]; )
                    if (Qt = Er[yt++].exec(er),
                    Qt)
                        for (At = 0; At < Ur.length; At++)
                            rr = Qt[++bt],
                            Gt = Ur[At],
                            typeof Gt === it && Gt.length > 0 ? Gt.length === 2 ? typeof Gt[1] == rt ? this[Gt[0]] = Gt[1].call(this, rr) : this[Gt[0]] = Gt[1] : Gt.length === 3 ? typeof Gt[1] === rt && !(Gt[1].exec && Gt[1].test) ? this[Gt[0]] = rr ? Gt[1].call(this, rr, Gt[2]) : _ : this[Gt[0]] = rr ? rr.replace(Gt[1], Gt[2]) : _ : Gt.length === 4 && (this[Gt[0]] = rr ? Gt[3].call(this, rr.replace(Gt[1], Gt[2])) : _) : this[Gt] = rr || _;
                Ct += 2
            }
        }
          , Gr = function(er, Ut) {
            for (var Ct in Ut)
                if (typeof Ut[Ct] === it && Ut[Ct].length > 0) {
                    for (var yt = 0; yt < Ut[Ct].length; yt++)
                        if (Cr(Ut[Ct][yt], er))
                            return Ct === tt ? _ : Ct
                } else if (Cr(Ut[Ct], er))
                    return Ct === tt ? _ : Ct;
            return er
        }
          , vn = {
            "1.0": "/8",
            "1.2": "/1",
            "1.3": "/3",
            "2.0": "/412",
            "2.0.2": "/416",
            "2.0.3": "/417",
            "2.0.4": "/419",
            "?": "/"
        }
          , fn = {
            ME: "4.90",
            "NT 3.11": "NT3.51",
            "NT 4.0": "NT4.0",
            2e3: "NT 5.0",
            XP: ["NT 5.1", "NT 5.2"],
            Vista: "NT 6.0",
            7: "NT 6.1",
            8: "NT 6.2",
            "8.1": "NT 6.3",
            10: ["NT 6.4", "NT 10.0"],
            RT: "ARM"
        }
          , Rn = {
            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [xt, [dt, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [xt, [dt, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [dt, xt], [/opios[\/ ]+([\w\.]+)/i], [xt, [dt, ar + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [xt, [dt, ar + " GX"]], [/\bopr\/([\w\.]+)/i], [xt, [dt, ar]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [xt, [dt, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [dt, xt], [/\bddg\/([\w\.]+)/i], [xt, [dt, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [xt, [dt, "UC" + Vt]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [xt, [dt, "WeChat"]], [/konqueror\/([\w\.]+)/i], [xt, [dt, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [xt, [dt, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [xt, [dt, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [xt, [dt, "Smart Lenovo " + Vt]], [/(avast|avg)\/([\w\.]+)/i], [[dt, /(.+)/, "$1 Secure " + Vt], xt], [/\bfocus\/([\w\.]+)/i], [xt, [dt, Rt + " Focus"]], [/\bopt\/([\w\.]+)/i], [xt, [dt, ar + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [xt, [dt, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [xt, [dt, "Dolphin"]], [/coast\/([\w\.]+)/i], [xt, [dt, ar + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [xt, [dt, "MIUI " + Vt]], [/fxios\/([-\w\.]+)/i], [xt, [dt, Rt]], [/\bqihu|(qi?ho?o?|360)browser/i], [[dt, "360 " + Vt]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[dt, /(.+)/, "$1 " + Vt], xt], [/samsungbrowser\/([\w\.]+)/i], [xt, [dt, wr + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[dt, /_/g, " "], xt], [/metasr[\/ ]?([\d\.]+)/i], [xt, [dt, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[dt, "Sogou Mobile"], xt], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [dt, xt], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [dt], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[dt, cr], xt], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [dt, xt], [/\bgsa\/([\w\.]+) .*safari\//i], [xt, [dt, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [xt, [dt, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [xt, [dt, Ft + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[dt, Ft + " WebView"], xt], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [xt, [dt, "Android " + Vt]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [dt, xt], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [xt, [dt, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [xt, dt], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [dt, [xt, Gr, vn]], [/(webkit|khtml)\/([\w\.]+)/i], [dt, xt], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[dt, "Netscape"], xt], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [xt, [dt, Rt + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [dt, xt], [/(cobalt)\/([\w\.]+)/i], [dt, [xt, /master.|lts./, ""]]],
            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[lt, "amd64"]], [/(ia32(?=;))/i], [[lt, hr]], [/((?:i[346]|x)86)[;\)]/i], [[lt, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[lt, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[lt, "armhf"]], [/windows (ce|mobile); ppc;/i], [[lt, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[lt, /ower/, et, hr]], [/(sun4\w)[;\)]/i], [[lt, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[lt, hr]]],
            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [st, [ht, wr], [ft, pt]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [st, [ht, wr], [ft, ut]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [st, [ht, Wt], [ft, ut]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [st, [ht, Wt], [ft, pt]], [/(macintosh);/i], [st, [ht, Wt]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [st, [ht, Tr], [ft, ut]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [st, [ht, Et], [ft, pt]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [st, [ht, Et], [ft, ut]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[st, /_/g, " "], [ht, kr], [ft, ut]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[st, /_/g, " "], [ht, kr], [ft, pt]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [st, [ht, "OPPO"], [ft, ut]], [/\b(opd2\d{3}a?) bui/i], [st, [ht, "OPPO"], [ft, pt]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [st, [ht, "Vivo"], [ft, ut]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [st, [ht, "Realme"], [ft, ut]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [st, [ht, Mt], [ft, ut]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [st, [ht, Mt], [ft, pt]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [st, [ht, St], [ft, pt]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [st, [ht, St], [ft, ut]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [st, [ht, "Lenovo"], [ft, pt]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[st, /_/g, " "], [ht, "Nokia"], [ft, ut]], [/(pixel c)\b/i], [st, [ht, qt], [ft, pt]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [st, [ht, qt], [ft, ut]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [st, [ht, Pr], [ft, ut]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[st, "Xperia Tablet"], [ht, Pr], [ft, pt]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [st, [ht, "OnePlus"], [ft, ut]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [st, [ht, $t], [ft, pt]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[st, /(.+)/g, "Fire Phone $1"], [ht, $t], [ft, ut]], [/(playbook);[-\w\),; ]+(rim)/i], [st, ht, [ft, pt]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [st, [ht, Dt], [ft, ut]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [st, [ht, Ht], [ft, pt]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [st, [ht, Ht], [ft, ut]], [/(nexus 9)/i], [st, [ht, "HTC"], [ft, pt]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [ht, [st, /_/g, " "], [ft, ut]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [st, [ht, "Acer"], [ft, pt]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [st, [ht, "Meizu"], [ft, ut]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [st, [ht, "Ulefone"], [ft, ut]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [ht, st, [ft, ut]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [ht, st, [ft, pt]], [/(surface duo)/i], [st, [ht, Lt], [ft, pt]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [st, [ht, "Fairphone"], [ft, ut]], [/(u304aa)/i], [st, [ht, "AT&T"], [ft, ut]], [/\bsie-(\w*)/i], [st, [ht, "Siemens"], [ft, ut]], [/\b(rct\w+) b/i], [st, [ht, "RCA"], [ft, pt]], [/\b(venue[\d ]{2,7}) b/i], [st, [ht, "Dell"], [ft, pt]], [/\b(q(?:mv|ta)\w+) b/i], [st, [ht, "Verizon"], [ft, pt]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [st, [ht, "Barnes & Noble"], [ft, pt]], [/\b(tm\d{3}\w+) b/i], [st, [ht, "NuVision"], [ft, pt]], [/\b(k88) b/i], [st, [ht, "ZTE"], [ft, pt]], [/\b(nx\d{3}j) b/i], [st, [ht, "ZTE"], [ft, ut]], [/\b(gen\d{3}) b.+49h/i], [st, [ht, "Swiss"], [ft, ut]], [/\b(zur\d{3}) b/i], [st, [ht, "Swiss"], [ft, pt]], [/\b((zeki)?tb.*\b) b/i], [st, [ht, "Zeki"], [ft, pt]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[ht, "Dragon Touch"], st, [ft, pt]], [/\b(ns-?\w{0,9}) b/i], [st, [ht, "Insignia"], [ft, pt]], [/\b((nxa|next)-?\w{0,9}) b/i], [st, [ht, "NextBook"], [ft, pt]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[ht, "Voice"], st, [ft, ut]], [/\b(lvtel\-)?(v1[12]) b/i], [[ht, "LvTel"], st, [ft, ut]], [/\b(ph-1) /i], [st, [ht, "Essential"], [ft, ut]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [st, [ht, "Envizen"], [ft, pt]], [/\b(trio[-\w\. ]+) b/i], [st, [ht, "MachSpeed"], [ft, pt]], [/\btu_(1491) b/i], [st, [ht, "Rotor"], [ft, pt]], [/(shield[\w ]+) b/i], [st, [ht, "Nvidia"], [ft, pt]], [/(sprint) (\w+)/i], [ht, st, [ft, ut]], [/(kin\.[onetw]{3})/i], [[st, /\./g, " "], [ht, Lt], [ft, ut]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [st, [ht, jr], [ft, pt]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [st, [ht, jr], [ft, ut]], [/smart-tv.+(samsung)/i], [ht, [ft, vt]], [/hbbtv.+maple;(\d+)/i], [[st, /^/, "SmartTV"], [ht, wr], [ft, vt]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[ht, St], [ft, vt]], [/(apple) ?tv/i], [ht, [st, Wt + " TV"], [ft, vt]], [/crkey/i], [[st, Ft + "cast"], [ht, qt], [ft, vt]], [/droid.+aft(\w+)( bui|\))/i], [st, [ht, $t], [ft, vt]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [st, [ht, Tr], [ft, vt]], [/(bravia[\w ]+)( bui|\))/i], [st, [ht, Pr], [ft, vt]], [/(mitv-\w{5}) bui/i], [st, [ht, kr], [ft, vt]], [/Hbbtv.*(technisat) (.*);/i], [ht, st, [ft, vt]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[ht, Zr], [st, Zr], [ft, vt]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[ft, vt]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [ht, st, [ft, ct]], [/droid.+; (shield) bui/i], [st, [ht, "Nvidia"], [ft, ct]], [/(playstation [345portablevi]+)/i], [st, [ht, Pr], [ft, ct]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [st, [ht, Lt], [ft, ct]], [/((pebble))app/i], [ht, st, [ft, _t]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [st, [ht, Wt], [ft, _t]], [/droid.+; (glass) \d/i], [st, [ht, qt], [ft, _t]], [/droid.+; (wt63?0{2,3})\)/i], [st, [ht, jr], [ft, _t]], [/(quest( \d| pro)?)/i], [st, [ht, cr], [ft, _t]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [ht, [ft, Pt]], [/(aeobc)\b/i], [st, [ht, $t], [ft, Pt]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [st, [ft, ut]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [st, [ft, pt]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[ft, pt]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[ft, ut]], [/(android[-\w\. ]{0,9});.+buil/i], [st, [ht, "Generic"]]],
            engine: [[/windows.+ edge\/([\w\.]+)/i], [xt, [dt, Kt + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [xt, [dt, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [dt, xt], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [xt, dt]],
            os: [[/microsoft (windows) (vista|xp)/i], [dt, xt], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [dt, [xt, Gr, fn]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[xt, Gr, fn], [dt, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[xt, /_/g, "."], [dt, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[dt, lr], [xt, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [xt, dt], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [dt, xt], [/\(bb(10);/i], [xt, [dt, Dt]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [xt, [dt, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [xt, [dt, Rt + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [xt, [dt, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [xt, [dt, "watchOS"]], [/crkey\/([\d\.]+)/i], [xt, [dt, Ft + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[dt, dr], xt], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [dt, xt], [/(sunos) ?([\w\.\d]*)/i], [[dt, "Solaris"], xt], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [dt, xt]]
        }
          , bn = function(er, Ut) {
            if (typeof er === it && (Ut = er,
            er = _),
            !(this instanceof bn))
                return new bn(er,Ut).getResult();
            var Ct = typeof b !== nt && b.navigator ? b.navigator : _
              , yt = er || (Ct && Ct.userAgent ? Ct.userAgent : et)
              , bt = Ct && Ct.userAgentData ? Ct.userAgentData : _
              , At = Ut ? ir(Rn, Ut) : Rn
              , Gt = Ct && Ct.userAgent == yt;
            return this.getBrowser = function() {
                var Qt = {};
                return Qt[dt] = _,
                Qt[xt] = _,
                ln.call(Qt, yt, At.browser),
                Qt[at] = zr(Qt[xt]),
                Gt && Ct && Ct.brave && typeof Ct.brave.isBrave == rt && (Qt[dt] = "Brave"),
                Qt
            }
            ,
            this.getCPU = function() {
                var Qt = {};
                return Qt[lt] = _,
                ln.call(Qt, yt, At.cpu),
                Qt
            }
            ,
            this.getDevice = function() {
                var Qt = {};
                return Qt[ht] = _,
                Qt[st] = _,
                Qt[ft] = _,
                ln.call(Qt, yt, At.device),
                Gt && !Qt[ft] && bt && bt.mobile && (Qt[ft] = ut),
                Gt && Qt[st] == "Macintosh" && Ct && typeof Ct.standalone !== nt && Ct.maxTouchPoints && Ct.maxTouchPoints > 2 && (Qt[st] = "iPad",
                Qt[ft] = pt),
                Qt
            }
            ,
            this.getEngine = function() {
                var Qt = {};
                return Qt[dt] = _,
                Qt[xt] = _,
                ln.call(Qt, yt, At.engine),
                Qt
            }
            ,
            this.getOS = function() {
                var Qt = {};
                return Qt[dt] = _,
                Qt[xt] = _,
                ln.call(Qt, yt, At.os),
                Gt && !Qt[dt] && bt && bt.platform && bt.platform != "Unknown" && (Qt[dt] = bt.platform.replace(/chrome os/i, dr).replace(/macos/i, lr)),
                Qt
            }
            ,
            this.getResult = function() {
                return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU()
                }
            }
            ,
            this.getUA = function() {
                return yt
            }
            ,
            this.setUA = function(Qt) {
                return yt = typeof Qt === ot && Qt.length > kt ? Zr(Qt, kt) : Qt,
                this
            }
            ,
            this.setUA(yt),
            this
        };
        bn.VERSION = $,
        bn.BROWSER = gr([dt, xt, at]),
        bn.CPU = gr([lt]),
        bn.DEVICE = gr([st, ht, ft, ct, ut, vt, pt, _t, Pt]),
        bn.ENGINE = bn.OS = gr([dt, xt]),
        d.exports && (g = d.exports = bn),
        g.UAParser = bn;
        var Un = typeof b !== nt && (b.jQuery || b.Zepto);
        if (Un && !Un.ua) {
            var zn = new bn;
            Un.ua = zn.getResult(),
            Un.ua.get = function() {
                return zn.getUA()
            }
            ,
            Un.ua.set = function(er) {
                zn.setUA(er);
                var Ut = zn.getResult();
                for (var Ct in Ut)
                    Un.ua[Ct] = Ut[Ct]
            }
        }
    }
    )(typeof window == "object" ? window : commonjsGlobal)
}
)(uaParser, uaParser.exports);
var uaParserExports = uaParser.exports;
const UAParser = getDefaultExportFromCjs(uaParserExports);
var isMergeableObject = function(g) {
    return isNonNullObject(g) && !isSpecial(g)
};
function isNonNullObject(d) {
    return !!d && typeof d == "object"
}
function isSpecial(d) {
    var g = Object.prototype.toString.call(d);
    return g === "[object RegExp]" || g === "[object Date]" || isReactElement(d)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(d) {
    return d.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(d) {
    return Array.isArray(d) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(d, g) {
    return g.clone !== !1 && g.isMergeableObject(d) ? deepmerge(emptyTarget(d), d, g) : d
}
function defaultArrayMerge(d, g, b) {
    return d.concat(g).map(function(_) {
        return cloneUnlessOtherwiseSpecified(_, b)
    })
}
function getMergeFunction(d, g) {
    if (!g.customMerge)
        return deepmerge;
    var b = g.customMerge(d);
    return typeof b == "function" ? b : deepmerge
}
function getEnumerableOwnPropertySymbols(d) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(d).filter(function(g) {
        return Object.propertyIsEnumerable.call(d, g)
    }) : []
}
function getKeys$2(d) {
    return Object.keys(d).concat(getEnumerableOwnPropertySymbols(d))
}
function propertyIsOnObject(d, g) {
    try {
        return g in d
    } catch {
        return !1
    }
}
function propertyIsUnsafe(d, g) {
    return propertyIsOnObject(d, g) && !(Object.hasOwnProperty.call(d, g) && Object.propertyIsEnumerable.call(d, g))
}
function mergeObject(d, g, b) {
    var _ = {};
    return b.isMergeableObject(d) && getKeys$2(d).forEach(function($) {
        _[$] = cloneUnlessOtherwiseSpecified(d[$], b)
    }),
    getKeys$2(g).forEach(function($) {
        propertyIsUnsafe(d, $) || (propertyIsOnObject(d, $) && b.isMergeableObject(g[$]) ? _[$] = getMergeFunction($, b)(d[$], g[$], b) : _[$] = cloneUnlessOtherwiseSpecified(g[$], b))
    }),
    _
}
function deepmerge(d, g, b) {
    b = b || {},
    b.arrayMerge = b.arrayMerge || defaultArrayMerge,
    b.isMergeableObject = b.isMergeableObject || isMergeableObject,
    b.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var _ = Array.isArray(g)
      , $ = Array.isArray(d)
      , et = _ === $;
    return et ? _ ? b.arrayMerge(d, g, b) : mergeObject(d, g, b) : cloneUnlessOtherwiseSpecified(g, b)
}
deepmerge.all = function(g, b) {
    if (!Array.isArray(g))
        throw new Error("first argument should be an array");
    return g.reduce(function(_, $) {
        return deepmerge(_, $, b)
    }, {})
}
;
var deepmerge_1 = deepmerge
  , cjs = deepmerge_1;
const deepmerge$1 = getDefaultExportFromCjs(cjs);
var __defProp$1 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (d,g,b)=>g in d ? __defProp$1(d, g, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: b
}) : d[g] = b, __spreadValues$1 = (d,g)=>{
    for (var b in g || (g = {}))
        __hasOwnProp$1.call(g, b) && __defNormalProp$1(d, b, g[b]);
    if (__getOwnPropSymbols$1)
        for (var b of __getOwnPropSymbols$1(g))
            __propIsEnum$1.call(g, b) && __defNormalProp$1(d, b, g[b]);
    return d
}
, __spreadProps = (d,g)=>__defProps(d, __getOwnPropDescs(g)), __publicField = (d,g,b)=>(__defNormalProp$1(d, typeof g != "symbol" ? g + "" : g, b),
b), __async = (d,g,b)=>new Promise((_,$)=>{
    var et = nt=>{
        try {
            rt(b.next(nt))
        } catch (it) {
            $(it)
        }
    }
      , tt = nt=>{
        try {
            rt(b.throw(nt))
        } catch (it) {
            $(it)
        }
    }
      , rt = nt=>nt.done ? _(nt.value) : Promise.resolve(nt.value).then(et, tt);
    rt((b = b.apply(d, g)).next())
}
), _a$3, _b, _c, _d, _e, _f, _g, _h;
const sharedConfig = {};
function setHydrateContext(d) {
    sharedConfig.context = d
}
const equalFn = (d,g)=>d === g
  , $PROXY = Symbol("solid-proxy")
  , $TRACK = Symbol("solid-track")
  , signalOptions = {
    equals: equalFn
};
let runEffects = runQueue;
const STALE = 1
  , PENDING = 2
  , UNOWNED = {
    owned: null,
    cleanups: null,
    context: null,
    owner: null
}
  , NO_INIT = {};
var Owner = null;
let Transition$1 = null
  , Listener = null
  , Updates = null
  , Effects = null
  , ExecCount = 0;
function createRoot(d, g) {
    const b = Listener
      , _ = Owner
      , $ = d.length === 0
      , et = $ ? UNOWNED : {
        owned: null,
        cleanups: null,
        context: null,
        owner: g === void 0 ? _ : g
    }
      , tt = $ ? d : ()=>d(()=>untrack(()=>cleanNode(et)));
    Owner = et,
    Listener = null;
    try {
        return runUpdates(tt, !0)
    } finally {
        Listener = b,
        Owner = _
    }
}
function createSignal(d, g) {
    g = g ? Object.assign({}, signalOptions, g) : signalOptions;
    const b = {
        value: d,
        observers: null,
        observerSlots: null,
        comparator: g.equals || void 0
    }
      , _ = $=>(typeof $ == "function" && ($ = $(b.value)),
    writeSignal(b, $));
    return [readSignal.bind(b), _]
}
function createComputed(d, g, b) {
    const _ = createComputation(d, g, !0, STALE);
    updateComputation(_)
}
function createRenderEffect(d, g, b) {
    const _ = createComputation(d, g, !1, STALE);
    updateComputation(_)
}
function createEffect(d, g, b) {
    runEffects = runUserEffects;
    const _ = createComputation(d, g, !1, STALE);
    _.user = !0,
    Effects ? Effects.push(_) : updateComputation(_)
}
function createMemo(d, g, b) {
    b = b ? Object.assign({}, signalOptions, b) : signalOptions;
    const _ = createComputation(d, g, !0, 0);
    return _.observers = null,
    _.observerSlots = null,
    _.comparator = b.equals || void 0,
    updateComputation(_),
    readSignal.bind(_)
}
function createResource(d, g, b) {
    let _, $, et;
    arguments.length === 2 && typeof g == "object" || arguments.length === 1 ? (_ = !0,
    $ = d,
    et = g || {}) : (_ = d,
    $ = g,
    et = b || {});
    let tt = null
      , rt = NO_INIT
      , nt = null
      , it = !1
      , ot = "initialValue"in et
      , at = typeof _ == "function" && createMemo(_);
    const st = new Set
      , [dt,ft] = (et.storage || createSignal)(et.initialValue)
      , [ht,xt] = createSignal(void 0)
      , [lt,ct] = createSignal(void 0, {
        equals: !1
    })
      , [ut,pt] = createSignal(ot ? "ready" : "unresolved");
    if (sharedConfig.context) {
        nt = `${sharedConfig.context.id}${sharedConfig.context.count++}`;
        let $t;
        et.ssrLoadFrom === "initial" ? rt = et.initialValue : sharedConfig.load && ($t = sharedConfig.load(nt)) && (rt = $t[0])
    }
    function vt($t, Wt, Ht, Dt) {
        return tt === $t && (tt = null,
        ot = !0,
        ($t === rt || Wt === rt) && et.onHydrated && queueMicrotask(()=>et.onHydrated(Dt, {
            value: Wt
        })),
        rt = NO_INIT,
        _t(Wt, Ht)),
        Wt
    }
    function _t($t, Wt) {
        runUpdates(()=>{
            Wt === void 0 && ft(()=>$t),
            pt(Wt !== void 0 ? "errored" : "ready"),
            xt(Wt);
            for (const Ht of st.keys())
                Ht.decrement();
            st.clear()
        }
        , !1)
    }
    function Pt() {
        const $t = SuspenseContext
          , Wt = dt()
          , Ht = ht();
        if (Ht !== void 0 && !tt)
            throw Ht;
        return Listener && !Listener.user && $t && createComputed(()=>{
            lt(),
            tt && ($t.resolved || st.has($t) || ($t.increment(),
            st.add($t)))
        }
        ),
        Wt
    }
    function kt($t=!0) {
        if ($t !== !1 && it)
            return;
        it = !1;
        const Wt = at ? at() : _;
        if (Wt == null || Wt === !1) {
            vt(tt, untrack(dt));
            return
        }
        const Ht = rt !== NO_INIT ? rt : untrack(()=>$(Wt, {
            value: dt(),
            refetching: $t
        }));
        return typeof Ht != "object" || !(Ht && "then"in Ht) ? (vt(tt, Ht, void 0, Wt),
        Ht) : (tt = Ht,
        it = !0,
        queueMicrotask(()=>it = !1),
        runUpdates(()=>{
            pt(ot ? "refreshing" : "pending"),
            ct()
        }
        , !1),
        Ht.then(Dt=>vt(Ht, Dt, void 0, Wt), Dt=>vt(Ht, void 0, castError(Dt), Wt)))
    }
    return Object.defineProperties(Pt, {
        state: {
            get: ()=>ut()
        },
        error: {
            get: ()=>ht()
        },
        loading: {
            get() {
                const $t = ut();
                return $t === "pending" || $t === "refreshing"
            }
        },
        latest: {
            get() {
                if (!ot)
                    return Pt();
                const $t = ht();
                if ($t && !tt)
                    throw $t;
                return dt()
            }
        }
    }),
    at ? createComputed(()=>kt(!1)) : kt(!1),
    [Pt, {
        refetch: kt,
        mutate: ft
    }]
}
function batch(d) {
    return runUpdates(d, !1)
}
function untrack(d) {
    if (Listener === null)
        return d();
    const g = Listener;
    Listener = null;
    try {
        return d()
    } finally {
        Listener = g
    }
}
function on(d, g, b) {
    const _ = Array.isArray(d);
    let $, et = b && b.defer;
    return tt=>{
        let rt;
        if (_) {
            rt = Array(d.length);
            for (let it = 0; it < d.length; it++)
                rt[it] = d[it]()
        } else
            rt = d();
        if (et) {
            et = !1;
            return
        }
        const nt = untrack(()=>g(rt, $, tt));
        return $ = rt,
        nt
    }
}
function onMount(d) {
    createEffect(()=>untrack(d))
}
function onCleanup(d) {
    return Owner === null || (Owner.cleanups === null ? Owner.cleanups = [d] : Owner.cleanups.push(d)),
    d
}
function getListener() {
    return Listener
}
function getOwner() {
    return Owner
}
function createContext(d, g) {
    const b = Symbol("context");
    return {
        id: b,
        Provider: createProvider(b),
        defaultValue: d
    }
}
function useContext(d) {
    let g;
    return (g = lookup(Owner, d.id)) !== void 0 ? g : d.defaultValue
}
function children(d) {
    const g = createMemo(d)
      , b = createMemo(()=>resolveChildren(g()));
    return b.toArray = ()=>{
        const _ = b();
        return Array.isArray(_) ? _ : _ != null ? [_] : []
    }
    ,
    b
}
let SuspenseContext;
function readSignal() {
    const d = Transition$1;
    if (this.sources && (this.state || d))
        if (this.state === STALE || d)
            updateComputation(this);
        else {
            const g = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(this), !1),
            Updates = g
        }
    if (Listener) {
        const g = this.observers ? this.observers.length : 0;
        Listener.sources ? (Listener.sources.push(this),
        Listener.sourceSlots.push(g)) : (Listener.sources = [this],
        Listener.sourceSlots = [g]),
        this.observers ? (this.observers.push(Listener),
        this.observerSlots.push(Listener.sources.length - 1)) : (this.observers = [Listener],
        this.observerSlots = [Listener.sources.length - 1])
    }
    return this.value
}
function writeSignal(d, g, b) {
    let _ = d.value;
    return (!d.comparator || !d.comparator(_, g)) && (d.value = g,
    d.observers && d.observers.length && runUpdates(()=>{
        for (let $ = 0; $ < d.observers.length; $ += 1) {
            const et = d.observers[$]
              , tt = Transition$1 && Transition$1.running;
            tt && Transition$1.disposed.has(et),
            (tt && !et.tState || !tt && !et.state) && (et.pure ? Updates.push(et) : Effects.push(et),
            et.observers && markDownstream(et)),
            tt || (et.state = STALE)
        }
        if (Updates.length > 1e6)
            throw Updates = [],
            new Error
    }
    , !1)),
    g
}
function updateComputation(d) {
    if (!d.fn)
        return;
    cleanNode(d);
    const g = Owner
      , b = Listener
      , _ = ExecCount;
    Listener = Owner = d,
    runComputation(d, d.value, _),
    Listener = b,
    Owner = g
}
function runComputation(d, g, b) {
    let _;
    try {
        _ = d.fn(g)
    } catch ($) {
        d.pure && (d.state = STALE,
        d.owned && d.owned.forEach(cleanNode),
        d.owned = null),
        handleError($)
    }
    (!d.updatedAt || d.updatedAt <= b) && (d.updatedAt != null && "observers"in d ? writeSignal(d, _) : d.value = _,
    d.updatedAt = b)
}
function createComputation(d, g, b, _=STALE, $) {
    const et = {
        fn: d,
        state: _,
        updatedAt: null,
        owned: null,
        sources: null,
        sourceSlots: null,
        cleanups: null,
        value: g,
        owner: Owner,
        context: null,
        pure: b
    };
    return Owner === null || Owner !== UNOWNED && (Owner.owned ? Owner.owned.push(et) : Owner.owned = [et]),
    et
}
function runTop(d) {
    const g = Transition$1;
    if (d.state === 0 || g)
        return;
    if (d.state === PENDING || g)
        return lookUpstream(d);
    if (d.suspense && untrack(d.suspense.inFallback))
        return d.suspense.effects.push(d);
    const b = [d];
    for (; (d = d.owner) && (!d.updatedAt || d.updatedAt < ExecCount); )
        (d.state || g) && b.push(d);
    for (let _ = b.length - 1; _ >= 0; _--)
        if (d = b[_],
        d.state === STALE || g)
            updateComputation(d);
        else if (d.state === PENDING || g) {
            const $ = Updates;
            Updates = null,
            runUpdates(()=>lookUpstream(d, b[0]), !1),
            Updates = $
        }
}
function runUpdates(d, g) {
    if (Updates)
        return d();
    let b = !1;
    g || (Updates = []),
    Effects ? b = !0 : Effects = [],
    ExecCount++;
    try {
        const _ = d();
        return completeUpdates(b),
        _
    } catch (_) {
        b || (Effects = null),
        Updates = null,
        handleError(_)
    }
}
function completeUpdates(d) {
    if (Updates && (runQueue(Updates),
    Updates = null),
    d)
        return;
    const g = Effects;
    Effects = null,
    g.length && runUpdates(()=>runEffects(g), !1)
}
function runQueue(d) {
    for (let g = 0; g < d.length; g++)
        runTop(d[g])
}
function runUserEffects(d) {
    let g, b = 0;
    for (g = 0; g < d.length; g++) {
        const _ = d[g];
        _.user ? d[b++] = _ : runTop(_)
    }
    for (sharedConfig.context && setHydrateContext(),
    g = 0; g < b; g++)
        runTop(d[g])
}
function lookUpstream(d, g) {
    const b = Transition$1;
    d.state = 0;
    for (let _ = 0; _ < d.sources.length; _ += 1) {
        const $ = d.sources[_];
        $.sources && ($.state === STALE || b ? $ !== g && runTop($) : ($.state === PENDING || b) && lookUpstream($, g))
    }
}
function markDownstream(d) {
    const g = Transition$1;
    for (let b = 0; b < d.observers.length; b += 1) {
        const _ = d.observers[b];
        (!_.state || g) && (_.state = PENDING,
        _.pure ? Updates.push(_) : Effects.push(_),
        _.observers && markDownstream(_))
    }
}
function cleanNode(d) {
    let g;
    if (d.sources)
        for (; d.sources.length; ) {
            const b = d.sources.pop()
              , _ = d.sourceSlots.pop()
              , $ = b.observers;
            if ($ && $.length) {
                const et = $.pop()
                  , tt = b.observerSlots.pop();
                _ < $.length && (et.sourceSlots[tt] = _,
                $[_] = et,
                b.observerSlots[_] = tt)
            }
        }
    if (d.owned) {
        for (g = 0; g < d.owned.length; g++)
            cleanNode(d.owned[g]);
        d.owned = null
    }
    if (d.cleanups) {
        for (g = 0; g < d.cleanups.length; g++)
            d.cleanups[g]();
        d.cleanups = null
    }
    d.state = 0,
    d.context = null
}
function castError(d) {
    return d instanceof Error || typeof d == "string" ? d : new Error("Unknown error")
}
function handleError(d) {
    throw d = castError(d),
    d
}
function lookup(d, g) {
    return d ? d.context && d.context[g] !== void 0 ? d.context[g] : lookup(d.owner, g) : void 0
}
function resolveChildren(d) {
    if (typeof d == "function" && !d.length)
        return resolveChildren(d());
    if (Array.isArray(d)) {
        const g = [];
        for (let b = 0; b < d.length; b++) {
            const _ = resolveChildren(d[b]);
            Array.isArray(_) ? g.push.apply(g, _) : g.push(_)
        }
        return g
    }
    return d
}
function createProvider(d, g) {
    return function(_) {
        let $;
        return createRenderEffect(()=>$ = untrack(()=>(Owner.context = {
            [d]: _.value
        },
        children(()=>_.children))), void 0),
        $
    }
}
const FALLBACK = Symbol("fallback");
function dispose(d) {
    for (let g = 0; g < d.length; g++)
        d[g]()
}
function mapArray(d, g, b={}) {
    let _ = []
      , $ = []
      , et = []
      , tt = 0
      , rt = g.length > 1 ? [] : null;
    return onCleanup(()=>dispose(et)),
    ()=>{
        let nt = d() || [], it, ot;
        return nt[$TRACK],
        untrack(()=>{
            let st = nt.length, dt, ft, ht, xt, lt, ct, ut, pt, vt;
            if (st === 0)
                tt !== 0 && (dispose(et),
                et = [],
                _ = [],
                $ = [],
                tt = 0,
                rt && (rt = [])),
                b.fallback && (_ = [FALLBACK],
                $[0] = createRoot(_t=>(et[0] = _t,
                b.fallback())),
                tt = 1);
            else if (tt === 0) {
                for ($ = new Array(st),
                ot = 0; ot < st; ot++)
                    _[ot] = nt[ot],
                    $[ot] = createRoot(at);
                tt = st
            } else {
                for (ht = new Array(st),
                xt = new Array(st),
                rt && (lt = new Array(st)),
                ct = 0,
                ut = Math.min(tt, st); ct < ut && _[ct] === nt[ct]; ct++)
                    ;
                for (ut = tt - 1,
                pt = st - 1; ut >= ct && pt >= ct && _[ut] === nt[pt]; ut--,
                pt--)
                    ht[pt] = $[ut],
                    xt[pt] = et[ut],
                    rt && (lt[pt] = rt[ut]);
                for (dt = new Map,
                ft = new Array(pt + 1),
                ot = pt; ot >= ct; ot--)
                    vt = nt[ot],
                    it = dt.get(vt),
                    ft[ot] = it === void 0 ? -1 : it,
                    dt.set(vt, ot);
                for (it = ct; it <= ut; it++)
                    vt = _[it],
                    ot = dt.get(vt),
                    ot !== void 0 && ot !== -1 ? (ht[ot] = $[it],
                    xt[ot] = et[it],
                    rt && (lt[ot] = rt[it]),
                    ot = ft[ot],
                    dt.set(vt, ot)) : et[it]();
                for (ot = ct; ot < st; ot++)
                    ot in ht ? ($[ot] = ht[ot],
                    et[ot] = xt[ot],
                    rt && (rt[ot] = lt[ot],
                    rt[ot](ot))) : $[ot] = createRoot(at);
                $ = $.slice(0, tt = st),
                _ = nt.slice(0)
            }
            return $
        }
        );
        function at(st) {
            if (et[ot] = st,
            rt) {
                const [dt,ft] = createSignal(ot);
                return rt[ot] = ft,
                g(nt[ot], dt)
            }
            return g(nt[ot])
        }
    }
}
function createComponent(d, g) {
    return untrack(()=>d(g || {}))
}
function trueFn() {
    return !0
}
const propTraps = {
    get(d, g, b) {
        return g === $PROXY ? b : d.get(g)
    },
    has(d, g) {
        return g === $PROXY ? !0 : d.has(g)
    },
    set: trueFn,
    deleteProperty: trueFn,
    getOwnPropertyDescriptor(d, g) {
        return {
            configurable: !0,
            enumerable: !0,
            get() {
                return d.get(g)
            },
            set: trueFn,
            deleteProperty: trueFn
        }
    },
    ownKeys(d) {
        return d.keys()
    }
};
function resolveSource(d) {
    return (d = typeof d == "function" ? d() : d) ? d : {}
}
function mergeProps(...d) {
    let g = !1;
    for (let _ = 0; _ < d.length; _++) {
        const $ = d[_];
        g = g || !!$ && $PROXY in $,
        d[_] = typeof $ == "function" ? (g = !0,
        createMemo($)) : $
    }
    if (g)
        return new Proxy({
            get(_) {
                for (let $ = d.length - 1; $ >= 0; $--) {
                    const et = resolveSource(d[$])[_];
                    if (et !== void 0)
                        return et
                }
            },
            has(_) {
                for (let $ = d.length - 1; $ >= 0; $--)
                    if (_ in resolveSource(d[$]))
                        return !0;
                return !1
            },
            keys() {
                const _ = [];
                for (let $ = 0; $ < d.length; $++)
                    _.push(...Object.keys(resolveSource(d[$])));
                return [...new Set(_)]
            }
        },propTraps);
    const b = {};
    for (let _ = d.length - 1; _ >= 0; _--)
        if (d[_]) {
            const $ = Object.getOwnPropertyDescriptors(d[_]);
            for (const et in $)
                et in b || Object.defineProperty(b, et, {
                    enumerable: !0,
                    get() {
                        for (let tt = d.length - 1; tt >= 0; tt--) {
                            const rt = (d[tt] || {})[et];
                            if (rt !== void 0)
                                return rt
                        }
                    }
                })
        }
    return b
}
function splitProps(d, ...g) {
    const b = new Set(g.flat());
    if ($PROXY in d) {
        const $ = g.map(et=>new Proxy({
            get(tt) {
                return et.includes(tt) ? d[tt] : void 0
            },
            has(tt) {
                return et.includes(tt) && tt in d
            },
            keys() {
                return et.filter(tt=>tt in d)
            }
        },propTraps));
        return $.push(new Proxy({
            get(et) {
                return b.has(et) ? void 0 : d[et]
            },
            has(et) {
                return b.has(et) ? !1 : et in d
            },
            keys() {
                return Object.keys(d).filter(et=>!b.has(et))
            }
        },propTraps)),
        $
    }
    const _ = Object.getOwnPropertyDescriptors(d);
    return g.push(Object.keys(_).filter($=>!b.has($))),
    g.map($=>{
        const et = {};
        for (let tt = 0; tt < $.length; tt++) {
            const rt = $[tt];
            rt in d && Object.defineProperty(et, rt, _[rt] ? _[rt] : {
                get() {
                    return d[rt]
                },
                set() {
                    return !0
                },
                enumerable: !0
            })
        }
        return et
    }
    )
}
function For(d) {
    const g = "fallback"in d && {
        fallback: ()=>d.fallback
    };
    return createMemo(mapArray(()=>d.each, d.children, g || void 0))
}
function Show(d) {
    let g = !1;
    const b = d.keyed
      , _ = createMemo(()=>d.when, void 0, {
        equals: ($,et)=>g ? $ === et : !$ == !et
    });
    return createMemo(()=>{
        const $ = _();
        if ($) {
            const et = d.children
              , tt = typeof et == "function" && et.length > 0;
            return g = b || tt,
            tt ? untrack(()=>et($)) : et
        }
        return d.fallback
    }
    , void 0, void 0)
}
function Switch(d) {
    let g = !1
      , b = !1;
    const _ = (tt,rt)=>tt[0] === rt[0] && (g ? tt[1] === rt[1] : !tt[1] == !rt[1]) && tt[2] === rt[2]
      , $ = children(()=>d.children)
      , et = createMemo(()=>{
        let tt = $();
        Array.isArray(tt) || (tt = [tt]);
        for (let rt = 0; rt < tt.length; rt++) {
            const nt = tt[rt].when;
            if (nt)
                return b = !!tt[rt].keyed,
                [rt, nt, tt[rt]]
        }
        return [-1]
    }
    , void 0, {
        equals: _
    });
    return createMemo(()=>{
        const [tt,rt,nt] = et();
        if (tt < 0)
            return d.fallback;
        const it = nt.children
          , ot = typeof it == "function" && it.length > 0;
        return g = b || ot,
        ot ? untrack(()=>it(rt)) : it
    }
    , void 0, void 0)
}
function Match(d) {
    return d
}
const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"]
  , Properties = new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans])
  , ChildProperties = new Set(["innerHTML", "textContent", "innerText", "children"])
  , Aliases = Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for"
})
  , PropAliases = Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: "formNoValidate",
    ismap: "isMap",
    nomodule: "noModule",
    playsinline: "playsInline",
    readonly: "readOnly"
})
  , DelegatedEvents = new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"])
  , SVGElements = new Set(["altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "linearGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "set", "stop", "svg", "switch", "symbol", "text", "textPath", "tref", "tspan", "use", "view", "vkern"])
  , SVGNamespace = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(d, g, b) {
    let _ = b.length
      , $ = g.length
      , et = _
      , tt = 0
      , rt = 0
      , nt = g[$ - 1].nextSibling
      , it = null;
    for (; tt < $ || rt < et; ) {
        if (g[tt] === b[rt]) {
            tt++,
            rt++;
            continue
        }
        for (; g[$ - 1] === b[et - 1]; )
            $--,
            et--;
        if ($ === tt) {
            const ot = et < _ ? rt ? b[rt - 1].nextSibling : b[et - rt] : nt;
            for (; rt < et; )
                d.insertBefore(b[rt++], ot)
        } else if (et === rt)
            for (; tt < $; )
                (!it || !it.has(g[tt])) && g[tt].remove(),
                tt++;
        else if (g[tt] === b[et - 1] && b[rt] === g[$ - 1]) {
            const ot = g[--$].nextSibling;
            d.insertBefore(b[rt++], g[tt++].nextSibling),
            d.insertBefore(b[--et], ot),
            g[$] = b[et]
        } else {
            if (!it) {
                it = new Map;
                let at = rt;
                for (; at < et; )
                    it.set(b[at], at++)
            }
            const ot = it.get(g[tt]);
            if (ot != null)
                if (rt < ot && ot < et) {
                    let at = tt, st = 1, dt;
                    for (; ++at < $ && at < et && !((dt = it.get(g[at])) == null || dt !== ot + st); )
                        st++;
                    if (st > ot - rt) {
                        const ft = g[tt];
                        for (; rt < ot; )
                            d.insertBefore(b[rt++], ft)
                    } else
                        d.replaceChild(b[rt++], g[tt++])
                } else
                    tt++;
            else
                g[tt++].remove()
        }
    }
}
const $$EVENTS = "_$DX_DELEGATE";
function render(d, g, b, _={}) {
    let $;
    return createRoot(et=>{
        $ = et,
        g === document ? d() : insert(g, d(), g.firstChild ? null : void 0, b)
    }
    , _.owner),
    ()=>{
        $(),
        g.textContent = ""
    }
}
function template$1(d, g, b) {
    if (typeof window > "u")
        return null;
    const _ = document.createElement("template");
    _.innerHTML = d;
    let $ = _.content.firstChild;
    return b && ($ = $.firstChild),
    $
}
function delegateEvents(d, g=window.document) {
    const b = g[$$EVENTS] || (g[$$EVENTS] = new Set);
    for (let _ = 0, $ = d.length; _ < $; _++) {
        const et = d[_];
        b.has(et) || (b.add(et),
        g.addEventListener(et, eventHandler))
    }
}
function setAttribute(d, g, b) {
    b == null ? d.removeAttribute(g) : d.setAttribute(g, b)
}
function setAttributeNS(d, g, b, _) {
    _ == null ? d.removeAttributeNS(g, b) : d.setAttributeNS(g, b, _)
}
function className(d, g) {
    g == null ? d.removeAttribute("class") : d.className = g
}
function addEventListener(d, g, b, _) {
    if (_)
        Array.isArray(b) ? (d[`$$${g}`] = b[0],
        d[`$$${g}Data`] = b[1]) : d[`$$${g}`] = b;
    else if (Array.isArray(b)) {
        const $ = b[0];
        d.addEventListener(g, b[0] = et=>$.call(d, b[1], et))
    } else
        d.addEventListener(g, b)
}
function classList(d, g, b={}) {
    const _ = Object.keys(g || {})
      , $ = Object.keys(b);
    let et, tt;
    for (et = 0,
    tt = $.length; et < tt; et++) {
        const rt = $[et];
        !rt || rt === "undefined" || g[rt] || (toggleClassKey(d, rt, !1),
        delete b[rt])
    }
    for (et = 0,
    tt = _.length; et < tt; et++) {
        const rt = _[et]
          , nt = !!g[rt];
        !rt || rt === "undefined" || b[rt] === nt || !nt || (toggleClassKey(d, rt, !0),
        b[rt] = nt)
    }
    return b
}
function style(d, g, b) {
    if (!g)
        return b ? setAttribute(d, "style") : g;
    const _ = d.style;
    if (typeof g == "string")
        return _.cssText = g;
    typeof b == "string" && (_.cssText = b = void 0),
    b || (b = {}),
    g || (g = {});
    let $, et;
    for (et in b)
        g[et] == null && _.removeProperty(et),
        delete b[et];
    for (et in g)
        $ = g[et],
        $ !== b[et] && (_.setProperty(et, $),
        b[et] = $);
    return b
}
function spread(d, g={}, b, _) {
    const $ = {};
    return _ || createRenderEffect(()=>$.children = insertExpression(d, g.children, $.children)),
    createRenderEffect(()=>g.ref && g.ref(d)),
    createRenderEffect(()=>assign$2(d, g, b, !0, $, !0)),
    $
}
function use(d, g, b) {
    return untrack(()=>d(g, b))
}
function insert(d, g, b, _) {
    if (b !== void 0 && !_ && (_ = []),
    typeof g != "function")
        return insertExpression(d, g, _, b);
    createRenderEffect($=>insertExpression(d, g(), $, b), _)
}
function assign$2(d, g, b, _, $={}, et=!1) {
    g || (g = {});
    for (const tt in $)
        if (!(tt in g)) {
            if (tt === "children")
                continue;
            $[tt] = assignProp(d, tt, null, $[tt], b, et)
        }
    for (const tt in g) {
        if (tt === "children") {
            _ || insertExpression(d, g.children);
            continue
        }
        const rt = g[tt];
        $[tt] = assignProp(d, tt, rt, $[tt], b, et)
    }
}
function getNextElement(d) {
    let g, b;
    return !sharedConfig.context || !(g = sharedConfig.registry.get(b = getHydrationKey())) ? d.cloneNode(!0) : (sharedConfig.completed && sharedConfig.completed.add(g),
    sharedConfig.registry.delete(b),
    g)
}
function toPropertyName(d) {
    return d.toLowerCase().replace(/-([a-z])/g, (g,b)=>b.toUpperCase())
}
function toggleClassKey(d, g, b) {
    const _ = g.trim().split(/\s+/);
    for (let $ = 0, et = _.length; $ < et; $++)
        d.classList.toggle(_[$], b)
}
function assignProp(d, g, b, _, $, et) {
    let tt, rt, nt;
    if (g === "style")
        return style(d, b, _);
    if (g === "classList")
        return classList(d, b, _);
    if (b === _)
        return _;
    if (g === "ref")
        et || b(d);
    else if (g.slice(0, 3) === "on:") {
        const it = g.slice(3);
        _ && d.removeEventListener(it, _),
        b && d.addEventListener(it, b)
    } else if (g.slice(0, 10) === "oncapture:") {
        const it = g.slice(10);
        _ && d.removeEventListener(it, _, !0),
        b && d.addEventListener(it, b, !0)
    } else if (g.slice(0, 2) === "on") {
        const it = g.slice(2).toLowerCase()
          , ot = DelegatedEvents.has(it);
        if (!ot && _) {
            const at = Array.isArray(_) ? _[0] : _;
            d.removeEventListener(it, at)
        }
        (ot || b) && (addEventListener(d, it, b, ot),
        ot && delegateEvents([it]))
    } else if ((nt = ChildProperties.has(g)) || !$ && (PropAliases[g] || (rt = Properties.has(g))) || (tt = d.nodeName.includes("-")))
        g === "class" || g === "className" ? className(d, b) : tt && !rt && !nt ? d[toPropertyName(g)] = b : d[PropAliases[g] || g] = b;
    else {
        const it = $ && g.indexOf(":") > -1 && SVGNamespace[g.split(":")[0]];
        it ? setAttributeNS(d, it, g, b) : setAttribute(d, Aliases[g] || g, b)
    }
    return b
}
function eventHandler(d) {
    const g = `$$${d.type}`;
    let b = d.composedPath && d.composedPath()[0] || d.target;
    for (d.target !== b && Object.defineProperty(d, "target", {
        configurable: !0,
        value: b
    }),
    Object.defineProperty(d, "currentTarget", {
        configurable: !0,
        get() {
            return b || document
        }
    }),
    sharedConfig.registry && !sharedConfig.done && (sharedConfig.done = !0,
    document.querySelectorAll("[id^=pl-]").forEach(_=>{
        for (; _ && _.nodeType !== 8 && _.nodeValue !== "pl-" + d; ) {
            let $ = _.nextSibling;
            _.remove(),
            _ = $
        }
        _ && _.remove()
    }
    )); b; ) {
        const _ = b[g];
        if (_ && !b.disabled) {
            const $ = b[`${g}Data`];
            if ($ !== void 0 ? _.call(b, $, d) : _.call(b, d),
            d.cancelBubble)
                return
        }
        b = b._$host || b.parentNode || b.host
    }
}
function insertExpression(d, g, b, _, $) {
    for (sharedConfig.context && !b && (b = [...d.childNodes]); typeof b == "function"; )
        b = b();
    if (g === b)
        return b;
    const et = typeof g
      , tt = _ !== void 0;
    if (d = tt && b[0] && b[0].parentNode || d,
    et === "string" || et === "number") {
        if (sharedConfig.context)
            return b;
        if (et === "number" && (g = g.toString()),
        tt) {
            let rt = b[0];
            rt && rt.nodeType === 3 ? rt.data = g : rt = document.createTextNode(g),
            b = cleanChildren(d, b, _, rt)
        } else
            b !== "" && typeof b == "string" ? b = d.firstChild.data = g : b = d.textContent = g
    } else if (g == null || et === "boolean") {
        if (sharedConfig.context)
            return b;
        b = cleanChildren(d, b, _)
    } else {
        if (et === "function")
            return createRenderEffect(()=>{
                let rt = g();
                for (; typeof rt == "function"; )
                    rt = rt();
                b = insertExpression(d, rt, b, _)
            }
            ),
            ()=>b;
        if (Array.isArray(g)) {
            const rt = []
              , nt = b && Array.isArray(b);
            if (normalizeIncomingArray(rt, g, b, $))
                return createRenderEffect(()=>b = insertExpression(d, rt, b, _, !0)),
                ()=>b;
            if (sharedConfig.context) {
                if (!rt.length)
                    return b;
                for (let it = 0; it < rt.length; it++)
                    if (rt[it].parentNode)
                        return b = rt
            }
            if (rt.length === 0) {
                if (b = cleanChildren(d, b, _),
                tt)
                    return b
            } else
                nt ? b.length === 0 ? appendNodes(d, rt, _) : reconcileArrays(d, b, rt) : (b && cleanChildren(d),
                appendNodes(d, rt));
            b = rt
        } else if (g instanceof Node) {
            if (sharedConfig.context && g.parentNode)
                return b = tt ? [g] : g;
            if (Array.isArray(b)) {
                if (tt)
                    return b = cleanChildren(d, b, _, g);
                cleanChildren(d, b, null, g)
            } else
                b == null || b === "" || !d.firstChild ? d.appendChild(g) : d.replaceChild(g, d.firstChild);
            b = g
        }
    }
    return b
}
function normalizeIncomingArray(d, g, b, _) {
    let $ = !1;
    for (let et = 0, tt = g.length; et < tt; et++) {
        let rt = g[et]
          , nt = b && b[et];
        if (rt instanceof Node)
            d.push(rt);
        else if (!(rt == null || rt === !0 || rt === !1))
            if (Array.isArray(rt))
                $ = normalizeIncomingArray(d, rt, nt) || $;
            else if (typeof rt == "function")
                if (_) {
                    for (; typeof rt == "function"; )
                        rt = rt();
                    $ = normalizeIncomingArray(d, Array.isArray(rt) ? rt : [rt], Array.isArray(nt) ? nt : [nt]) || $
                } else
                    d.push(rt),
                    $ = !0;
            else {
                const it = String(rt);
                nt && nt.nodeType === 3 && nt.data === it ? d.push(nt) : d.push(document.createTextNode(it))
            }
    }
    return $
}
function appendNodes(d, g, b=null) {
    for (let _ = 0, $ = g.length; _ < $; _++)
        d.insertBefore(g[_], b)
}
function cleanChildren(d, g, b, _) {
    if (b === void 0)
        return d.textContent = "";
    const $ = _ || document.createTextNode("");
    if (g.length) {
        let et = !1;
        for (let tt = g.length - 1; tt >= 0; tt--) {
            const rt = g[tt];
            if ($ !== rt) {
                const nt = rt.parentNode === d;
                !et && !tt ? nt ? d.replaceChild($, rt) : d.insertBefore($, b) : nt && rt.remove()
            } else
                et = !0
        }
    } else
        d.insertBefore($, b);
    return [$]
}
function getHydrationKey() {
    const d = sharedConfig.context;
    return `${d.id}${d.count++}`
}
const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement$1(d, g=!1) {
    return g ? document.createElementNS(SVG_NAMESPACE, d) : document.createElement(d)
}
function Portal(d) {
    const {useShadow: g} = d
      , b = document.createTextNode("")
      , _ = d.mount || document.body;
    function $() {
        if (sharedConfig.context) {
            const [et,tt] = createSignal(!1);
            return queueMicrotask(()=>tt(!0)),
            ()=>et() && d.children
        } else
            return ()=>d.children
    }
    if (_ instanceof HTMLHeadElement) {
        const [et,tt] = createSignal(!1)
          , rt = ()=>tt(!0);
        createRoot(nt=>insert(_, ()=>et() ? nt() : $()(), null)),
        onCleanup(()=>{
            sharedConfig.context ? queueMicrotask(rt) : rt()
        }
        )
    } else {
        const et = createElement$1(d.isSVG ? "g" : "div", d.isSVG)
          , tt = g && et.attachShadow ? et.attachShadow({
            mode: "open"
        }) : et;
        Object.defineProperty(et, "_$host", {
            get() {
                return b.parentNode
            },
            configurable: !0
        }),
        insert(tt, $()),
        _.appendChild(et),
        d.ref && d.ref(et),
        onCleanup(()=>_.removeChild(et))
    }
    return b
}
function Dynamic(d) {
    const [g,b] = splitProps(d, ["component"])
      , _ = createMemo(()=>g.component);
    return createMemo(()=>{
        const $ = _();
        switch (typeof $) {
        case "function":
            return untrack(()=>$(b));
        case "string":
            const et = SVGElements.has($)
              , tt = sharedConfig.context ? getNextElement() : createElement$1($, et);
            return spread(tt, b, et),
            tt
        }
    }
    )
}
var THEME = (d=>(d.DARK = "DARK",
d.LIGHT = "LIGHT",
d))(THEME || {});
let e$1 = {
    data: ""
}
  , t$2 = d=>typeof window == "object" ? ((d ? d.querySelector("#_goober") : window._goober) || Object.assign((d || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : d || e$1
  , l$1 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , a = /\/\*[^]*?\*\/|  +/g
  , n$2 = /\n+/g
  , o = (d,g)=>{
    let b = ""
      , _ = ""
      , $ = "";
    for (let et in d) {
        let tt = d[et];
        et[0] == "@" ? et[1] == "i" ? b = et + " " + tt + ";" : _ += et[1] == "f" ? o(tt, et) : et + "{" + o(tt, et[1] == "k" ? "" : g) + "}" : typeof tt == "object" ? _ += o(tt, g ? g.replace(/([^,])+/g, rt=>et.replace(/(^:.*)|([^,])+/g, nt=>/&/.test(nt) ? nt.replace(/&/g, rt) : rt ? rt + " " + nt : nt)) : et) : tt != null && (et = /^--/.test(et) ? et : et.replace(/[A-Z]/g, "-$&").toLowerCase(),
        $ += o.p ? o.p(et, tt) : et + ":" + tt + ";")
    }
    return b + (g && $ ? g + "{" + $ + "}" : $) + _
}
  , c = {}
  , s = d=>{
    if (typeof d == "object") {
        let g = "";
        for (let b in d)
            g += b + s(d[b]);
        return g
    }
    return d
}
  , i$1 = (d,g,b,_,$)=>{
    let et = s(d)
      , tt = c[et] || (c[et] = (nt=>{
        let it = 0
          , ot = 11;
        for (; it < nt.length; )
            ot = 101 * ot + nt.charCodeAt(it++) >>> 0;
        return "go" + ot
    }
    )(et));
    if (!c[tt]) {
        let nt = et !== d ? d : (it=>{
            let ot, at, st = [{}];
            for (; ot = l$1.exec(it.replace(a, "")); )
                ot[4] ? st.shift() : ot[3] ? (at = ot[3].replace(n$2, " ").trim(),
                st.unshift(st[0][at] = st[0][at] || {})) : st[0][ot[1]] = ot[2].replace(n$2, " ").trim();
            return st[0]
        }
        )(d);
        c[tt] = o($ ? {
            ["@keyframes " + tt]: nt
        } : nt, b ? "" : "." + tt)
    }
    let rt = b && c.g ? c.g : null;
    return b && (c.g = c[tt]),
    ((nt,it,ot,at)=>{
        at ? it.data = it.data.replace(at, nt) : it.data.indexOf(nt) === -1 && (it.data = ot ? nt + it.data : it.data + nt)
    }
    )(c[tt], g, _, rt),
    tt
}
  , p$2 = (d,g,b)=>d.reduce((_,$,et)=>{
    let tt = g[et];
    if (tt && tt.call) {
        let rt = tt(b)
          , nt = rt && rt.props && rt.props.className || /^go/.test(rt) && rt;
        tt = nt ? "." + nt : rt && typeof rt == "object" ? rt.props ? "" : o(rt, "") : rt === !1 ? "" : rt
    }
    return _ + $ + (tt ?? "")
}
, "");
function u$2(d) {
    let g = this || {}
      , b = d.call ? d(g.p) : d;
    return i$1(b.unshift ? b.raw ? p$2(b, [].slice.call(arguments, 1), g.p) : b.reduce((_,$)=>Object.assign(_, $ && $.call ? $(g.p) : $), {}) : b, t$2(g.target), g.g, g.o, g.k)
}
u$2.bind({
    g: 1
});
let h$2 = u$2.bind({
    k: 1
});
const ThemeContext = createContext();
function ThemeProvider(d) {
    return createComponent(ThemeContext.Provider, {
        value: d.theme,
        get children() {
            return d.children
        }
    })
}
function useTheme() {
    return useContext(ThemeContext)
}
function makeStyled(d) {
    let g = this || {};
    return (...b)=>{
        const _ = $=>{
            const et = useContext(ThemeContext)
              , tt = mergeProps($, {
                theme: et
            })
              , rt = mergeProps(tt, {
                get class() {
                    const dt = tt.class
                      , ft = "class"in tt && /^go[0-9]+/.test(dt);
                    let ht = u$2.apply({
                        target: g.target,
                        o: ft,
                        p: tt,
                        g: g.g
                    }, b);
                    return [dt, ht].filter(Boolean).join(" ")
                }
            })
              , [nt,it] = splitProps(rt, ["as", "theme"])
              , ot = it
              , at = nt.as || d;
            let st;
            return typeof at == "function" ? st = at(ot) : g.g == 1 ? (st = document.createElement(at),
            spread(st, ot)) : st = Dynamic(mergeProps({
                component: at
            }, ot)),
            st
        }
        ;
        return _.class = $=>untrack(()=>u$2.apply({
            target: g.target,
            p: $,
            g: g.g
        }, b)),
        _
    }
}
const styled = new Proxy(makeStyled,{
    get(d, g) {
        return d(g)
    }
});
function createGlobalStyles() {
    const d = makeStyled.call({
        g: 1
    }, "div").apply(null, arguments);
    return function(b) {
        return d(b),
        null
    }
}
const globalStylesTag = "tc-root"
  , disableScrollClass = "tc-disable-scroll"
  , usingMouseClass = "tc-using-mouse"
  , GlobalStyles = ()=>{
    document.body.addEventListener("mousedown", ()=>document.body.classList.add(usingMouseClass)),
    document.body.addEventListener("keydown", g=>{
        g.key === "Tab" && document.body.classList.remove(usingMouseClass)
    }
    );
    const d = createGlobalStyles`
    ${globalStylesTag} * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        
        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;        
        -webkit-tap-highlight-color: transparent;
    }
    
    ${globalStylesTag} img {
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }   
 
    ${globalStylesTag} *:focus {
        outline: #08f auto 2px;
    }
    
    ${globalStylesTag} li {
        list-style: none;
    }
    
    ${globalStylesTag} button {
        outline: none;
    }
    
    body.${disableScrollClass} {
        position: fixed; 
        overflow-y: scroll;
        right: 0;
        left: 0;
    }
    
    body.${usingMouseClass} ${globalStylesTag} *:focus {
        outline: none;
    }
`;
    return createComponent(d, {})
}
;
function hexToRgb(d) {
    d[0] === "#" && (d = d.slice(1));
    const g = parseInt(d, 16)
      , b = g >> 16 & 255
      , _ = g >> 8 & 255
      , $ = g & 255;
    return [b, _, $].join(",")
}
function rgba$1(d, g) {
    return d[0] === "#" && (d = hexToRgb(d)),
    `rgba(${d}, ${g})`
}
function toPx(d) {
    return d.toString() + "px"
}
const _InMemoryStorage = class {
    constructor() {
        __publicField(this, "storage", {})
    }
    static getInstance() {
        return _InMemoryStorage.instance || (_InMemoryStorage.instance = new _InMemoryStorage),
        _InMemoryStorage.instance
    }
    get length() {
        return Object.keys(this.storage).length
    }
    clear() {
        this.storage = {}
    }
    getItem(d) {
        var g;
        return (g = this.storage[d]) != null ? g : null
    }
    key(d) {
        var g;
        const b = Object.keys(this.storage);
        return d < 0 || d >= b.length ? null : (g = b[d]) != null ? g : null
    }
    removeItem(d) {
        delete this.storage[d]
    }
    setItem(d, g) {
        this.storage[d] = g
    }
}
;
let InMemoryStorage = _InMemoryStorage;
__publicField(InMemoryStorage, "instance");
class TonConnectUIError extends TonConnectError {
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, TonConnectUIError.prototype)
    }
}
function logDebug(...d) {
    try {
        console.debug("[TON_CONNECT_UI]", ...d)
    } catch {}
}
function logError(...d) {
    try {
        console.error("[TON_CONNECT_UI]", ...d)
    } catch {}
}
function logWarning(...d) {
    try {
        console.warn("[TON_CONNECT_UI]", ...d)
    } catch {}
}
function openLink(d, g="_self") {
    logDebug("openLink", d, g),
    window.open(d, g, "noopener noreferrer")
}
function openLinkBlank(d) {
    openLink(d, "_blank")
}
function openDeeplinkWithFallback(d, g) {
    const b = ()=>{
        isBrowser$1("safari") || isOS("android") && isBrowser$1("firefox") || g()
    }
      , _ = setTimeout(()=>b(), 200);
    window.addEventListener("blur", ()=>clearTimeout(_), {
        once: !0
    }),
    openLink(d, "_self")
}
function getSystemTheme() {
    return window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches ? THEME.LIGHT : THEME.DARK
}
function subscribeToThemeChange(d) {
    const g = b=>d(b.matches ? THEME.DARK : THEME.LIGHT);
    return window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", g),
    ()=>window.matchMedia("(prefers-color-scheme: dark)").removeEventListener("change", g)
}
function disableScroll() {
    document.documentElement.scrollHeight !== document.documentElement.clientHeight && (document.body.style.top = toPx(-document.documentElement.scrollTop),
    document.body.classList.add(disableScrollClass))
}
function enableScroll() {
    document.body.classList.remove(disableScrollClass),
    document.documentElement.scrollTo({
        top: -parseFloat(getComputedStyle(document.body).top)
    }),
    document.body.style.top = "auto"
}
function fixMobileSafariActiveTransition() {
    document.body.hasAttribute("ontouchstart") || document.body.setAttribute("ontouchstart", "")
}
function defineStylesRoot() {
    customElements.define(globalStylesTag, class extends HTMLElement {
    }
    )
}
function createMacrotask(d) {
    return __async(this, null, function*() {
        yield new Promise(g=>requestAnimationFrame(g)),
        d()
    })
}
function createMacrotaskAsync(d) {
    return __async(this, null, function*() {
        return yield new Promise(g=>requestAnimationFrame(g)),
        d()
    })
}
function preloadImages(d) {
    document.readyState !== "complete" ? window.addEventListener("load", ()=>createMacrotask(()=>preloadImages(d)), {
        once: !0
    }) : d.forEach(g=>{
        const b = new window.Image;
        b.src = g
    }
    )
}
function getWindow$1() {
    if (typeof window < "u")
        return window
}
function tryGetLocalStorage() {
    if (isLocalStorageAvailable())
        return localStorage;
    if (isNodeJs())
        throw new TonConnectUIError("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
    return InMemoryStorage.getInstance()
}
function isLocalStorageAvailable() {
    try {
        return typeof localStorage < "u"
    } catch {
        return !1
    }
}
function isNodeJs() {
    return typeof dist$3.process < "u" && dist$3.process.versions != null && dist$3.process.versions.node != null
}
function getUserAgent() {
    var d, g, b;
    const _ = new UAParser().getResult()
      , $ = (d = _.os.name) == null ? void 0 : d.toLowerCase()
      , et = (g = _.device.model) == null ? void 0 : g.toLowerCase();
    let tt;
    switch (!0) {
    case et === "ipad":
        tt = "ipad";
        break;
    case $ === "ios":
        tt = "ios";
        break;
    case $ === "android":
        tt = "android";
        break;
    case $ === "mac os":
        tt = "macos";
        break;
    case $ === "linux":
        tt = "linux";
        break;
    case ($ == null ? void 0 : $.includes("windows")):
        tt = "windows";
        break
    }
    const rt = (b = _.browser.name) == null ? void 0 : b.toLowerCase();
    let nt;
    switch (!0) {
    case rt === "chrome":
        nt = "chrome";
        break;
    case rt === "firefox":
        nt = "firefox";
        break;
    case (rt == null ? void 0 : rt.includes("safari")):
        nt = "safari";
        break;
    case (rt == null ? void 0 : rt.includes("opera")):
        nt = "opera";
        break
    }
    return {
        os: tt,
        browser: nt
    }
}
function isOS(...d) {
    return d.includes(getUserAgent().os)
}
function isBrowser$1(...d) {
    return d.includes(getUserAgent().browser)
}
function toDeeplink(d, g) {
    const b = new URL(d);
    return g + b.search
}
class WalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setWalletInfo(g) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(g))
    }
    getWalletInfo() {
        const g = this.localStorage.getItem(this.storageKey);
        return g ? JSON.parse(g) : null
    }
    removeWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
class PreferredWalletStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_preferred-wallet"),
        this.localStorage = tryGetLocalStorage()
    }
    setPreferredWalletAppName(g) {
        this.localStorage.setItem(this.storageKey, g)
    }
    getPreferredWalletAppName() {
        return this.localStorage.getItem(this.storageKey) || void 0
    }
}
class LastSelectedWalletInfoStorage {
    constructor() {
        __publicField(this, "localStorage"),
        __publicField(this, "storageKey", "ton-connect-ui_last-selected-wallet-info"),
        this.localStorage = tryGetLocalStorage()
    }
    setLastSelectedWalletInfo(g) {
        this.localStorage.setItem(this.storageKey, JSON.stringify(g))
    }
    getLastSelectedWalletInfo() {
        const g = this.localStorage.getItem(this.storageKey);
        return g ? JSON.parse(g) : null
    }
    removeLastSelectedWalletInfo() {
        this.localStorage.removeItem(this.storageKey)
    }
}
const [walletsModalState,setWalletsModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getWalletsModalIsOpened = createMemo(()=>walletsModalState().status === "opened")
  , [singleWalletModalState,setSingleWalletModalState] = createSignal({
    status: "closed",
    closeReason: null
})
  , getSingleWalletModalIsOpened = createMemo(()=>singleWalletModalState().status === "opened")
  , getSingleWalletModalWalletInfo = createMemo(()=>{
    const d = singleWalletModalState();
    return d.status === "opened" ? d.walletInfo : null
}
);
let lastSelectedWalletInfoStorage = typeof window < "u" ? new LastSelectedWalletInfoStorage : void 0;
const [lastSelectedWalletInfo,_setLastSelectedWalletInfo] = createSignal((lastSelectedWalletInfoStorage == null ? void 0 : lastSelectedWalletInfoStorage.getLastSelectedWalletInfo()) || null)
  , setLastSelectedWalletInfo = d=>{
    lastSelectedWalletInfoStorage || (lastSelectedWalletInfoStorage = new LastSelectedWalletInfoStorage),
    d ? lastSelectedWalletInfoStorage.setLastSelectedWalletInfo(d) : lastSelectedWalletInfoStorage.removeLastSelectedWalletInfo(),
    _setLastSelectedWalletInfo(d)
}
  , [action,setAction] = createSignal(null)
  , common$1 = {
    close: "Close",
    openWallet: "Open wallet",
    copyLink: "Copy Link",
    linkCopied: "Link Copied",
    copied: "Copied",
    yourWallet: "Your Wallet",
    retry: "Retry",
    get: "GET",
    mobile: "Mobile",
    browserExtension: "Browser Extension",
    desktop: "Desktop"
}
  , button$1 = {
    connectWallet: "Connect Wallet",
    dropdown: {
        copy: "Copy address",
        copied: "Address copied!",
        disconnect: "Disconnect"
    }
}
  , notifications$1 = {
    confirm: {
        header: "Open {{ name }} to confirm the transaction."
    },
    transactionSent: {
        header: "Transaction sent",
        text: "Your transaction will be processed in a few seconds."
    },
    transactionCanceled: {
        header: "Transaction canceled",
        text: "There will be no changes to your account."
    }
}
  , walletItem$1 = {
    walletOn: "Wallet On",
    recent: "Recent",
    installed: "Installed",
    popular: "Popular"
}
  , walletModal$1 = {
    loading: "Loading wallets",
    wallets: "Wallets",
    mobileUniversalModal: {
        connectYourWallet: "Connect your wallet",
        openWalletOnTelegramOrSelect: "Open Wallet in Telegram or select your wallet to connect",
        openWalletOnTelegram: "Open Wallet in Telegram",
        openLink: "Open Link",
        scan: "Scan with your mobile wallet"
    },
    desktopUniversalModal: {
        connectYourWallet: "Connect your wallet",
        scan: "Scan with your mobile wallet",
        availableWallets: "Available wallets"
    },
    mobileConnectionModal: {
        showQR: "Show QR Code",
        scanQR: "Scan the QR code below with your phone’s or {{ name }}’s camera",
        continueIn: "Continue in {{ name }}…",
        connectionDeclined: "Connection declined"
    },
    desktopConnectionModal: {
        scanQR: "Scan the QR code below with your phone’s or {{ name }}’s camera",
        continueInExtension: "Continue in {{ name }} browser extension…",
        dontHaveExtension: "Seems you don't have installed {{ name }} browser extension",
        getWallet: "Get {{ name }}",
        continueOnDesktop: "Continue in {{ name }} on desktop…",
        openWalletOnTelegram: "Open Wallet in Telegram on desktop",
        connectionDeclined: "Connection declined"
    },
    infoModal: {
        whatIsAWallet: "What is a wallet",
        secureDigitalAssets: "Secure digital assets storage",
        walletProtects: "A wallet protects and manages your digital assets including TON, tokens and collectables.",
        controlIdentity: "Control your Web3 identity",
        manageIdentity: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem.",
        effortlessCryptoTransactions: "Effortless crypto transactions",
        easilySend: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications.",
        getAWallet: "Get a Wallet"
    }
}
  , actionModal$1 = {
    confirmTransaction: {
        header: "Confirm the transaction in {{ name }}",
        text: "It will only take a moment."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , en = {
    common: common$1,
    button: button$1,
    notifications: notifications$1,
    walletItem: walletItem$1,
    walletModal: walletModal$1,
    actionModal: actionModal$1
}
  , common = {
    close: "Закрыть",
    openWallet: "Открыть кошелёк",
    copyLink: "Копировать ссылку",
    linkCopied: "Ссылка скопирована",
    copied: "Ссылка скопирована",
    yourWallet: "Ваш кошелёк",
    retry: "Повторить",
    get: "Скачать",
    mobile: "Мобильный",
    browserExtension: "Расширение",
    desktop: "Десктоп"
}
  , button = {
    connectWallet: "Подключить кошелёк",
    dropdown: {
        copy: "Скопировать адрес",
        copied: "Адрес скопирован!",
        disconnect: "Отключить кошелёк"
    }
}
  , notifications = {
    confirm: {
        header: "Откройте {{ name }}, чтобы подтвердить транзакцию."
    },
    transactionSent: {
        header: "Транзакция отправлена",
        text: "Ваша транзакция будет обработана через несколько секунд."
    },
    transactionCanceled: {
        header: "Транзакция отменена",
        text: "Состояние вашего счёта не изменится."
    }
}
  , walletItem = {
    walletOn: "Wallet в",
    recent: "Недавний",
    installed: "Установлен",
    popular: "Популярен"
}
  , walletModal = {
    loading: "Кошельки загружаются",
    wallets: "Кошельки",
    mobileUniversalModal: {
        connectYourWallet: "Подключите кошелёк",
        openWalletOnTelegramOrSelect: "Подключите Wallet в Telegram или выберете кошелёк для подключения",
        openWalletOnTelegram: "Открыть Wallet в Telegram",
        openLink: "Открыть ссылку",
        scan: "Отсканируйте камерой вашего телефона"
    },
    desktopUniversalModal: {
        connectYourWallet: "Подключите кошелёк",
        scan: "Отсканируйте QR-код камерой вашего телефона",
        availableWallets: "Доступные кошельки"
    },
    mobileConnectionModal: {
        showQR: "Показать QR-код",
        scanQR: "Отсканируйте QR-код ниже камерой в приложении {{ name }}, или камерой телефона",
        continueIn: "Продолжите в {{ name }}…",
        connectionDeclined: "Подключение отклонено"
    },
    desktopConnectionModal: {
        scanQR: "Отсканируйте QR-код ниже камерой в приложении {{ name }}, или камерой телефона",
        continueInExtension: "Откройте браузерное расширение {{ name }}",
        dontHaveExtension: "Похоже, у вас не установлено браузерное расширение {{ name }}",
        getWallet: "Скачать {{ name }}",
        continueOnDesktop: "Откройте {{ name }} на компьютере…",
        openWalletOnTelegram: "Открыть Wallet в Telegram",
        connectionDeclined: "Подключение отклонено"
    },
    infoModal: {
        whatIsAWallet: "Что такое кошелёк?",
        secureDigitalAssets: "Надежное хранилище цифровых активов",
        walletProtects: "Кошелёк защищает ваши цифровые активы, включая TON, токены и предметы коллекционирования, и управляет ими.",
        controlIdentity: "Контроль своей личности Web3",
        manageIdentity: "Управляйте своей цифровой идентификацией и с легкостью получайте доступ к децентрализованным приложениям. Сохраняйте контроль над своими данными и безопасно участвуйте в экосистеме блокчейна.",
        effortlessCryptoTransactions: "Простые криптотранзакции",
        easilySend: "Легко отправляйте, получайте и отслеживайте свои криптовалюты. Оптимизируйте свои операции с помощью децентрализованных приложений.",
        getAWallet: "Скачать кошелёк"
    }
}
  , actionModal = {
    confirmTransaction: {
        header: "Подтвердите действие в {{ name }}",
        text: "Это займет пару секунд."
    },
    transactionSent: "$notifications.transactionSent",
    transactionCanceled: "$notifications.transactionCanceled"
}
  , ru = {
    common,
    button,
    notifications,
    walletItem,
    walletModal,
    actionModal
}
  , i18nDictionary = {
    en: parseDictionary(en),
    ru: parseDictionary(ru)
};
function parseDictionary(d) {
    const g = "$"
      , b = _=>{
        Object.entries(_).forEach(([$,et])=>{
            if (typeof et == "object" && et)
                return b(et);
            if (typeof et == "string") {
                if (et[0] === g) {
                    const tt = et.slice(1).split(".");
                    let rt = d;
                    tt.forEach(nt=>{
                        if (nt in rt)
                            rt = rt[nt];
                        else
                            throw new Error(`Cannot parse translations: there is no property ${nt} in translation`)
                    }
                    ),
                    _[$] = rt
                }
                et.slice(0, 2) === `\\${g}` && (_[$] = et.slice(1))
            }
        }
        )
    }
    ;
    return b(d),
    d
}
const ConnectorContext = createContext()
  , $RAW = Symbol("store-raw")
  , $NODE = Symbol("store-node")
  , $NAME = Symbol("store-name");
function wrap$1(d, g) {
    let b = d[$PROXY];
    if (!b && (Object.defineProperty(d, $PROXY, {
        value: b = new Proxy(d,proxyTraps$1)
    }),
    !Array.isArray(d))) {
        const _ = Object.keys(d)
          , $ = Object.getOwnPropertyDescriptors(d);
        for (let et = 0, tt = _.length; et < tt; et++) {
            const rt = _[et];
            $[rt].get && Object.defineProperty(d, rt, {
                enumerable: $[rt].enumerable,
                get: $[rt].get.bind(b)
            })
        }
    }
    return b
}
function isWrappable(d) {
    let g;
    return d != null && typeof d == "object" && (d[$PROXY] || !(g = Object.getPrototypeOf(d)) || g === Object.prototype || Array.isArray(d))
}
function unwrap(d, g=new Set) {
    let b, _, $, et;
    if (b = d != null && d[$RAW])
        return b;
    if (!isWrappable(d) || g.has(d))
        return d;
    if (Array.isArray(d)) {
        Object.isFrozen(d) ? d = d.slice(0) : g.add(d);
        for (let tt = 0, rt = d.length; tt < rt; tt++)
            $ = d[tt],
            (_ = unwrap($, g)) !== $ && (d[tt] = _)
    } else {
        Object.isFrozen(d) ? d = Object.assign({}, d) : g.add(d);
        const tt = Object.keys(d)
          , rt = Object.getOwnPropertyDescriptors(d);
        for (let nt = 0, it = tt.length; nt < it; nt++)
            et = tt[nt],
            !rt[et].get && ($ = d[et],
            (_ = unwrap($, g)) !== $ && (d[et] = _))
    }
    return d
}
function getDataNodes(d) {
    let g = d[$NODE];
    return g || Object.defineProperty(d, $NODE, {
        value: g = {}
    }),
    g
}
function getDataNode(d, g, b) {
    return d[g] || (d[g] = createDataNode(b))
}
function proxyDescriptor$1(d, g) {
    const b = Reflect.getOwnPropertyDescriptor(d, g);
    return !b || b.get || !b.configurable || g === $PROXY || g === $NODE || g === $NAME || (delete b.value,
    delete b.writable,
    b.get = ()=>d[$PROXY][g]),
    b
}
function trackSelf(d) {
    if (getListener()) {
        const g = getDataNodes(d);
        (g._ || (g._ = createDataNode()))()
    }
}
function ownKeys(d) {
    return trackSelf(d),
    Reflect.ownKeys(d)
}
function createDataNode(d) {
    const [g,b] = createSignal(d, {
        equals: !1,
        internal: !0
    });
    return g.$ = b,
    g
}
const proxyTraps$1 = {
    get(d, g, b) {
        if (g === $RAW)
            return d;
        if (g === $PROXY)
            return b;
        if (g === $TRACK)
            return trackSelf(d),
            b;
        const _ = getDataNodes(d)
          , $ = _.hasOwnProperty(g);
        let et = $ ? _[g]() : d[g];
        if (g === $NODE || g === "__proto__")
            return et;
        if (!$) {
            const tt = Object.getOwnPropertyDescriptor(d, g);
            getListener() && (typeof et != "function" || d.hasOwnProperty(g)) && !(tt && tt.get) && (et = getDataNode(_, g, et)())
        }
        return isWrappable(et) ? wrap$1(et) : et
    },
    has(d, g) {
        return g === $RAW || g === $PROXY || g === $TRACK || g === $NODE || g === "__proto__" ? !0 : (this.get(d, g, d),
        g in d)
    },
    set() {
        return !0
    },
    deleteProperty() {
        return !0
    },
    ownKeys,
    getOwnPropertyDescriptor: proxyDescriptor$1
};
function setProperty(d, g, b, _=!1) {
    if (!_ && d[g] === b)
        return;
    const $ = d[g]
      , et = d.length;
    b === void 0 ? delete d[g] : d[g] = b;
    let tt = getDataNodes(d), rt;
    (rt = getDataNode(tt, g, $)) && rt.$(()=>b),
    Array.isArray(d) && d.length !== et && (rt = getDataNode(tt, "length", et)) && rt.$(d.length),
    (rt = tt._) && rt.$()
}
function mergeStoreNode(d, g) {
    const b = Object.keys(g);
    for (let _ = 0; _ < b.length; _ += 1) {
        const $ = b[_];
        setProperty(d, $, g[$])
    }
}
function updateArray(d, g) {
    if (typeof g == "function" && (g = g(d)),
    g = unwrap(g),
    Array.isArray(g)) {
        if (d === g)
            return;
        let b = 0
          , _ = g.length;
        for (; b < _; b++) {
            const $ = g[b];
            d[b] !== $ && setProperty(d, b, $)
        }
        setProperty(d, "length", _)
    } else
        mergeStoreNode(d, g)
}
function updatePath(d, g, b=[]) {
    let _, $ = d;
    if (g.length > 1) {
        _ = g.shift();
        const tt = typeof _
          , rt = Array.isArray(d);
        if (Array.isArray(_)) {
            for (let nt = 0; nt < _.length; nt++)
                updatePath(d, [_[nt]].concat(g), b);
            return
        } else if (rt && tt === "function") {
            for (let nt = 0; nt < d.length; nt++)
                _(d[nt], nt) && updatePath(d, [nt].concat(g), b);
            return
        } else if (rt && tt === "object") {
            const {from: nt=0, to: it=d.length - 1, by: ot=1} = _;
            for (let at = nt; at <= it; at += ot)
                updatePath(d, [at].concat(g), b);
            return
        } else if (g.length > 1) {
            updatePath(d[_], g, [_].concat(b));
            return
        }
        $ = d[_],
        b = [_].concat(b)
    }
    let et = g[0];
    typeof et == "function" && (et = et($, b),
    et === $) || _ === void 0 && et == null || (et = unwrap(et),
    _ === void 0 || isWrappable($) && isWrappable(et) && !Array.isArray(et) ? mergeStoreNode($, et) : setProperty(d, _, et))
}
function createStore$1(...[d,g]) {
    const b = unwrap(d || {})
      , _ = Array.isArray(b)
      , $ = wrap$1(b);
    function et(...tt) {
        batch(()=>{
            _ && tt.length === 1 ? updateArray(b, tt[0]) : updatePath(b, tt)
        }
        )
    }
    return [$, et]
}
const defaultLightColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#0098EA",
    telegramButton: "#0098EA",
    icon: {
        primary: "#0F0F0F",
        secondary: "#7A8999",
        tertiary: "#C1CAD2",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#FFFFFF",
        secondary: "#F1F3F5",
        segment: "#FFFFFF",
        tint: "#F1F3F5",
        qr: "#F1F3F5"
    },
    text: {
        primary: "#0F0F0F",
        secondary: "#6A7785"
    }
}
  , defaultDarkColorsSet = {
    constant: {
        black: "#000000",
        white: "#FFFFFF"
    },
    connectButton: {
        background: "#0098EA",
        foreground: "#FFFFFF"
    },
    accent: "#E5E5EA",
    telegramButton: "#31A6F5",
    icon: {
        primary: "#E5E5EA",
        secondary: "#909099",
        tertiary: "#434347",
        success: "#29CC6A",
        error: "#F5A73B"
    },
    background: {
        primary: "#121214",
        secondary: "#18181A",
        segment: "#262629",
        tint: "#222224",
        qr: "#FFFFFF"
    },
    text: {
        primary: "#E5E5EA",
        secondary: "#7D7D85"
    }
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$8(d) {
    return Object.prototype.toString.call(d) === "[object Object]"
}
function isPlainObject(d) {
    var g, b;
    return isObject$8(d) === !1 ? !1 : (g = d.constructor,
    g === void 0 ? !0 : (b = g.prototype,
    !(isObject$8(b) === !1 || b.hasOwnProperty("isPrototypeOf") === !1)))
}
function mergeOptions(d, g) {
    return d ? deepmerge$1(g, d, {
        arrayMerge: (_,$,et)=>$,
        isMergeableObject: isPlainObject
    }) : g
}
const [themeState,setThemeState] = createStore$1({
    theme: THEME.LIGHT,
    colors: defaultLightColorsSet,
    borderRadius: "m"
})
  , themeColorsMappingDefault = {
    [THEME.LIGHT]: defaultLightColorsSet,
    [THEME.DARK]: defaultDarkColorsSet
}
  , themeCustomColors = {
    [THEME.LIGHT]: void 0,
    [THEME.DARK]: void 0
};
function setTheme(d, g) {
    g && (themeCustomColors[THEME.DARK] = mergeOptions(g[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(g[THEME.LIGHT], themeCustomColors[THEME.LIGHT])),
    setThemeState({
        theme: d,
        colors: mergeOptions(themeCustomColors[d], themeColorsMappingDefault[d])
    })
}
function setBorderRadius(d) {
    setThemeState({
        borderRadius: d
    })
}
function setColors(d) {
    themeCustomColors[THEME.DARK] = mergeOptions(d[THEME.DARK], themeCustomColors[THEME.DARK]),
    themeCustomColors[THEME.LIGHT] = mergeOptions(d[THEME.LIGHT], themeCustomColors[THEME.LIGHT]),
    setThemeState(g=>({
        colors: mergeOptions(themeCustomColors[g.theme], themeColorsMappingDefault[g.theme])
    }))
}
const ImagePlaceholder = styled.div`
    background-color: ${d=>d.theme.colors.background.secondary};
`
  , Image$1 = d=>{
    let g;
    const [b,_] = createSignal(null);
    return createEffect(()=>{
        const $ = new window.Image;
        return $.src = d.src,
        $.alt = d.alt || "",
        $.setAttribute("draggable", "false"),
        d.class && $.classList.add(d.class),
        $.complete ? _($) : ($.addEventListener("load", ()=>_($)),
        ()=>$.removeEventListener("load", ()=>_($)))
    }
    ),
    [createComponent(Show, {
        get when() {
            return b()
        },
        get children() {
            return b()
        }
    }), createComponent(Show, {
        get when() {
            return !b()
        },
        get children() {
            return createComponent(ImagePlaceholder, {
                get class() {
                    return d.class
                },
                ref($) {
                    const et = g;
                    typeof et == "function" ? et($) : g = $
                }
            })
        }
    })]
}
;
let initParams = {};
try {
    let d = location.hash.toString();
    initParams = urlParseHashParams(d)
} catch {}
let tmaPlatform = "unknown";
initParams != null && initParams.tgWebAppPlatform && (tmaPlatform = (_a$3 = initParams.tgWebAppPlatform) != null ? _a$3 : "unknown");
if (tmaPlatform === "unknown") {
    const d = getWindow$1();
    tmaPlatform = (_d = (_c = (_b = d == null ? void 0 : d.Telegram) == null ? void 0 : _b.WebApp) == null ? void 0 : _c.platform) != null ? _d : "unknown"
}
let webAppVersion = "6.0";
initParams != null && initParams.tgWebAppVersion && (webAppVersion = initParams.tgWebAppVersion);
if (!webAppVersion) {
    const d = getWindow$1();
    webAppVersion = (_g = (_f = (_e = d == null ? void 0 : d.Telegram) == null ? void 0 : _e.WebApp) == null ? void 0 : _f.version) != null ? _g : "6.0"
}
function isTmaPlatform(...d) {
    return d.includes(tmaPlatform)
}
function isInTMA() {
    var d;
    return tmaPlatform !== "unknown" || !!((d = getWindow$1()) != null && d.TelegramWebviewProxy)
}
function sendExpand() {
    postEvent("web_app_expand", {})
}
function sendOpenTelegramLink(d, g) {
    const b = new URL(d);
    if (b.protocol !== "http:" && b.protocol !== "https:") {
        if (g)
            return g();
        throw new TonConnectUIError(`Url protocol is not supported: ${b}`)
    }
    if (b.hostname !== "t.me") {
        if (g)
            return g();
        throw new TonConnectUIError(`Url host is not supported: ${b}`)
    }
    const _ = b.pathname + b.search;
    isIframe() || versionAtLeast("6.1") ? postEvent("web_app_open_tg_link", {
        path_full: _
    }) : openLinkBlank("https://t.me" + _)
}
function isIframe() {
    try {
        const d = getWindow$1();
        return d ? d.parent != null && d !== d.parent : !1
    } catch {
        return !1
    }
}
function postEvent(d, g) {
    try {
        const b = getWindow$1();
        if (!b)
            throw new TonConnectUIError("Can't post event to parent window: window is not defined");
        if (b.TelegramWebviewProxy !== void 0)
            logDebug("postEvent", d, g),
            b.TelegramWebviewProxy.postEvent(d, JSON.stringify(g));
        else if (b.external && "notify"in b.external)
            logDebug("postEvent", d, g),
            b.external.notify(JSON.stringify({
                eventType: d,
                eventData: g
            }));
        else if (isIframe()) {
            const _ = "*"
              , $ = JSON.stringify({
                eventType: d,
                eventData: g
            });
            logDebug("postEvent", d, g),
            b.parent.postMessage($, _)
        } else
            throw new TonConnectUIError("Can't post event to TMA")
    } catch (b) {
        logError(`Can't post event to parent window: ${b}`)
    }
}
function urlParseHashParams(d) {
    d = d.replace(/^#/, "");
    let g = {};
    if (!d.length)
        return g;
    if (d.indexOf("=") < 0 && d.indexOf("?") < 0)
        return g._path = urlSafeDecode(d),
        g;
    let b = d.indexOf("?");
    if (b >= 0) {
        let $ = d.substr(0, b);
        g._path = urlSafeDecode($),
        d = d.substr(b + 1)
    }
    let _ = urlParseQueryString(d);
    for (let $ in _)
        g[$] = _[$];
    return g
}
function urlSafeDecode(d) {
    try {
        return d = d.replace(/\+/g, "%20"),
        decodeURIComponent(d)
    } catch {
        return d
    }
}
function urlParseQueryString(d) {
    let g = {};
    if (!d.length)
        return g;
    let b = d.split("&"), _, $, et, tt;
    for (_ = 0; _ < b.length; _++)
        $ = b[_].split("="),
        et = urlSafeDecode($[0]),
        tt = $[1] == null ? null : urlSafeDecode($[1]),
        g[et] = tt;
    return g
}
function versionCompare(d, g) {
    typeof d != "string" && (d = ""),
    typeof g != "string" && (g = "");
    let b = d.replace(/^\s+|\s+$/g, "").split("."), _ = g.replace(/^\s+|\s+$/g, "").split("."), $, et, tt, rt;
    for ($ = Math.max(b.length, _.length),
    et = 0; et < $; et++)
        if (tt = parseInt(b[et]) || 0,
        rt = parseInt(_[et]) || 0,
        tt !== rt)
            return tt > rt ? 1 : -1;
    return 0
}
function versionAtLeast(d) {
    return versionCompare(webAppVersion, d) >= 0
}
const maxWidth = {
    mobile: 440,
    tablet: 1020
};
function isDevice(d) {
    const g = getWindow$1();
    if (!g)
        return d === "desktop";
    if (isTmaPlatform("weba"))
        return !0;
    const b = g.innerWidth;
    switch (d) {
    case "desktop":
        return b > maxWidth.tablet;
    case "tablet":
        return b > maxWidth.mobile;
    default:
    case "mobile":
        return b <= maxWidth.mobile || isOS("ios", "android", "ipad")
    }
}
function media(d) {
    switch (d) {
    case "mobile":
        return `@media (max-width: ${maxWidth.mobile}px)`;
    case "tablet":
        return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;
    default:
    case "desktop":
        return `@media (min-width: ${maxWidth.tablet}px)`
    }
}
const mediaTouch = "@media (hover: none)"
  , mediaNotTouch = "@media not all and (hover: none)"
  , borders$5 = {
    m: "100vh",
    s: "8px",
    none: "0"
}
  , scaleValues = {
    s: .02,
    m: .04
}
  , ButtonStyled$1 = styled.button`
    display: ${d=>d.leftIcon || d.rightIcon ? "flex" : "inline-block"};
    gap: ${d=>d.leftIcon || d.rightIcon ? "6px" : "unset"};
    align-items: ${d=>d.leftIcon || d.rightIcon ? "center" : "unset"};
    justify-content: ${d=>d.leftIcon || d.rightIcon ? "space-between" : "unset"};
    background-color: ${d=>d.appearance === "flat" ? "transparent" : d.appearance === "secondary" ? d.theme.colors.background.tint : rgba$1(d.theme.colors.accent, .12)};
    color: ${d=>d.appearance === "secondary" ? d.theme.colors.text.primary : d.theme.colors.accent};

    padding: ${d=>d.appearance === "flat" ? "0" : "9px 16px"};
    padding-left: ${d=>d.leftIcon && d.appearance !== "flat" ? "12px" : "16px"};
    padding-right: ${d=>d.rightIcon && d.appearance !== "flat" ? "12px" : "16px"};
    border: none;
    border-radius: ${d=>borders$5[d.theme.borderRadius]};
    cursor: ${d=>d.disabled ? "not-allowed" : "pointer"};

    font-size: 14px;
    font-weight: 590;
    line-height: 18px;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: ${d=>d.disabled ? "unset" : `scale(${1 + scaleValues[d.scale]})`};
        }
    }

    &:active {
        transform: ${d=>d.disabled ? "unset" : `scale(${1 - scaleValues[d.scale]})`};
    }

    ${mediaTouch} {
        &:active {
            transform: ${d=>d.disabled ? "unset" : `scale(${1 - scaleValues[d.scale] * 2})`};
        }
    }
`;
function useDataAttributes(d) {
    const g = untrack(()=>Object.keys(d).filter(_=>_.startsWith("data-")))
      , [b] = splitProps(d, g);
    return b
}
const Button = d=>{
    const g = useDataAttributes(d);
    return createComponent(ButtonStyled$1, mergeProps({
        get appearance() {
            return d.appearance || "primary"
        },
        get class() {
            return d.class
        },
        onClick: b=>{
            var _;
            return (_ = d.onClick) == null ? void 0 : _.call(d, b)
        }
        ,
        onMouseEnter: b=>{
            var _;
            return (_ = d.onMouseEnter) == null ? void 0 : _.call(d, b)
        }
        ,
        onMouseLeave: b=>{
            var _;
            return (_ = d.onMouseLeave) == null ? void 0 : _.call(d, b)
        }
        ,
        ref(b) {
            const _ = d.ref;
            typeof _ == "function" ? _(b) : d.ref = b
        },
        get disabled() {
            return d.disabled
        },
        get scale() {
            return d.scale || "m"
        },
        get leftIcon() {
            return !!d.leftIcon
        },
        get rightIcon() {
            return !!d.rightIcon
        },
        "data-tc-button": "true"
    }, g, {
        get children() {
            return [createMemo(()=>d.leftIcon), createMemo(()=>d.children), createMemo(()=>d.rightIcon)]
        }
    }))
}
;
function nextFrame(d) {
    requestAnimationFrame(()=>{
        requestAnimationFrame(d)
    }
    )
}
const Transition = d=>{
    let g, b = !0;
    const [_,$] = createSignal()
      , [et,tt] = createSignal()
      , rt = children(()=>d.children)
      , {onBeforeEnter: nt, onEnter: it, onAfterEnter: ot, onBeforeExit: at, onExit: st, onAfterExit: dt} = d
      , ft = createMemo(()=>{
        const lt = d.name || "s";
        return {
            enterActiveClass: d.enterActiveClass || lt + "-enter-active",
            enterClass: d.enterClass || lt + "-enter",
            enterToClass: d.enterToClass || lt + "-enter-to",
            exitActiveClass: d.exitActiveClass || lt + "-exit-active",
            exitClass: d.exitClass || lt + "-exit",
            exitToClass: d.exitToClass || lt + "-exit-to"
        }
    }
    );
    function ht(lt, ct) {
        if (!b || d.appear) {
            let ut = function(Pt) {
                lt && (!Pt || Pt.target === lt) && (lt.removeEventListener("transitionend", ut),
                lt.removeEventListener("animationend", ut),
                lt.classList.remove(...vt),
                lt.classList.remove(..._t),
                batch(()=>{
                    _() !== lt && $(lt),
                    et() === lt && tt(void 0)
                }
                ),
                ot && ot(lt),
                d.mode === "inout" && xt(lt, ct))
            };
            const pt = ft().enterClass.split(" ")
              , vt = ft().enterActiveClass.split(" ")
              , _t = ft().enterToClass.split(" ");
            nt && nt(lt),
            lt.classList.add(...pt),
            lt.classList.add(...vt),
            nextFrame(()=>{
                lt.classList.remove(...pt),
                lt.classList.add(..._t),
                it && it(lt, ()=>ut()),
                (!it || it.length < 2) && (lt.addEventListener("transitionend", ut),
                lt.addEventListener("animationend", ut))
            }
            )
        }
        ct && !d.mode ? tt(lt) : $(lt)
    }
    function xt(lt, ct) {
        const ut = ft().exitClass.split(" ")
          , pt = ft().exitActiveClass.split(" ")
          , vt = ft().exitToClass.split(" ");
        if (!ct.parentNode)
            return _t();
        at && at(ct),
        ct.classList.add(...ut),
        ct.classList.add(...pt),
        nextFrame(()=>{
            ct.classList.remove(...ut),
            ct.classList.add(...vt)
        }
        ),
        st && st(ct, ()=>_t()),
        (!st || st.length < 2) && (ct.addEventListener("transitionend", _t),
        ct.addEventListener("animationend", _t));
        function _t(Pt) {
            (!Pt || Pt.target === ct) && (ct.removeEventListener("transitionend", _t),
            ct.removeEventListener("animationend", _t),
            ct.classList.remove(...pt),
            ct.classList.remove(...vt),
            _() === ct && $(void 0),
            dt && dt(ct),
            d.mode === "outin" && ht(lt, ct))
        }
    }
    return createComputed(lt=>{
        for (g = rt(); typeof g == "function"; )
            g = g();
        return untrack(()=>(g && g !== lt && (d.mode !== "outin" ? ht(g, lt) : b && $(g)),
        lt && lt !== g && d.mode !== "inout" && xt(g, lt),
        b = !1,
        g))
    }
    ),
    [_, et]
}
;
function getRect(d) {
    const {top: g, bottom: b, left: _, right: $, width: et, height: tt} = d.getBoundingClientRect()
      , rt = d.parentNode.getBoundingClientRect();
    return {
        top: g - rt.top,
        bottom: b,
        left: _ - rt.left,
        right: $,
        width: et,
        height: tt
    }
}
const TransitionGroup = d=>{
    const g = children(()=>d.children)
      , b = createMemo(()=>{
        const dt = d.name || "s";
        return {
            enterActiveClass: d.enterActiveClass || dt + "-enter-active",
            enterClass: d.enterClass || dt + "-enter",
            enterToClass: d.enterToClass || dt + "-enter-to",
            exitActiveClass: d.exitActiveClass || dt + "-exit-active",
            exitClass: d.exitClass || dt + "-exit",
            exitToClass: d.exitToClass || dt + "-exit-to",
            moveClass: d.moveClass || dt + "-move"
        }
    }
    )
      , {onBeforeEnter: _, onEnter: $, onAfterEnter: et, onBeforeExit: tt, onExit: rt, onAfterExit: nt} = d
      , [it,ot] = createSignal();
    let at = []
      , st = !0;
    return createComputed(()=>{
        const dt = g()
          , ft = [...dt]
          , ht = new Set(dt)
          , xt = new Set(at)
          , lt = b().enterClass.split(" ")
          , ct = b().enterActiveClass.split(" ")
          , ut = b().enterToClass.split(" ")
          , pt = b().exitClass.split(" ")
          , vt = b().exitActiveClass.split(" ")
          , _t = b().exitToClass.split(" ");
        for (let Pt = 0; Pt < dt.length; Pt++) {
            const kt = dt[Pt];
            if (!st && !xt.has(kt)) {
                let $t = function(Wt) {
                    kt && (!Wt || Wt.target === kt) && (kt.removeEventListener("transitionend", $t),
                    kt.removeEventListener("animationend", $t),
                    kt.classList.remove(...ct),
                    kt.classList.remove(...ut),
                    et && et(kt))
                };
                _ && _(kt),
                kt.classList.add(...lt),
                kt.classList.add(...ct),
                nextFrame(()=>{
                    kt.classList.remove(...lt),
                    kt.classList.add(...ut),
                    $ && $(kt, ()=>$t()),
                    (!$ || $.length < 2) && (kt.addEventListener("transitionend", $t),
                    kt.addEventListener("animationend", $t))
                }
                )
            }
        }
        for (let Pt = 0; Pt < at.length; Pt++) {
            const kt = at[Pt];
            if (!ht.has(kt) && kt.parentNode) {
                let $t = function(Wt) {
                    (!Wt || Wt.target === kt) && (kt.removeEventListener("transitionend", $t),
                    kt.removeEventListener("animationend", $t),
                    kt.classList.remove(...vt),
                    kt.classList.remove(..._t),
                    nt && nt(kt),
                    at = at.filter(Ht=>Ht !== kt),
                    ot(at))
                };
                ft.splice(Pt, 0, kt),
                tt && tt(kt),
                kt.classList.add(...pt),
                kt.classList.add(...vt),
                nextFrame(()=>{
                    kt.classList.remove(...pt),
                    kt.classList.add(..._t)
                }
                ),
                rt && rt(kt, ()=>$t()),
                (!rt || rt.length < 2) && (kt.addEventListener("transitionend", $t),
                kt.addEventListener("animationend", $t))
            }
        }
        at = ft,
        ot(ft)
    }
    ),
    createEffect(dt=>{
        const ft = it();
        return ft.forEach(ht=>{
            let xt;
            (xt = dt.get(ht)) ? xt.new && (xt.new = !1,
            xt.newPos = getRect(ht)) : dt.set(ht, xt = {
                pos: getRect(ht),
                new: !st
            }),
            xt.new && ht.addEventListener("transitionend", ()=>{
                xt.new = !1,
                ht.parentNode && (xt.newPos = getRect(ht))
            }
            , {
                once: !0
            }),
            xt.newPos && (xt.pos = xt.newPos),
            xt.newPos = getRect(ht)
        }
        ),
        st ? (st = !1,
        dt) : (ft.forEach(ht=>{
            const xt = dt.get(ht)
              , lt = xt.pos
              , ct = xt.newPos
              , ut = lt.left - ct.left
              , pt = lt.top - ct.top;
            if (ut || pt) {
                xt.moved = !0;
                const vt = ht.style;
                vt.transform = `translate(${ut}px,${pt}px)`,
                vt.transitionDuration = "0s"
            }
        }
        ),
        document.body.offsetHeight,
        ft.forEach(ht=>{
            const xt = dt.get(ht);
            if (xt.moved) {
                let lt = function(pt) {
                    pt && pt.target !== ht || !ht.parentNode || (!pt || /transform$/.test(pt.propertyName)) && (ht.removeEventListener("transitionend", lt),
                    ht.classList.remove(...ut))
                };
                xt.moved = !1;
                const ct = ht.style
                  , ut = b().moveClass.split(" ");
                ht.classList.add(...ut),
                ct.transform = ct.transitionDuration = "",
                ht.addEventListener("transitionend", lt)
            }
        }
        ),
        dt)
    }
    , new Map),
    it
}
;
function clickOutside$1(d, g) {
    const b = _=>{
        var $;
        return !d.contains(_.target) && (($ = g()) == null ? void 0 : $())
    }
    ;
    document.body.addEventListener("click", b),
    onCleanup(()=>document.body.removeEventListener("click", b))
}
function escPressed(d, g) {
    const b = _=>{
        var $, et;
        _.key === "Escape" && (($ = document.activeElement) == null || $.blur(),
        (et = g()) == null || et())
    }
    ;
    document.body.addEventListener("keydown", b),
    onCleanup(()=>document.body.removeEventListener("keydown", b))
}
function androidBackHandler$1(d, g) {
    const {isEnabled: b, onClose: _} = g();
    if (!b || !(getUserAgent().os === "android"))
        return;
    window.history.pushState(ROUTE_STATE, "");
    const et = tt=>{
        tt.preventDefault(),
        _()
    }
    ;
    window.addEventListener("popstate", et, {
        once: !0
    }),
    onCleanup(()=>{
        window.removeEventListener("popstate", et),
        createMacrotask(()=>{
            var tt;
            ((tt = window.history.state) == null ? void 0 : tt[ROUTE_STATE_KEY]) === !0 && window.history.back()
        }
        )
    }
    )
}
const ROUTE_STATE_KEY = "androidBackHandler"
  , ROUTE_STATE = {
    [ROUTE_STATE_KEY]: !0
}
  , _tmpl$$v = template$1('<svg><path fill-rule="evenodd" clip-rule="evenodd" d="M10.2122 14.3407C10.5384 14.0854 10.5959 13.614 10.3406 13.2878L6.20237 8.00003L10.3406 2.71227C10.5959 2.38607 10.5384 1.91469 10.2122 1.6594C9.88604 1.40412 9.41465 1.46161 9.15937 1.7878L4.65937 7.5378C4.44688 7.80932 4.44688 8.19074 4.65937 8.46226L9.15937 14.2123C9.41465 14.5385 9.88604 14.5959 10.2122 14.3407Z"></path></svg>', 4, !0)
  , rotationDegrees = {
    left: 0,
    top: 90,
    right: 180,
    bottom: 270
}
  , ArrowIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary
      , _ = ()=>d.direction || "left"
      , $ = styled("svg")`
        transform: rotate(${et=>rotationDegrees[et.svgDirection]}deg);
        transition: transform 0.1s ease-in-out;
    `;
    return createComponent($, {
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        get svgDirection() {
            return _()
        },
        get children() {
            const et = _tmpl$$v.cloneNode(!0);
            return createRenderEffect(()=>setAttribute(et, "fill", b())),
            et
        }
    })
}
  , _tmpl$$u = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.71966 2.71968C3.01255 2.42678 3.48743 2.42677 3.78032 2.71966L8.00002 6.93925L12.2197 2.71967C12.5126 2.42677 12.9874 2.42678 13.2803 2.71967C13.5732 3.01257 13.5732 3.48744 13.2803 3.78033L9.06068 7.99991L13.2803 12.2197C13.5732 12.5126 13.5732 12.9874 13.2803 13.2803C12.9874 13.5732 12.5126 13.5732 12.2197 13.2803L8.00002 9.06057L3.78033 13.2803C3.48744 13.5732 3.01257 13.5732 2.71967 13.2803C2.42678 12.9874 2.42677 12.5126 2.71967 12.2197L6.93936 7.99991L2.71968 3.78034C2.42678 3.48745 2.42677 3.01257 2.71966 2.71968Z"></path></svg>')
  , CloseIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$u.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , IconButtonStyled = styled.button`
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: ${d=>d.theme.colors.background.tint};
    border: none;
    cursor: pointer;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , IconButton = d=>{
    const g = useDataAttributes(d)
      , b = ()=>d.icon || "close";
    return createComponent(IconButtonStyled, mergeProps({
        get class() {
            return d.class
        },
        onClick: ()=>d.onClick(),
        "data-tc-icon-button": "true"
    }, g, {
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !!d.children
                },
                get children() {
                    return d.children
                }
            }), createComponent(Show, {
                get when() {
                    return !d.children
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return b() === "close"
                                },
                                get children() {
                                    return createComponent(CloseIcon, {
                                        get fill() {
                                            return d.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return b() === "arrow"
                                },
                                get children() {
                                    return createComponent(ArrowIcon, {
                                        get fill() {
                                            return d.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return b() === "question"
                                },
                                get children() {
                                    return createComponent(QuestionIcon, {
                                        get fill() {
                                            return d.fill
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return typeof b() != "string"
                                },
                                get children() {
                                    return b()
                                }
                            })]
                        }
                    })
                }
            })]
        }
    }))
}
  , borders$4 = {
    m: "24px",
    s: "16px",
    none: "0"
}
  , ModalBackgroundStyled = styled.div`
    display: flex;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.4);
    padding: 20px 0;
    overflow-y: auto;

    ${media("mobile")} {
        padding-bottom: 0;
    }
`
  , ModalWrapperClass = u$2`
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);
    width: fit-content;
    margin: auto;

    ${media("mobile")} {
        width: 100%;
        height: fit-content;
        margin: auto 0 0 0;
    }
`
  , ModalBodyStyled = styled.div`
    position: relative;
    min-height: 100px;
    width: 416px;
    padding: 44px 56px 24px;

    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.04);

    background-color: ${d=>d.theme.colors.background.primary};
    border-radius: ${d=>borders$4[d.theme.borderRadius]};

    ${media("mobile")} {
        width: 100%;
    }
`
  , CloseButtonStyled = styled(IconButton)`
    position: absolute;
    right: 16px;
    top: 16px;
`
  , ModalFooterStyled = styled.div`
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px 16px 16px 18px;
    border-radius: 0 0 ${d=>borders$4[d.theme.borderRadius]}
        ${d=>borders$4[d.theme.borderRadius]};
`
  , QuestionButtonStyled = styled(IconButton)`
    background-color: ${d=>rgba$1(d.theme.colors.icon.secondary, .12)};
`;
class AnimationTimelineNoop {
    constructor() {
        __publicField(this, "currentTime", 0)
    }
}
const _AnimationNoop = class {
    constructor() {
        __publicField(this, "currentTime", 0),
        __publicField(this, "playbackRate", 1),
        __publicField(this, "startTime", null),
        __publicField(this, "timeline", new AnimationTimelineNoop),
        __publicField(this, "finished", Promise.resolve(this)),
        __publicField(this, "effect", null),
        __publicField(this, "id", ""),
        __publicField(this, "pending", !1),
        __publicField(this, "playState", "finished"),
        __publicField(this, "replaceState", "active"),
        __publicField(this, "ready", Promise.resolve(this)),
        __publicField(this, "oncancel", null),
        __publicField(this, "onfinish", null),
        __publicField(this, "onremove", null)
    }
    static create() {
        return _AnimationNoop._instance || (logWarning("Animation is not supported in this environment: please consider using the `web-animations-js` polyfill to provide a fallback implementation of the Web Animations API."),
        _AnimationNoop._instance = new _AnimationNoop),
        _AnimationNoop._instance
    }
    cancel() {}
    finish() {}
    pause() {}
    play() {}
    reverse() {}
    addEventListener(d, g, b) {}
    dispatchEvent(d) {
        return !1
    }
    removeEventListener(d, g, b) {}
    updatePlaybackRate(d) {}
    commitStyles() {}
    persist() {}
}
;
let AnimationNoop = _AnimationNoop;
__publicField(AnimationNoop, "_instance", null);
function animate(d, g, b) {
    return "animate"in d ? d.animate(g, b) : AnimationNoop.create()
}
const _tmpl$$t = template$1("<div></div>")
  , clickOutside = clickOutside$1
  , keyPressed = escPressed
  , androidBackHandler = androidBackHandler$1
  , Modal = d=>{
    const g = useTheme()
      , b = useDataAttributes(d);
    return createEffect(()=>{
        d.opened ? disableScroll() : enableScroll()
    }
    ),
    createComponent(Transition, {
        onBeforeEnter: _=>{
            const $ = isDevice("mobile") ? 200 : 100;
            animate(_, [{
                opacity: 0
            }, {
                opacity: 1
            }], {
                duration: $
            }),
            isDevice("mobile") && animate(_.firstElementChild, [{
                transform: "translateY(390px)"
            }, {
                transform: "translateY(0)"
            }], {
                duration: $
            })
        }
        ,
        onExit: (_,$)=>{
            const et = isDevice("mobile") ? 200 : 100
              , tt = animate(_, [{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: et
            });
            if (isDevice("mobile")) {
                const rt = animate(_.firstElementChild, [{
                    transform: "translateY(0)"
                }, {
                    transform: "translateY(390px)"
                }], {
                    duration: et
                });
                Promise.all([tt.finished, rt.finished]).then($)
            } else
                tt.finished.then($)
        }
        ,
        get children() {
            return createComponent(Show, {
                get when() {
                    return d.opened
                },
                get children() {
                    return createComponent(ModalBackgroundStyled, mergeProps({
                        "data-tc-modal": "true"
                    }, b, {
                        get children() {
                            const _ = _tmpl$$t.cloneNode(!0);
                            return use(androidBackHandler, _, ()=>({
                                isEnabled: d.enableAndroidBackHandler,
                                onClose: ()=>d.onClose()
                            })),
                            use(keyPressed, _, ()=>()=>d.onClose()),
                            use(clickOutside, _, ()=>()=>d.onClose()),
                            insert(_, createComponent(ModalBodyStyled, {
                                get class() {
                                    return d.class
                                },
                                get children() {
                                    return [createComponent(CloseButtonStyled, {
                                        icon: "close",
                                        onClick: ()=>d.onClose()
                                    }), createMemo(()=>d.children)]
                                }
                            }), null),
                            insert(_, createComponent(Show, {
                                get when() {
                                    return d.onClickQuestion
                                },
                                get children() {
                                    return createComponent(ModalFooterStyled, {
                                        get children() {
                                            return [createComponent(TonConnectBrand, {}), createComponent(QuestionButtonStyled, {
                                                get onClick() {
                                                    return d.onClickQuestion
                                                },
                                                icon: "question"
                                            })]
                                        }
                                    })
                                }
                            }), null),
                            createRenderEffect(()=>className(_, classNames(ModalWrapperClass, u$2`
                                border-radius: ${borders$4[g.borderRadius]};
                                background-color: ${g.colors.background.tint};

                                ${media("mobile")} {
                                    border-radius: ${borders$4[g.borderRadius]}
                                        ${borders$4[g.borderRadius]} 0 0;
                                }
                            `))),
                            _
                        }
                    }))
                }
            })
        }
    })
}
  , wrapperBorderRadius = {
    m: "22px",
    s: "12px",
    none: "0"
}
  , sliderBorderRadius = {
    m: "18px",
    s: "8px",
    none: "0"
}
  , TabBarStyled = styled.div`
    display: grid;
    grid-template: 1fr / 1fr 1fr;
    width: fit-content;
    justify-items: center;
    gap: 4px;

    position: relative;
    padding: 4px;
    border-radius: ${d=>wrapperBorderRadius[d.theme.borderRadius]};

    background-color: ${d=>d.theme.colors.background.secondary};
`
  , SliderStyled = styled.div`
    position: absolute;
    top: 4px;
    left: 4px;

    height: calc(100% - 8px);
    width: calc(50% - 4px);

    border-radius: ${d=>sliderBorderRadius[d.theme.borderRadius]};
    background-color: ${d=>d.theme.colors.background.segment};

    transform: ${d=>d.right ? "translateX(100%)" : "translateX(0)"};

    transition: transform 0.13s ease-in-out;
`
  , InputStyled = styled.input`
    display: none;
`
  , LabelStyled = styled.label`
    padding: 9px 12px;
    z-index: 1;

    cursor: ${d=>d.isActive ? "default" : "pointer"};

    transition: transform 0.13s ease-in-out;

    &:hover {
        transform: ${d=>d.isActive ? "none" : "scale(1.025)"};
    }

    > * {
        ${d=>d.isActive ? "" : `color: ${d.theme.colors.text.secondary};`}
    }
`
  , TabBar = d=>{
    const g = "tabBar" + Math.floor(Math.random() * 1e4);
    return createComponent(TabBarStyled, {
        get class() {
            return d.class
        },
        "data-tc-tab-bar": "true",
        get children() {
            return [createComponent(SliderStyled, {
                get right() {
                    return d.selectedTabIndex === 1
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return d.selectedTabIndex === 0
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        name: g,
                        get checked() {
                            return d.selectedTabIndex === 0
                        },
                        onInput: ()=>{
                            var b;
                            return (b = d.onSelectedTabIndexChange) == null ? void 0 : b.call(d, 0)
                        }
                    }), createMemo(()=>d.tab1)]
                }
            }), createComponent(LabelStyled, {
                get isActive() {
                    return d.selectedTabIndex === 1
                },
                get children() {
                    return [createComponent(InputStyled, {
                        type: "radio",
                        get checked() {
                            return d.selectedTabIndex === 1
                        },
                        name: g,
                        onInput: ()=>{
                            var b;
                            return (b = d.onSelectedTabIndexChange) == null ? void 0 : b.call(d, 1)
                        }
                    }), createMemo(()=>d.tab2)]
                }
            })]
        }
    })
}
  , backgroundBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , imageBorders = {
    m: "12px",
    s: "8px",
    none: "0"
}
  , qrNormalSize = 256
  , imgSizeDefault = 60
  , picSizeDefault = 48
  , qrPaddingTop = 24
  , CopyIconButton = styled.div`
    width: 52px;
    height: 52px;
    background: transparent;
    position: absolute;
    right: 0;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.125s ease-in-out;
`
  , QrCodeBackground = styled.button`
    display: flex;
    align-items: center;
    position: relative;
    background-color: ${d=>d.theme.colors.background.qr};
    border-radius: ${d=>backgroundBorders[d.theme.borderRadius]};
    padding: ${toPx(qrPaddingTop)} 0;
    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};
    width: 100%;

    overflow: hidden;
    cursor: pointer;
    border: none;

    ${mediaNotTouch} {
        &:hover {
            ${CopyIconButton.class} {
                transform: scale(1.04);
            }
        }
    }

    &:active {
        ${CopyIconButton.class} {
            transform: scale(0.96);
        }
    }

    ${mediaTouch} {
        &:active {
            ${CopyIconButton.class} {
                transform: scale(0.92);
            }
        }
    }
`
  , QrCodeWrapper$2 = styled.div`
    position: relative;

    width: fit-content;
    margin: 0 auto;

    > div:first-child {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    rect {
        fill: transparent;
    }

    path {
        fill: ${d=>d.theme.colors.constant.black};
    }
`
  , ImageBackground = styled.div`
    position: absolute;
    width: ${toPx(imgSizeDefault)};
    height: ${toPx(imgSizeDefault)};
    background: ${d=>d.theme.colors.background.qr};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , ImageStyled$3 = styled(Image$1)`
    width: ${d=>toPx(d.size)};
    height: ${d=>toPx(d.size)};
    border-radius: ${d=>imageBorders[d.theme.borderRadius]};
    background-color: ${d=>d.theme.colors.background.qr};
`
  , CopiedBoxStyled = styled.div`
    position: absolute;
    bottom: 14px;
    left: 50%;
    transform: translate(-50%, 0);

    display: flex;
    gap: 6px;
    align-items: center;
    border-radius: 18px;
    min-width: 126px;
    padding: 9px 16px 9px 10px;

    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));
    background-color: ${d=>d.theme.colors.background.segment};
`;
var qrcode$1 = {
    exports: {}
};
(function(d, g) {
    var b = function() {
        var _ = function(vt, _t) {
            var Pt = 236
              , kt = 17
              , $t = vt
              , Wt = et[_t]
              , Ht = null
              , Dt = 0
              , Vt = null
              , Ft = []
              , Kt = {}
              , Rt = function(cr, dr) {
                Dt = $t * 4 + 17,
                Ht = function(lr) {
                    for (var ir = new Array(lr), gr = 0; gr < lr; gr += 1) {
                        ir[gr] = new Array(lr);
                        for (var Cr = 0; Cr < lr; Cr += 1)
                            ir[gr][Cr] = null
                    }
                    return ir
                }(Dt),
                qt(0, 0),
                qt(Dt - 7, 0),
                qt(0, Dt - 7),
                Lt(),
                St(),
                ar(cr, dr),
                $t >= 7 && Mt(cr),
                Vt == null && (Vt = Pr($t, Wt, Ft)),
                wr(Vt, dr)
            }
              , qt = function(cr, dr) {
                for (var lr = -1; lr <= 7; lr += 1)
                    if (!(cr + lr <= -1 || Dt <= cr + lr))
                        for (var ir = -1; ir <= 7; ir += 1)
                            dr + ir <= -1 || Dt <= dr + ir || (0 <= lr && lr <= 6 && (ir == 0 || ir == 6) || 0 <= ir && ir <= 6 && (lr == 0 || lr == 6) || 2 <= lr && lr <= 4 && 2 <= ir && ir <= 4 ? Ht[cr + lr][dr + ir] = !0 : Ht[cr + lr][dr + ir] = !1)
            }
              , Et = function() {
                for (var cr = 0, dr = 0, lr = 0; lr < 8; lr += 1) {
                    Rt(!0, lr);
                    var ir = rt.getLostPoint(Kt);
                    (lr == 0 || cr > ir) && (cr = ir,
                    dr = lr)
                }
                return dr
            }
              , St = function() {
                for (var cr = 8; cr < Dt - 8; cr += 1)
                    Ht[cr][6] == null && (Ht[cr][6] = cr % 2 == 0);
                for (var dr = 8; dr < Dt - 8; dr += 1)
                    Ht[6][dr] == null && (Ht[6][dr] = dr % 2 == 0)
            }
              , Lt = function() {
                for (var cr = rt.getPatternPosition($t), dr = 0; dr < cr.length; dr += 1)
                    for (var lr = 0; lr < cr.length; lr += 1) {
                        var ir = cr[dr]
                          , gr = cr[lr];
                        if (Ht[ir][gr] == null)
                            for (var Cr = -2; Cr <= 2; Cr += 1)
                                for (var hr = -2; hr <= 2; hr += 1)
                                    Cr == -2 || Cr == 2 || hr == -2 || hr == 2 || Cr == 0 && hr == 0 ? Ht[ir + Cr][gr + hr] = !0 : Ht[ir + Cr][gr + hr] = !1
                    }
            }
              , Mt = function(cr) {
                for (var dr = rt.getBCHTypeNumber($t), lr = 0; lr < 18; lr += 1) {
                    var ir = !cr && (dr >> lr & 1) == 1;
                    Ht[Math.floor(lr / 3)][lr % 3 + Dt - 8 - 3] = ir
                }
                for (var lr = 0; lr < 18; lr += 1) {
                    var ir = !cr && (dr >> lr & 1) == 1;
                    Ht[lr % 3 + Dt - 8 - 3][Math.floor(lr / 3)] = ir
                }
            }
              , ar = function(cr, dr) {
                for (var lr = Wt << 3 | dr, ir = rt.getBCHTypeInfo(lr), gr = 0; gr < 15; gr += 1) {
                    var Cr = !cr && (ir >> gr & 1) == 1;
                    gr < 6 ? Ht[gr][8] = Cr : gr < 8 ? Ht[gr + 1][8] = Cr : Ht[Dt - 15 + gr][8] = Cr
                }
                for (var gr = 0; gr < 15; gr += 1) {
                    var Cr = !cr && (ir >> gr & 1) == 1;
                    gr < 8 ? Ht[8][Dt - gr - 1] = Cr : gr < 9 ? Ht[8][15 - gr - 1 + 1] = Cr : Ht[8][15 - gr - 1] = Cr
                }
                Ht[Dt - 8][8] = !cr
            }
              , wr = function(cr, dr) {
                for (var lr = -1, ir = Dt - 1, gr = 7, Cr = 0, hr = rt.getMaskFunction(dr), zr = Dt - 1; zr > 0; zr -= 2)
                    for (zr == 6 && (zr -= 1); ; ) {
                        for (var Zr = 0; Zr < 2; Zr += 1)
                            if (Ht[ir][zr - Zr] == null) {
                                var ln = !1;
                                Cr < cr.length && (ln = (cr[Cr] >>> gr & 1) == 1);
                                var Gr = hr(ir, zr - Zr);
                                Gr && (ln = !ln),
                                Ht[ir][zr - Zr] = ln,
                                gr -= 1,
                                gr == -1 && (Cr += 1,
                                gr = 7)
                            }
                        if (ir += lr,
                        ir < 0 || Dt <= ir) {
                            ir -= lr,
                            lr = -lr;
                            break
                        }
                    }
            }
              , Tr = function(cr, dr) {
                for (var lr = 0, ir = 0, gr = 0, Cr = new Array(dr.length), hr = new Array(dr.length), zr = 0; zr < dr.length; zr += 1) {
                    var Zr = dr[zr].dataCount
                      , ln = dr[zr].totalCount - Zr;
                    ir = Math.max(ir, Zr),
                    gr = Math.max(gr, ln),
                    Cr[zr] = new Array(Zr);
                    for (var Gr = 0; Gr < Cr[zr].length; Gr += 1)
                        Cr[zr][Gr] = 255 & cr.getBuffer()[Gr + lr];
                    lr += Zr;
                    var vn = rt.getErrorCorrectPolynomial(ln)
                      , fn = it(Cr[zr], vn.getLength() - 1)
                      , Rn = fn.mod(vn);
                    hr[zr] = new Array(vn.getLength() - 1);
                    for (var Gr = 0; Gr < hr[zr].length; Gr += 1) {
                        var bn = Gr + Rn.getLength() - hr[zr].length;
                        hr[zr][Gr] = bn >= 0 ? Rn.getAt(bn) : 0
                    }
                }
                for (var Un = 0, Gr = 0; Gr < dr.length; Gr += 1)
                    Un += dr[Gr].totalCount;
                for (var zn = new Array(Un), er = 0, Gr = 0; Gr < ir; Gr += 1)
                    for (var zr = 0; zr < dr.length; zr += 1)
                        Gr < Cr[zr].length && (zn[er] = Cr[zr][Gr],
                        er += 1);
                for (var Gr = 0; Gr < gr; Gr += 1)
                    for (var zr = 0; zr < dr.length; zr += 1)
                        Gr < hr[zr].length && (zn[er] = hr[zr][Gr],
                        er += 1);
                return zn
            }
              , Pr = function(cr, dr, lr) {
                for (var ir = ot.getRSBlocks(cr, dr), gr = at(), Cr = 0; Cr < lr.length; Cr += 1) {
                    var hr = lr[Cr];
                    gr.put(hr.getMode(), 4),
                    gr.put(hr.getLength(), rt.getLengthInBits(hr.getMode(), cr)),
                    hr.write(gr)
                }
                for (var zr = 0, Cr = 0; Cr < ir.length; Cr += 1)
                    zr += ir[Cr].dataCount;
                if (gr.getLengthInBits() > zr * 8)
                    throw "code length overflow. (" + gr.getLengthInBits() + ">" + zr * 8 + ")";
                for (gr.getLengthInBits() + 4 <= zr * 8 && gr.put(0, 4); gr.getLengthInBits() % 8 != 0; )
                    gr.putBit(!1);
                for (; !(gr.getLengthInBits() >= zr * 8 || (gr.put(Pt, 8),
                gr.getLengthInBits() >= zr * 8)); )
                    gr.put(kt, 8);
                return Tr(gr, ir)
            };
            Kt.addData = function(cr, dr) {
                dr = dr || "Byte";
                var lr = null;
                switch (dr) {
                case "Numeric":
                    lr = st(cr);
                    break;
                case "Alphanumeric":
                    lr = dt(cr);
                    break;
                case "Byte":
                    lr = ft(cr);
                    break;
                case "Kanji":
                    lr = ht(cr);
                    break;
                default:
                    throw "mode:" + dr
                }
                Ft.push(lr),
                Vt = null
            }
            ,
            Kt.isDark = function(cr, dr) {
                if (cr < 0 || Dt <= cr || dr < 0 || Dt <= dr)
                    throw cr + "," + dr;
                return Ht[cr][dr]
            }
            ,
            Kt.getModuleCount = function() {
                return Dt
            }
            ,
            Kt.make = function() {
                if ($t < 1) {
                    for (var cr = 1; cr < 40; cr++) {
                        for (var dr = ot.getRSBlocks(cr, Wt), lr = at(), ir = 0; ir < Ft.length; ir++) {
                            var gr = Ft[ir];
                            lr.put(gr.getMode(), 4),
                            lr.put(gr.getLength(), rt.getLengthInBits(gr.getMode(), cr)),
                            gr.write(lr)
                        }
                        for (var Cr = 0, ir = 0; ir < dr.length; ir++)
                            Cr += dr[ir].dataCount;
                        if (lr.getLengthInBits() <= Cr * 8)
                            break
                    }
                    $t = cr
                }
                Rt(!1, Et())
            }
            ,
            Kt.createTableTag = function(cr, dr) {
                cr = cr || 2,
                dr = typeof dr > "u" ? cr * 4 : dr;
                var lr = "";
                lr += '<table style="',
                lr += " border-width: 0px; border-style: none;",
                lr += " border-collapse: collapse;",
                lr += " padding: 0px; margin: " + dr + "px;",
                lr += '">',
                lr += "<tbody>";
                for (var ir = 0; ir < Kt.getModuleCount(); ir += 1) {
                    lr += "<tr>";
                    for (var gr = 0; gr < Kt.getModuleCount(); gr += 1)
                        lr += '<td style="',
                        lr += " border-width: 0px; border-style: none;",
                        lr += " border-collapse: collapse;",
                        lr += " padding: 0px; margin: 0px;",
                        lr += " width: " + cr + "px;",
                        lr += " height: " + cr + "px;",
                        lr += " background-color: ",
                        lr += Kt.isDark(ir, gr) ? "#000000" : "#ffffff",
                        lr += ";",
                        lr += '"/>';
                    lr += "</tr>"
                }
                return lr += "</tbody>",
                lr += "</table>",
                lr
            }
            ,
            Kt.createSvgTag = function(cr, dr, lr, ir) {
                var gr = {};
                typeof arguments[0] == "object" && (gr = arguments[0],
                cr = gr.cellSize,
                dr = gr.margin,
                lr = gr.alt,
                ir = gr.title),
                cr = cr || 2,
                dr = typeof dr > "u" ? cr * 4 : dr,
                lr = typeof lr == "string" ? {
                    text: lr
                } : lr || {},
                lr.text = lr.text || null,
                lr.id = lr.text ? lr.id || "qrcode-description" : null,
                ir = typeof ir == "string" ? {
                    text: ir
                } : ir || {},
                ir.text = ir.text || null,
                ir.id = ir.text ? ir.id || "qrcode-title" : null;
                var Cr = Kt.getModuleCount() * cr + dr * 2, hr, zr, Zr, ln, Gr = "", vn;
                for (vn = "l" + cr + ",0 0," + cr + " -" + cr + ",0 0,-" + cr + "z ",
                Gr += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"',
                Gr += gr.scalable ? "" : ' width="' + Cr + 'px" height="' + Cr + 'px"',
                Gr += ' viewBox="0 0 ' + Cr + " " + Cr + '" ',
                Gr += ' preserveAspectRatio="xMinYMin meet"',
                Gr += ir.text || lr.text ? ' role="img" aria-labelledby="' + kr([ir.id, lr.id].join(" ").trim()) + '"' : "",
                Gr += ">",
                Gr += ir.text ? '<title id="' + kr(ir.id) + '">' + kr(ir.text) + "</title>" : "",
                Gr += lr.text ? '<description id="' + kr(lr.id) + '">' + kr(lr.text) + "</description>" : "",
                Gr += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>',
                Gr += '<path d="',
                Zr = 0; Zr < Kt.getModuleCount(); Zr += 1)
                    for (ln = Zr * cr + dr,
                    hr = 0; hr < Kt.getModuleCount(); hr += 1)
                        Kt.isDark(Zr, hr) && (zr = hr * cr + dr,
                        Gr += "M" + zr + "," + ln + vn);
                return Gr += '" stroke="transparent" fill="black"/>',
                Gr += "</svg>",
                Gr
            }
            ,
            Kt.createDataURL = function(cr, dr) {
                cr = cr || 2,
                dr = typeof dr > "u" ? cr * 4 : dr;
                var lr = Kt.getModuleCount() * cr + dr * 2
                  , ir = dr
                  , gr = lr - dr;
                return pt(lr, lr, function(Cr, hr) {
                    if (ir <= Cr && Cr < gr && ir <= hr && hr < gr) {
                        var zr = Math.floor((Cr - ir) / cr)
                          , Zr = Math.floor((hr - ir) / cr);
                        return Kt.isDark(Zr, zr) ? 0 : 1
                    } else
                        return 1
                })
            }
            ,
            Kt.createImgTag = function(cr, dr, lr) {
                cr = cr || 2,
                dr = typeof dr > "u" ? cr * 4 : dr;
                var ir = Kt.getModuleCount() * cr + dr * 2
                  , gr = "";
                return gr += "<img",
                gr += ' src="',
                gr += Kt.createDataURL(cr, dr),
                gr += '"',
                gr += ' width="',
                gr += ir,
                gr += '"',
                gr += ' height="',
                gr += ir,
                gr += '"',
                lr && (gr += ' alt="',
                gr += kr(lr),
                gr += '"'),
                gr += "/>",
                gr
            }
            ;
            var kr = function(cr) {
                for (var dr = "", lr = 0; lr < cr.length; lr += 1) {
                    var ir = cr.charAt(lr);
                    switch (ir) {
                    case "<":
                        dr += "&lt;";
                        break;
                    case ">":
                        dr += "&gt;";
                        break;
                    case "&":
                        dr += "&amp;";
                        break;
                    case '"':
                        dr += "&quot;";
                        break;
                    default:
                        dr += ir;
                        break
                    }
                }
                return dr
            }
              , jr = function(cr) {
                var dr = 1;
                cr = typeof cr > "u" ? dr * 2 : cr;
                var lr = Kt.getModuleCount() * dr + cr * 2, ir = cr, gr = lr - cr, Cr, hr, zr, Zr, ln, Gr = {
                    "██": "█",
                    "█ ": "▀",
                    " █": "▄",
                    "  ": " "
                }, vn = {
                    "██": "▀",
                    "█ ": "▀",
                    " █": " ",
                    "  ": " "
                }, fn = "";
                for (Cr = 0; Cr < lr; Cr += 2) {
                    for (zr = Math.floor((Cr - ir) / dr),
                    Zr = Math.floor((Cr + 1 - ir) / dr),
                    hr = 0; hr < lr; hr += 1)
                        ln = "█",
                        ir <= hr && hr < gr && ir <= Cr && Cr < gr && Kt.isDark(zr, Math.floor((hr - ir) / dr)) && (ln = " "),
                        ir <= hr && hr < gr && ir <= Cr + 1 && Cr + 1 < gr && Kt.isDark(Zr, Math.floor((hr - ir) / dr)) ? ln += " " : ln += "█",
                        fn += cr < 1 && Cr + 1 >= gr ? vn[ln] : Gr[ln];
                    fn += `
`
                }
                return lr % 2 && cr > 0 ? fn.substring(0, fn.length - lr - 1) + Array(lr + 1).join("▀") : fn.substring(0, fn.length - 1)
            };
            return Kt.createASCII = function(cr, dr) {
                if (cr = cr || 1,
                cr < 2)
                    return jr(dr);
                cr -= 1,
                dr = typeof dr > "u" ? cr * 2 : dr;
                var lr = Kt.getModuleCount() * cr + dr * 2, ir = dr, gr = lr - dr, Cr, hr, zr, Zr, ln = Array(cr + 1).join("██"), Gr = Array(cr + 1).join("  "), vn = "", fn = "";
                for (Cr = 0; Cr < lr; Cr += 1) {
                    for (zr = Math.floor((Cr - ir) / cr),
                    fn = "",
                    hr = 0; hr < lr; hr += 1)
                        Zr = 1,
                        ir <= hr && hr < gr && ir <= Cr && Cr < gr && Kt.isDark(zr, Math.floor((hr - ir) / cr)) && (Zr = 0),
                        fn += Zr ? ln : Gr;
                    for (zr = 0; zr < cr; zr += 1)
                        vn += fn + `
`
                }
                return vn.substring(0, vn.length - 1)
            }
            ,
            Kt.renderTo2dContext = function(cr, dr) {
                dr = dr || 2;
                for (var lr = Kt.getModuleCount(), ir = 0; ir < lr; ir++)
                    for (var gr = 0; gr < lr; gr++)
                        cr.fillStyle = Kt.isDark(ir, gr) ? "black" : "white",
                        cr.fillRect(ir * dr, gr * dr, dr, dr)
            }
            ,
            Kt
        };
        _.stringToBytesFuncs = {
            default: function(vt) {
                for (var _t = [], Pt = 0; Pt < vt.length; Pt += 1) {
                    var kt = vt.charCodeAt(Pt);
                    _t.push(kt & 255)
                }
                return _t
            }
        },
        _.stringToBytes = _.stringToBytesFuncs.default,
        _.createStringToBytes = function(vt, _t) {
            var Pt = function() {
                for (var $t = ct(vt), Wt = function() {
                    var St = $t.read();
                    if (St == -1)
                        throw "eof";
                    return St
                }, Ht = 0, Dt = {}; ; ) {
                    var Vt = $t.read();
                    if (Vt == -1)
                        break;
                    var Ft = Wt()
                      , Kt = Wt()
                      , Rt = Wt()
                      , qt = String.fromCharCode(Vt << 8 | Ft)
                      , Et = Kt << 8 | Rt;
                    Dt[qt] = Et,
                    Ht += 1
                }
                if (Ht != _t)
                    throw Ht + " != " + _t;
                return Dt
            }()
              , kt = "?".charCodeAt(0);
            return function($t) {
                for (var Wt = [], Ht = 0; Ht < $t.length; Ht += 1) {
                    var Dt = $t.charCodeAt(Ht);
                    if (Dt < 128)
                        Wt.push(Dt);
                    else {
                        var Vt = Pt[$t.charAt(Ht)];
                        typeof Vt == "number" ? (Vt & 255) == Vt ? Wt.push(Vt) : (Wt.push(Vt >>> 8),
                        Wt.push(Vt & 255)) : Wt.push(kt)
                    }
                }
                return Wt
            }
        }
        ;
        var $ = {
            MODE_NUMBER: 1,
            MODE_ALPHA_NUM: 2,
            MODE_8BIT_BYTE: 4,
            MODE_KANJI: 8
        }
          , et = {
            L: 1,
            M: 0,
            Q: 3,
            H: 2
        }
          , tt = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
        }
          , rt = function() {
            var vt = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]]
              , _t = 1335
              , Pt = 7973
              , kt = 21522
              , $t = {}
              , Wt = function(Ht) {
                for (var Dt = 0; Ht != 0; )
                    Dt += 1,
                    Ht >>>= 1;
                return Dt
            };
            return $t.getBCHTypeInfo = function(Ht) {
                for (var Dt = Ht << 10; Wt(Dt) - Wt(_t) >= 0; )
                    Dt ^= _t << Wt(Dt) - Wt(_t);
                return (Ht << 10 | Dt) ^ kt
            }
            ,
            $t.getBCHTypeNumber = function(Ht) {
                for (var Dt = Ht << 12; Wt(Dt) - Wt(Pt) >= 0; )
                    Dt ^= Pt << Wt(Dt) - Wt(Pt);
                return Ht << 12 | Dt
            }
            ,
            $t.getPatternPosition = function(Ht) {
                return vt[Ht - 1]
            }
            ,
            $t.getMaskFunction = function(Ht) {
                switch (Ht) {
                case tt.PATTERN000:
                    return function(Dt, Vt) {
                        return (Dt + Vt) % 2 == 0
                    }
                    ;
                case tt.PATTERN001:
                    return function(Dt, Vt) {
                        return Dt % 2 == 0
                    }
                    ;
                case tt.PATTERN010:
                    return function(Dt, Vt) {
                        return Vt % 3 == 0
                    }
                    ;
                case tt.PATTERN011:
                    return function(Dt, Vt) {
                        return (Dt + Vt) % 3 == 0
                    }
                    ;
                case tt.PATTERN100:
                    return function(Dt, Vt) {
                        return (Math.floor(Dt / 2) + Math.floor(Vt / 3)) % 2 == 0
                    }
                    ;
                case tt.PATTERN101:
                    return function(Dt, Vt) {
                        return Dt * Vt % 2 + Dt * Vt % 3 == 0
                    }
                    ;
                case tt.PATTERN110:
                    return function(Dt, Vt) {
                        return (Dt * Vt % 2 + Dt * Vt % 3) % 2 == 0
                    }
                    ;
                case tt.PATTERN111:
                    return function(Dt, Vt) {
                        return (Dt * Vt % 3 + (Dt + Vt) % 2) % 2 == 0
                    }
                    ;
                default:
                    throw "bad maskPattern:" + Ht
                }
            }
            ,
            $t.getErrorCorrectPolynomial = function(Ht) {
                for (var Dt = it([1], 0), Vt = 0; Vt < Ht; Vt += 1)
                    Dt = Dt.multiply(it([1, nt.gexp(Vt)], 0));
                return Dt
            }
            ,
            $t.getLengthInBits = function(Ht, Dt) {
                if (1 <= Dt && Dt < 10)
                    switch (Ht) {
                    case $.MODE_NUMBER:
                        return 10;
                    case $.MODE_ALPHA_NUM:
                        return 9;
                    case $.MODE_8BIT_BYTE:
                        return 8;
                    case $.MODE_KANJI:
                        return 8;
                    default:
                        throw "mode:" + Ht
                    }
                else if (Dt < 27)
                    switch (Ht) {
                    case $.MODE_NUMBER:
                        return 12;
                    case $.MODE_ALPHA_NUM:
                        return 11;
                    case $.MODE_8BIT_BYTE:
                        return 16;
                    case $.MODE_KANJI:
                        return 10;
                    default:
                        throw "mode:" + Ht
                    }
                else if (Dt < 41)
                    switch (Ht) {
                    case $.MODE_NUMBER:
                        return 14;
                    case $.MODE_ALPHA_NUM:
                        return 13;
                    case $.MODE_8BIT_BYTE:
                        return 16;
                    case $.MODE_KANJI:
                        return 12;
                    default:
                        throw "mode:" + Ht
                    }
                else
                    throw "type:" + Dt
            }
            ,
            $t.getLostPoint = function(Ht) {
                for (var Dt = Ht.getModuleCount(), Vt = 0, Ft = 0; Ft < Dt; Ft += 1)
                    for (var Kt = 0; Kt < Dt; Kt += 1) {
                        for (var Rt = 0, qt = Ht.isDark(Ft, Kt), Et = -1; Et <= 1; Et += 1)
                            if (!(Ft + Et < 0 || Dt <= Ft + Et))
                                for (var St = -1; St <= 1; St += 1)
                                    Kt + St < 0 || Dt <= Kt + St || Et == 0 && St == 0 || qt == Ht.isDark(Ft + Et, Kt + St) && (Rt += 1);
                        Rt > 5 && (Vt += 3 + Rt - 5)
                    }
                for (var Ft = 0; Ft < Dt - 1; Ft += 1)
                    for (var Kt = 0; Kt < Dt - 1; Kt += 1) {
                        var Lt = 0;
                        Ht.isDark(Ft, Kt) && (Lt += 1),
                        Ht.isDark(Ft + 1, Kt) && (Lt += 1),
                        Ht.isDark(Ft, Kt + 1) && (Lt += 1),
                        Ht.isDark(Ft + 1, Kt + 1) && (Lt += 1),
                        (Lt == 0 || Lt == 4) && (Vt += 3)
                    }
                for (var Ft = 0; Ft < Dt; Ft += 1)
                    for (var Kt = 0; Kt < Dt - 6; Kt += 1)
                        Ht.isDark(Ft, Kt) && !Ht.isDark(Ft, Kt + 1) && Ht.isDark(Ft, Kt + 2) && Ht.isDark(Ft, Kt + 3) && Ht.isDark(Ft, Kt + 4) && !Ht.isDark(Ft, Kt + 5) && Ht.isDark(Ft, Kt + 6) && (Vt += 40);
                for (var Kt = 0; Kt < Dt; Kt += 1)
                    for (var Ft = 0; Ft < Dt - 6; Ft += 1)
                        Ht.isDark(Ft, Kt) && !Ht.isDark(Ft + 1, Kt) && Ht.isDark(Ft + 2, Kt) && Ht.isDark(Ft + 3, Kt) && Ht.isDark(Ft + 4, Kt) && !Ht.isDark(Ft + 5, Kt) && Ht.isDark(Ft + 6, Kt) && (Vt += 40);
                for (var Mt = 0, Kt = 0; Kt < Dt; Kt += 1)
                    for (var Ft = 0; Ft < Dt; Ft += 1)
                        Ht.isDark(Ft, Kt) && (Mt += 1);
                var ar = Math.abs(100 * Mt / Dt / Dt - 50) / 5;
                return Vt += ar * 10,
                Vt
            }
            ,
            $t
        }()
          , nt = function() {
            for (var vt = new Array(256), _t = new Array(256), Pt = 0; Pt < 8; Pt += 1)
                vt[Pt] = 1 << Pt;
            for (var Pt = 8; Pt < 256; Pt += 1)
                vt[Pt] = vt[Pt - 4] ^ vt[Pt - 5] ^ vt[Pt - 6] ^ vt[Pt - 8];
            for (var Pt = 0; Pt < 255; Pt += 1)
                _t[vt[Pt]] = Pt;
            var kt = {};
            return kt.glog = function($t) {
                if ($t < 1)
                    throw "glog(" + $t + ")";
                return _t[$t]
            }
            ,
            kt.gexp = function($t) {
                for (; $t < 0; )
                    $t += 255;
                for (; $t >= 256; )
                    $t -= 255;
                return vt[$t]
            }
            ,
            kt
        }();
        function it(vt, _t) {
            if (typeof vt.length > "u")
                throw vt.length + "/" + _t;
            var Pt = function() {
                for (var $t = 0; $t < vt.length && vt[$t] == 0; )
                    $t += 1;
                for (var Wt = new Array(vt.length - $t + _t), Ht = 0; Ht < vt.length - $t; Ht += 1)
                    Wt[Ht] = vt[Ht + $t];
                return Wt
            }()
              , kt = {};
            return kt.getAt = function($t) {
                return Pt[$t]
            }
            ,
            kt.getLength = function() {
                return Pt.length
            }
            ,
            kt.multiply = function($t) {
                for (var Wt = new Array(kt.getLength() + $t.getLength() - 1), Ht = 0; Ht < kt.getLength(); Ht += 1)
                    for (var Dt = 0; Dt < $t.getLength(); Dt += 1)
                        Wt[Ht + Dt] ^= nt.gexp(nt.glog(kt.getAt(Ht)) + nt.glog($t.getAt(Dt)));
                return it(Wt, 0)
            }
            ,
            kt.mod = function($t) {
                if (kt.getLength() - $t.getLength() < 0)
                    return kt;
                for (var Wt = nt.glog(kt.getAt(0)) - nt.glog($t.getAt(0)), Ht = new Array(kt.getLength()), Dt = 0; Dt < kt.getLength(); Dt += 1)
                    Ht[Dt] = kt.getAt(Dt);
                for (var Dt = 0; Dt < $t.getLength(); Dt += 1)
                    Ht[Dt] ^= nt.gexp(nt.glog($t.getAt(Dt)) + Wt);
                return it(Ht, 0).mod($t)
            }
            ,
            kt
        }
        var ot = function() {
            var vt = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]]
              , _t = function($t, Wt) {
                var Ht = {};
                return Ht.totalCount = $t,
                Ht.dataCount = Wt,
                Ht
            }
              , Pt = {}
              , kt = function($t, Wt) {
                switch (Wt) {
                case et.L:
                    return vt[($t - 1) * 4 + 0];
                case et.M:
                    return vt[($t - 1) * 4 + 1];
                case et.Q:
                    return vt[($t - 1) * 4 + 2];
                case et.H:
                    return vt[($t - 1) * 4 + 3];
                default:
                    return
                }
            };
            return Pt.getRSBlocks = function($t, Wt) {
                var Ht = kt($t, Wt);
                if (typeof Ht > "u")
                    throw "bad rs block @ typeNumber:" + $t + "/errorCorrectionLevel:" + Wt;
                for (var Dt = Ht.length / 3, Vt = [], Ft = 0; Ft < Dt; Ft += 1)
                    for (var Kt = Ht[Ft * 3 + 0], Rt = Ht[Ft * 3 + 1], qt = Ht[Ft * 3 + 2], Et = 0; Et < Kt; Et += 1)
                        Vt.push(_t(Rt, qt));
                return Vt
            }
            ,
            Pt
        }()
          , at = function() {
            var vt = []
              , _t = 0
              , Pt = {};
            return Pt.getBuffer = function() {
                return vt
            }
            ,
            Pt.getAt = function(kt) {
                var $t = Math.floor(kt / 8);
                return (vt[$t] >>> 7 - kt % 8 & 1) == 1
            }
            ,
            Pt.put = function(kt, $t) {
                for (var Wt = 0; Wt < $t; Wt += 1)
                    Pt.putBit((kt >>> $t - Wt - 1 & 1) == 1)
            }
            ,
            Pt.getLengthInBits = function() {
                return _t
            }
            ,
            Pt.putBit = function(kt) {
                var $t = Math.floor(_t / 8);
                vt.length <= $t && vt.push(0),
                kt && (vt[$t] |= 128 >>> _t % 8),
                _t += 1
            }
            ,
            Pt
        }
          , st = function(vt) {
            var _t = $.MODE_NUMBER
              , Pt = vt
              , kt = {};
            kt.getMode = function() {
                return _t
            }
            ,
            kt.getLength = function(Ht) {
                return Pt.length
            }
            ,
            kt.write = function(Ht) {
                for (var Dt = Pt, Vt = 0; Vt + 2 < Dt.length; )
                    Ht.put($t(Dt.substring(Vt, Vt + 3)), 10),
                    Vt += 3;
                Vt < Dt.length && (Dt.length - Vt == 1 ? Ht.put($t(Dt.substring(Vt, Vt + 1)), 4) : Dt.length - Vt == 2 && Ht.put($t(Dt.substring(Vt, Vt + 2)), 7))
            }
            ;
            var $t = function(Ht) {
                for (var Dt = 0, Vt = 0; Vt < Ht.length; Vt += 1)
                    Dt = Dt * 10 + Wt(Ht.charAt(Vt));
                return Dt
            }
              , Wt = function(Ht) {
                if ("0" <= Ht && Ht <= "9")
                    return Ht.charCodeAt(0) - "0".charCodeAt(0);
                throw "illegal char :" + Ht
            };
            return kt
        }
          , dt = function(vt) {
            var _t = $.MODE_ALPHA_NUM
              , Pt = vt
              , kt = {};
            kt.getMode = function() {
                return _t
            }
            ,
            kt.getLength = function(Wt) {
                return Pt.length
            }
            ,
            kt.write = function(Wt) {
                for (var Ht = Pt, Dt = 0; Dt + 1 < Ht.length; )
                    Wt.put($t(Ht.charAt(Dt)) * 45 + $t(Ht.charAt(Dt + 1)), 11),
                    Dt += 2;
                Dt < Ht.length && Wt.put($t(Ht.charAt(Dt)), 6)
            }
            ;
            var $t = function(Wt) {
                if ("0" <= Wt && Wt <= "9")
                    return Wt.charCodeAt(0) - "0".charCodeAt(0);
                if ("A" <= Wt && Wt <= "Z")
                    return Wt.charCodeAt(0) - "A".charCodeAt(0) + 10;
                switch (Wt) {
                case " ":
                    return 36;
                case "$":
                    return 37;
                case "%":
                    return 38;
                case "*":
                    return 39;
                case "+":
                    return 40;
                case "-":
                    return 41;
                case ".":
                    return 42;
                case "/":
                    return 43;
                case ":":
                    return 44;
                default:
                    throw "illegal char :" + Wt
                }
            };
            return kt
        }
          , ft = function(vt) {
            var _t = $.MODE_8BIT_BYTE
              , Pt = _.stringToBytes(vt)
              , kt = {};
            return kt.getMode = function() {
                return _t
            }
            ,
            kt.getLength = function($t) {
                return Pt.length
            }
            ,
            kt.write = function($t) {
                for (var Wt = 0; Wt < Pt.length; Wt += 1)
                    $t.put(Pt[Wt], 8)
            }
            ,
            kt
        }
          , ht = function(vt) {
            var _t = $.MODE_KANJI
              , Pt = _.stringToBytesFuncs.SJIS;
            if (!Pt)
                throw "sjis not supported.";
            (function(Wt, Ht) {
                var Dt = Pt(Wt);
                if (Dt.length != 2 || (Dt[0] << 8 | Dt[1]) != Ht)
                    throw "sjis not supported."
            }
            )("友", 38726);
            var kt = Pt(vt)
              , $t = {};
            return $t.getMode = function() {
                return _t
            }
            ,
            $t.getLength = function(Wt) {
                return ~~(kt.length / 2)
            }
            ,
            $t.write = function(Wt) {
                for (var Ht = kt, Dt = 0; Dt + 1 < Ht.length; ) {
                    var Vt = (255 & Ht[Dt]) << 8 | 255 & Ht[Dt + 1];
                    if (33088 <= Vt && Vt <= 40956)
                        Vt -= 33088;
                    else if (57408 <= Vt && Vt <= 60351)
                        Vt -= 49472;
                    else
                        throw "illegal char at " + (Dt + 1) + "/" + Vt;
                    Vt = (Vt >>> 8 & 255) * 192 + (Vt & 255),
                    Wt.put(Vt, 13),
                    Dt += 2
                }
                if (Dt < Ht.length)
                    throw "illegal char at " + (Dt + 1)
            }
            ,
            $t
        }
          , xt = function() {
            var vt = []
              , _t = {};
            return _t.writeByte = function(Pt) {
                vt.push(Pt & 255)
            }
            ,
            _t.writeShort = function(Pt) {
                _t.writeByte(Pt),
                _t.writeByte(Pt >>> 8)
            }
            ,
            _t.writeBytes = function(Pt, kt, $t) {
                kt = kt || 0,
                $t = $t || Pt.length;
                for (var Wt = 0; Wt < $t; Wt += 1)
                    _t.writeByte(Pt[Wt + kt])
            }
            ,
            _t.writeString = function(Pt) {
                for (var kt = 0; kt < Pt.length; kt += 1)
                    _t.writeByte(Pt.charCodeAt(kt))
            }
            ,
            _t.toByteArray = function() {
                return vt
            }
            ,
            _t.toString = function() {
                var Pt = "";
                Pt += "[";
                for (var kt = 0; kt < vt.length; kt += 1)
                    kt > 0 && (Pt += ","),
                    Pt += vt[kt];
                return Pt += "]",
                Pt
            }
            ,
            _t
        }
          , lt = function() {
            var vt = 0
              , _t = 0
              , Pt = 0
              , kt = ""
              , $t = {}
              , Wt = function(Dt) {
                kt += String.fromCharCode(Ht(Dt & 63))
            }
              , Ht = function(Dt) {
                if (!(Dt < 0)) {
                    if (Dt < 26)
                        return 65 + Dt;
                    if (Dt < 52)
                        return 97 + (Dt - 26);
                    if (Dt < 62)
                        return 48 + (Dt - 52);
                    if (Dt == 62)
                        return 43;
                    if (Dt == 63)
                        return 47
                }
                throw "n:" + Dt
            };
            return $t.writeByte = function(Dt) {
                for (vt = vt << 8 | Dt & 255,
                _t += 8,
                Pt += 1; _t >= 6; )
                    Wt(vt >>> _t - 6),
                    _t -= 6
            }
            ,
            $t.flush = function() {
                if (_t > 0 && (Wt(vt << 6 - _t),
                vt = 0,
                _t = 0),
                Pt % 3 != 0)
                    for (var Dt = 3 - Pt % 3, Vt = 0; Vt < Dt; Vt += 1)
                        kt += "="
            }
            ,
            $t.toString = function() {
                return kt
            }
            ,
            $t
        }
          , ct = function(vt) {
            var _t = vt
              , Pt = 0
              , kt = 0
              , $t = 0
              , Wt = {};
            Wt.read = function() {
                for (; $t < 8; ) {
                    if (Pt >= _t.length) {
                        if ($t == 0)
                            return -1;
                        throw "unexpected end of file./" + $t
                    }
                    var Dt = _t.charAt(Pt);
                    if (Pt += 1,
                    Dt == "=")
                        return $t = 0,
                        -1;
                    if (Dt.match(/^\s$/))
                        continue;
                    kt = kt << 6 | Ht(Dt.charCodeAt(0)),
                    $t += 6
                }
                var Vt = kt >>> $t - 8 & 255;
                return $t -= 8,
                Vt
            }
            ;
            var Ht = function(Dt) {
                if (65 <= Dt && Dt <= 90)
                    return Dt - 65;
                if (97 <= Dt && Dt <= 122)
                    return Dt - 97 + 26;
                if (48 <= Dt && Dt <= 57)
                    return Dt - 48 + 52;
                if (Dt == 43)
                    return 62;
                if (Dt == 47)
                    return 63;
                throw "c:" + Dt
            };
            return Wt
        }
          , ut = function(vt, _t) {
            var Pt = vt
              , kt = _t
              , $t = new Array(vt * _t)
              , Wt = {};
            Wt.setPixel = function(Ft, Kt, Rt) {
                $t[Kt * Pt + Ft] = Rt
            }
            ,
            Wt.write = function(Ft) {
                Ft.writeString("GIF87a"),
                Ft.writeShort(Pt),
                Ft.writeShort(kt),
                Ft.writeByte(128),
                Ft.writeByte(0),
                Ft.writeByte(0),
                Ft.writeByte(0),
                Ft.writeByte(0),
                Ft.writeByte(0),
                Ft.writeByte(255),
                Ft.writeByte(255),
                Ft.writeByte(255),
                Ft.writeString(","),
                Ft.writeShort(0),
                Ft.writeShort(0),
                Ft.writeShort(Pt),
                Ft.writeShort(kt),
                Ft.writeByte(0);
                var Kt = 2
                  , Rt = Dt(Kt);
                Ft.writeByte(Kt);
                for (var qt = 0; Rt.length - qt > 255; )
                    Ft.writeByte(255),
                    Ft.writeBytes(Rt, qt, 255),
                    qt += 255;
                Ft.writeByte(Rt.length - qt),
                Ft.writeBytes(Rt, qt, Rt.length - qt),
                Ft.writeByte(0),
                Ft.writeString(";")
            }
            ;
            var Ht = function(Ft) {
                var Kt = Ft
                  , Rt = 0
                  , qt = 0
                  , Et = {};
                return Et.write = function(St, Lt) {
                    if (St >>> Lt)
                        throw "length over";
                    for (; Rt + Lt >= 8; )
                        Kt.writeByte(255 & (St << Rt | qt)),
                        Lt -= 8 - Rt,
                        St >>>= 8 - Rt,
                        qt = 0,
                        Rt = 0;
                    qt = St << Rt | qt,
                    Rt = Rt + Lt
                }
                ,
                Et.flush = function() {
                    Rt > 0 && Kt.writeByte(qt)
                }
                ,
                Et
            }
              , Dt = function(Ft) {
                for (var Kt = 1 << Ft, Rt = (1 << Ft) + 1, qt = Ft + 1, Et = Vt(), St = 0; St < Kt; St += 1)
                    Et.add(String.fromCharCode(St));
                Et.add(String.fromCharCode(Kt)),
                Et.add(String.fromCharCode(Rt));
                var Lt = xt()
                  , Mt = Ht(Lt);
                Mt.write(Kt, qt);
                var ar = 0
                  , wr = String.fromCharCode($t[ar]);
                for (ar += 1; ar < $t.length; ) {
                    var Tr = String.fromCharCode($t[ar]);
                    ar += 1,
                    Et.contains(wr + Tr) ? wr = wr + Tr : (Mt.write(Et.indexOf(wr), qt),
                    Et.size() < 4095 && (Et.size() == 1 << qt && (qt += 1),
                    Et.add(wr + Tr)),
                    wr = Tr)
                }
                return Mt.write(Et.indexOf(wr), qt),
                Mt.write(Rt, qt),
                Mt.flush(),
                Lt.toByteArray()
            }
              , Vt = function() {
                var Ft = {}
                  , Kt = 0
                  , Rt = {};
                return Rt.add = function(qt) {
                    if (Rt.contains(qt))
                        throw "dup key:" + qt;
                    Ft[qt] = Kt,
                    Kt += 1
                }
                ,
                Rt.size = function() {
                    return Kt
                }
                ,
                Rt.indexOf = function(qt) {
                    return Ft[qt]
                }
                ,
                Rt.contains = function(qt) {
                    return typeof Ft[qt] < "u"
                }
                ,
                Rt
            };
            return Wt
        }
          , pt = function(vt, _t, Pt) {
            for (var kt = ut(vt, _t), $t = 0; $t < _t; $t += 1)
                for (var Wt = 0; Wt < vt; Wt += 1)
                    kt.setPixel(Wt, $t, Pt(Wt, $t));
            var Ht = xt();
            kt.write(Ht);
            for (var Dt = lt(), Vt = Ht.toByteArray(), Ft = 0; Ft < Vt.length; Ft += 1)
                Dt.writeByte(Vt[Ft]);
            return Dt.flush(),
            "data:image/gif;base64," + Dt
        };
        return _
    }();
    (function() {
        b.stringToBytesFuncs["UTF-8"] = function(_) {
            function $(et) {
                for (var tt = [], rt = 0; rt < et.length; rt++) {
                    var nt = et.charCodeAt(rt);
                    nt < 128 ? tt.push(nt) : nt < 2048 ? tt.push(192 | nt >> 6, 128 | nt & 63) : nt < 55296 || nt >= 57344 ? tt.push(224 | nt >> 12, 128 | nt >> 6 & 63, 128 | nt & 63) : (rt++,
                    nt = 65536 + ((nt & 1023) << 10 | et.charCodeAt(rt) & 1023),
                    tt.push(240 | nt >> 18, 128 | nt >> 12 & 63, 128 | nt >> 6 & 63, 128 | nt & 63))
                }
                return tt
            }
            return $(_)
        }
    }
    )(),
    function(_) {
        d.exports = _()
    }(function() {
        return b
    })
}
)(qrcode$1);
const qrcode = qrcode$1.exports;
function copyToClipboard(d) {
    return __async(this, null, function*() {
        try {
            if (!(navigator != null && navigator.clipboard))
                throw new TonConnectUIError("Clipboard API not available");
            return yield navigator.clipboard.writeText(d)
        } catch {}
        fallbackCopyTextToClipboard(d)
    })
}
function fallbackCopyTextToClipboard(d) {
    const g = document.createElement("textarea");
    g.value = d,
    g.style.top = "0",
    g.style.left = "0",
    g.style.position = "fixed",
    document.body.appendChild(g),
    g.focus(),
    g.select();
    try {
        document.execCommand("copy")
    } finally {
        document.body.removeChild(g)
    }
}
const _tmpl$$s = template$1("<div></div>")
  , QRCode = d=>{
    let g, b, _;
    const [$,et] = createSignal(!1)
      , [tt,rt] = createSignal(picSizeDefault);
    createEffect(()=>{
        const st = qrcode(0, "L");
        st.addData(d.sourceUrl),
        st.make(),
        g.innerHTML = st.createSvgTag(4, 0);
        const dt = g.firstElementChild.clientWidth
          , ft = Math.round(qrNormalSize / dt * 1e5) / 1e5;
        if (_) {
            const ht = Math.ceil(imgSizeDefault / (ft * 4)) * 4
              , xt = toPx(Math.ceil((dt - ht) / (2 * 4)) * 4);
            _.style.top = xt,
            _.style.left = xt,
            _.style.height = toPx(ht),
            _.style.width = toPx(ht),
            rt(Math.round(picSizeDefault / ft))
        }
        b.style.transform = `scale(${ft})`
    }
    );
    let nt = null;
    return createComponent(QrCodeBackground, {
        get class() {
            return d.class
        },
        onClick: ()=>{
            et(!0),
            copyToClipboard(d.sourceUrl),
            nt != null && clearTimeout(nt),
            nt = setTimeout(()=>et(!1), 1500)
        }
        ,
        get children() {
            return [createComponent(QrCodeWrapper$2, {
                ref(ot) {
                    const at = b;
                    typeof at == "function" ? at(ot) : b = ot
                },
                get children() {
                    return [(()=>{
                        const ot = _tmpl$$s.cloneNode(!0)
                          , at = g;
                        return typeof at == "function" ? use(at, ot) : g = ot,
                        ot
                    }
                    )(), createComponent(Show, {
                        get when() {
                            return d.imageUrl
                        },
                        get children() {
                            return createComponent(ImageBackground, {
                                ref(ot) {
                                    const at = _;
                                    typeof at == "function" ? at(ot) : _ = ot
                                },
                                get children() {
                                    return createComponent(ImageStyled$3, {
                                        get src() {
                                            return d.imageUrl
                                        },
                                        alt: "",
                                        get size() {
                                            return tt()
                                        }
                                    })
                                }
                            })
                        }
                    })]
                }
            }), createComponent(Transition, {
                onBeforeEnter: ot=>{
                    animate(ot, [{
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }, {
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    })
                }
                ,
                onExit: (ot,at)=>{
                    animate(ot, [{
                        opacity: 1,
                        transform: "translate(-50%, 0)"
                    }, {
                        opacity: 0,
                        transform: "translate(-50%, 44px)"
                    }], {
                        duration: 150,
                        easing: "ease-out"
                    }).finished.then(()=>{
                        at()
                    }
                    )
                }
                ,
                get children() {
                    return createComponent(Show, {
                        get when() {
                            return $() && !d.disableCopy
                        },
                        get children() {
                            return createComponent(CopiedBoxStyled, {
                                get children() {
                                    return [createComponent(SuccessIcon, {
                                        size: "xs"
                                    }), createComponent(Text, {
                                        translationKey: "common.linkCopied",
                                        children: "Link Copied"
                                    })]
                                }
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !d.disableCopy
                },
                get children() {
                    return createComponent(CopyIconButton, {
                        get children() {
                            return createComponent(CopyLightIcon, {})
                        }
                    })
                }
            })]
        }
    })
}
;
var deepReadObject = (d,g,b)=>{
    const _ = g.trim().split(".").reduce(($,et)=>$ ? $[et] : void 0, d);
    return _ !== void 0 ? _ : b
}
  , template = (d,g,b=/{{(.*?)}}/g)=>d.replace(b, (_,$)=>deepReadObject(g, $, ""))
  , createI18nContext = (d={},g=navigator.language in d ? navigator.language : Object.keys(d)[0])=>{
    const [b,_] = createSignal(g)
      , [$,et] = createStore$1(d);
    return [(nt,it,ot)=>{
        const at = deepReadObject($[b()], nt, ot || "");
        return typeof at == "function" ? at(it) : typeof at == "string" ? template(at, it || {}) : at
    }
    , {
        add(nt, it) {
            et(nt, ot=>Object.assign(ot || {}, it))
        },
        locale: nt=>nt ? _(nt) : b(),
        dict: nt=>deepReadObject($, nt)
    }]
}
  , I18nContext = createContext({})
  , useI18n = ()=>useContext(I18nContext);
const TextStyled$3 = styled.div`
    font-style: normal;
    font-weight: ${d=>d.fontWeight};
    font-size: ${d=>d.fontSize};
    line-height: ${d=>d.lineHeight};

    color: ${d=>d.color};
`
  , Text = d=>{
    const g = useTheme()
      , [b] = useI18n();
    let _;
    const $ = ()=>d.color || g.colors.text.primary
      , et = mergeProps({
        fontSize: "14px",
        fontWeight: "510",
        lineHeight: "130%"
    }, d);
    return createEffect(()=>{
        _ && et.cursor !== "unset" && getComputedStyle(_).cursor !== "pointer" && (_.style.cursor = "default")
    }
    ),
    createComponent(TextStyled$3, {
        get fontSize() {
            return et.fontSize
        },
        get fontWeight() {
            return et.fontWeight
        },
        get lineHeight() {
            return et.lineHeight
        },
        get color() {
            return $()
        },
        get class() {
            return et.class
        },
        ref(tt) {
            const rt = _;
            typeof rt == "function" ? rt(tt) : _ = tt
        },
        "data-tc-text": "true",
        get children() {
            var tt;
            return createMemo(()=>!!et.translationKey)() ? b(et.translationKey, et.translationValues, (tt = et.children) == null ? void 0 : tt.toString()) : et.children
        }
    })
}
  , ImageContainer = styled.div`
    position: relative;

    &::after {
        content: '';
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        border: 0.5px solid rgba(0, 0, 0, 0.08);

        border-radius: inherit;
    }
`
  , ImageStyled$2 = styled(Image$1)`
    width: 100%;
    height: 100%;
    border-radius: inherit;
`
  , WalletImage = d=>createComponent(ImageContainer, {
    get class() {
        return d.class
    },
    get children() {
        return createComponent(ImageStyled$2, {
            get src() {
                return d.src
            }
        })
    }
})
  , borders$3 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , badgeBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , WalletItemStyled = styled.button`
    position: relative;
    cursor: pointer;
    border: none;
    background-color: unset;
    padding: 8px 4px;
    width: 92px;
    display: flex;
    flex-direction: column;
    align-items: center;

    transition: transform 0.125s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${media("mobile")} {
        padding: 8px 4px;
        width: 82px;
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , ImageStyled$1 = styled(WalletImage)`
    width: 60px;
    height: 60px;
    border-radius: ${d=>borders$3[d.theme.borderRadius]};

    margin-bottom: 8px;
`
  , BadgeStyled = styled(Image$1)`
    position: absolute;
    right: 10px;
    top: 50px;
    width: 24px;
    height: 24px;
    border-radius: ${d=>badgeBorders[d.theme.borderRadius]};
    box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.08);
`
  , StyledText = styled(Text)`
    max-width: 90px;
    font-weight: 590;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , StyledSecondLine = styled(Text)`
    font-weight: 510;
    max-width: 90px;
    white-space: nowrap;
    text-overflow: ellipsis;
    overflow: hidden;
    color: ${d=>d.colorPrimary ? d.theme.colors.text.primary : d.theme.colors.text.secondary};

    ${media("mobile")} {
        max-width: 80px;
    }
`
  , WalletItem = d=>createComponent(WalletItemStyled, {
    get class() {
        return d.class
    },
    onClick: ()=>d.onClick(),
    "data-tc-wallet-item": "true",
    get children() {
        return [createMemo(()=>createMemo(()=>typeof d.icon == "string")() ? createComponent(ImageStyled$1, {
            get src() {
                return d.icon
            }
        }) : d.icon), createMemo(()=>createMemo(()=>!!d.badgeUrl)() && createComponent(BadgeStyled, {
            get src() {
                return d.badgeUrl
            }
        })), createComponent(StyledText, {
            get children() {
                return d.name
            }
        }), createMemo(()=>createMemo(()=>!!d.secondLine)() && createComponent(StyledSecondLine, {
            get colorPrimary() {
                var g;
                return (g = d.secondLineColorPrimary) != null ? g : !0
            },
            get children() {
                return d.secondLine
            }
        }))]
    }
})
  , H1Styled$9 = styled.h1`
    font-style: normal;
    font-weight: 700;
    font-size: 20px;
    line-height: 28px;

    text-align: center;

    color: ${d=>d.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H1 = d=>{
    const [g] = useI18n();
    return createComponent(H1Styled$9, {
        get class() {
            return d.class
        },
        "data-tc-h1": "true",
        get children() {
            var b;
            return createMemo(()=>!!d.translationKey)() ? g(d.translationKey, d.translationValues, (b = d.children) == null ? void 0 : b.toString()) : d.children
        }
    })
}
  , H2Styled$5 = styled.h2`
    font-style: normal;
    font-weight: 510;
    font-size: 16px;
    line-height: 22px;

    text-align: center;

    color: ${d=>d.theme.colors.text.secondary};

    margin-top: 0;
    margin-bottom: 32px;

    cursor: default;
`
  , H2 = d=>{
    const [g] = useI18n();
    return createComponent(H2Styled$5, {
        get class() {
            return d.class
        },
        "data-tc-h2": "true",
        get children() {
            var b;
            return createMemo(()=>!!d.translationKey)() ? g(d.translationKey, d.translationValues, (b = d.children) == null ? void 0 : b.toString()) : d.children
        }
    })
}
  , H3Styled$1 = styled.h3`
    font-style: normal;
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;

    color: ${d=>d.theme.colors.text.primary};

    margin-top: 0;
    margin-bottom: 0;

    cursor: default;
`
  , H3 = d=>{
    const [g] = useI18n();
    return createComponent(H3Styled$1, {
        "data-tc-h3": "true",
        get class() {
            return d.class
        },
        get children() {
            var b;
            return createMemo(()=>!!d.translationKey)() ? g(d.translationKey, d.translationValues, (b = d.children) == null ? void 0 : b.toString()) : d.children
        }
    })
}
  , _tmpl$$r = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.75 7.5C9.33579 7.5 9 7.16421 9 6.75C9 6.33579 9.33579 6 9.75 6H21.25C21.6642 6 22 6.33579 22 6.75V18.25C22 18.6642 21.6642 19 21.25 19C20.8358 19 20.5 18.6642 20.5 18.25V8.56066L6.28033 22.7803C5.98744 23.0732 5.51256 23.0732 5.21967 22.7803C4.92678 22.4874 4.92678 22.0126 5.21967 21.7197L19.4393 7.5H9.75Z"></path></svg>')
  , LongArrowIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$r.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = b()
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "fill", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$q = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z"></path></svg>')
  , TonIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$q.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$p = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><g clip-path="url(#clip0_3783_2045)"><circle cx="8" cy="8.00098" r="8"></circle><path d="M4.75 8.50098L7 10.751L11.75 6.00098" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></g><defs><clipPath id="clip0_3783_2045"><rect width="16" height="16" fill="white" transform="translate(0 0.000976562)"></rect></clipPath></defs></svg>')
  , _tmpl$2$3 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z"></path></svg>')
  , _tmpl$3$2 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z"></path></svg>')
  , SuccessIcon = d=>{
    const g = useTheme()
      , b = ()=>d.size || "s"
      , _ = ()=>d.fill || g.colors.icon.success;
    return createMemo((()=>{
        const $ = createMemo(()=>b() === "xs");
        return ()=>$() ? (()=>{
            const et = _tmpl$$p.cloneNode(!0)
              , tt = et.firstChild
              , rt = tt.firstChild
              , nt = rt.nextSibling;
            return createRenderEffect(it=>{
                const ot = d.class
                  , at = _()
                  , st = g.colors.constant.white;
                return ot !== it._v$ && setAttribute(et, "class", it._v$ = ot),
                at !== it._v$2 && setAttribute(rt, "fill", it._v$2 = at),
                st !== it._v$3 && setAttribute(nt, "stroke", it._v$3 = st),
                it
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            et
        }
        )() : (()=>{
            const et = createMemo(()=>b() === "s");
            return ()=>et() ? (()=>{
                const tt = _tmpl$2$3.cloneNode(!0)
                  , rt = tt.firstChild
                  , nt = rt.nextSibling;
                return createRenderEffect(it=>{
                    const ot = d.class
                      , at = _()
                      , st = g.colors.constant.white;
                    return ot !== it._v$4 && setAttribute(tt, "class", it._v$4 = ot),
                    at !== it._v$5 && setAttribute(rt, "fill", it._v$5 = at),
                    st !== it._v$6 && setAttribute(nt, "fill", it._v$6 = st),
                    it
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                tt
            }
            )() : (()=>{
                const tt = _tmpl$3$2.cloneNode(!0)
                  , rt = tt.firstChild
                  , nt = rt.nextSibling;
                return createRenderEffect(it=>{
                    const ot = d.class
                      , at = _()
                      , st = g.colors.constant.white;
                    return ot !== it._v$7 && setAttribute(tt, "class", it._v$7 = ot),
                    at !== it._v$8 && setAttribute(rt, "fill", it._v$8 = at),
                    st !== it._v$9 && setAttribute(nt, "fill", it._v$9 = st),
                    it
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                tt
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$o = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="36" cy="36" r="33"></circle><path d="M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z"></path></svg>')
  , _tmpl$2$2 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><circle cx="24" cy="24.001" r="22"></circle><path d="M24 24.001L31.5 16.501M24 24.001L16.5 16.501M24 24.001L16.5 31.501M24 24.001L31.5 31.501" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , _tmpl$3$1 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11"></circle><path d="M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z"></path></svg>')
  , ErrorIcon = d=>{
    const g = useTheme()
      , b = ()=>d.size || "m"
      , _ = ()=>d.fill || g.colors.icon.error;
    return createMemo((()=>{
        const $ = createMemo(()=>b() === "m");
        return ()=>$() ? (()=>{
            const et = _tmpl$$o.cloneNode(!0)
              , tt = et.firstChild
              , rt = tt.nextSibling;
            return createRenderEffect(nt=>{
                const it = d.class
                  , ot = _()
                  , at = g.colors.constant.white;
                return it !== nt._v$ && setAttribute(et, "class", nt._v$ = it),
                ot !== nt._v$2 && setAttribute(tt, "fill", nt._v$2 = ot),
                at !== nt._v$3 && setAttribute(rt, "fill", nt._v$3 = at),
                nt
            }
            , {
                _v$: void 0,
                _v$2: void 0,
                _v$3: void 0
            }),
            et
        }
        )() : (()=>{
            const et = createMemo(()=>b() === "s");
            return ()=>et() ? (()=>{
                const tt = _tmpl$2$2.cloneNode(!0)
                  , rt = tt.firstChild
                  , nt = rt.nextSibling;
                return createRenderEffect(it=>{
                    const ot = d.class
                      , at = _()
                      , st = g.colors.constant.white;
                    return ot !== it._v$4 && setAttribute(tt, "class", it._v$4 = ot),
                    at !== it._v$5 && setAttribute(rt, "fill", it._v$5 = at),
                    st !== it._v$6 && setAttribute(nt, "stroke", it._v$6 = st),
                    it
                }
                , {
                    _v$4: void 0,
                    _v$5: void 0,
                    _v$6: void 0
                }),
                tt
            }
            )() : (()=>{
                const tt = _tmpl$3$1.cloneNode(!0)
                  , rt = tt.firstChild
                  , nt = rt.nextSibling;
                return createRenderEffect(it=>{
                    const ot = d.class
                      , at = _()
                      , st = g.colors.constant.white;
                    return ot !== it._v$7 && setAttribute(tt, "class", it._v$7 = ot),
                    at !== it._v$8 && setAttribute(rt, "fill", it._v$8 = at),
                    st !== it._v$9 && setAttribute(nt, "fill", it._v$9 = st),
                    it
                }
                , {
                    _v$7: void 0,
                    _v$8: void 0,
                    _v$9: void 0
                }),
                tt
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$n = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z"></path></svg>')
  , _tmpl$2$1 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M22 2.99951C11.5066 2.99951 3 11.5061 3 21.9995C3 32.4929 11.5066 40.9995 22 40.9995C22.8284 40.9995 23.5 41.6711 23.5 42.4995C23.5 43.3279 22.8284 43.9995 22 43.9995C9.84974 43.9995 0 34.1498 0 21.9995C0 9.84925 9.84974 -0.000488281 22 -0.000488281C34.1503 -0.000488281 44 9.84925 44 21.9995C44 22.8279 43.3284 23.4995 42.5 23.4995C41.6716 23.4995 41 22.8279 41 21.9995C41 11.5061 32.4934 2.99951 22 2.99951Z"></path></svg>')
  , _tmpl$3 = template$1('<svg width="72" height="72" viewBox="0 0 72 72" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999" stroke-width="4" stroke-linecap="round" stroke-linejoin="round"></path></svg>')
  , LoaderIcon = d=>{
    const g = useTheme()
      , b = ()=>d.size || "xs"
      , _ = ()=>d.fill || g.colors.icon.tertiary
      , $ = h$2`
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
    `
      , et = u$2`
        animation: ${$} 1s linear infinite;
    `;
    return createMemo((()=>{
        const tt = createMemo(()=>b() === "xs");
        return ()=>tt() ? (()=>{
            const rt = _tmpl$$n.cloneNode(!0)
              , nt = rt.firstChild;
            return createRenderEffect(it=>{
                const ot = classNames(et, d.class)
                  , at = _();
                return ot !== it._v$ && setAttribute(rt, "class", it._v$ = ot),
                at !== it._v$2 && setAttribute(nt, "fill", it._v$2 = at),
                it
            }
            , {
                _v$: void 0,
                _v$2: void 0
            }),
            rt
        }
        )() : (()=>{
            const rt = createMemo(()=>b() === "s");
            return ()=>rt() ? (()=>{
                const nt = _tmpl$2$1.cloneNode(!0)
                  , it = nt.firstChild;
                return createRenderEffect(ot=>{
                    const at = classNames(et, d.class)
                      , st = _();
                    return at !== ot._v$3 && setAttribute(nt, "class", ot._v$3 = at),
                    st !== ot._v$4 && setAttribute(it, "fill", ot._v$4 = st),
                    ot
                }
                , {
                    _v$3: void 0,
                    _v$4: void 0
                }),
                nt
            }
            )() : (()=>{
                const nt = _tmpl$3.cloneNode(!0)
                  , it = nt.firstChild;
                return createRenderEffect(ot=>{
                    const at = classNames(et, d.class)
                      , st = _();
                    return at !== ot._v$5 && setAttribute(nt, "class", ot._v$5 = at),
                    st !== ot._v$6 && setAttribute(it, "stroke", ot._v$6 = st),
                    ot
                }
                , {
                    _v$5: void 0,
                    _v$6: void 0
                }),
                nt
            }
            )()
        }
        )()
    }
    )())
}
  , _tmpl$$m = template$1('<svg width="158" height="28" viewBox="0 0 158 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M28 14.001C28 21.733 21.732 28.001 14 28.001C6.26801 28.001 0 21.733 0 14.001C0 6.26899 6.26801 0.000976562 14 0.000976562C21.732 0.000976562 28 6.26899 28 14.001ZM9.21931 8.00098H18.7801H18.7813C20.538 8.00098 21.6522 9.89966 20.7691 11.4302L14.8672 21.6576C14.4822 22.3254 13.5172 22.3254 13.1322 21.6576L7.23158 11.4302C6.34721 9.89726 7.4614 8.00098 9.21931 8.00098ZM13.1262 18.5882V9.74806H9.21811C8.78976 9.74806 8.53708 10.2029 8.74163 10.5578L11.8423 16.1035L13.1262 18.5882ZM16.1559 16.1047L19.2554 10.5566C19.4599 10.2017 19.2073 9.74685 18.7789 9.74685H14.8709V18.5906L16.1559 16.1047Z" fill="#0098EA"></path><path d="M18.7802 8.00098H9.21936C7.46145 8.00098 6.34727 9.89726 7.23164 11.4302L13.1322 21.6576C13.5173 22.3254 14.4823 22.3254 14.8673 21.6576L20.7691 11.4302C21.6523 9.89966 20.5381 8.00098 18.7814 8.00098H18.7802ZM13.1274 18.5906L11.8424 16.1035L8.74168 10.5578C8.53714 10.2029 8.78981 9.74806 9.21816 9.74806H13.1262V18.5918L13.1274 18.5906ZM19.2555 10.5566L16.156 16.1047L14.8709 18.5906V9.74685H18.779C19.2073 9.74685 19.46 10.2017 19.2555 10.5566Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M51.7483 22.1967C55.7182 22.1967 58.9609 18.954 58.9609 14.9841C58.9609 11.0142 55.7182 7.77148 51.7483 7.77148C47.7588 7.77148 44.5357 11.0142 44.5357 14.9841C44.5357 18.954 47.7588 22.1967 51.7483 22.1967ZM51.7483 19.1702C49.4686 19.1702 47.6802 17.2442 47.6802 14.9841C47.6802 12.724 49.4686 10.798 51.7483 10.798C54.0084 10.798 55.7968 12.724 55.7968 14.9841C55.7968 17.2442 54.0084 19.1702 51.7483 19.1702ZM37.0698 21.9609H40.2142V10.9946H44.2843V8.00732H33V10.9946H37.0698V21.9609ZM69.9379 8.00732H73.0823V21.9609H70.3899L63.59 13.3333V21.9609H60.4652V8.00732H63.1576L69.9379 16.6153V8.00732ZM79.2259 14.9887C79.2259 10.9202 82.351 7.77539 86.4982 7.77539C89.8592 7.77539 92.5519 9.95709 93.2202 12.6891H90.7437C90.154 11.0971 88.4637 9.9964 86.4982 9.9964C83.5893 9.9964 81.5452 12.1781 81.5452 14.9887C81.5452 17.7994 83.5893 19.9811 86.4982 19.9811C88.4637 19.9811 90.154 18.8804 90.7437 17.2884H93.2202C92.5519 20.0204 89.8592 22.2021 86.4982 22.2021C82.351 22.2021 79.2259 19.0573 79.2259 14.9887ZM104.584 17.0525C104.584 19.9025 102.343 22.1628 99.4342 22.1628C96.5253 22.1628 94.2846 19.9025 94.2846 17.0525C94.2846 14.2025 96.5253 11.9422 99.4342 11.9422C102.343 11.9422 104.584 14.2025 104.584 17.0525ZM96.4663 17.0525C96.4663 18.8018 97.6849 20.158 99.4342 20.158C101.164 20.158 102.382 18.8018 102.382 17.0525C102.382 15.3032 101.164 13.947 99.4342 13.947C97.6849 13.947 96.4663 15.3032 96.4663 17.0525ZM108.626 12.1388H106.463V21.9662H108.626V17.1311C108.626 15.0281 109.726 13.9077 111.161 13.9077C112.419 13.9077 113.205 14.8512 113.205 16.4039V21.9662H115.367V16.0501C115.367 13.5539 113.893 11.9422 111.613 11.9422C110.335 11.9422 109.215 12.4926 108.626 13.4753V12.1388ZM117.839 12.1388H120.001V13.4753C120.59 12.4926 121.711 11.9422 122.988 11.9422C125.268 11.9422 126.742 13.5539 126.742 16.0501V21.9662H124.58V16.4039C124.58 14.8512 123.794 13.9077 122.536 13.9077C121.101 13.9077 120.001 15.0281 120.001 17.1311V21.9662H117.839V12.1388ZM133.558 22.1628C136.054 22.1628 137.823 20.728 138.373 18.8804H136.113C135.661 19.8238 134.717 20.2563 133.636 20.2563C131.887 20.2563 130.747 19.077 130.668 17.5832H138.491C138.688 14.2419 136.585 11.9422 133.577 11.9422C130.551 11.9422 128.526 14.1436 128.526 17.0525C128.526 20.0007 130.629 22.1628 133.558 22.1628ZM130.747 16.0501C131.042 14.5367 132.162 13.7505 133.518 13.7505C134.717 13.7505 135.838 14.4581 136.172 16.0501H130.747ZM149.851 18.3694C149.32 20.5511 147.453 22.1628 144.859 22.1628C141.871 22.1628 139.709 19.8828 139.709 17.0525C139.709 14.2222 141.871 11.9422 144.859 11.9422C147.453 11.9422 149.32 13.5539 149.851 15.7356H147.571C147.178 14.6743 146.215 13.9077 144.859 13.9077C143.109 13.9077 141.91 15.2246 141.91 17.0525C141.91 18.8804 143.109 20.1973 144.859 20.1973C146.215 20.1973 147.178 19.4307 147.571 18.3694H149.851ZM155.75 22.0645C156.418 22.0645 156.929 21.9859 157.362 21.8483V19.9221C157.047 20.0401 156.615 20.1187 156.202 20.1187C155.082 20.1187 154.551 19.6666 154.551 18.448V14.065H157.362V12.1388H154.551V9.40675H152.389V12.1388H150.345V14.065H152.389V18.8018C152.389 21.0228 153.863 22.0645 155.75 22.0645Z"></path></svg>')
  , TonConnectBrand = ()=>{
    const d = useTheme()
      , g = ()=>d.theme === THEME.DARK ? d.colors.constant.white : d.colors.constant.black;
    return (()=>{
        const b = _tmpl$$m.cloneNode(!0)
          , _ = b.firstChild
          , $ = _.nextSibling
          , et = $.nextSibling;
        return createRenderEffect(()=>setAttribute(et, "fill", g())),
        b
    }
    )()
}
  , _tmpl$$l = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.56608 4.42584C5.82527 3.32158 6.8176 2.5 8.00001 2.5C9.38072 2.5 10.5 3.61929 10.5 5C10.5 5.63026 10.3391 6.0386 10.1264 6.34455C9.90018 6.66993 9.58561 6.92478 9.18864 7.20877C9.12579 7.25372 9.05873 7.30025 8.9887 7.34883C8.27392 7.84472 7.25001 8.55507 7.25001 10V10.25C7.25001 10.6642 7.5858 11 8.00001 11C8.41422 11 8.75001 10.6642 8.75001 10.25V10C8.75001 9.36502 9.10777 9.1096 9.94554 8.51149L10.0614 8.42873C10.4769 8.13147 10.9748 7.75194 11.358 7.20076C11.7547 6.63015 12 5.91973 12 5C12 2.79086 10.2091 1 8.00001 1C6.10564 1 4.5205 2.31615 4.10577 4.08308C4.01112 4.48634 4.26129 4.88997 4.66454 4.98462C5.0678 5.07927 5.47143 4.8291 5.56608 4.42584ZM8.00001 15C8.60752 15 9.10001 14.5075 9.10001 13.9C9.10001 13.2925 8.60752 12.8 8.00001 12.8C7.39249 12.8 6.90001 13.2925 6.90001 13.9C6.90001 14.5075 7.39249 15 8.00001 15Z"></path></svg>')
  , QuestionIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$l.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$k = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M9.98156 8.75C9.84854 11.4328 9.01206 13.5 8 13.5C6.98794 13.5 6.15146 11.4328 6.01844 8.75H9.98156ZM11.4832 8.75C11.4217 10.1155 11.1929 11.3869 10.8239 12.4017C10.7734 12.5405 10.7188 12.6789 10.6595 12.8154C12.1454 11.993 13.2103 10.5029 13.4493 8.75H11.4832ZM13.4493 7.25H11.4832C11.4217 5.88453 11.1929 4.61314 10.8239 3.5983C10.7734 3.4595 10.7188 3.32111 10.6595 3.18459C12.1454 4.00697 13.2103 5.49709 13.4493 7.25ZM9.98156 7.25H6.01844C6.15144 4.56764 6.98769 2.50062 7.99955 2.5H8C9.01206 2.5 9.84854 4.56724 9.98156 7.25ZM4.51678 7.25C4.57826 5.88453 4.80706 4.61314 5.1761 3.5983C5.22657 3.4595 5.28124 3.32111 5.3405 3.18459C3.85463 4.00697 2.78972 5.49709 2.55071 7.25H4.51678ZM2.55071 8.75C2.78972 10.5029 3.85463 11.993 5.3405 12.8154C5.28124 12.6789 5.22657 12.5405 5.1761 12.4017C4.80706 11.3869 4.57826 10.1155 4.51678 8.75H2.55071ZM15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1C11.866 1 15 4.13401 15 8Z"></path></svg>')
  , BrowserIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$k.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$j = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.5 4.8C2.5 3.11984 2.5 2.27976 2.82698 1.63803C3.1146 1.07354 3.57354 0.614601 4.13803 0.32698C4.77976 0 5.61984 0 7.3 0H8.7C10.3802 0 11.2202 0 11.862 0.32698C12.4265 0.614601 12.8854 1.07354 13.173 1.63803C13.5 2.27976 13.5 3.11984 13.5 4.8V11.2C13.5 12.8802 13.5 13.7202 13.173 14.362C12.8854 14.9265 12.4265 15.3854 11.862 15.673C11.2202 16 10.3802 16 8.7 16H7.3C5.61984 16 4.77976 16 4.13803 15.673C3.57354 15.3854 3.1146 14.9265 2.82698 14.362C2.5 13.7202 2.5 12.8802 2.5 11.2V4.8ZM4 3.9C4 3.05992 4 2.63988 4.16349 2.31901C4.3073 2.03677 4.53677 1.8073 4.81901 1.66349C5.13988 1.5 5.55992 1.5 6.4 1.5H9.6C10.4401 1.5 10.8601 1.5 11.181 1.66349C11.4632 1.8073 11.6927 2.03677 11.8365 2.31901C12 2.63988 12 3.05992 12 3.9V12.1C12 12.9401 12 13.3601 11.8365 13.681C11.6927 13.9632 11.4632 14.1927 11.181 14.3365C10.8601 14.5 10.4401 14.5 9.6 14.5H6.4C5.55992 14.5 5.13988 14.5 4.81901 14.3365C4.53677 14.1927 4.3073 13.9632 4.16349 13.681C4 13.3601 4 12.9401 4 12.1V3.9ZM7 2.5C6.58579 2.5 6.25 2.83579 6.25 3.25C6.25 3.66421 6.58579 4 7 4H9C9.41421 4 9.75 3.66421 9.75 3.25C9.75 2.83579 9.41421 2.5 9 2.5H7Z"></path></svg>')
  , MobileIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$j.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$i = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 6.8C1.5 5.11984 1.5 4.27976 1.82698 3.63803C2.1146 3.07354 2.57354 2.6146 3.13803 2.32698C3.77976 2 4.61984 2 6.3 2H9.7C11.3802 2 12.2202 2 12.862 2.32698C13.4265 2.6146 13.8854 3.07354 14.173 3.63803C14.5 4.27976 14.5 5.11984 14.5 6.8V11.5H15.25C15.6642 11.5 16 11.8358 16 12.25C16 12.6642 15.6642 13 15.25 13H0.75C0.335786 13 0 12.6642 0 12.25C0 11.8358 0.335786 11.5 0.75 11.5H1.5V6.8ZM3 11.5H13V5.9C13 5.05992 13 4.63988 12.8365 4.31901C12.6927 4.03677 12.4632 3.8073 12.181 3.66349C11.8601 3.5 11.4401 3.5 10.6 3.5H5.4C4.55992 3.5 4.13988 3.5 3.81901 3.66349C3.53677 3.8073 3.3073 4.03677 3.16349 4.31901C3 4.63988 3 5.05992 3 5.9V11.5Z"></path></svg>')
  , DesktopIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$i.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$h = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1603)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15.5 1.25049C15.5 0.836275 15.1642 0.500488 14.75 0.500488C14.3358 0.500488 14 0.836275 14 1.25049V3.67012C12.7187 2.04487 10.7318 1.00049 8.5 1.00049C4.63401 1.00049 1.5 4.1345 1.5 8.00049C1.5 11.8665 4.63401 15.0005 8.5 15.0005C11.6844 15.0005 14.3703 12.8748 15.2199 9.96661C15.3361 9.56902 15.1079 9.15254 14.7103 9.03638C14.3127 8.92023 13.8962 9.14838 13.7801 9.54597C13.1123 11.8319 11 13.5005 8.5 13.5005C5.46243 13.5005 3 11.0381 3 8.00049C3 4.96292 5.46243 2.50049 8.5 2.50049C10.321 2.50049 11.9363 3.3855 12.9377 4.75049H10.5C10.0858 4.75049 9.75 5.08627 9.75 5.50049C9.75 5.9147 10.0858 6.25049 10.5 6.25049H14.75C15.1642 6.25049 15.5 5.9147 15.5 5.50049V1.25049Z"></path></g><defs><clipPath id="clip0_3676_1603"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000488281)"></rect></clipPath></defs></svg>')
  , RetryIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.accent;
    return (()=>{
        const _ = _tmpl$$h.cloneNode(!0)
          , $ = _.firstChild
          , et = $.firstChild;
        return createRenderEffect(()=>setAttribute(et, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$g = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M13 4.06119V6.75053C13 7.16474 13.3358 7.50053 13.75 7.50053C14.1642 7.50053 14.5 7.16474 14.5 6.75053V2.75053L14.5 2.72807C14.5001 2.63191 14.5003 2.49627 14.4842 2.37627C14.4638 2.22503 14.4063 1.99261 14.2071 1.79342C14.0079 1.59423 13.7755 1.5367 13.6243 1.51637C13.5043 1.50023 13.3686 1.50039 13.2725 1.50051L13.25 1.50053H9.25C8.83579 1.50053 8.5 1.83631 8.5 2.25053C8.5 2.66474 8.83579 3.00053 9.25 3.00053H11.9393L7.21967 7.7202C6.92678 8.01309 6.92678 8.48796 7.21967 8.78086C7.51256 9.07375 7.98744 9.07375 8.28033 8.78086L13 4.06119ZM5.85 1.50053H5.81903H5.81899C5.21528 1.50052 4.71702 1.50051 4.31113 1.53367C3.88956 1.56812 3.50203 1.64204 3.13803 1.82751C2.57354 2.11513 2.1146 2.57407 1.82698 3.13856C1.64151 3.50256 1.56759 3.89009 1.53315 4.31166C1.49998 4.71755 1.49999 5.21581 1.5 5.81953V5.81955V5.85053V10.1505V10.1815V10.1815C1.49999 10.7852 1.49998 11.2835 1.53315 11.6894C1.56759 12.111 1.64151 12.4985 1.82698 12.8625C2.1146 13.427 2.57354 13.8859 3.13803 14.1735C3.50203 14.359 3.88956 14.4329 4.31113 14.4674C4.71702 14.5005 5.21527 14.5005 5.81897 14.5005H5.81901H5.85H10.15H10.181H10.181C10.7847 14.5005 11.283 14.5005 11.6889 14.4674C12.1104 14.4329 12.498 14.359 12.862 14.1735C13.4265 13.8859 13.8854 13.427 14.173 12.8625C14.3585 12.4985 14.4324 12.111 14.4669 11.6894C14.5 11.2835 14.5 10.7853 14.5 10.1816V10.1815V10.1505V9.75053C14.5 9.33631 14.1642 9.00053 13.75 9.00053C13.3358 9.00053 13 9.33631 13 9.75053V10.1505C13 10.793 12.9994 11.2297 12.9718 11.5672C12.945 11.8961 12.8963 12.0642 12.8365 12.1815C12.6927 12.4638 12.4632 12.6932 12.181 12.837C12.0637 12.8968 11.8955 12.9455 11.5667 12.9724C11.2292 12.9999 10.7924 13.0005 10.15 13.0005H5.85C5.20757 13.0005 4.77085 12.9999 4.43328 12.9724C4.10447 12.9455 3.93632 12.8968 3.81902 12.837C3.53677 12.6932 3.3073 12.4638 3.16349 12.1815C3.10372 12.0642 3.05503 11.8961 3.02816 11.5672C3.00058 11.2297 3 10.793 3 10.1505V5.85053C3 5.20809 3.00058 4.77137 3.02816 4.43381C3.05503 4.10499 3.10372 3.93684 3.16349 3.81954C3.3073 3.5373 3.53677 3.30783 3.81902 3.16402C3.93632 3.10425 4.10447 3.05556 4.43328 3.02869C4.77085 3.00111 5.20757 3.00053 5.85 3.00053H6.25C6.66422 3.00053 7 2.66474 7 2.25053C7 1.83631 6.66422 1.50053 6.25 1.50053H5.85Z"></path></svg>')
  , LinkIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.accent;
    return (()=>{
        const _ = _tmpl$$g.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$f = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="17" height="16" viewBox="0 0 17 16" fill="none"><g clip-path="url(#clip0_3676_1274)"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.82698 2.63901C1.5 3.28074 1.5 4.12082 1.5 5.80098V8.80098V9.00098V10.201C1.5 11.8811 1.5 12.7212 1.82698 13.3629C2.1146 13.9274 2.57354 14.3864 3.13803 14.674C3.77976 15.001 4.61984 15.001 6.3 15.001H11.7C13.3802 15.001 14.2202 15.001 14.862 14.674C15.4265 14.3864 15.8854 13.9274 16.173 13.3629C16.5 12.7212 16.5 11.8811 16.5 10.201V8.80098C16.5 7.12082 16.5 6.28074 16.173 5.63901C15.8854 5.07452 15.4265 4.61558 14.862 4.32796C14.743 4.26733 14.6172 4.21795 14.4805 4.17772C14.4501 3.49449 14.3722 3.02994 14.173 2.63901C13.8854 2.07452 13.4265 1.61558 12.862 1.32796C12.2202 1.00098 11.3802 1.00098 9.7 1.00098H6.3C4.61984 1.00098 3.77976 1.00098 3.13803 1.32796C2.57354 1.61558 2.1146 2.07452 1.82698 2.63901ZM12.9861 4.00942C12.9684 3.7108 12.9281 3.49982 12.8365 3.31999C12.6927 3.03775 12.4632 2.80828 12.181 2.66447C11.8601 2.50098 11.4401 2.50098 10.6 2.50098H5.4C4.55992 2.50098 4.13988 2.50098 3.81901 2.66447C3.53677 2.80828 3.3073 3.03775 3.16349 3.31999C3.03615 3.56991 3.00799 3.88 3.00177 4.40188C3.04646 4.37612 3.09189 4.35146 3.13803 4.32796C3.77976 4.00098 4.61984 4.00098 6.3 4.00098H11.7C12.1966 4.00098 12.6197 4.00098 12.9861 4.00942ZM3 7.90098V8.10098C3 8.47468 3 8.76527 3.01439 9.00098H3V11.101C3 11.9411 3 12.3611 3.16349 12.682C3.3073 12.9642 3.53677 13.1937 3.81901 13.3375C4.13988 13.501 4.55992 13.501 5.4 13.501H12.6C13.4401 13.501 13.8601 13.501 14.181 13.3375C14.4632 13.1937 14.6927 12.9642 14.8365 12.682C15 12.3611 15 11.9411 15 11.101V7.90098C15 7.0609 15 6.64086 14.8365 6.31999C14.6927 6.03775 14.4632 5.80828 14.181 5.66447C13.8601 5.50098 13.4401 5.50098 12.6 5.50098H5.4C4.55992 5.50098 4.13988 5.50098 3.81901 5.66447C3.53677 5.80828 3.3073 6.03775 3.16349 6.31999C3 6.64086 3 7.0609 3 7.90098ZM10.5 9.75098C10.5 9.33676 10.8358 9.00098 11.25 9.00098H12.75C13.1642 9.00098 13.5 9.33676 13.5 9.75098C13.5 10.1652 13.1642 10.501 12.75 10.501H11.25C10.8358 10.501 10.5 10.1652 10.5 9.75098Z"></path></g><defs><clipPath id="clip0_3676_1274"><rect width="16" height="16" fill="white" transform="translate(0.5 0.000976562)"></rect></clipPath></defs></svg>')
  , WalletIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.accent;
    return (()=>{
        const _ = _tmpl$$f.cloneNode(!0)
          , $ = _.firstChild
          , et = $.firstChild;
        return createRenderEffect(()=>setAttribute(et, "fill", b())),
        _
    }
    )()
}
  , _tmpl$$e = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M39.6319 16.8719C38.3212 16.2041 36.7002 16.0478 34 16.0112V11C34 5.47715 29.5228 1 24 1C18.4772 1 14 5.47715 14 11V16.0112C11.2998 16.0478 9.6788 16.2041 8.36808 16.8719C6.86278 17.6389 5.63893 18.8628 4.87195 20.3681C4 22.0794 4 24.3196 4 28.8V32.2C4 36.6804 4 38.9206 4.87195 40.6319C5.63893 42.1372 6.86278 43.3611 8.36808 44.1281C10.0794 45 12.3196 45 16.8 45H31.2C35.6804 45 37.9206 45 39.6319 44.1281C41.1372 43.3611 42.3611 42.1372 43.1281 40.6319C44 38.9206 44 36.6804 44 32.2V28.8C44 24.3196 44 22.0794 43.1281 20.3681C42.3611 18.8628 41.1372 17.6389 39.6319 16.8719ZM31 11V16H17V11C17 7.13401 20.134 4 24 4C27.866 4 31 7.13401 31 11ZM7.54497 21.73C7 22.7996 7 24.1997 7 27V34C7 36.8003 7 38.2004 7.54497 39.27C8.02433 40.2108 8.78924 40.9757 9.73005 41.455C10.7996 42 12.1997 42 15 42H33C35.8003 42 37.2004 42 38.27 41.455C39.2108 40.9757 39.9757 40.2108 40.455 39.27C41 38.2004 41 36.8003 41 34V27C41 24.1997 41 22.7996 40.455 21.73C39.9757 20.7892 39.2108 20.0243 38.27 19.545C37.2004 19 35.8003 19 33 19H15C12.1997 19 10.7996 19 9.73005 19.545C8.78924 20.0243 8.02433 20.7892 7.54497 21.73ZM24 24C23.1716 24 22.5 24.6716 22.5 25.5V29.5C22.5 30.3284 23.1716 31 24 31C24.8284 31 25.5 30.3284 25.5 29.5V25.5C25.5 24.6716 24.8284 24 24 24Z"></path></svg>')
  , SecurityIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$e.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$d = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M37.485 37.3849C40.894 33.9506 43 29.2212 43 24C43 13.5066 34.4934 5 24 5C13.5066 5 5 13.5066 5 24C5 29.2213 7.1061 33.9507 10.5151 37.385C13.3583 32.9438 18.3354 30 24.0001 30C29.6647 30 34.6418 32.9437 37.485 37.3849ZM35.1809 39.3635C32.9143 35.5532 28.7554 33 24.0001 33C19.2448 33 15.0858 35.5533 12.8193 39.3636C15.9564 41.6506 19.8206 43 24 43C28.1795 43 32.0437 41.6505 35.1809 39.3635ZM24 46C36.1503 46 46 36.1503 46 24C46 11.8497 36.1503 2 24 2C11.8497 2 2 11.8497 2 24C2 36.1503 11.8497 46 24 46ZM24 24C26.7614 24 29 21.7614 29 19C29 16.2386 26.7614 14 24 14C21.2386 14 19 16.2386 19 19C19 21.7614 21.2386 24 24 24ZM24 27C28.4183 27 32 23.4183 32 19C32 14.5817 28.4183 11 24 11C19.5817 11 16 14.5817 16 19C16 23.4183 19.5817 27 24 27Z"></path></svg>')
  , PersonalityIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$d.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$c = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 48 48" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M34.5607 4.43934C33.9749 3.85355 33.0251 3.85355 32.4393 4.43934C31.8536 5.02513 31.8536 5.97487 32.4393 6.56066L37.8787 12H10.5C9.67157 12 9 12.6716 9 13.5C9 14.3284 9.67157 15 10.5 15H37.8787L32.4393 20.4393C31.8536 21.0251 31.8536 21.9749 32.4393 22.5607C33.0251 23.1464 33.9749 23.1464 34.5607 22.5607L42.5607 14.5607C43.1464 13.9749 43.1464 13.0251 42.5607 12.4393L34.5607 4.43934ZM13.4393 25.4393C14.0251 24.8536 14.9749 24.8536 15.5607 25.4393C16.1464 26.0251 16.1464 26.9749 15.5607 27.5607L10.1213 33H37.5C38.3284 33 39 33.6716 39 34.5C39 35.3284 38.3284 36 37.5 36H10.1213L15.5607 41.4393C16.1464 42.0251 16.1464 42.9749 15.5607 43.5607C14.9749 44.1464 14.0251 44.1464 13.4393 43.5607L5.43934 35.5607C4.85355 34.9749 4.85355 34.0251 5.43934 33.4393L13.4393 25.4393Z"></path></svg>')
  , SwapIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$c.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$b = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="29" viewBox="0 0 28 29" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.75 12.002C1.75 9.20169 1.75 7.80156 2.29497 6.732C2.77433 5.79119 3.53924 5.02629 4.48005 4.54692C5.54961 4.00195 6.94974 4.00195 9.75 4.00195H17.25C20.0503 4.00195 21.4504 4.00195 22.52 4.54692C23.4608 5.02629 24.2257 5.79119 24.705 6.732C24.8256 6.96861 24.9195 7.2214 24.9926 7.50195H21.5C19.6377 7.50195 18.7065 7.50195 17.9609 7.77334C16.711 8.22828 15.7263 9.21291 15.2714 10.4629C15 11.2085 15 12.1396 15 14.002C15 15.8643 15 16.7954 15.2714 17.541C15.7263 18.791 16.711 19.7756 17.9609 20.2306C18.7065 20.502 19.6377 20.502 21.5 20.502H24.9926C24.9195 20.7825 24.8256 21.0353 24.705 21.2719C24.2257 22.2127 23.4608 22.9776 22.52 23.457C21.4504 24.002 20.0503 24.002 17.25 24.002H9.75C6.94974 24.002 5.54961 24.002 4.48005 23.457C3.53924 22.9776 2.77433 22.2127 2.29497 21.2719C1.75 20.2023 1.75 18.8022 1.75 16.002V12.002ZM16.4999 13.802C16.4999 12.1218 16.4999 11.2817 16.8269 10.64C17.1145 10.0755 17.5735 9.61656 18.138 9.32894C18.7797 9.00196 19.6198 9.00196 21.2999 9.00196H23.1999C24.8801 9.00196 25.7202 9.00196 26.3619 9.32894C26.9264 9.61656 27.3853 10.0755 27.673 10.64C27.9999 11.2817 27.9999 12.1218 27.9999 13.802V14.202C27.9999 15.8821 27.9999 16.7222 27.673 17.3639C27.3853 17.9284 26.9264 18.3874 26.3619 18.675C25.7202 19.002 24.8801 19.002 23.1999 19.002H21.2999C19.6198 19.002 18.7797 19.002 18.138 18.675C17.5735 18.3874 17.1145 17.9284 16.8269 17.3639C16.4999 16.7222 16.4999 15.8821 16.4999 14.202V13.802ZM22.4999 14.002C22.4999 14.9685 21.7164 15.752 20.7499 15.752C19.7834 15.752 18.9999 14.9685 18.9999 14.002C18.9999 13.0355 19.7834 12.252 20.7499 12.252C21.7164 12.252 22.4999 13.0355 22.4999 14.002Z"></path></svg>')
  , AtWalletIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.constant.white;
    return (()=>{
        const _ = _tmpl$$b.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$a = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M24.7803 7.21967C25.0732 7.51256 25.0732 7.98744 24.7803 8.28033L11.5303 21.5303C11.2374 21.8232 10.7626 21.8232 10.4697 21.5303L4.21967 15.2803C3.92678 14.9874 3.92678 14.5126 4.21967 14.2197C4.51256 13.9268 4.98744 13.9268 5.28033 14.2197L11 19.9393L23.7197 7.21967C24.0126 6.92678 24.4874 6.92678 24.7803 7.21967Z"></path></svg>')
  , DoneIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$a.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$9 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.0001 10.0001C10.0016 8.02333 10.0267 6.98719 10.436 6.18404C10.8195 5.43139 11.4314 4.81947 12.184 4.43597C13.0397 4 14.1598 4 16.4 4H17.6C19.8402 4 20.9603 4 21.816 4.43597C22.5686 4.81947 23.1805 5.43139 23.564 6.18404C24 7.03969 24 8.15979 24 10.4V11.6C24 13.8402 24 14.9603 23.564 15.816C23.1805 16.5686 22.5686 17.1805 21.816 17.564C21.0128 17.9733 19.9767 17.9984 17.9999 17.9999C17.9984 19.9767 17.9733 21.0128 17.564 21.816C17.1805 22.5686 16.5686 23.1805 15.816 23.564C14.9603 24 13.8402 24 11.6 24H10.4C8.15979 24 7.03969 24 6.18404 23.564C5.43139 23.1805 4.81947 22.5686 4.43597 21.816C4 20.9603 4 19.8402 4 17.6V16.4C4 14.1598 4 13.0397 4.43597 12.184C4.81947 11.4314 5.43139 10.8195 6.18404 10.436C6.98719 10.0267 8.02333 10.0016 10.0001 10.0001ZM10 11.5H9.5C8.09987 11.5 7.3998 11.5 6.86502 11.7725C6.39462 12.0122 6.01217 12.3946 5.77248 12.865C5.5 13.3998 5.5 14.0999 5.5 15.5V18.5C5.5 19.9001 5.5 20.6002 5.77248 21.135C6.01217 21.6054 6.39462 21.9878 6.86502 22.2275C7.3998 22.5 8.09987 22.5 9.5 22.5H12.5C13.9001 22.5 14.6002 22.5 15.135 22.2275C15.6054 21.9878 15.9878 21.6054 16.2275 21.135C16.5 20.6002 16.5 19.9001 16.5 18.5V18H16.4C14.1598 18 13.0397 18 12.184 17.564C11.4314 17.1805 10.8195 16.5686 10.436 15.816C10 14.9603 10 13.8402 10 11.6V11.5ZM11.5 9.5C11.5 8.09987 11.5 7.3998 11.7725 6.86502C12.0122 6.39462 12.3946 6.01217 12.865 5.77248C13.3998 5.5 14.0999 5.5 15.5 5.5H18.5C19.9001 5.5 20.6002 5.5 21.135 5.77248C21.6054 6.01217 21.9878 6.39462 22.2275 6.86502C22.5 7.3998 22.5 8.09987 22.5 9.5V12.5C22.5 13.9001 22.5 14.6002 22.2275 15.135C21.9878 15.6054 21.6054 15.9878 21.135 16.2275C20.6002 16.5 19.9001 16.5 18.5 16.5H15.5C14.0999 16.5 13.3998 16.5 12.865 16.2275C12.3946 15.9878 12.0122 15.6054 11.7725 15.135C11.5 14.6002 11.5 13.9001 11.5 12.5V9.5Z"></path></svg>')
  , CopyLightIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$9.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = b()
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "fill", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$8 = template$1('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="17" viewBox="0 0 16 17" fill="none"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 4.12695C1 3.07754 1 2.55284 1.19202 2.14684C1.38986 1.72856 1.7266 1.39181 2.14489 1.19397C2.55088 1.00195 3.07559 1.00195 4.125 1.00195C5.17441 1.00195 5.69912 1.00195 6.10511 1.19397C6.5234 1.39181 6.86014 1.72856 7.05798 2.14684C7.25 2.55284 7.25 3.07754 7.25 4.12695C7.25 5.17636 7.25 5.70107 7.05798 6.10706C6.86014 6.52535 6.5234 6.8621 6.10511 7.05993C5.69912 7.25195 5.17441 7.25195 4.125 7.25195C3.07559 7.25195 2.55088 7.25195 2.14489 7.05993C1.7266 6.8621 1.38986 6.52535 1.19202 6.10706C1 5.70107 1 5.17636 1 4.12695ZM2.5 3.30195C2.5 3.02193 2.5 2.88191 2.5545 2.77496C2.60243 2.68088 2.67892 2.60439 2.773 2.55645C2.87996 2.50195 3.01997 2.50195 3.3 2.50195H4.95C5.23003 2.50195 5.37004 2.50195 5.477 2.55645C5.57108 2.60439 5.64757 2.68088 5.6955 2.77496C5.75 2.88191 5.75 3.02193 5.75 3.30195V4.95195C5.75 5.23198 5.75 5.37199 5.6955 5.47895C5.64757 5.57303 5.57108 5.64952 5.477 5.69746C5.37004 5.75195 5.23003 5.75195 4.95 5.75195H3.3C3.01997 5.75195 2.87996 5.75195 2.773 5.69746C2.67892 5.64952 2.60243 5.57303 2.5545 5.47895C2.5 5.37199 2.5 5.23198 2.5 4.95195V3.30195ZM1 11.877C1 10.8275 1 10.3028 1.19202 9.89684C1.38986 9.47856 1.7266 9.14181 2.14489 8.94397C2.55088 8.75195 3.07559 8.75195 4.125 8.75195C5.17441 8.75195 5.69912 8.75195 6.10511 8.94397C6.5234 9.14181 6.86014 9.47856 7.05798 9.89684C7.25 10.3028 7.25 10.8275 7.25 11.877C7.25 12.9264 7.25 13.4511 7.05798 13.8571C6.86014 14.2753 6.5234 14.6121 6.10511 14.8099C5.69912 15.002 5.17441 15.002 4.125 15.002C3.07559 15.002 2.55088 15.002 2.14489 14.8099C1.7266 14.6121 1.38986 14.2753 1.19202 13.8571C1 13.4511 1 12.9264 1 11.877ZM2.5 11.052C2.5 10.7719 2.5 10.6319 2.5545 10.525C2.60243 10.4309 2.67892 10.3544 2.773 10.3064C2.87996 10.252 3.01997 10.252 3.3 10.252H4.95C5.23003 10.252 5.37004 10.252 5.477 10.3064C5.57108 10.3544 5.64757 10.4309 5.6955 10.525C5.75 10.6319 5.75 10.7719 5.75 11.052V12.702C5.75 12.982 5.75 13.122 5.6955 13.2289C5.64757 13.323 5.57108 13.3995 5.477 13.4475C5.37004 13.502 5.23003 13.502 4.95 13.502H3.3C3.01997 13.502 2.87996 13.502 2.773 13.4475C2.67892 13.3995 2.60243 13.323 2.5545 13.2289C2.5 13.122 2.5 12.982 2.5 12.702V11.052ZM8.94202 2.14684C8.75 2.55284 8.75 3.07754 8.75 4.12695C8.75 5.17636 8.75 5.70107 8.94202 6.10706C9.13986 6.52535 9.4766 6.8621 9.89489 7.05993C10.3009 7.25195 10.8256 7.25195 11.875 7.25195C12.9244 7.25195 13.4491 7.25195 13.8551 7.05993C14.2734 6.8621 14.6101 6.52535 14.808 6.10706C15 5.70107 15 5.17636 15 4.12695C15 3.07754 15 2.55284 14.808 2.14684C14.6101 1.72856 14.2734 1.39181 13.8551 1.19397C13.4491 1.00195 12.9244 1.00195 11.875 1.00195C10.8256 1.00195 10.3009 1.00195 9.89489 1.19397C9.4766 1.39181 9.13986 1.72856 8.94202 2.14684ZM10.3045 2.77496C10.25 2.88191 10.25 3.02193 10.25 3.30195V4.95195C10.25 5.23198 10.25 5.37199 10.3045 5.47895C10.3524 5.57303 10.4289 5.64952 10.523 5.69746C10.63 5.75195 10.77 5.75195 11.05 5.75195H12.7C12.98 5.75195 13.12 5.75195 13.227 5.69746C13.3211 5.64952 13.3976 5.57303 13.4455 5.47895C13.5 5.37199 13.5 5.23198 13.5 4.95195V3.30195C13.5 3.02193 13.5 2.88191 13.4455 2.77496C13.3976 2.68088 13.3211 2.60439 13.227 2.55645C13.12 2.50195 12.98 2.50195 12.7 2.50195H11.05C10.77 2.50195 10.63 2.50195 10.523 2.55645C10.4289 2.60439 10.3524 2.68088 10.3045 2.77496ZM8.80727 9.13518C8.75 9.26242 8.75 9.4256 8.75 9.75195C8.75 10.0783 8.75 10.2415 8.80727 10.3687C8.87245 10.5136 8.9884 10.6295 9.13323 10.6947C9.26047 10.752 9.42365 10.752 9.75 10.752C10.0764 10.752 10.2395 10.752 10.3668 10.6947C10.5116 10.6295 10.6276 10.5136 10.6927 10.3687C10.75 10.2415 10.75 10.0783 10.75 9.75195C10.75 9.4256 10.75 9.26242 10.6927 9.13518C10.6276 8.99035 10.5116 8.8744 10.3668 8.80922C10.2395 8.75195 10.0764 8.75195 9.75 8.75195C9.42365 8.75195 9.26047 8.75195 9.13323 8.80922C8.9884 8.8744 8.87245 8.99035 8.80727 9.13518ZM10.87 11.8771C10.87 11.546 10.87 11.3805 10.9289 11.2517C10.9938 11.1098 11.1077 10.9959 11.2497 10.931C11.3784 10.8721 11.5439 10.8721 11.875 10.8721C12.2061 10.8721 12.3716 10.8721 12.5003 10.931C12.6423 10.9959 12.7562 11.1098 12.8211 11.2517C12.88 11.3805 12.88 11.546 12.88 11.8771C12.88 12.2081 12.88 12.3737 12.8211 12.5024C12.7562 12.6444 12.6423 12.7583 12.5003 12.8232C12.3716 12.8821 12.2061 12.8821 11.875 12.8821C11.5439 12.8821 11.3784 12.8821 11.2497 12.8232C11.1077 12.7583 10.9938 12.6444 10.9289 12.5024C10.87 12.3737 10.87 12.2081 10.87 11.8771ZM8.80727 13.3852C8.75 13.5124 8.75 13.6756 8.75 14.002C8.75 14.3283 8.75 14.4915 8.80727 14.6187C8.87245 14.7636 8.9884 14.8795 9.13323 14.9447C9.26047 15.002 9.42365 15.002 9.75 15.002C10.0764 15.002 10.2395 15.002 10.3668 14.9447C10.5116 14.8795 10.6276 14.7636 10.6927 14.6187C10.75 14.4915 10.75 14.3283 10.75 14.002C10.75 13.6756 10.75 13.5124 10.6927 13.3852C10.6276 13.2404 10.5116 13.1244 10.3668 13.0592C10.2395 13.002 10.0764 13.002 9.75 13.002C9.42365 13.002 9.26047 13.002 9.13323 13.0592C8.9884 13.1244 8.87245 13.2404 8.80727 13.3852ZM13 9.75195C13 9.4256 13 9.26242 13.0573 9.13518C13.1224 8.99035 13.2384 8.8744 13.3832 8.80922C13.5105 8.75195 13.6736 8.75195 14 8.75195C14.3264 8.75195 14.4895 8.75195 14.6168 8.80922C14.7616 8.8744 14.8776 8.99035 14.9427 9.13518C15 9.26242 15 9.4256 15 9.75195C15 10.0783 15 10.2415 14.9427 10.3687C14.8776 10.5136 14.7616 10.6295 14.6168 10.6947C14.4895 10.752 14.3264 10.752 14 10.752C13.6736 10.752 13.5105 10.752 13.3832 10.6947C13.2384 10.6295 13.1224 10.5136 13.0573 10.3687C13 10.2415 13 10.0783 13 9.75195ZM13.0573 13.3852C13 13.5124 13 13.6756 13 14.002C13 14.3283 13 14.4915 13.0573 14.6187C13.1224 14.7636 13.2384 14.8795 13.3832 14.9447C13.5105 15.002 13.6736 15.002 14 15.002C14.3264 15.002 14.4895 15.002 14.6168 14.9447C14.7616 14.8795 14.8776 14.7636 14.9427 14.6187C15 14.4915 15 14.3283 15 14.002C15 13.6756 15 13.5124 14.9427 13.3852C14.8776 13.2404 14.7616 13.1244 14.6168 13.0592C14.4895 13.002 14.3264 13.002 14 13.002C13.6736 13.002 13.5105 13.002 13.3832 13.0592C13.2384 13.1244 13.1224 13.2404 13.0573 13.3852Z"></path></svg>')
  , QRIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.secondary;
    return (()=>{
        const _ = _tmpl$$8.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(()=>setAttribute($, "fill", b())),
        _
    }
    )()
}
  , containerBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , walletBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , FourWalletsCard = styled.div`
    width: 60px;
    height: 60px;
    padding: 8px;
    margin-bottom: 8px;
    border-radius: ${d=>containerBorders[d.theme.borderRadius]};
    background-color: ${d=>d.theme.colors.background.tint};
    display: grid;
    grid-template: 1fr 1fr / 1fr 1fr;
    gap: 4px;
`
  , FourWalletsImage = styled(WalletImage)`
    width: 20px;
    height: 20px;
    border-radius: ${d=>walletBorders[d.theme.borderRadius]};
`
  , FourWalletsItem = d=>createComponent(WalletItem, {
    get name() {
        return d.labelLine1
    },
    get secondLine() {
        return d.labelLine2
    },
    get icon() {
        return createComponent(FourWalletsCard, {
            get children() {
                return createComponent(For, {
                    each: [0, 1, 2, 3],
                    children: g=>createComponent(FourWalletsImage, {
                        get src() {
                            return d.images[g]
                        }
                    })
                })
            }
        })
    },
    onClick: ()=>d.onClick()
})
  , AT_WALLET_APP_NAME = "telegram-wallet"
  , IMG = {
    TON: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/ton-icon-48.png",
    TG: "https://raw.githubusercontent.com/ton-connect/sdk/main/assets/tg.png"
}
  , WalletLabeledItem = d=>{
    const [g] = useI18n()
      , b = ()=>{
        if (d.wallet.appName !== AT_WALLET_APP_NAME) {
            if ("isPreferred"in d.wallet && d.wallet.isPreferred)
                return g("walletItem.recent", {}, "Recent");
            if (isWalletInfoCurrentlyInjected(d.wallet))
                return g("walletItem.installed", {}, "Installed");
            if (d.wallet.name === "Tonkeeper")
                return g("walletItem.popular", {}, "Popular")
        }
    }
    ;
    return createMemo((()=>{
        const _ = createMemo(()=>d.wallet.appName === AT_WALLET_APP_NAME);
        return ()=>_() ? createComponent(WalletItem, {
            get icon() {
                return d.wallet.imageUrl
            },
            get name() {
                return g("walletItem.walletOn", {}, "Wallet On")
            },
            secondLine: "Telegram",
            get badgeUrl() {
                return IMG.TG
            },
            onClick: ()=>d.onClick()
        }) : createComponent(WalletItem, {
            get icon() {
                return d.wallet.imageUrl
            },
            get name() {
                return d.wallet.name
            },
            get secondLine() {
                return b()
            },
            secondLineColorPrimary: !1,
            onClick: ()=>d.onClick()
        })
    }
    )())
}
  , ScrollContainerStyled = styled.div`
    width: 100%;
    overflow-y: auto;
    max-height: ${d=>d.maxHeight};

    scrollbar-width: none;
    &&::-webkit-scrollbar {
        display: none;
    }

    &&::-webkit-scrollbar-track {
        background: transparent;
    }

    &&::-webkit-scrollbar-thumb {
        display: none;
    }
`
  , ScrollDivider = styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.08;
    background: ${d=>d.isShown ? d.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
        margin: 0;
    }
`
  , [windowHeight,setWindowHeight] = createSignal(((_h = getWindow$1()) == null ? void 0 : _h.innerHeight) || 0);
getWindow$1() && window.addEventListener("resize", ()=>setWindowHeight(window.innerHeight));
const [isMobile,setIsMobile] = createSignal(isDevice("mobile"))
  , updateIsMobile = ()=>setIsMobile(isDevice("mobile"));
getWindow$1() && (window.addEventListener("resize", ()=>updateIsMobile()),
window.addEventListener("load", ()=>updateIsMobile(), {
    once: !0
}));
const ScrollContainer = d=>{
    const [g,b] = createSignal(!1)
      , _ = tt=>{
        b(tt.target.scrollTop > 0)
    }
      , $ = ()=>isMobile() ? 150 : 200
      , et = ()=>d.maxHeight !== void 0 ? `${d.maxHeight}px` : `${windowHeight() - $()}px`;
    return [createComponent(ScrollDivider, {
        get isShown() {
            return g()
        }
    }), createComponent(ScrollContainerStyled, {
        get maxHeight() {
            return et()
        },
        onScroll: _,
        get class() {
            return d.class
        },
        get children() {
            return d.children
        }
    })]
}
  , AStyled = styled.a`
    display: block;
    text-decoration: unset;
`
  , Link = d=>createComponent(AStyled, mergeProps({
    get href() {
        return d.href
    },
    get target() {
        return d.blank ? "_blank" : "_self"
    },
    get class() {
        return d.class
    }
}, ()=>d.blank ? {
    rel: "noreferrer noopener"
} : {}, {
    get children() {
        return d.children
    }
}))
  , TonConnectUiContext = createContext()
  , _tmpl$$7 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z"></path></svg>')
  , CopyIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$7.cloneNode(!0)
          , $ = _.firstChild;
        return createRenderEffect(et=>{
            const tt = d.class
              , rt = b();
            return tt !== et._v$ && setAttribute(_, "class", et._v$ = tt),
            rt !== et._v$2 && setAttribute($, "fill", et._v$2 = rt),
            et
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , _tmpl$$6 = template$1('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z"></path><path d="M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z"></path></svg>')
  , DisconnectIcon = d=>{
    const g = useTheme()
      , b = ()=>d.fill || g.colors.icon.primary;
    return (()=>{
        const _ = _tmpl$$6.cloneNode(!0)
          , $ = _.firstChild
          , et = $.nextSibling;
        return createRenderEffect(tt=>{
            const rt = b()
              , nt = b();
            return rt !== tt._v$ && setAttribute($, "fill", tt._v$ = rt),
            nt !== tt._v$2 && setAttribute(et, "fill", tt._v$2 = nt),
            tt
        }
        , {
            _v$: void 0,
            _v$2: void 0
        }),
        _
    }
    )()
}
  , hoverBorders$1 = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , dropdownBorders = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , AccountButtonDropdownStyled = styled.div`
    width: 256px;
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${d=>dropdownBorders[d.theme.borderRadius]};

    background-color: ${d=>d.theme.colors.background.primary}
           
    color: ${d=>d.theme.colors.text.primary}
`
  , UlStyled$1 = styled.ul`
    background-color: ${d=>d.theme.colors.background.primary};
    padding: 8px;
`
  , MenuButtonStyled = styled.button`
    display: flex;
    align-items: center;
    gap: 8px;
    height: 40px;
    padding-left: 8px;
    width: 100%;

    background-color: ${d=>d.theme.colors.background.primary};
    border: none;
    border-radius: ${d=>hoverBorders$1[d.theme.borderRadius]};
    cursor: pointer;

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${d=>d.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`
  , _tmpl$$5 = template$1("<li></li>")
  , MenuItemText = d=>createComponent(Text, {
    get translationKey() {
        return d.translationKey
    },
    fontSize: "15px",
    fontWeight: "590",
    get children() {
        return d.children
    }
})
  , AccountButtonDropdown = d=>{
    const g = useContext(TonConnectUiContext)
      , [b,_] = createSignal(!1)
      , $ = ()=>__async(void 0, null, function*() {
        const tt = toUserFriendlyAddress(g.account.address, g.account.chain === CHAIN.TESTNET);
        yield copyToClipboard(tt),
        _(!0),
        setTimeout(()=>_(!1), 1e3)
    })
      , et = ()=>{
        g.disconnect(),
        d.onClose()
    }
    ;
    return createComponent(AccountButtonDropdownStyled, {
        ref(tt) {
            const rt = d.ref;
            typeof rt == "function" ? rt(tt) : d.ref = tt
        },
        get class() {
            return d.class
        },
        "data-tc-dropdown": "true",
        get children() {
            return createComponent(UlStyled$1, {
                get children() {
                    return [(()=>{
                        const tt = _tmpl$$5.cloneNode(!0);
                        return insert(tt, createComponent(MenuButtonStyled, {
                            onClick: ()=>$(),
                            get children() {
                                return [createComponent(CopyIcon, {}), createComponent(Show, {
                                    get when() {
                                        return !b()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copy",
                                            children: "Copy address"
                                        })
                                    }
                                }), createComponent(Show, {
                                    get when() {
                                        return b()
                                    },
                                    get children() {
                                        return createComponent(MenuItemText, {
                                            translationKey: "button.dropdown.copied",
                                            children: "Address copied!"
                                        })
                                    }
                                })]
                            }
                        })),
                        tt
                    }
                    )(), (()=>{
                        const tt = _tmpl$$5.cloneNode(!0);
                        return insert(tt, createComponent(MenuButtonStyled, {
                            onClick: ()=>et(),
                            get children() {
                                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {
                                    translationKey: "button.dropdown.disconnect",
                                    children: "Disconnect"
                                })]
                            }
                        })),
                        tt
                    }
                    )()]
                }
            })
        }
    })
}
  , borders$2 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , NotificationStyled = styled.div`
    width: 256px;
    padding: 12px 16px;
    display: flex;
    gap: 9px;

    background-color: ${d=>d.theme.colors.background.primary};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
    border-radius: ${d=>borders$2[d.theme.borderRadius]};
`
  , NotificationContentStyled = styled.div`
    width: 192px;

    > h3 {
        font-size: 15px;
    }
`
  , TextStyled$2 = styled(Text)`
    margin-top: 4px;
    color: ${d=>d.theme.colors.text.secondary};
`
  , Notification = d=>{
    const g = useDataAttributes(d);
    return createComponent(NotificationStyled, mergeProps({
        get class() {
            return d.class
        },
        "data-tc-notification": "true"
    }, g, {
        get children() {
            return [createComponent(NotificationContentStyled, {
                get children() {
                    return [createComponent(H3, {
                        get translationKey() {
                            return d.header.translationKey
                        },
                        get translationValues() {
                            return d.header.translationValues
                        },
                        get children() {
                            return d.children
                        }
                    }), createComponent(Show, {
                        get when() {
                            return d.text
                        },
                        get children() {
                            return createComponent(TextStyled$2, {
                                get translationKey() {
                                    return d.text.translationKey
                                },
                                get translationValues() {
                                    return d.text.translationValues
                                }
                            })
                        }
                    })]
                }
            }), createMemo(()=>d.icon)]
        }
    }))
}
  , LoaderIconStyled$2 = styled(LoaderIcon)`
    align-self: center;
`
  , ConfirmOperationNotification = d=>{
    const g = useContext(TonConnectUiContext)
      , [b] = useI18n()
      , _ = ()=>g.wallet && "name"in g.wallet ? g.wallet.name : b("common.yourWallet", {}, "Your wallet");
    return createComponent(Notification, {
        get header() {
            return {
                translationKey: "notifications.confirm.header",
                translationValues: {
                    name: _()
                }
            }
        },
        get class() {
            return d.class
        },
        get icon() {
            return createComponent(LoaderIconStyled$2, {})
        },
        "data-tc-notification-confirm": "true",
        children: "Confirm operation in your wallet"
    })
}
  , ErrorIconStyled$2 = styled(ErrorIcon)`
    margin-top: 2px;
`
  , ErrorTransactionNotification = d=>createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionCanceled.header"
    },
    text: {
        translationKey: "notifications.transactionCanceled.text"
    },
    get icon() {
        return createComponent(ErrorIconStyled$2, {
            size: "xs"
        })
    },
    get class() {
        return d.class
    },
    "data-tc-notification-tx-cancelled": "true",
    children: "Transaction cancelled"
})
  , SuccessIconStyled = styled(SuccessIcon)`
    margin-top: 2px;
`
  , SuccessTransactionNotification = d=>createComponent(Notification, {
    header: {
        translationKey: "notifications.transactionSent.header"
    },
    text: {
        translationKey: "notifications.transactionSent.text"
    },
    get icon() {
        return createComponent(SuccessIconStyled, {})
    },
    get class() {
        return d.class
    },
    "data-tc-notification-tx-sent": "true",
    children: "Transaction sent"
})
  , NotificationClass = u$2`
    transform: translateY(-8px);
    margin-bottom: 12px;
`
  , defaultConfig = {
    timeout: 4500
}
  , [latestAction,setLatestAction] = createSignal(null);
function useOpenedNotifications(d) {
    const {timeout: g} = __spreadValues$1(__spreadValues$1({}, defaultConfig), d)
      , [b,_] = createSignal([])
      , [$,et] = createSignal([]);
    return createEffect(on(action, tt=>{
        var rt;
        if (!tt || !tt.showNotification || latestAction() === tt || ((rt = latestAction()) == null ? void 0 : rt.name) === "confirm-transaction" && tt.name === "confirm-transaction")
            return;
        setLatestAction(tt),
        _(ot=>ot.filter(at=>at.action !== "confirm-transaction"));
        const nt = {
            action: tt.name
        };
        _(ot=>[...ot, nt]);
        const it = setTimeout(()=>{
            _(ot=>ot.filter(at=>at !== nt)),
            et(ot=>ot.filter(at=>at !== it))
        }
        , g);
        et(ot=>[...ot, it])
    }
    )),
    onCleanup(()=>{
        $().forEach(tt=>clearTimeout(tt))
    }
    ),
    b
}
const _tmpl$$4 = template$1('<div data-tc-list-notifications="true"></div>')
  , Notifications = d=>{
    const g = useOpenedNotifications();
    return (()=>{
        const b = _tmpl$$4.cloneNode(!0);
        return insert(b, createComponent(TransitionGroup, {
            onBeforeEnter: _=>{
                animate(_, [{
                    opacity: 0,
                    transform: "translateY(0)"
                }, {
                    opacity: 1,
                    transform: "translateY(-8px)"
                }], {
                    duration: 200
                })
            }
            ,
            onExit: (_,$)=>{
                animate(_, [{
                    opacity: 1,
                    transform: "translateY(-8px)"
                }, {
                    opacity: 0,
                    transform: "translateY(-30px)"
                }], {
                    duration: 200
                }).finished.then($)
            }
            ,
            get children() {
                return createComponent(For, {
                    get each() {
                        return g()
                    },
                    children: _=>createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return _.action === "transaction-sent"
                                },
                                get children() {
                                    return createComponent(SuccessTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return _.action === "transaction-canceled"
                                },
                                get children() {
                                    return createComponent(ErrorTransactionNotification, {
                                        class: NotificationClass
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return _.action === "confirm-transaction"
                                },
                                get children() {
                                    return createComponent(ConfirmOperationNotification, {
                                        class: NotificationClass
                                    })
                                }
                            })]
                        }
                    })
                })
            }
        })),
        createRenderEffect(()=>className(b, d.class)),
        b
    }
    )()
}
  , AccountButtonStyled = styled(Button)`
    background-color: ${d=>d.theme.colors.connectButton.background};
    color: ${d=>d.theme.colors.connectButton.foreground};
    box-shadow: ${d=>`0 4px 24px ${rgba$1(d.theme.colors.constant.black, .16)}`};
    padding: 8px 16px 8px 12px;

    display: flex;
    align-items: center;
    gap: 4px;
    height: 40px;
`
  , DropdownButtonStyled = styled(AccountButtonStyled)`
    padding: 12px 16px;
    min-width: 148px;
    justify-content: center;
    background-color: ${d=>d.theme.colors.background.primary};
`
  , LoaderButtonStyled$1 = styled(Button)`
    min-width: 148px;
    height: 40px;

    background-color: ${d=>d.theme.colors.background.primary};
    color: ${d=>d.theme.colors.connectButton.foreground};
    box-shadow: ${d=>`0 4px 24px ${rgba$1(d.theme.colors.constant.black, .16)}`};

    display: flex;
    align-items: center;
    justify-content: center;
`
  , LoaderIconStyled$1 = styled(LoaderIcon)`
    height: 18px;
    width: 18px;
`
  , DropdownContainerStyled = styled.div`
    width: fit-content;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
`
  , DropdownStyled = styled(AccountButtonDropdown)`
    box-sizing: border-box;
    overflow: hidden;
    margin-top: 12px;
`
  , NotificationsStyled = styled(Notifications)`
    > div:first-child {
        margin-top: 20px;
    }
`;
function getSide(d) {
    return d.split("-")[0]
}
function getAlignment(d) {
    return d.split("-")[1]
}
function getMainAxisFromPlacement(d) {
    return ["top", "bottom"].includes(getSide(d)) ? "x" : "y"
}
function getLengthFromAxis(d) {
    return d === "y" ? "height" : "width"
}
function computeCoordsFromPlacement(d, g, b) {
    let {reference: _, floating: $} = d;
    const et = _.x + _.width / 2 - $.width / 2
      , tt = _.y + _.height / 2 - $.height / 2
      , rt = getMainAxisFromPlacement(g)
      , nt = getLengthFromAxis(rt)
      , it = _[nt] / 2 - $[nt] / 2
      , ot = getSide(g)
      , at = rt === "x";
    let st;
    switch (ot) {
    case "top":
        st = {
            x: et,
            y: _.y - $.height
        };
        break;
    case "bottom":
        st = {
            x: et,
            y: _.y + _.height
        };
        break;
    case "right":
        st = {
            x: _.x + _.width,
            y: tt
        };
        break;
    case "left":
        st = {
            x: _.x - $.width,
            y: tt
        };
        break;
    default:
        st = {
            x: _.x,
            y: _.y
        }
    }
    switch (getAlignment(g)) {
    case "start":
        st[rt] -= it * (b && at ? -1 : 1);
        break;
    case "end":
        st[rt] += it * (b && at ? -1 : 1);
        break
    }
    return st
}
const computePosition$1 = (d,g,b)=>__async(void 0, null, function*() {
    const {placement: _="bottom", strategy: $="absolute", middleware: et=[], platform: tt} = b
      , rt = et.filter(Boolean)
      , nt = yield tt.isRTL == null ? void 0 : tt.isRTL(g);
    if ({}.NODE_ENV !== "production") {
        if (tt == null && console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" ")),
        rt.filter(ht=>{
            let {name: xt} = ht;
            return xt === "autoPlacement" || xt === "flip"
        }
        ).length > 1)
            throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement` middleware", "detected. This will lead to an infinite loop. Ensure only one of", "either has been passed to the `middleware` array."].join(" "));
        (!d || !g) && console.error(["Floating UI: The reference and/or floating element was not defined", "when `computePosition()` was called. Ensure that both elements have", "been created and can be measured."].join(" "))
    }
    let it = yield tt.getElementRects({
        reference: d,
        floating: g,
        strategy: $
    })
      , {x: ot, y: at} = computeCoordsFromPlacement(it, _, nt)
      , st = _
      , dt = {}
      , ft = 0;
    for (let ht = 0; ht < rt.length; ht++) {
        const {name: xt, fn: lt} = rt[ht]
          , {x: ct, y: ut, data: pt, reset: vt} = yield lt({
            x: ot,
            y: at,
            initialPlacement: _,
            placement: st,
            strategy: $,
            middlewareData: dt,
            rects: it,
            platform: tt,
            elements: {
                reference: d,
                floating: g
            }
        });
        if (ot = ct ?? ot,
        at = ut ?? at,
        dt = __spreadProps(__spreadValues$1({}, dt), {
            [xt]: __spreadValues$1(__spreadValues$1({}, dt[xt]), pt)
        }),
        {}.NODE_ENV !== "production" && ft > 50 && console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" ")),
        vt && ft <= 50) {
            ft++,
            typeof vt == "object" && (vt.placement && (st = vt.placement),
            vt.rects && (it = vt.rects === !0 ? yield tt.getElementRects({
                reference: d,
                floating: g,
                strategy: $
            }) : vt.rects),
            {x: ot, y: at} = computeCoordsFromPlacement(it, st, nt)),
            ht = -1;
            continue
        }
    }
    return {
        x: ot,
        y: at,
        placement: st,
        strategy: $,
        middlewareData: dt
    }
});
function rectToClientRect(d) {
    return __spreadProps(__spreadValues$1({}, d), {
        top: d.y,
        left: d.x,
        right: d.x + d.width,
        bottom: d.y + d.height
    })
}
function getWindow$2(d) {
    var g;
    return ((g = d.ownerDocument) == null ? void 0 : g.defaultView) || window
}
function getComputedStyle$1$1(d) {
    return getWindow$2(d).getComputedStyle(d)
}
function getNodeName(d) {
    return isNode$1(d) ? (d.nodeName || "").toLowerCase() : ""
}
let uaString;
function getUAString() {
    if (uaString)
        return uaString;
    const d = navigator.userAgentData;
    return d && Array.isArray(d.brands) ? (uaString = d.brands.map(g=>g.brand + "/" + g.version).join(" "),
    uaString) : navigator.userAgent
}
function isHTMLElement(d) {
    return d instanceof getWindow$2(d).HTMLElement
}
function isElement(d) {
    return d instanceof getWindow$2(d).Element
}
function isNode$1(d) {
    return d instanceof getWindow$2(d).Node
}
function isShadowRoot(d) {
    if (typeof ShadowRoot > "u")
        return !1;
    const g = getWindow$2(d).ShadowRoot;
    return d instanceof g || d instanceof ShadowRoot
}
function isOverflowElement(d) {
    const {overflow: g, overflowX: b, overflowY: _, display: $} = getComputedStyle$1$1(d);
    return /auto|scroll|overlay|hidden/.test(g + _ + b) && !["inline", "contents"].includes($)
}
function isTableElement(d) {
    return ["table", "td", "th"].includes(getNodeName(d))
}
function isContainingBlock(d) {
    const g = /firefox/i.test(getUAString())
      , b = getComputedStyle$1$1(d)
      , _ = b.backdropFilter || b.WebkitBackdropFilter;
    return b.transform !== "none" || b.perspective !== "none" || (_ ? _ !== "none" : !1) || g && b.willChange === "filter" || g && (b.filter ? b.filter !== "none" : !1) || ["transform", "perspective"].some($=>b.willChange.includes($)) || ["paint", "layout", "strict", "content"].some($=>{
        const et = b.contain;
        return et != null ? et.includes($) : !1
    }
    )
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function isLastTraversableNode(d) {
    return ["html", "body", "#document"].includes(getNodeName(d))
}
const min$2 = Math.min
  , max$1 = Math.max
  , round = Math.round
  , FALLBACK_SCALE = {
    x: 1,
    y: 1
};
function getScale(d) {
    const g = !isElement(d) && d.contextElement ? d.contextElement : isElement(d) ? d : null;
    if (!g)
        return FALLBACK_SCALE;
    const b = g.getBoundingClientRect()
      , _ = getComputedStyle$1$1(g);
    if (_.boxSizing !== "border-box")
        return isHTMLElement(g) ? {
            x: g.offsetWidth > 0 && round(b.width) / g.offsetWidth || 1,
            y: g.offsetHeight > 0 && round(b.height) / g.offsetHeight || 1
        } : FALLBACK_SCALE;
    let $ = b.width / parseFloat(_.width)
      , et = b.height / parseFloat(_.height);
    return (!$ || !Number.isFinite($)) && ($ = 1),
    (!et || !Number.isFinite(et)) && (et = 1),
    {
        x: $,
        y: et
    }
}
function getBoundingClientRect(d, g, b, _) {
    var $, et, tt, rt;
    g === void 0 && (g = !1),
    b === void 0 && (b = !1);
    const nt = d.getBoundingClientRect();
    let it = FALLBACK_SCALE;
    g && (_ ? isElement(_) && (it = getScale(_)) : it = getScale(d));
    const ot = isElement(d) ? getWindow$2(d) : window
      , at = !isLayoutViewport() && b
      , st = (nt.left + (at && ($ = (et = ot.visualViewport) == null ? void 0 : et.offsetLeft) != null ? $ : 0)) / it.x
      , dt = (nt.top + (at && (tt = (rt = ot.visualViewport) == null ? void 0 : rt.offsetTop) != null ? tt : 0)) / it.y
      , ft = nt.width / it.x
      , ht = nt.height / it.y;
    return {
        width: ft,
        height: ht,
        top: dt,
        right: st + ft,
        bottom: dt + ht,
        left: st,
        x: st,
        y: dt
    }
}
function getDocumentElement(d) {
    return ((isNode$1(d) ? d.ownerDocument : d.document) || window.document).documentElement
}
function getNodeScroll(d) {
    return isElement(d) ? {
        scrollLeft: d.scrollLeft,
        scrollTop: d.scrollTop
    } : {
        scrollLeft: d.pageXOffset,
        scrollTop: d.pageYOffset
    }
}
function getWindowScrollBarX(d) {
    return getBoundingClientRect(getDocumentElement(d)).left + getNodeScroll(d).scrollLeft
}
function getRectRelativeToOffsetParent(d, g, b) {
    const _ = isHTMLElement(g)
      , $ = getDocumentElement(g)
      , et = getBoundingClientRect(d, !0, b === "fixed", g);
    let tt = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const rt = {
        x: 0,
        y: 0
    };
    if (_ || !_ && b !== "fixed")
        if ((getNodeName(g) !== "body" || isOverflowElement($)) && (tt = getNodeScroll(g)),
        isHTMLElement(g)) {
            const nt = getBoundingClientRect(g, !0);
            rt.x = nt.x + g.clientLeft,
            rt.y = nt.y + g.clientTop
        } else
            $ && (rt.x = getWindowScrollBarX($));
    return {
        x: et.left + tt.scrollLeft - rt.x,
        y: et.top + tt.scrollTop - rt.y,
        width: et.width,
        height: et.height
    }
}
function getParentNode(d) {
    if (getNodeName(d) === "html")
        return d;
    const g = d.assignedSlot || d.parentNode || (isShadowRoot(d) ? d.host : null) || getDocumentElement(d);
    return isShadowRoot(g) ? g.host : g
}
function getTrueOffsetParent(d) {
    return !isHTMLElement(d) || getComputedStyle$1$1(d).position === "fixed" ? null : d.offsetParent
}
function getContainingBlock(d) {
    let g = getParentNode(d);
    for (; isHTMLElement(g) && !isLastTraversableNode(g); ) {
        if (isContainingBlock(g))
            return g;
        g = getParentNode(g)
    }
    return null
}
function getOffsetParent(d) {
    const g = getWindow$2(d);
    let b = getTrueOffsetParent(d);
    for (; b && isTableElement(b) && getComputedStyle$1$1(b).position === "static"; )
        b = getTrueOffsetParent(b);
    return b && (getNodeName(b) === "html" || getNodeName(b) === "body" && getComputedStyle$1$1(b).position === "static" && !isContainingBlock(b)) ? g : b || getContainingBlock(d) || g
}
function getDimensions(d) {
    if (isHTMLElement(d))
        return {
            width: d.offsetWidth,
            height: d.offsetHeight
        };
    const g = getBoundingClientRect(d);
    return {
        width: g.width,
        height: g.height
    }
}
function convertOffsetParentRelativeRectToViewportRelativeRect(d) {
    let {rect: g, offsetParent: b, strategy: _} = d;
    const $ = isHTMLElement(b)
      , et = getDocumentElement(b);
    if (b === et)
        return g;
    let tt = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , rt = {
        x: 1,
        y: 1
    };
    const nt = {
        x: 0,
        y: 0
    };
    if (($ || !$ && _ !== "fixed") && ((getNodeName(b) !== "body" || isOverflowElement(et)) && (tt = getNodeScroll(b)),
    isHTMLElement(b))) {
        const it = getBoundingClientRect(b);
        rt = getScale(b),
        nt.x = it.x + b.clientLeft,
        nt.y = it.y + b.clientTop
    }
    return {
        width: g.width * rt.x,
        height: g.height * rt.y,
        x: g.x * rt.x - tt.scrollLeft * rt.x + nt.x,
        y: g.y * rt.y - tt.scrollTop * rt.y + nt.y
    }
}
function getViewportRect(d, g) {
    const b = getWindow$2(d)
      , _ = getDocumentElement(d)
      , $ = b.visualViewport;
    let et = _.clientWidth
      , tt = _.clientHeight
      , rt = 0
      , nt = 0;
    if ($) {
        et = $.width,
        tt = $.height;
        const it = isLayoutViewport();
        (it || !it && g === "fixed") && (rt = $.offsetLeft,
        nt = $.offsetTop)
    }
    return {
        width: et,
        height: tt,
        x: rt,
        y: nt
    }
}
function getDocumentRect(d) {
    var g;
    const b = getDocumentElement(d)
      , _ = getNodeScroll(d)
      , $ = (g = d.ownerDocument) == null ? void 0 : g.body
      , et = max$1(b.scrollWidth, b.clientWidth, $ ? $.scrollWidth : 0, $ ? $.clientWidth : 0)
      , tt = max$1(b.scrollHeight, b.clientHeight, $ ? $.scrollHeight : 0, $ ? $.clientHeight : 0);
    let rt = -_.scrollLeft + getWindowScrollBarX(d);
    const nt = -_.scrollTop;
    return getComputedStyle$1$1($ || b).direction === "rtl" && (rt += max$1(b.clientWidth, $ ? $.clientWidth : 0) - et),
    {
        width: et,
        height: tt,
        x: rt,
        y: nt
    }
}
function getNearestOverflowAncestor(d) {
    const g = getParentNode(d);
    return isLastTraversableNode(g) ? d.ownerDocument.body : isHTMLElement(g) && isOverflowElement(g) ? g : getNearestOverflowAncestor(g)
}
function getOverflowAncestors(d, g) {
    var b;
    g === void 0 && (g = []);
    const _ = getNearestOverflowAncestor(d)
      , $ = _ === ((b = d.ownerDocument) == null ? void 0 : b.body)
      , et = getWindow$2(_);
    return $ ? g.concat(et, et.visualViewport || [], isOverflowElement(_) ? _ : []) : g.concat(_, getOverflowAncestors(_))
}
function getInnerBoundingClientRect(d, g) {
    const b = getBoundingClientRect(d, !0, g === "fixed")
      , _ = b.top + d.clientTop
      , $ = b.left + d.clientLeft
      , et = isHTMLElement(d) ? getScale(d) : {
        x: 1,
        y: 1
    }
      , tt = d.clientWidth * et.x
      , rt = d.clientHeight * et.y
      , nt = $ * et.x
      , it = _ * et.y;
    return {
        top: it,
        left: nt,
        right: nt + tt,
        bottom: it + rt,
        x: nt,
        y: it,
        width: tt,
        height: rt
    }
}
function getClientRectFromClippingAncestor(d, g, b) {
    return g === "viewport" ? rectToClientRect(getViewportRect(d, b)) : isElement(g) ? getInnerBoundingClientRect(g, b) : rectToClientRect(getDocumentRect(getDocumentElement(d)))
}
function getClippingElementAncestors(d, g) {
    const b = g.get(d);
    if (b)
        return b;
    let _ = getOverflowAncestors(d).filter(rt=>isElement(rt) && getNodeName(rt) !== "body")
      , $ = null;
    const et = getComputedStyle$1$1(d).position === "fixed";
    let tt = et ? getParentNode(d) : d;
    for (; isElement(tt) && !isLastTraversableNode(tt); ) {
        const rt = getComputedStyle$1$1(tt)
          , nt = isContainingBlock(tt);
        (et ? !nt && !$ : !nt && rt.position === "static" && !!$ && ["absolute", "fixed"].includes($.position)) ? _ = _.filter(ot=>ot !== tt) : $ = rt,
        tt = getParentNode(tt)
    }
    return g.set(d, _),
    _
}
function getClippingRect(d) {
    let {element: g, boundary: b, rootBoundary: _, strategy: $} = d;
    const tt = [...b === "clippingAncestors" ? getClippingElementAncestors(g, this._c) : [].concat(b), _]
      , rt = tt[0]
      , nt = tt.reduce((it,ot)=>{
        const at = getClientRectFromClippingAncestor(g, ot, $);
        return it.top = max$1(at.top, it.top),
        it.right = min$2(at.right, it.right),
        it.bottom = min$2(at.bottom, it.bottom),
        it.left = max$1(at.left, it.left),
        it
    }
    , getClientRectFromClippingAncestor(g, rt, $));
    return {
        width: nt.right - nt.left,
        height: nt.bottom - nt.top,
        x: nt.left,
        y: nt.top
    }
}
const platform = {
    getClippingRect,
    convertOffsetParentRelativeRectToViewportRelativeRect,
    isElement,
    getDimensions,
    getOffsetParent,
    getDocumentElement,
    getScale,
    getElementRects(d) {
        return __async(this, null, function*() {
            let {reference: g, floating: b, strategy: _} = d;
            const $ = this.getOffsetParent || getOffsetParent
              , et = this.getDimensions;
            return {
                reference: getRectRelativeToOffsetParent(g, yield $(b), _),
                floating: __spreadValues$1({
                    x: 0,
                    y: 0
                }, yield et(b))
            }
        })
    },
    getClientRects: d=>Array.from(d.getClientRects()),
    isRTL: d=>getComputedStyle$1$1(d).direction === "rtl"
};
function autoUpdate(d, g, b, _) {
    _ === void 0 && (_ = {});
    const {ancestorScroll: $=!0, ancestorResize: et=!0, elementResize: tt=!0, animationFrame: rt=!1} = _
      , nt = $ && !rt
      , it = nt || et ? [...isElement(d) ? getOverflowAncestors(d) : d.contextElement ? getOverflowAncestors(d.contextElement) : [], ...getOverflowAncestors(g)] : [];
    it.forEach(ft=>{
        nt && ft.addEventListener("scroll", b, {
            passive: !0
        }),
        et && ft.addEventListener("resize", b)
    }
    );
    let ot = null;
    if (tt) {
        let ft = !0;
        ot = new ResizeObserver(()=>{
            ft || b(),
            ft = !1
        }
        ),
        isElement(d) && !rt && ot.observe(d),
        !isElement(d) && d.contextElement && !rt && ot.observe(d.contextElement),
        ot.observe(g)
    }
    let at, st = rt ? getBoundingClientRect(d) : null;
    rt && dt();
    function dt() {
        const ft = getBoundingClientRect(d);
        st && (ft.x !== st.x || ft.y !== st.y || ft.width !== st.width || ft.height !== st.height) && b(),
        st = ft,
        at = requestAnimationFrame(dt)
    }
    return b(),
    ()=>{
        var ft;
        it.forEach(ht=>{
            nt && ht.removeEventListener("scroll", b),
            et && ht.removeEventListener("resize", b)
        }
        ),
        (ft = ot) == null || ft.disconnect(),
        ot = null,
        rt && cancelAnimationFrame(at)
    }
}
const computePosition = (d,g,b)=>{
    const _ = new Map
      , $ = __spreadValues$1({
        platform
    }, b)
      , et = __spreadProps(__spreadValues$1({}, $.platform), {
        _c: _
    });
    return computePosition$1(d, g, __spreadProps(__spreadValues$1({}, $), {
        platform: et
    }))
}
;
function P(d, g, b) {
    let _ = ()=>{
        var at;
        return (at = b == null ? void 0 : b.placement) != null ? at : "bottom"
    }
      , $ = ()=>{
        var at;
        return (at = b == null ? void 0 : b.strategy) != null ? at : "absolute"
    }
      , [et,tt] = createSignal({
        x: null,
        y: null,
        placement: _(),
        strategy: $(),
        middlewareData: {}
    })
      , [rt,nt] = createSignal();
    createEffect(()=>{
        let at = rt();
        if (at)
            throw at.value
    }
    );
    let it = createMemo(()=>(d(),
    g(),
    {}));
    function ot() {
        let at = d()
          , st = g();
        if (at && st) {
            let dt = it();
            computePosition(at, st, {
                middleware: b == null ? void 0 : b.middleware,
                placement: _(),
                strategy: $()
            }).then(ft=>{
                dt === it() && tt(ft)
            }
            , ft=>{
                nt(ft)
            }
            )
        }
    }
    return createEffect(()=>{
        let at = d()
          , st = g();
        if (b == null || b.middleware,
        _(),
        $(),
        at && st)
            if (b != null && b.whileElementsMounted) {
                let dt = b.whileElementsMounted(at, st, ot);
                dt && onCleanup(dt)
            } else
                ot()
    }
    ),
    {
        get x() {
            return et().x
        },
        get y() {
            return et().y
        },
        get placement() {
            return et().placement
        },
        get strategy() {
            return et().strategy
        },
        get middlewareData() {
            return et().middlewareData
        },
        update: ot
    }
}
const _tmpl$$3 = template$1('<tc-root data-tc-dropdown-container="true"></tc-root>')
  , AccountButton = ()=>{
    const d = useTheme()
      , g = useContext(ConnectorContext)
      , b = useContext(TonConnectUiContext)
      , [_,$] = createSignal(!1)
      , [et,tt] = createSignal(g.account)
      , [rt,nt] = createSignal(!g.account);
    let it;
    const [ot,at] = createSignal()
      , [st,dt] = createSignal()
      , ft = P(st, ot, {
        whileElementsMounted: autoUpdate,
        placement: "bottom-end"
    })
      , ht = ()=>{
        const ct = et();
        if (ct) {
            const ut = toUserFriendlyAddress(ct.address, ct.chain === CHAIN.TESTNET);
            return ut.slice(0, 4) + "…" + ut.slice(-4)
        }
        return ""
    }
    ;
    b.connectionRestored.then(()=>nt(!1));
    const xt = g.onStatusChange(ct=>{
        if (!ct) {
            $(!1),
            tt(null),
            nt(!1);
            return
        }
        tt(ct.account),
        nt(!1)
    }
    )
      , lt = ct=>{
        if (!et() || !_())
            return;
        const ut = st().contains(ct.target)
          , pt = it.contains(ct.target);
        !ut && !pt && $(!1)
    }
    ;
    return onMount(()=>{
        document.body.addEventListener("click", lt)
    }
    ),
    onCleanup(()=>{
        document.body.removeEventListener("click", lt),
        xt()
    }
    ),
    createComponent(Dynamic, {
        component: globalStylesTag,
        get children() {
            return [createComponent(Show, {
                get when() {
                    return rt()
                },
                get children() {
                    return createComponent(LoaderButtonStyled$1, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled$1, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !rt()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return !et()
                        },
                        get children() {
                            return createComponent(AccountButtonStyled, {
                                onClick: ()=>b.openModal(),
                                "data-tc-connect-button": "true",
                                scale: "s",
                                get children() {
                                    return [createComponent(TonIcon, {
                                        get fill() {
                                            return d.colors.connectButton.foreground
                                        }
                                    }), createComponent(Text, {
                                        translationKey: "button.connectWallet",
                                        fontSize: "15px",
                                        lineHeight: "18px",
                                        fontWeight: "590",
                                        get color() {
                                            return d.colors.connectButton.foreground
                                        },
                                        children: "Connect wallet"
                                    })]
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return et()
                        },
                        get children() {
                            return createComponent(DropdownContainerStyled, {
                                get children() {
                                    return [createComponent(DropdownButtonStyled, {
                                        onClick: ()=>$(ct=>!ct),
                                        ref: dt,
                                        "data-tc-dropdown-button": "true",
                                        scale: "s",
                                        get children() {
                                            return [createComponent(Text, {
                                                fontSize: "15px",
                                                fontWeight: "590",
                                                lineHeight: "18px",
                                                get children() {
                                                    return ht()
                                                }
                                            }), createComponent(ArrowIcon, {
                                                direction: "bottom"
                                            })]
                                        }
                                    }), createComponent(Portal, {
                                        get children() {
                                            const ct = untrack(()=>document.importNode(_tmpl$$3, !0));
                                            return use(at, ct),
                                            ct.style.setProperty("z-index", "999"),
                                            ct._$owner = getOwner(),
                                            insert(ct, createComponent(Transition, {
                                                onBeforeEnter: ut=>{
                                                    animate(ut, [{
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }, {
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }], {
                                                        duration: 150
                                                    })
                                                }
                                                ,
                                                onExit: (ut,pt)=>{
                                                    animate(ut, [{
                                                        opacity: 1,
                                                        transform: "translateY(0)"
                                                    }, {
                                                        opacity: 0,
                                                        transform: "translateY(-8px)"
                                                    }], {
                                                        duration: 150
                                                    }).finished.then(pt)
                                                }
                                                ,
                                                get children() {
                                                    return createComponent(Show, {
                                                        get when() {
                                                            return _()
                                                        },
                                                        get children() {
                                                            return createComponent(DropdownStyled, {
                                                                get hidden() {
                                                                    return !_()
                                                                },
                                                                onClose: ()=>$(!1),
                                                                ref(ut) {
                                                                    const pt = it;
                                                                    typeof pt == "function" ? pt(ut) : it = ut
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            }), null),
                                            insert(ct, createComponent(NotificationsStyled, {}), null),
                                            createRenderEffect(ut=>{
                                                var pt, vt;
                                                const _t = ft.strategy
                                                  , Pt = `${(pt = ft.y) != null ? pt : 0}px`
                                                  , kt = `${(vt = ft.x) != null ? vt : 0}px`;
                                                return _t !== ut._v$ && ct.style.setProperty("position", ut._v$ = _t),
                                                Pt !== ut._v$2 && ct.style.setProperty("top", ut._v$2 = Pt),
                                                kt !== ut._v$3 && ct.style.setProperty("left", ut._v$3 = kt),
                                                ut
                                            }
                                            , {
                                                _v$: void 0,
                                                _v$2: void 0,
                                                _v$3: void 0
                                            }),
                                            ct
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , StyledModal = styled(Modal)`
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 18px;
    padding-bottom: 0;

    ${media("mobile")} {
        padding-left: 0;
        padding-right: 0;

        min-height: 364px;
    }
`
  , H1Styled$8 = styled(H1)`
    margin-top: 12px;

    ${media("mobile")} {
        padding: 0 10px;
    }
`
  , LoaderContainerStyled = styled.div`
    margin: 30px 0;
    width: 100%;
    display: flex;
    justify-content: center;

    ${media("mobile")} {
        height: 160px;
        align-items: center;
    }
`;
styled(Text)`
    min-width: 84px;
    text-align: center;
    font-weight: 590;
`;
styled(TabBar)`
    margin: 0 auto 22px;
`;
const [appState,setAppState] = createStore$1({
    buttonRootId: null,
    language: "en",
    returnStrategy: "back",
    twaReturnUrl: void 0,
    walletsListConfiguration: {},
    enableAndroidBackHandler: !0
});
function uniq(d) {
    return [...new Set(d)]
}
function mergeConcat(d, g, b) {
    return g.map(_=>{
        const $ = b.find(et=>et[d] === _[d]);
        return b = b.filter(et=>et[d] !== _[d]),
        $ === void 0 ? _ : $
    }
    ).concat(b)
}
function uiWalletToWalletInfo(d) {
    return "jsBridgeKey"in d ? __spreadProps(__spreadValues$1({}, d), {
        injected: TonConnect.isWalletInjected(d.jsBridgeKey),
        embedded: TonConnect.isInsideWalletBrowser(d.jsBridgeKey)
    }) : d
}
function applyWalletsListConfiguration(d, g) {
    var b;
    return g && (b = g.includeWallets) != null && b.length && (d = mergeConcat("name", d, g.includeWallets.map(uiWalletToWalletInfo))),
    d
}
function supportsDesktop(d) {
    return d.platforms.some(g=>["macos", "linux", "windows"].includes(g))
}
function supportsMobile(d) {
    return d.platforms.some(g=>["ios", "android"].includes(g))
}
function supportsExtension(d) {
    return d.platforms.some(g=>["chrome", "firefox", "safari"].includes(g))
}
function eqWalletName(d, g) {
    return g ? d.name.toLowerCase() === g.toLowerCase() || d.appName.toLowerCase() === g.toLowerCase() : !1
}
const DesktopSelectWalletModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , H1Styled$7 = styled(H1)`
    margin-bottom: 18px;
`;
styled.div`
    height: 1px;
    margin: 0 -24px;
    width: calc(100% + 48px);
    opacity: 0.12;
    background: ${d=>d.isShown ? d.theme.colors.icon.secondary : "transparent"};
    transition: background 0.15s ease-in-out;

    ${media("mobile")} {
        width: 100%;
    }
`;
const WalletsUl = styled.ul`
    display: grid;
    grid-template-columns: repeat(auto-fit, 92px);
    grid-template-rows: auto;
    align-content: flex-start;
    justify-content: center;
    row-gap: 8px;
    width: 100%;
    padding: 0 0 16px;
    align-self: flex-start;
    max-width: 400px;
    margin: 0 auto;

    > li {
        display: block;
        height: fit-content;
    }

    ${media("mobile")} {
        grid-template-columns: repeat(auto-fit, 82px);
    }
`;
styled(Button)`
    display: block;
    margin: 0 auto 1px;
    font-size: 15px;
`;
const StyledIconButton$3 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , WalletLabeledItemStyled = styled(WalletLabeledItem)`
    height: 100%;
`
  , _tmpl$$2 = template$1("<li></li>")
  , AllWalletsListModal = d=>{
    const g = ()=>isMobile() ? void 0 : 510
      , b = ()=>isMobile() ? d.walletsList.filter(supportsMobile) : d.walletsList;
    return createComponent(DesktopSelectWalletModalStyled, {
        "data-tc-wallets-modal-list": "true",
        get children() {
            return [createComponent(StyledIconButton$3, {
                icon: "arrow",
                onClick: ()=>d.onBack()
            }), createComponent(H1Styled$7, {
                translationKey: "walletModal.wallets",
                children: "Wallets"
            }), createComponent(ScrollContainer, {
                get maxHeight() {
                    return g()
                },
                get children() {
                    return createComponent(WalletsUl, {
                        get children() {
                            return createComponent(For, {
                                get each() {
                                    return b()
                                },
                                children: _=>(()=>{
                                    const $ = _tmpl$$2.cloneNode(!0);
                                    return insert($, createComponent(WalletLabeledItemStyled, {
                                        wallet: _,
                                        onClick: ()=>d.onSelect(_)
                                    })),
                                    $
                                }
                                )()
                            })
                        }
                    })
                }
            })]
        }
    })
}
  , tgButtonBorders = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgIconBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , DesktopConnectionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
`
  , BodyStyled$1 = styled.div`
    flex: 1;
    margin-top: ${d=>d.qr ? "0" : "18px"};
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , QRCodeStyled$1 = styled(QRCode)`
    margin-bottom: 24px;
`
  , H1Styled$6 = styled(H1)`
    max-width: 288px;
    margin: 0 auto 2px;
`
  , H2Styled$4 = styled(H2)`
    max-width: 288px;
    text-align: center;
    margin: 0 auto 20px;
`
  , StyledIconButton$2 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , ButtonsContainerStyled$1 = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , BottomButtonsContainerStyled = styled(ButtonsContainerStyled$1)`
    padding-bottom: 0;
`
  , FooterButton$1 = styled(Button)`
    margin-bottom: 24px;
`
  , LoaderStyled$1 = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled$1 = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled$1 = styled(H2)`
    color: ${d=>d.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , TgButtonStyled = styled(Button)`
    margin-top: -8px;
    margin-bottom: 24px;
    width: 100%;
    padding: 12px 12px 12px 20px;
    border-radius: ${d=>tgButtonBorders[d.theme.borderRadius]};
    font-size: 16px;
    line-height: 20px;
`
  , TgImageStyled = styled(Image$1)`
    width: 32px;
    height: 32px;
    border-radius: ${d=>tgIconBorders[d.theme.borderRadius]};
`
  , Translation = d=>{
    const [g] = useI18n();
    return createMemo(()=>{
        var b;
        return g(d.translationKey, d.translationValues, (b = d.children) == null ? void 0 : b.toString())
    }
    )
}
;
function addReturnStrategy(d, g) {
    let b;
    typeof g == "string" ? b = g : b = isInTMA() ? g.twaReturnUrl || g.returnStrategy : "none";
    const _ = addQueryParameter(d, "ret", b);
    if (!isTelegramUrl(d))
        return _;
    const $ = _.slice(_.lastIndexOf("&") + 1);
    return _.slice(0, _.lastIndexOf("&")) + "-" + encodeTelegramUrlParameters($)
}
function redirectToTelegram(d, g) {
    g = __spreadValues$1({}, g);
    const b = convertToTGDirectLink(d)
      , _ = new URL(b);
    if (_.searchParams.has("startapp") || _.searchParams.append("startapp", "tonconnect"),
    isInTMA())
        isTmaPlatform("ios", "android", "macos") ? (g.returnStrategy = "back",
        g.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy(_.toString(), g))) : isTmaPlatform("tdesktop") || isTmaPlatform("weba") ? sendOpenTelegramLink(addReturnStrategy(_.toString(), g)) : isTmaPlatform("web") ? (g.returnStrategy = "back",
        g.twaReturnUrl = void 0,
        sendOpenTelegramLink(addReturnStrategy(_.toString(), g))) : openLinkBlank(addReturnStrategy(_.toString(), g));
    else if (isOS("ios")) {
        g.returnStrategy === "back" && (isBrowser$1("safari") ? g.returnStrategy = "back" : isBrowser$1("chrome") ? g.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? g.returnStrategy = "firefox://" : isBrowser$1("opera") ? g.returnStrategy = "opera-http://" : g.returnStrategy = location.href);
        const $ = isBrowser$1("chrome")
          , et = isBrowser$1("firefox");
        if (($ || et) && !g.forceRedirect) {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy)
              , nt = convertToTGDeepLink(rt);
            openDeeplinkWithFallback(nt, ()=>openLinkBlank(rt))
        } else {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy);
            openLinkBlank(rt)
        }
    } else if (isOS("android")) {
        g.returnStrategy = "none";
        const $ = isBrowser$1("chrome")
          , et = isBrowser$1("firefox");
        if (($ || et) && !g.forceRedirect) {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy)
              , nt = convertToTGDeepLink(rt);
            openDeeplinkWithFallback(nt, ()=>openLinkBlank(rt))
        } else {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy);
            openLinkBlank(rt)
        }
    } else if (isOS("ipad")) {
        g.returnStrategy === "back" && (isBrowser$1("safari") ? g.returnStrategy = "back" : isBrowser$1("chrome") ? g.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? g.returnStrategy = "firefox://" : isBrowser$1("opera") ? g.returnStrategy = "opera-http://" : g.returnStrategy = location.href);
        const $ = isBrowser$1("chrome")
          , et = isBrowser$1("firefox");
        if (($ || et) && !g.forceRedirect) {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy)
              , nt = convertToTGDeepLink(rt);
            openDeeplinkWithFallback(nt, ()=>openLinkBlank(rt))
        } else {
            const rt = addReturnStrategy(_.toString(), g.returnStrategy);
            openLinkBlank(rt)
        }
    } else if (isOS("macos", "windows", "linux"))
        if (g.returnStrategy = "none",
        g.twaReturnUrl = void 0,
        g.forceRedirect)
            openLinkBlank(addReturnStrategy(_.toString(), g));
        else {
            const $ = addReturnStrategy(_.toString(), g)
              , et = convertToTGDeepLink($);
            openDeeplinkWithFallback(et, ()=>openLinkBlank($))
        }
    else
        openLinkBlank(addReturnStrategy(_.toString(), g))
}
function redirectToWallet(d, g, b, _) {
    if (b = __spreadValues$1({}, b),
    isInTMA())
        if (isTmaPlatform("ios", "android")) {
            b.returnStrategy === "back" && (b.returnStrategy = "tg://resolve"),
            _("universal-link");
            const $ = addReturnStrategy(d, b.returnStrategy);
            sendOpenTelegramLink($, ()=>{
                _("universal-link"),
                openLinkBlank($)
            }
            )
        } else if (isTmaPlatform("macos", "tdesktop")) {
            b.returnStrategy === "back" && (b.returnStrategy = "tg://resolve");
            const $ = addReturnStrategy(d, b.returnStrategy);
            !!g && !b.forceRedirect ? (_("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink($, g), ()=>{
                _("universal-link"),
                openLinkBlank($)
            }
            )) : (_("universal-link"),
            openLinkBlank($))
        } else if (isTmaPlatform("weba")) {
            b.returnStrategy === "back" && (isBrowser$1("safari") ? b.returnStrategy = location.href : isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = location.href);
            const $ = addReturnStrategy(d, b.returnStrategy);
            !!g && !b.forceRedirect ? (_("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink($, g), ()=>{
                _("universal-link"),
                openLinkBlank($)
            }
            )) : (_("universal-link"),
            openLinkBlank($))
        } else if (isTmaPlatform("web")) {
            b.returnStrategy === "back" && (isBrowser$1("safari") ? b.returnStrategy = location.href : isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = location.href);
            const $ = addReturnStrategy(d, b.returnStrategy);
            !!g && !b.forceRedirect ? (_("custom-deeplink"),
            openDeeplinkWithFallback(toDeeplink($, g), ()=>{
                _("universal-link"),
                openLinkBlank($)
            }
            )) : (_("universal-link"),
            openLinkBlank($))
        } else {
            _("universal-link");
            const $ = addReturnStrategy(d, b.returnStrategy);
            openLinkBlank($)
        }
    else if (isOS("ios"))
        b.returnStrategy === "back" && (isBrowser$1("safari") ? b.returnStrategy = "none" : isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = location.href),
        isBrowser$1("chrome") ? (_("universal-link"),
        openLink(addReturnStrategy(d, b.returnStrategy), "_self")) : (_("universal-link"),
        openLinkBlank(addReturnStrategy(d, b.returnStrategy)));
    else if (isOS("android"))
        b.returnStrategy === "back" && (isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = location.href),
        _("universal-link"),
        openLinkBlank(addReturnStrategy(d, b.returnStrategy));
    else if (isOS("ipad"))
        b.returnStrategy === "back" && (isBrowser$1("safari") ? b.returnStrategy = "none" : isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = location.href),
        isBrowser$1("chrome") ? (_("universal-link"),
        openLink(addReturnStrategy(d, b.returnStrategy), "_self")) : (_("universal-link"),
        openLinkBlank(addReturnStrategy(d, b.returnStrategy)));
    else if (isOS("macos", "windows", "linux")) {
        b.returnStrategy === "back" && (isBrowser$1("safari") ? b.returnStrategy = "none" : isBrowser$1("chrome") ? b.returnStrategy = "googlechrome://" : isBrowser$1("firefox") ? b.returnStrategy = "firefox://" : isBrowser$1("opera") ? b.returnStrategy = "opera-http://" : b.returnStrategy = "none");
        const $ = addReturnStrategy(d, b.returnStrategy);
        !!g && !b.forceRedirect ? (_("custom-deeplink"),
        openDeeplinkWithFallback(toDeeplink($, g), ()=>{
            _("universal-link"),
            openLinkBlank($)
        }
        )) : (_("universal-link"),
        openLinkBlank($))
    } else
        _("universal-link"),
        openLinkBlank(addReturnStrategy(d, b.returnStrategy))
}
function addQueryParameter(d, g, b) {
    const _ = new URL(d);
    return _.searchParams.append(g, b),
    _.toString()
}
function convertToTGDirectLink(d) {
    const g = new URL(d);
    return g.searchParams.has("attach") && (g.searchParams.delete("attach"),
    g.pathname += "/start"),
    g.toString()
}
function convertToTGDeepLink(d) {
    const g = new URL(d)
      , [,b,_] = g.pathname.split("/")
      , $ = g.searchParams.get("startapp");
    return `tg://resolve?domain=${b}&appname=${_}&startapp=${$}`
}
const DesktopConnectionModal = d=>{
    const [g,b] = createSignal("mobile")
      , [_,$] = createSignal(!1)
      , [et,tt] = createSignal()
      , [rt,nt] = createSignal(!0)
      , it = useContext(ConnectorContext)
      , ot = it.onStatusChange(()=>{}
    , ()=>{
        d.wallet.appName !== AT_WALLET_APP_NAME && $(!0)
    }
    );
    onCleanup(ot);
    const at = ()=>{
        try {
            const xt = it.connect({
                universalLink: d.wallet.universalLink,
                bridgeUrl: d.wallet.bridgeUrl
            }, d.additionalRequest);
            tt(xt)
        } catch {}
    }
    ;
    createEffect(()=>{
        untrack(g) !== "extension" && (supportsMobile(d.wallet) || supportsDesktop(d.wallet)) && at()
    }
    );
    const st = ()=>{
        $(!1),
        g() === "extension" && at(),
        b("mobile"),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
            openMethod: "qrcode"
        }))
    }
      , dt = ()=>{
        $(!1),
        g() === "extension" && at(),
        b("desktop");
        const xt = !rt();
        nt(!1),
        redirectToWallet(et(), d.wallet.deepLink, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: xt
        }, lt=>{
            setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
                openMethod: lt
            }))
        }
        )
    }
      , ft = ()=>{
        const xt = !rt();
        nt(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(et(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: xt
        })
    }
      , ht = ()=>{
        $(!1),
        b("extension"),
        isWalletInfoCurrentlyInjected(d.wallet) && (setLastSelectedWalletInfo(d.wallet),
        it.connect({
            jsBridgeKey: d.wallet.jsBridgeKey
        }, d.additionalRequest))
    }
    ;
    return supportsMobile(d.wallet) ? st() : supportsExtension(d.wallet) ? ht() : dt(),
    createComponent(DesktopConnectionModalStyled, {
        "data-tc-wallets-modal-connection-desktop": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !d.backDisabled
                },
                get children() {
                    return createComponent(StyledIconButton$2, {
                        icon: "arrow",
                        onClick: ()=>d.onBackClick()
                    })
                }
            }), createComponent(H1Styled$6, {
                get children() {
                    return d.wallet.name
                }
            }), createComponent(Show, {
                get when() {
                    return g() === "mobile"
                },
                get children() {
                    return createComponent(H2Styled$4, {
                        translationKey: "walletModal.desktopConnectionModal.scanQR",
                        get translationValues() {
                            return {
                                name: d.wallet.name
                            }
                        },
                        get children() {
                            return ["Scan the QR code below with your phone’s or ", createMemo(()=>d.wallet.name), "’s camera"]
                        }
                    })
                }
            }), createComponent(BodyStyled$1, {
                get qr() {
                    return g() === "mobile"
                },
                get children() {
                    return createComponent(Switch, {
                        get children() {
                            return [createComponent(Match, {
                                get when() {
                                    return g() === "mobile"
                                },
                                get children() {
                                    return createComponent(QRCodeStyled$1, {
                                        disableCopy: !1,
                                        get sourceUrl() {
                                            return addReturnStrategy(et(), "none")
                                        },
                                        get imageUrl() {
                                            return d.wallet.imageUrl
                                        }
                                    })
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return _()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled$1, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                get onClick() {
                                                    return g() === "extension" ? ht : dt
                                                },
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            })
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return g() === "extension"
                                },
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return isWalletInfoCurrentlyInjected(d.wallet)
                                        },
                                        get children() {
                                            return [createComponent(LoaderStyled$1, {
                                                size: "s"
                                            }), createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.continueInExtension",
                                                get translationValues() {
                                                    return {
                                                        name: d.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Continue in ", createMemo(()=>d.wallet.name), " browser extension…"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Button, {
                                                        get leftIcon() {
                                                            return createComponent(RetryIcon, {})
                                                        },
                                                        onClick: ht,
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "common.retry",
                                                                children: "Retry"
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    }), createComponent(Show, {
                                        get when() {
                                            return !isWalletInfoCurrentlyInjected(d.wallet)
                                        },
                                        get children() {
                                            return [createComponent(BodyTextStyled$1, {
                                                translationKey: "walletModal.desktopConnectionModal.dontHaveExtension",
                                                get translationValues() {
                                                    return {
                                                        name: d.wallet.name
                                                    }
                                                },
                                                get children() {
                                                    return ["Seems you don't have installed ", createMemo(()=>d.wallet.name), " browser extension"]
                                                }
                                            }), createComponent(ButtonsContainerStyled$1, {
                                                get children() {
                                                    return createComponent(Link, {
                                                        get href() {
                                                            return d.wallet.aboutUrl
                                                        },
                                                        blank: !0,
                                                        get children() {
                                                            return createComponent(Button, {
                                                                get rightIcon() {
                                                                    return createComponent(LinkIcon, {})
                                                                },
                                                                onClick: ht,
                                                                get children() {
                                                                    return createComponent(Translation, {
                                                                        translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                        get translationValues() {
                                                                            return {
                                                                                name: d.wallet.name
                                                                            }
                                                                        },
                                                                        get children() {
                                                                            return ["Get ", createMemo(()=>d.wallet.name)]
                                                                        }
                                                                    })
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Match, {
                                get when() {
                                    return g() === "desktop"
                                },
                                get children() {
                                    return [createComponent(LoaderIcon, {
                                        size: "m"
                                    }), createComponent(BodyTextStyled$1, {
                                        translationKey: "walletModal.desktopConnectionModal.continueOnDesktop",
                                        get translationValues() {
                                            return {
                                                name: d.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>d.wallet.name), " on desktop…"]
                                        }
                                    }), createComponent(ButtonsContainerStyled$1, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: dt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Link, {
                                                get href() {
                                                    return d.wallet.aboutUrl
                                                },
                                                blank: !0,
                                                get children() {
                                                    return createComponent(Button, {
                                                        get rightIcon() {
                                                            return createComponent(LinkIcon, {})
                                                        },
                                                        get children() {
                                                            return createComponent(Translation, {
                                                                translationKey: "walletModal.desktopConnectionModal.getWallet",
                                                                get translationValues() {
                                                                    return {
                                                                        name: d.wallet.name
                                                                    }
                                                                },
                                                                get children() {
                                                                    return ["Get ", createMemo(()=>d.wallet.name)]
                                                                }
                                                            })
                                                        }
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return d.wallet.appName === AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(TgButtonStyled, {
                        get rightIcon() {
                            return createComponent(TgImageStyled, {
                                get src() {
                                    return IMG.TG
                                }
                            })
                        },
                        scale: "s",
                        onClick: ft,
                        get children() {
                            return createComponent(Translation, {
                                translationKey: "walletModal.desktopConnectionModal.openWalletOnTelegram",
                                children: "Open Wallet in Telegram on desktop"
                            })
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return d.wallet.appName !== AT_WALLET_APP_NAME
                },
                get children() {
                    return createComponent(BottomButtonsContainerStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return createMemo(()=>g() !== "mobile")() && supportsMobile(d.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(MobileIcon, {})
                                        },
                                        onClick: st,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.mobile",
                                                children: "Mobile"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>g() !== "extension")() && supportsExtension(d.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(BrowserIcon, {})
                                        },
                                        onClick: ht,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.browserExtension",
                                                children: "Browser Extension"
                                            })
                                        }
                                    })
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return createMemo(()=>g() !== "desktop")() && supportsDesktop(d.wallet)
                                },
                                get children() {
                                    return createComponent(FooterButton$1, {
                                        appearance: "secondary",
                                        get leftIcon() {
                                            return createComponent(DesktopIcon, {})
                                        },
                                        onClick: dt,
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.desktop",
                                                children: "Desktop"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })
                }
            })]
        }
    })
}
  , InfoModalStyled = styled.div``
  , StyledIconButton$1 = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$5 = styled(H1)`
    margin-bottom: 18px;
`
  , InfoBlock = styled.div`
    padding: 16px 0;
    display: flex;
    flex-direction: column;
    align-items: center;
`
  , InfoBlockIconClass = u$2`
    margin-bottom: 12px;
`
  , H3Styled = styled(H3)`
    text-align: center;
    margin-bottom: 4px;
`
  , TextStyled$1 = styled(Text)`
    text-align: center;
    max-width: 352px;
    color: ${d=>d.theme.colors.text.secondary};
`
  , ButtonsBlock = styled.div`
    padding: 16px 24px 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
`
  , LINKS = {
    GET_A_WALLET: "https://ton.org/wallets?filters[wallet_features][slug][$in]=dapp-auth&pagination[limit]=-1"
}
  , InfoModal = d=>createComponent(InfoModalStyled, {
    "data-tc-wallets-modal-info": "true",
    get children() {
        return [createComponent(StyledIconButton$1, {
            icon: "arrow",
            onClick: ()=>d.onBackClick()
        }), createComponent(H1Styled$5, {
            translationKey: "walletModal.infoModal.whatIsAWallet",
            children: "What is a wallet"
        }), createComponent(ScrollContainer, {
            get children() {
                return [createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SecurityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.secureDigitalAssets",
                            children: "Secure digital assets storage"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.walletProtects",
                            children: "A wallet protects and manages your digital assets including TON, tokens and collectables."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(PersonalityIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.controlIdentity",
                            children: "Control your Web3 identity"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.manageIdentity",
                            children: "Manage your digital identity and access decentralized applications with ease. Maintain control over your data and engage securely in the blockchain ecosystem."
                        })]
                    }
                }), createComponent(InfoBlock, {
                    get children() {
                        return [createComponent(SwapIcon, {
                            class: InfoBlockIconClass
                        }), createComponent(H3Styled, {
                            translationKey: "walletModal.infoModal.effortlessCryptoTransactions",
                            children: "Effortless crypto transactions"
                        }), createComponent(TextStyled$1, {
                            translationKey: "walletModal.infoModal.easilySend",
                            children: "Easily send, receive, monitor your cryptocurrencies. Streamline your operations with decentralized applications."
                        })]
                    }
                }), createComponent(ButtonsBlock, {
                    get children() {
                        return createComponent(Link, {
                            get href() {
                                return LINKS.GET_A_WALLET
                            },
                            blank: !0,
                            get children() {
                                return createComponent(Button, {
                                    get rightIcon() {
                                        return createComponent(WalletIcon, {})
                                    },
                                    get children() {
                                        return createComponent(Translation, {
                                            translationKey: "walletModal.infoModal.getAWallet",
                                            children: "Get a Wallet"
                                        })
                                    }
                                })
                            }
                        })
                    }
                })]
            }
        })]
    }
})
  , MobileConnectionModalStyled = styled.div``
  , BodyStyled = styled.div`
    flex: 1;
    margin-top: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 232px;
`
  , H1Styled$4 = styled(H1)`
    max-width: 262px;
    margin: 0 auto 8px;
`
  , StyledIconButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , FooterStyled = styled.div`
    padding: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    border-top: 0.5px solid ${d=>rgba$1(d.theme.colors.icon.secondary, .2)};
`
  , ImageStyled = styled(Image$1)`
    width: 36px;
    height: 36px;
    border-radius: 10px;
`
  , FooterButton = styled(Link)`
    margin-left: auto;
`
  , LoaderStyled = styled(LoaderIcon)`
    margin-bottom: 18px;
    margin-top: 2px;
`
  , ErrorIconStyled = styled(ErrorIcon)`
    margin-bottom: 16px;
`
  , BodyTextStyled = styled(H2)`
    color: ${d=>d.theme.colors.text.secondary};
    text-align: center;
    margin-bottom: 20px;
`
  , ButtonsContainerStyled = styled.div`
    display: flex;
    justify-content: center;
    gap: 8px;
    padding-bottom: 16px;
`
  , H1Styled$3 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$3 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
    min-height: 44px;
`
  , QrCodeWrapper$1 = styled.div`
    padding: 0 24px 24px;
`
  , MobileConnectionQR = d=>[createComponent(H1Styled$3, {
    get children() {
        return d.walletInfo.name
    }
}), createComponent(H2Styled$3, {
    translationKey: "walletModal.mobileConnectionModal.scanQR",
    get translationValues() {
        return {
            name: d.walletInfo.name
        }
    },
    get children() {
        return ["Scan the QR code below with your phone’s or ", createMemo(()=>d.walletInfo.name), "’s camera"]
    }
}), createComponent(QrCodeWrapper$1, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return d.walletInfo.imageUrl
            },
            get sourceUrl() {
                return addReturnStrategy(d.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})]
  , MobileConnectionModal = d=>{
    const g = useTheme()
      , [b,_] = createSignal(!0)
      , [$,et] = createSignal(!1)
      , [tt,rt] = createSignal(!1)
      , nt = useContext(ConnectorContext)
      , it = nt.onStatusChange(()=>{}
    , ()=>{
        rt(!0)
    }
    )
      , ot = createMemo(()=>nt.connect({
        universalLink: d.wallet.universalLink,
        bridgeUrl: d.wallet.bridgeUrl
    }, d.additionalRequest))
      , at = ()=>{
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
            openMethod: "universal-link"
        })),
        redirectToTelegram(ot(), {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: !0
        })
    }
      , st = ()=>{
        const xt = ot();
        if (isTelegramUrl(xt))
            return at();
        rt(!1);
        const lt = !b();
        _(!1),
        redirectToWallet(ot(), d.wallet.deepLink, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: lt
        }, ct=>{
            setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
                openMethod: ct
            }))
        }
        )
    }
      , dt = ()=>{
        rt(!1),
        et(!0),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
            openMethod: "qrcode"
        }))
    }
      , ft = ()=>{
        et(!1),
        setLastSelectedWalletInfo(__spreadProps(__spreadValues$1({}, d.wallet), {
            openMethod: "universal-link"
        }))
    }
      , ht = ()=>{
        $() ? ft() : d.onBackClick()
    }
    ;
    return onCleanup(it),
    st(),
    createComponent(MobileConnectionModalStyled, {
        "data-tc-wallets-modal-connection-mobile": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return !d.backDisabled || $()
                },
                get children() {
                    return createComponent(StyledIconButton, {
                        icon: "arrow",
                        onClick: ht
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return $()
                },
                get children() {
                    return createComponent(MobileConnectionQR, {
                        get universalLink() {
                            return ot()
                        },
                        get walletInfo() {
                            return d.wallet
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !$()
                },
                get children() {
                    return [createComponent(H1Styled$4, {
                        get children() {
                            return d.wallet.name
                        }
                    }), createComponent(BodyStyled, {
                        get children() {
                            return [createComponent(Show, {
                                get when() {
                                    return tt()
                                },
                                get children() {
                                    return [createComponent(ErrorIconStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.connectionDeclined",
                                        children: "Connection declined"
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: st,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return g.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: dt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return !tt()
                                },
                                get children() {
                                    return [createComponent(LoaderStyled, {
                                        size: "s"
                                    }), createComponent(BodyTextStyled, {
                                        translationKey: "walletModal.mobileConnectionModal.continueIn",
                                        get translationValues() {
                                            return {
                                                name: d.wallet.name
                                            }
                                        },
                                        get children() {
                                            return ["Continue in ", createMemo(()=>d.wallet.name), "…"]
                                        }
                                    }), createComponent(ButtonsContainerStyled, {
                                        get children() {
                                            return [createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(RetryIcon, {})
                                                },
                                                onClick: st,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "common.retry",
                                                        children: "Retry"
                                                    })
                                                }
                                            }), createComponent(Button, {
                                                get leftIcon() {
                                                    return createComponent(QRIcon, {
                                                        get fill() {
                                                            return g.colors.accent
                                                        }
                                                    })
                                                },
                                                onClick: dt,
                                                get children() {
                                                    return createComponent(Translation, {
                                                        translationKey: "walletModal.mobileConnectionModal.showQR",
                                                        children: "Show QR Code"
                                                    })
                                                }
                                            })]
                                        }
                                    })]
                                }
                            })]
                        }
                    }), createComponent(FooterStyled, {
                        get children() {
                            return [createComponent(ImageStyled, {
                                get src() {
                                    return d.wallet.imageUrl
                                }
                            }), createComponent(H3, {
                                get children() {
                                    return d.wallet.name
                                }
                            }), createComponent(FooterButton, {
                                get href() {
                                    return d.wallet.aboutUrl
                                },
                                blank: !0,
                                get children() {
                                    return createComponent(Button, {
                                        get children() {
                                            return createComponent(Translation, {
                                                translationKey: "common.get",
                                                children: "GET"
                                            })
                                        }
                                    })
                                }
                            })]
                        }
                    })]
                }
            })]
        }
    })
}
  , borders$1 = {
    m: "16px",
    s: "12px",
    none: "0"
}
  , tgBorders = {
    m: "6px",
    s: "6px",
    none: "0"
}
  , UlStyled = styled.ul`
    display: flex;
    justify-content: space-between;
    margin: 0 auto;
    width: fit-content;
    max-width: 100%;
    min-width: 100%;
    height: fit-content;
    overflow-x: auto;
    overflow-y: hidden;
    padding: 0 13px 24px;

    &&::-webkit-scrollbar {
        display: none;
    }

    -ms-overflow-style: none;
    scrollbar-width: none;

    > li {
        height: fit-content;
    }
`
  , OtherOptionButton = styled.li`
    width: 82px;
    min-width: 82px;
    height: 124px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 8px 4px;

    text-align: center;
    cursor: pointer;

    transition: transform 0.1s ease-in-out;

    ${mediaNotTouch} {
        &:hover {
            transform: scale(1.04);
        }
    }

    &:active {
        transform: scale(0.96);
    }

    ${mediaTouch} {
        &:active {
            transform: scale(0.92);
        }
    }
`
  , Divider = styled.div`
    width: 1px;
    margin: 0 10px;
    height: 24px;
    position: relative;
    top: 26px;

    background-color: ${d=>d.theme.colors.icon.secondary};
    opacity: 0.2;
`
  , IconContainer = styled.div`
    width: 60px;
    height: 60px;
    border-radius: ${d=>borders$1[d.theme.borderRadius]};
    display: flex;
    align-items: center;
    justify-content: center;

    background-color: ${d=>d.theme.colors.background.tint};
    margin-bottom: 8px;
`
  , H1Styled$2 = styled(H1)`
    margin-top: 38px;
    margin-bottom: 4px;
    padding: 0 24px;
`
  , H2Styled$2 = styled(H2)`
    margin-bottom: 24px;
    padding: 0 24px;
    min-height: 44px;
`;
styled(Button)`
    display: block;
    margin: 0 auto;
`;
const TelegramButtonStyled = styled(Button)`
    margin: 0 24px 24px;
    width: calc(100% - 48px);
    border-radius: ${d=>borders$1[d.theme.borderRadius]};
    padding: 14px 16px 14px 14px;
    background-color: ${d=>d.theme.colors.telegramButton};

    color: ${d=>d.theme.colors.constant.white};
    font-weight: 590;
    font-size: 16px;
    line-height: 20px;
`
  , TGImageStyled = styled(Image$1)`
    border-radius: ${d=>tgBorders[d.theme.borderRadius]};
    width: 24px;
    height: 24px;
`
  , StyledLeftActionButton = styled(IconButton)`
    position: absolute;
    top: 16px;
    left: 16px;
`
  , H1Styled$1 = styled(H1)`
    margin-bottom: 2px;
    padding: 0 64px;
`
  , H2Styled$1 = styled(H2)`
    margin-bottom: 20px;
    padding: 0 64px;
`
  , QrCodeWrapper = styled.div`
    padding: 0 24px 24px;
`
  , MobileUniversalQR = d=>[createComponent(H1Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
    children: "Connect your wallet"
}), createComponent(H2Styled$1, {
    translationKey: "walletModal.mobileUniversalModal.scan",
    children: "Scan with your mobile wallet"
}), createComponent(QrCodeWrapper, {
    get children() {
        return createComponent(QRCode, {
            get imageUrl() {
                return IMG.TON
            },
            get sourceUrl() {
                return addReturnStrategy(d.universalLink, "none")
            },
            disableCopy: !0
        })
    }
})];
function getUniqueBridges(d) {
    const g = new Set(d.filter(isWalletInfoRemote).map(b=>b.bridgeUrl));
    return Array.from(g).map(b=>({
        bridgeUrl: b
    }))
}
function bridgesIsEqual(d, g) {
    const b = new Set(d == null ? void 0 : d.map($=>$.bridgeUrl))
      , _ = new Set(g == null ? void 0 : g.map($=>$.bridgeUrl));
    return b.size === _.size && [...b].every($=>_.has($))
}
const _tmpl$$1 = template$1("<li></li>")
  , _tmpl$2 = template$1('<div data-tc-wallets-modal-universal-mobile="true"></div>')
  , MobileUniversalModal = d=>{
    const [g,b] = createSignal(!1)
      , [_,$] = createSignal(!0)
      , [et,tt] = createSignal(null)
      , rt = appState.connector
      , nt = ()=>d.walletsList.filter(ut=>supportsMobile(ut) && ut.appName !== AT_WALLET_APP_NAME)
      , it = ()=>nt().length > 7
      , ot = createMemo(()=>getUniqueBridges(d.walletsList), null, {
        equals: bridgesIsEqual
    })
      , at = ()=>(et() || tt(rt.connect(ot(), d.additionalRequest)),
    et());
    setLastSelectedWalletInfo({
        openMethod: "universal-link"
    });
    const [st,dt] = createSignal(void 0)
      , ft = ()=>__async(void 0, null, function*() {
        st() !== void 0 && clearTimeout(st()),
        yield copyToClipboard(at());
        const ut = setTimeout(()=>dt(void 0), 1500);
        dt(ut)
    })
      , ht = ()=>{
        const ut = !_();
        $(!1),
        redirectToWallet(at(), void 0, {
            returnStrategy: appState.returnStrategy,
            forceRedirect: ut
        }, pt=>{
            setLastSelectedWalletInfo({
                openMethod: pt
            })
        }
        )
    }
      , xt = ()=>{
        tt(null);
        const ut = d.walletsList.find(_t=>_t.appName === AT_WALLET_APP_NAME);
        if (!ut || !isWalletInfoRemote(ut))
            throw new TonConnectUIError("@wallet bot not found in the wallets list");
        const pt = rt.connect({
            bridgeUrl: ut.bridgeUrl,
            universalLink: ut.universalLink
        }, d.additionalRequest)
          , vt = !_();
        $(!1),
        redirectToTelegram(pt, {
            returnStrategy: appState.returnStrategy,
            twaReturnUrl: appState.twaReturnUrl,
            forceRedirect: vt
        })
    }
      , lt = ()=>{
        b(!0),
        setLastSelectedWalletInfo({
            openMethod: "qrcode"
        })
    }
      , ct = ()=>{
        b(!1),
        setLastSelectedWalletInfo({
            openMethod: "universal-link"
        })
    }
    ;
    return (()=>{
        const ut = _tmpl$2.cloneNode(!0);
        return insert(ut, createComponent(Show, {
            get when() {
                return g()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    icon: "arrow",
                    onClick: ct
                }), createComponent(MobileUniversalQR, {
                    get universalLink() {
                        return at()
                    }
                })]
            }
        }), null),
        insert(ut, createComponent(Show, {
            get when() {
                return !g()
            },
            get children() {
                return [createComponent(StyledLeftActionButton, {
                    get icon() {
                        return createComponent(QRIcon, {})
                    },
                    onClick: lt
                }), createComponent(H1Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.connectYourWallet",
                    children: "Connect your wallet"
                }), createComponent(H2Styled$2, {
                    translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegramOrSelect",
                    children: "Open Wallet in Telegram or select your wallet to connect"
                }), createComponent(TelegramButtonStyled, {
                    get leftIcon() {
                        return createComponent(AtWalletIcon, {})
                    },
                    get rightIcon() {
                        return createComponent(TGImageStyled, {
                            get src() {
                                return IMG.TG
                            }
                        })
                    },
                    onClick: xt,
                    scale: "s",
                    get children() {
                        return createComponent(Translation, {
                            translationKey: "walletModal.mobileUniversalModal.openWalletOnTelegram",
                            children: "Open Wallet in Telegram"
                        })
                    }
                }), createComponent(UlStyled, {
                    get children() {
                        return [createComponent(For, {
                            get each() {
                                return createMemo(()=>!!it())() ? nt().slice(0, 4) : nt()
                            },
                            children: pt=>(()=>{
                                const vt = _tmpl$$1.cloneNode(!0);
                                return insert(vt, createComponent(WalletItem, {
                                    get icon() {
                                        return pt.imageUrl
                                    },
                                    get name() {
                                        return pt.name
                                    },
                                    onClick: ()=>d.onSelect(pt)
                                })),
                                vt
                            }
                            )()
                        }), createComponent(Show, {
                            get when() {
                                return it()
                            },
                            get children() {
                                const pt = _tmpl$$1.cloneNode(!0);
                                return insert(pt, createComponent(FourWalletsItem, {
                                    labelLine1: "View all",
                                    labelLine2: "wallets",
                                    get images() {
                                        return nt().slice(3, 7).map(vt=>vt.imageUrl)
                                    },
                                    onClick: ()=>d.onSelectAllWallets()
                                })),
                                pt
                            }
                        }), createComponent(Divider, {
                            children: " "
                        }), createComponent(OtherOptionButton, {
                            onClick: ht,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createComponent(LongArrowIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    translationKey: "walletModal.mobileUniversalModal.openLink",
                                    children: "Open Link"
                                })]
                            }
                        }), createComponent(OtherOptionButton, {
                            onClick: ft,
                            get children() {
                                return [createComponent(IconContainer, {
                                    get children() {
                                        return createMemo(()=>st() !== void 0)() ? createComponent(DoneIcon, {}) : createComponent(CopyLightIcon, {})
                                    }
                                }), createComponent(Text, {
                                    fontWeight: 590,
                                    get translationKey() {
                                        return st() !== void 0 ? "common.copied" : "common.copyLink"
                                    },
                                    get children() {
                                        return st() !== void 0 ? "Copied" : "Copy Link"
                                    }
                                })]
                            }
                        })]
                    }
                })]
            }
        }), null),
        ut
    }
    )()
}
  , borders$6 = {
    m: "16px",
    s: "8px",
    none: "0"
}
  , hoverBorders = {
    m: "8px",
    s: "4px",
    none: "0"
}
  , DesktopUniversalModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 16px;
`
  , H2Styled = styled(H2)`
    max-width: 320px;
    margin-top: 2px;
    margin-bottom: 20px;
`
  , H2AvailableWalletsStyled = styled(H2)`
    margin-bottom: 16px;
`
  , QRCodeStyled = styled(QRCode)`
    margin-bottom: 24px;
`
  , WalletsContainerStyled = styled.ul`
    display: flex;
`;
styled.div`
    display: flex;
    gap: 16px;
    width: 100%;
`;
styled(Button)`
    position: relative;
    font-size: 16px;
    line-height: 20px;
    width: 100%;
    padding: 0 16px;
    height: 56px;
    border-radius: ${d=>borders$6[d.theme.borderRadius]};

    &:hover {
        ${d=>d.disableEventsAnimation ? "transform: unset;" : ""}
    }

    &:active {
        ${d=>d.disableEventsAnimation ? "transform: unset;" : ""}
    }
`;
styled.ul`
    position: absolute;
    bottom: 100%;
    left: 0;
    margin: 0;
    padding: 8px;
    width: 188px;
    transform: translateY(-16px);

    background-color: ${d=>d.theme.colors.background.primary};
    border-radius: ${d=>borders$6[d.theme.borderRadius]};
    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);
`;
styled.li`
    padding: 8px;

    display: flex;
    align-items: center;
    gap: 8px;

    cursor: pointer;
    border-radius: ${d=>hoverBorders[d.theme.borderRadius]};

    transition: background-color, transform 0.1s ease-in-out;

    &:hover {
        background-color: ${d=>d.theme.colors.background.secondary};
    }

    &:active {
        transform: scale(0.96);
    }
`;
styled(Image$1)`
    width: 24px;
    height: 24px;

    border-radius: 6px;
`;
styled.div`
    margin-top: 23px;
    margin-bottom: 1px;
    width: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
`;
styled(Text)`
    color: ${d=>d.theme.colors.text.secondary};
    font-size: 16px;
`;
const _tmpl$ = template$1("<li></li>")
  , DesktopUniversalModal = d=>{
    const [g,b] = createSignal(!1)
      , _ = appState.connector
      , $ = createMemo(()=>getUniqueBridges(d.walletsList), null, {
        equals: bridgesIsEqual
    });
    setLastSelectedWalletInfo({
        openMethod: "qrcode"
    });
    const et = createMemo(()=>_.connect($(), d.additionalRequest));
    return createComponent(DesktopUniversalModalStyled, {
        onClick: ()=>b(!1),
        "data-tc-wallets-modal-universal-desktop": "true",
        get children() {
            return [createComponent(H1, {
                translationKey: "walletModal.desktopUniversalModal.connectYourWallet",
                children: "Connect your wallet"
            }), createComponent(H2Styled, {
                translationKey: "walletModal.desktopUniversalModal.scan",
                children: "Scan with your mobile wallet"
            }), createComponent(QRCodeStyled, {
                get sourceUrl() {
                    return addReturnStrategy(et(), "none")
                },
                get disableCopy() {
                    return g()
                },
                get imageUrl() {
                    return IMG.TON
                }
            }), createComponent(H2AvailableWalletsStyled, {
                translationKey: "walletModal.desktopUniversalModal.availableWallets",
                children: "Available wallets"
            }), createComponent(WalletsContainerStyled, {
                get children() {
                    return [createComponent(For, {
                        get each() {
                            return d.walletsList.slice(0, 3)
                        },
                        children: tt=>(()=>{
                            const rt = _tmpl$.cloneNode(!0);
                            return insert(rt, createComponent(WalletLabeledItem, {
                                wallet: tt,
                                onClick: ()=>d.onSelect(tt)
                            })),
                            rt
                        }
                        )()
                    }), createComponent(FourWalletsItem, {
                        labelLine1: "View all",
                        labelLine2: "wallets",
                        get images() {
                            return d.walletsList.slice(3, 7).map(tt=>tt.imageUrl)
                        },
                        onClick: ()=>d.onSelectAllWallets()
                    })]
                }
            })]
        }
    })
}
  , WalletsModal = ()=>{
    const {locale: d} = useI18n()[1];
    createEffect(()=>d(appState.language)),
    createEffect(()=>{
        getWalletsModalIsOpened() ? updateIsMobile() : (et(null),
        rt("universal"),
        it(!1))
    }
    );
    const g = useContext(ConnectorContext)
      , b = useContext(TonConnectUiContext)
      , [_] = createResource(()=>b.getWallets())
      , [$,et] = createSignal(null)
      , [tt,rt] = createSignal("universal")
      , [nt,it] = createSignal(!1)
      , ot = createMemo(()=>{
        if (_.state !== "ready")
            return null;
        let ct = applyWalletsListConfiguration(_(), appState.walletsListConfiguration);
        const ut = ct.filter(isWalletInfoCurrentlyInjected)
          , pt = ct.filter($t=>!isWalletInfoCurrentlyInjected($t));
        ct = (ut || []).concat(pt);
        const vt = appState.preferredWalletAppName
          , _t = ct.find($t=>eqWalletName($t, vt))
          , Pt = ct.filter($t=>eqWalletName($t, vt)).length >= 2;
        vt && _t && !Pt && (ct = [__spreadProps(__spreadValues$1({}, _t), {
            isPreferred: !0
        })].concat(ct.filter($t=>!eqWalletName($t, vt))));
        const kt = ct.find($t=>eqWalletName($t, AT_WALLET_APP_NAME));
        return kt && (ct = [kt].concat(ct.filter($t=>!eqWalletName($t, AT_WALLET_APP_NAME)))),
        ct
    }
    )
      , at = ()=>{
        var ct;
        return ((ct = appState.connectRequestParameters) == null ? void 0 : ct.state) === "loading"
    }
      , st = createMemo(()=>{
        var ct;
        if (!at())
            return (ct = appState.connectRequestParameters) == null ? void 0 : ct.value
    }
    )
      , dt = ct=>{
        b.closeModal(ct)
    }
      , ft = g.onStatusChange(ct=>{
        ct && dt("wallet-selected")
    }
    )
      , ht = ()=>{
        rt("all-wallets")
    }
      , xt = ()=>{
        rt("universal")
    }
      , lt = ()=>{
        et(null)
    }
    ;
    return onCleanup(()=>{
        et(null),
        it(!1)
    }
    ),
    onCleanup(ft),
    createComponent(StyledModal, {
        get opened() {
            return getWalletsModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: ()=>dt("action-cancelled"),
        onClickQuestion: ()=>it(ct=>!ct),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return nt()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: ()=>it(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !nt()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return at() || !ot()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return createMemo(()=>!at())() && ot()
                        },
                        get children() {
                            return createComponent(Switch, {
                                get children() {
                                    return [createComponent(Match, {
                                        get when() {
                                            return $()
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile() ? MobileConnectionModal : DesktopConnectionModal
                                                },
                                                get wallet() {
                                                    return $()
                                                },
                                                get additionalRequest() {
                                                    return st()
                                                },
                                                onBackClick: lt
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return tt() === "universal"
                                        },
                                        get children() {
                                            return createComponent(Dynamic, {
                                                get component() {
                                                    return isMobile() ? MobileUniversalModal : DesktopUniversalModal
                                                },
                                                onSelect: et,
                                                get walletsList() {
                                                    return ot()
                                                },
                                                get additionalRequest() {
                                                    return st()
                                                },
                                                onSelectAllWallets: ht
                                            })
                                        }
                                    }), createComponent(Match, {
                                        get when() {
                                            return tt() === "all-wallets"
                                        },
                                        get children() {
                                            return createComponent(AllWalletsListModal, {
                                                get walletsList() {
                                                    return ot()
                                                },
                                                onBack: xt,
                                                onSelect: et
                                            })
                                        }
                                    })]
                                }
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , ActionModalStyled = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 8px;
`
  , H1Styled = styled(H1)`
    margin-top: 16px;
`
  , TextStyled = styled(Text)`
    font-weight: 510;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    max-width: 250px;

    color: ${d=>d.theme.colors.text.secondary};
`
  , LoaderButtonStyled = styled(Button)`
    min-width: 112px;
    margin-top: 32px;
`
  , LoaderIconStyled = styled(LoaderIcon)`
    height: 16px;
    width: 16px;
`
  , ButtonStyled = styled(Button)`
    margin-top: 32px;
`
  , ActionModal = d=>{
    const g = useDataAttributes(d)
      , b = useContext(TonConnectUiContext)
      , [_,$] = createSignal(!0)
      , [et,tt] = createSignal(!1);
    createEffect(()=>{
        const ot = action();
        tt(!!ot && "sent"in ot && ot.sent)
    }
    );
    let rt;
    b != null && b.wallet && "universalLink"in b.wallet && (b.wallet.openMethod === "universal-link" || isTelegramUrl(b.wallet.universalLink) && isInTMA()) && (rt = b.wallet.universalLink);
    let nt;
    b != null && b.wallet && "deepLink"in b.wallet && (b.wallet.openMethod === "custom-deeplink" || isTelegramUrl(b.wallet.deepLink) && isInTMA()) && (nt = b.wallet.deepLink);
    const it = ()=>{
        const ot = action()
          , at = "returnStrategy"in ot ? ot.returnStrategy : appState.returnStrategy
          , st = !_();
        $(!1),
        isTelegramUrl(rt) ? redirectToTelegram(rt, {
            returnStrategy: at,
            twaReturnUrl: "twaReturnUrl"in ot ? ot.twaReturnUrl : appState.twaReturnUrl,
            forceRedirect: st
        }) : redirectToWallet(rt, nt, {
            returnStrategy: at,
            forceRedirect: st
        }, ()=>{}
        )
    }
    ;
    return createComponent(ActionModalStyled, mergeProps(g, {
        get children() {
            return [createMemo(()=>d.icon), createComponent(H1Styled, {
                get translationKey() {
                    return d.headerTranslationKey
                },
                get translationValues() {
                    return d.headerTranslationValues
                }
            }), createComponent(TextStyled, {
                get translationKey() {
                    return d.textTranslationKey
                },
                get translationValues() {
                    return d.textTranslationValues
                }
            }), createComponent(Show, {
                get when() {
                    return !et() && (d.showButton === "open-wallet" && rt || d.showButton !== "open-wallet")
                },
                get children() {
                    return createComponent(LoaderButtonStyled, {
                        disabled: !0,
                        "data-tc-connect-button-loading": "true",
                        get children() {
                            return createComponent(LoaderIconStyled, {})
                        }
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return et()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return d.showButton !== "open-wallet"
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: ()=>d.onClose(),
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.close",
                                        children: "Close"
                                    })
                                }
                            })
                        }
                    }), createComponent(Show, {
                        get when() {
                            return d.showButton === "open-wallet" && rt
                        },
                        get children() {
                            return createComponent(ButtonStyled, {
                                onClick: it,
                                get children() {
                                    return createComponent(Translation, {
                                        translationKey: "common.openWallet",
                                        children: "Open wallet"
                                    })
                                }
                            })
                        }
                    })]
                }
            })]
        }
    }))
}
  , ConfirmTransactionModal = d=>{
    const g = useContext(TonConnectUiContext)
      , [b] = useI18n()
      , _ = ()=>g.wallet && "name"in g.wallet ? g.wallet.name : b("common.yourWallet", {}, "Your wallet");
    return createComponent(ActionModal, {
        headerTranslationKey: "actionModal.confirmTransaction.header",
        get headerTranslationValues() {
            return {
                name: _()
            }
        },
        textTranslationKey: "actionModal.confirmTransaction.text",
        get icon() {
            return createComponent(LoaderIcon, {
                size: "m"
            })
        },
        onClose: ()=>d.onClose(),
        showButton: "open-wallet",
        "data-tc-confirm-modal": "true"
    })
}
  , TransactionCanceledModal = d=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionCanceled.header",
    textTranslationKey: "actionModal.transactionCanceled.text",
    get icon() {
        return createComponent(ErrorIcon, {
            size: "m"
        })
    },
    onClose: ()=>d.onClose(),
    "data-tc-transaction-canceled-modal": "true"
})
  , TransactionSentModal = d=>createComponent(ActionModal, {
    headerTranslationKey: "actionModal.transactionSent.header",
    textTranslationKey: "actionModal.transactionSent.text",
    get icon() {
        return createComponent(SuccessIcon, {
            size: "m"
        })
    },
    onClose: ()=>d.onClose(),
    "data-tc-transaction-sent-modal": "true"
})
  , ActionsModal = ()=>createComponent(Modal, {
    get opened() {
        var d;
        return createMemo(()=>action() !== null)() && ((d = action()) == null ? void 0 : d.openModal) === !0
    },
    get enableAndroidBackHandler() {
        return appState.enableAndroidBackHandler
    },
    onClose: ()=>setAction(null),
    "data-tc-actions-modal-container": "true",
    get children() {
        return createComponent(Switch, {
            get children() {
                return [createComponent(Match, {
                    get when() {
                        return action().name === "transaction-sent"
                    },
                    get children() {
                        return createComponent(TransactionSentModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "transaction-canceled"
                    },
                    get children() {
                        return createComponent(TransactionCanceledModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                }), createComponent(Match, {
                    get when() {
                        return action().name === "confirm-transaction"
                    },
                    get children() {
                        return createComponent(ConfirmTransactionModal, {
                            onClose: ()=>setAction(null)
                        })
                    }
                })]
            }
        })
    }
})
  , SingleWalletModal = ()=>{
    const {locale: d} = useI18n()[1];
    createEffect(()=>d(appState.language)),
    createEffect(()=>{
        getSingleWalletModalIsOpened() && updateIsMobile()
    }
    );
    const g = useContext(ConnectorContext)
      , b = useContext(TonConnectUiContext)
      , [_,$] = createSignal(!1)
      , et = ()=>{
        var it;
        return ((it = appState.connectRequestParameters) == null ? void 0 : it.state) === "loading"
    }
      , tt = createMemo(()=>{
        var it;
        if (!et())
            return (it = appState.connectRequestParameters) == null ? void 0 : it.value
    }
    )
      , rt = it=>{
        b.closeSingleWalletModal(it)
    }
      , nt = g.onStatusChange(it=>{
        it && rt("wallet-selected")
    }
    );
    return onCleanup(nt),
    onCleanup(()=>{
        $(!1)
    }
    ),
    createComponent(StyledModal, {
        get opened() {
            return getSingleWalletModalIsOpened()
        },
        get enableAndroidBackHandler() {
            return appState.enableAndroidBackHandler
        },
        onClose: ()=>rt("action-cancelled"),
        onClickQuestion: ()=>$(it=>!it),
        "data-tc-wallets-modal-container": "true",
        get children() {
            return [createComponent(Show, {
                get when() {
                    return _()
                },
                get children() {
                    return createComponent(InfoModal, {
                        onBackClick: ()=>$(!1)
                    })
                }
            }), createComponent(Show, {
                get when() {
                    return !_()
                },
                get children() {
                    return [createComponent(Show, {
                        get when() {
                            return et()
                        },
                        get children() {
                            return [createComponent(H1Styled$8, {
                                translationKey: "walletModal.loading",
                                children: "Wallets list is loading"
                            }), createComponent(LoaderContainerStyled, {
                                get children() {
                                    return createComponent(LoaderIcon, {
                                        size: "m"
                                    })
                                }
                            })]
                        }
                    }), createComponent(Show, {
                        get when() {
                            return !et()
                        },
                        get children() {
                            return createComponent(Dynamic, {
                                get component() {
                                    return isMobile() ? MobileConnectionModal : DesktopConnectionModal
                                },
                                get wallet() {
                                    return getSingleWalletModalWalletInfo()
                                },
                                get additionalRequest() {
                                    return tt()
                                },
                                onBackClick: ()=>{}
                                ,
                                backDisabled: !0
                            })
                        }
                    })]
                }
            })]
        }
    })
}
  , App = d=>{
    const g = createI18nContext(i18nDictionary, appState.language);
    return defineStylesRoot(),
    fixMobileSafariActiveTransition(),
    createComponent(I18nContext.Provider, {
        value: g,
        get children() {
            return createComponent(TonConnectUiContext.Provider, {
                get value() {
                    return d.tonConnectUI
                },
                get children() {
                    return createComponent(ConnectorContext.Provider, {
                        get value() {
                            return appState.connector
                        },
                        get children() {
                            return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {
                                theme: themeState,
                                get children() {
                                    return [createComponent(Show, {
                                        get when() {
                                            return appState.buttonRootId
                                        },
                                        get children() {
                                            return createComponent(Portal, {
                                                get mount() {
                                                    return document.getElementById(appState.buttonRootId)
                                                },
                                                get children() {
                                                    return createComponent(AccountButton, {})
                                                }
                                            })
                                        }
                                    }), createComponent(Dynamic, {
                                        component: globalStylesTag,
                                        get children() {
                                            return [createComponent(WalletsModal, {}), createComponent(SingleWalletModal, {}), createComponent(ActionsModal, {})]
                                        }
                                    })]
                                }
                            })]
                        }
                    })
                }
            })
        }
    })
}
  , widgetController = {
    openWalletsModal: ()=>void setTimeout(()=>setWalletsModalState({
        status: "opened",
        closeReason: null
    })),
    closeWalletsModal: d=>void setTimeout(()=>setWalletsModalState({
        status: "closed",
        closeReason: d
    })),
    openSingleWalletModal: d=>{
        setTimeout(()=>setSingleWalletModalState({
            status: "opened",
            closeReason: null,
            walletInfo: d
        }))
    }
    ,
    closeSingleWalletModal: d=>void setTimeout(()=>setSingleWalletModalState({
        status: "closed",
        closeReason: d
    })),
    setAction: d=>void setTimeout(()=>setAction(d)),
    clearAction: ()=>void setTimeout(()=>setAction(null)),
    getSelectedWalletInfo: ()=>lastSelectedWalletInfo(),
    removeSelectedWalletInfo: ()=>setLastSelectedWalletInfo(null),
    renderApp: (d,g)=>render(()=>createComponent(App, {
        tonConnectUI: g
    }), document.getElementById(d))
};
class WalletsModalManager {
    constructor(g) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", walletsModalState()),
        this.connector = g.connector,
        this.tracker = g.tracker,
        this.setConnectRequestParametersCallback = g.setConnectRequestParametersCallback,
        createEffect(()=>{
            const b = walletsModalState();
            this.state = b,
            this.consumers.forEach(_=>_(b))
        }
        )
    }
    open() {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const b = (yield this.connector.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return b ? this.connectEmbeddedWallet(b) : this.openWalletsModal()
        })
    }
    close(g="action-cancelled") {
        g === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeWalletsModal(g)
    }
    onStateChange(g) {
        return this.consumers.push(g),
        ()=>{
            this.consumers = this.consumers.filter(b=>b !== g)
        }
    }
    connectEmbeddedWallet(g) {
        const b = $=>{
            setLastSelectedWalletInfo(g),
            this.connector.connect({
                jsBridgeKey: g.jsBridgeKey
            }, $)
        }
          , _ = appState.connectRequestParameters;
        (_ == null ? void 0 : _.state) === "loading" ? this.setConnectRequestParametersCallback(b) : b(_ == null ? void 0 : _.value)
    }
    openWalletsModal() {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openWalletsModal(),
            new Promise(g=>{
                const b = this.onStateChange(_=>{
                    const {status: $} = _;
                    $ === "opened" && (b(),
                    g())
                }
                )
            }
            )
        })
    }
}
class TransactionModalManager {
    constructor(g) {
        __publicField(this, "connector"),
        __publicField(this, "consumers", []),
        this.connector = g.connector,
        createEffect(()=>{
            const b = action();
            this.consumers.forEach(_=>_(b))
        }
        )
    }
    onStateChange(g) {
        return this.consumers.push(g),
        ()=>{
            this.consumers = this.consumers.filter(b=>b !== g)
        }
    }
}
class SingleWalletModalManager {
    constructor(g) {
        __publicField(this, "connector"),
        __publicField(this, "setConnectRequestParametersCallback"),
        __publicField(this, "consumers", []),
        __publicField(this, "tracker"),
        __publicField(this, "state", singleWalletModalState()),
        this.connector = g.connector,
        this.tracker = g.tracker,
        this.setConnectRequestParametersCallback = g.setConnectRequestParametersCallback,
        createEffect(()=>{
            const b = singleWalletModalState();
            this.state = b,
            this.consumers.forEach(_=>_(b))
        }
        )
    }
    open(g) {
        return __async(this, null, function*() {
            this.tracker.trackConnectionStarted();
            const b = yield this.connector.getWallets()
              , _ = applyWalletsListConfiguration(b, appState.walletsListConfiguration)
              , $ = _.find(isWalletInfoCurrentlyEmbedded);
            if (!!$)
                return this.connectEmbeddedWallet($);
            const rt = _.filter(isWalletInfoRemote).find(ot=>eqWalletName(ot, g));
            if (!!rt)
                return this.openSingleWalletModal(rt);
            const it = `Trying to open modal window with unknown wallet "${g}".`;
            throw this.tracker.trackConnectionError(it),
            new TonConnectUIError(it)
        })
    }
    close(g="action-cancelled") {
        g === "action-cancelled" && this.tracker.trackConnectionError("Connection was cancelled"),
        widgetController.closeSingleWalletModal("action-cancelled")
    }
    onStateChange(g) {
        return this.consumers.push(g),
        ()=>{
            this.consumers = this.consumers.filter(b=>b !== g)
        }
    }
    connectEmbeddedWallet(g) {
        const b = $=>{
            setLastSelectedWalletInfo(g),
            this.connector.connect({
                jsBridgeKey: g.jsBridgeKey
            }, $)
        }
          , _ = appState.connectRequestParameters;
        (_ == null ? void 0 : _.state) === "loading" ? this.setConnectRequestParametersCallback(b) : b(_ == null ? void 0 : _.value)
    }
    openSingleWalletModal(g) {
        return __async(this, null, function*() {
            return isInTMA() && sendExpand(),
            widgetController.openSingleWalletModal(g),
            new Promise(b=>{
                const _ = this.onStateChange($=>{
                    const {status: et} = $;
                    et === "opened" && (_(),
                    b())
                }
                )
            }
            )
        })
    }
}
class TonConnectUITracker {
    constructor(g) {
        __publicField(this, "eventPrefix", "ton-connect-ui-"),
        __publicField(this, "tonConnectUiVersion"),
        __publicField(this, "tonConnectSdkVersion", null),
        __publicField(this, "eventDispatcher");
        var b;
        this.eventDispatcher = (b = g == null ? void 0 : g.eventDispatcher) != null ? b : new BrowserEventDispatcher,
        this.tonConnectUiVersion = g.tonConnectUiVersion,
        this.init().catch()
    }
    get version() {
        return createVersionInfo({
            ton_connect_sdk_lib: this.tonConnectSdkVersion,
            ton_connect_ui_lib: this.tonConnectUiVersion
        })
    }
    init() {
        return __async(this, null, function*() {
            try {
                yield this.setRequestVersionHandler(),
                this.tonConnectSdkVersion = yield this.requestTonConnectSdkVersion()
            } catch {}
        })
    }
    setRequestVersionHandler() {
        return __async(this, null, function*() {
            yield this.eventDispatcher.addEventListener("ton-connect-ui-request-version", ()=>__async(this, null, function*() {
                yield this.eventDispatcher.dispatchEvent("ton-connect-ui-response-version", createResponseVersionEvent(this.tonConnectUiVersion))
            }))
        })
    }
    requestTonConnectSdkVersion() {
        return __async(this, null, function*() {
            return new Promise((g,b)=>__async(this, null, function*() {
                try {
                    yield this.eventDispatcher.addEventListener("ton-connect-response-version", _=>{
                        g(_.detail.version)
                    }
                    , {
                        once: !0
                    }),
                    yield this.eventDispatcher.dispatchEvent("ton-connect-request-version", createRequestVersionEvent())
                } catch (_) {
                    b(_)
                }
            }))
        })
    }
    dispatchUserActionEvent(g) {
        var b;
        try {
            (b = this.eventDispatcher) == null || b.dispatchEvent(`${this.eventPrefix}${g.type}`, g).catch()
        } catch {}
    }
    trackConnectionStarted(...g) {
        try {
            const b = createConnectionStartedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionCompleted(...g) {
        try {
            const b = createConnectionCompletedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionError(...g) {
        try {
            const b = createConnectionErrorEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringStarted(...g) {
        try {
            const b = createConnectionRestoringStartedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringCompleted(...g) {
        try {
            const b = createConnectionRestoringCompletedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackConnectionRestoringError(...g) {
        try {
            const b = createConnectionRestoringErrorEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackDisconnection(...g) {
        try {
            const b = createDisconnectionEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSentForSignature(...g) {
        try {
            const b = createTransactionSentForSignatureEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSigned(...g) {
        try {
            const b = createTransactionSignedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
    trackTransactionSigningFailed(...g) {
        try {
            const b = createTransactionSigningFailedEvent(this.version, ...g);
            this.dispatchUserActionEvent(b)
        } catch {}
    }
}
const tonConnectUiVersion = "2.0.5";
class TonConnectUI {
    constructor(g) {
        if (__publicField(this, "walletInfoStorage", new WalletInfoStorage),
        __publicField(this, "preferredWalletStorage", new PreferredWalletStorage),
        __publicField(this, "tracker"),
        __publicField(this, "walletInfo", null),
        __publicField(this, "systemThemeChangeUnsubscribe", null),
        __publicField(this, "actionsConfiguration"),
        __publicField(this, "walletsList"),
        __publicField(this, "connectRequestParametersCallback"),
        __publicField(this, "connector"),
        __publicField(this, "modal"),
        __publicField(this, "singleWalletModal"),
        __publicField(this, "transactionModal"),
        __publicField(this, "connectionRestored", Promise.resolve(!1)),
        g && "connector"in g && g.connector)
            this.connector = g.connector;
        else if (g && "manifestUrl"in g && g.manifestUrl)
            this.connector = new TonConnect({
                manifestUrl: g.manifestUrl,
                eventDispatcher: g == null ? void 0 : g.eventDispatcher
            });
        else
            throw new TonConnectUIError("You have to specify a `manifestUrl` or a `connector` in the options.");
        this.tracker = new TonConnectUITracker({
            eventDispatcher: g == null ? void 0 : g.eventDispatcher,
            tonConnectUiVersion
        }),
        this.modal = new WalletsModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: $=>{
                this.connectRequestParametersCallback = $
            }
        }),
        this.singleWalletModal = new SingleWalletModalManager({
            connector: this.connector,
            tracker: this.tracker,
            setConnectRequestParametersCallback: $=>{
                this.connectRequestParametersCallback = $
            }
        }),
        this.transactionModal = new TransactionModalManager({
            connector: this.connector
        }),
        this.walletsList = this.getWallets(),
        this.walletsList.then($=>preloadImages(uniq($.map(et=>et.imageUrl))));
        const b = this.normalizeWidgetRoot(g == null ? void 0 : g.widgetRootId);
        this.subscribeToWalletChange(),
        (g == null ? void 0 : g.restoreConnection) !== !1 && (this.connectionRestored = createMacrotaskAsync(()=>__async(this, null, function*() {
            return this.tracker.trackConnectionRestoringStarted(),
            yield this.connector.restoreConnection(),
            this.connector.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : (this.tracker.trackConnectionRestoringError("Connection was not restored"),
            this.walletInfoStorage.removeWalletInfo()),
            this.connector.connected
        }))),
        this.uiOptions = mergeOptions(g, {
            uiPreferences: {
                theme: "SYSTEM"
            }
        });
        const _ = this.preferredWalletStorage.getPreferredWalletAppName();
        setAppState({
            connector: this.connector,
            preferredWalletAppName: _
        }),
        widgetController.renderApp(b, this)
    }
    static getWallets() {
        return TonConnect.getWallets()
    }
    get connected() {
        return this.connector.connected
    }
    get account() {
        return this.connector.account
    }
    get wallet() {
        return this.connector.wallet ? __spreadValues$1(__spreadValues$1({}, this.connector.wallet), this.walletInfo) : null
    }
    set uiOptions(g) {
        var b, _, $, et, tt;
        this.checkButtonRootExist(g.buttonRootId),
        this.actionsConfiguration = g.actionsConfiguration,
        (b = g.uiPreferences) != null && b.theme ? ((_ = g.uiPreferences) == null ? void 0 : _.theme) !== "SYSTEM" ? (($ = this.systemThemeChangeUnsubscribe) == null || $.call(this),
        setTheme(g.uiPreferences.theme, g.uiPreferences.colorsSet)) : (setTheme(getSystemTheme(), g.uiPreferences.colorsSet),
        this.systemThemeChangeUnsubscribe || (this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme))) : (et = g.uiPreferences) != null && et.colorsSet && setColors(g.uiPreferences.colorsSet),
        (tt = g.uiPreferences) != null && tt.borderRadius && setBorderRadius(g.uiPreferences.borderRadius),
        setAppState(rt=>{
            var nt, it;
            const ot = mergeOptions(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, g.language && {
                language: g.language
            }), !!((nt = g.actionsConfiguration) != null && nt.returnStrategy) && {
                returnStrategy: g.actionsConfiguration.returnStrategy
            }), !!((it = g.actionsConfiguration) != null && it.twaReturnUrl) && {
                twaReturnUrl: g.actionsConfiguration.twaReturnUrl
            }), !!g.walletsListConfiguration && {
                walletsListConfiguration: g.walletsListConfiguration
            }), unwrap(rt));
            return g.buttonRootId !== void 0 && (ot.buttonRootId = g.buttonRootId),
            g.enableAndroidBackHandler !== void 0 && (ot.enableAndroidBackHandler = g.enableAndroidBackHandler),
            ot
        }
        )
    }
    setConnectRequestParameters(g) {
        var b;
        setAppState({
            connectRequestParameters: g
        }),
        ((g == null ? void 0 : g.state) === "ready" || !g) && ((b = this.connectRequestParametersCallback) == null || b.call(this, g == null ? void 0 : g.value))
    }
    getWallets() {
        return __async(this, null, function*() {
            return this.connector.getWallets()
        })
    }
    onStatusChange(g, b) {
        return this.connector.onStatusChange(_=>__async(this, null, function*() {
            if (_) {
                const $ = yield this.getSelectedWalletInfo(_);
                g(__spreadValues$1(__spreadValues$1({}, _), $ || this.walletInfoStorage.getWalletInfo()))
            } else
                g(_)
        }), b)
    }
    openModal() {
        return __async(this, null, function*() {
            return this.modal.open()
        })
    }
    closeModal(g) {
        this.modal.close(g)
    }
    onModalStateChange(g) {
        return this.modal.onStateChange(g)
    }
    get modalState() {
        return this.modal.state
    }
    openSingleWalletModal(g) {
        return __async(this, null, function*() {
            return this.singleWalletModal.open(g)
        })
    }
    closeSingleWalletModal(g) {
        this.singleWalletModal.close(g)
    }
    onSingleWalletModalStateChange(g) {
        return this.singleWalletModal.onStateChange(g)
    }
    get singleWalletModalState() {
        return this.singleWalletModal.state
    }
    connectWallet() {
        return __async(this, null, function*() {
            const b = (yield this.getWallets()).find(isWalletInfoCurrentlyEmbedded);
            return b ? yield this.connectEmbeddedWallet(b) : yield this.connectExternalWallet()
        })
    }
    disconnect() {
        return this.tracker.trackDisconnection(this.wallet, "dapp"),
        widgetController.clearAction(),
        widgetController.removeSelectedWalletInfo(),
        this.walletInfoStorage.removeWalletInfo(),
        this.connector.disconnect()
    }
    sendTransaction(g, b) {
        return __async(this, null, function*() {
            if (this.tracker.trackTransactionSentForSignature(this.wallet, g),
            !this.connected)
                throw this.tracker.trackTransactionSigningFailed(this.wallet, g, "Wallet was not connected"),
                new TonConnectUIError("Connect wallet to send a transaction.");
            isInTMA() && sendExpand();
            const {notifications: _, modals: $, returnStrategy: et, twaReturnUrl: tt, skipRedirectToWallet: rt} = this.getModalsAndNotificationsConfiguration(b);
            widgetController.setAction({
                name: "confirm-transaction",
                showNotification: _.includes("before"),
                openModal: $.includes("before"),
                sent: !1
            });
            const nt = ()=>{
                it.signal.aborted || (widgetController.setAction({
                    name: "confirm-transaction",
                    showNotification: _.includes("before"),
                    openModal: $.includes("before"),
                    sent: !0
                }),
                this.walletInfo && "universalLink"in this.walletInfo && (this.walletInfo.openMethod === "universal-link" || this.walletInfo.openMethod === "custom-deeplink") && (isTelegramUrl(this.walletInfo.universalLink) ? redirectToTelegram(this.walletInfo.universalLink, {
                    returnStrategy: et,
                    twaReturnUrl: tt || appState.twaReturnUrl,
                    forceRedirect: !1
                }) : redirectToWallet(this.walletInfo.universalLink, this.walletInfo.deepLink, {
                    returnStrategy: et,
                    forceRedirect: !1
                }, ()=>{}
                )))
            }
              , it = new AbortController
              , ot = this.onTransactionModalStateChange(at=>{
                at != null && at.openModal || (ot(),
                at || it.abort())
            }
            );
            try {
                const at = yield this.waitForSendTransaction({
                    transaction: g,
                    signal: it.signal
                }, nt);
                return this.tracker.trackTransactionSigned(this.wallet, g, at),
                widgetController.setAction({
                    name: "transaction-sent",
                    showNotification: _.includes("success"),
                    openModal: $.includes("success")
                }),
                at
            } catch (at) {
                throw widgetController.setAction({
                    name: "transaction-canceled",
                    showNotification: _.includes("error"),
                    openModal: $.includes("error")
                }),
                at instanceof TonConnectError ? at : (console.error(at),
                new TonConnectUIError("Unhandled error:" + at))
            } finally {
                ot()
            }
        })
    }
    connectEmbeddedWallet(g) {
        return __async(this, null, function*() {
            const b = $=>{
                setLastSelectedWalletInfo(g),
                this.connector.connect({
                    jsBridgeKey: g.jsBridgeKey
                }, $)
            }
              , _ = appState.connectRequestParameters;
            return (_ == null ? void 0 : _.state) === "loading" ? this.connectRequestParametersCallback = b : b(_ == null ? void 0 : _.value),
            yield this.waitForWalletConnection({
                ignoreErrors: !1
            })
        })
    }
    connectExternalWallet() {
        return __async(this, null, function*() {
            const g = new AbortController;
            widgetController.openWalletsModal();
            const b = this.onModalStateChange(_=>{
                const {status: $, closeReason: et} = _;
                $ !== "opened" && (b(),
                et === "action-cancelled" && g.abort())
            }
            );
            return yield this.waitForWalletConnection({
                ignoreErrors: !0,
                signal: g.signal
            })
        })
    }
    waitForWalletConnection(g) {
        return __async(this, null, function*() {
            return new Promise((b,_)=>{
                this.tracker.trackConnectionStarted();
                const {ignoreErrors: $=!1, signal: et=null} = g;
                if (et && et.aborted)
                    return this.tracker.trackConnectionError("Connection was cancelled"),
                    _(new TonConnectUIError("Wallet was not connected"));
                const tt = it=>__async(this, null, function*() {
                    if (it)
                        this.tracker.trackConnectionCompleted(it),
                        nt(),
                        b(it);
                    else {
                        if (this.tracker.trackConnectionError("Connection was cancelled"),
                        $)
                            return;
                        nt(),
                        _(new TonConnectUIError("Wallet was not connected"))
                    }
                })
                  , rt = it=>{
                    this.tracker.trackConnectionError(it.message),
                    !$ && (nt(),
                    _(it))
                }
                  , nt = this.onStatusChange(it=>tt(it), it=>rt(it));
                et && et.addEventListener("abort", ()=>{
                    nt(),
                    _(new TonConnectUIError("Wallet was not connected"))
                }
                , {
                    once: !0
                })
            }
            )
        })
    }
    waitForSendTransaction(g, b) {
        return __async(this, null, function*() {
            return new Promise((_,$)=>{
                const {transaction: et, signal: tt} = g;
                if (tt.aborted)
                    return this.tracker.trackTransactionSigningFailed(this.wallet, et, "Transaction was cancelled"),
                    $(new TonConnectUIError("Transaction was not sent"));
                const rt = ot=>__async(this, null, function*() {
                    _(ot)
                })
                  , nt = ot=>{
                    $(ot)
                }
                  , it = ()=>{
                    this.tracker.trackTransactionSigningFailed(this.wallet, et, "Transaction was cancelled"),
                    $(new TonConnectUIError("Transaction was not sent"))
                }
                ;
                tt.addEventListener("abort", it, {
                    once: !0
                }),
                this.connector.sendTransaction(et, {
                    onRequestSent: b,
                    signal: tt
                }).then(ot=>(tt.removeEventListener("abort", it),
                rt(ot))).catch(ot=>(tt.removeEventListener("abort", it),
                nt(ot)))
            }
            )
        })
    }
    onTransactionModalStateChange(g) {
        return this.transactionModal.onStateChange(g)
    }
    subscribeToWalletChange() {
        this.connector.onStatusChange(g=>__async(this, null, function*() {
            var b;
            g ? (yield this.updateWalletInfo(g),
            this.setPreferredWalletAppName(((b = this.walletInfo) == null ? void 0 : b.appName) || g.device.appName)) : this.walletInfoStorage.removeWalletInfo()
        }))
    }
    setPreferredWalletAppName(g) {
        this.preferredWalletStorage.setPreferredWalletAppName(g),
        setAppState({
            preferredWalletAppName: g
        })
    }
    getSelectedWalletInfo(g) {
        return __async(this, null, function*() {
            let b = widgetController.getSelectedWalletInfo();
            if (!b)
                return null;
            let _;
            if ("name"in b)
                _ = b;
            else {
                const et = applyWalletsListConfiguration(yield this.walletsList, appState.walletsListConfiguration).find(tt=>eqWalletName(tt, g.device.appName));
                if (!et)
                    throw new TonConnectUIError(`Cannot find WalletInfo for the '${g.device.appName}' wallet`);
                _ = __spreadValues$1(__spreadValues$1({}, et), b)
            }
            return _
        })
    }
    updateWalletInfo(g) {
        return __async(this, null, function*() {
            const b = yield this.getSelectedWalletInfo(g);
            if (b) {
                this.walletInfo = b,
                this.walletInfoStorage.setWalletInfo(b);
                return
            }
            const _ = this.walletInfoStorage.getWalletInfo();
            if (_) {
                this.walletInfo = _;
                return
            }
            this.walletInfo = (yield this.walletsList).find($=>eqWalletName($, g.device.appName)) || null
        })
    }
    normalizeWidgetRoot(g) {
        if (!g || !document.getElementById(g)) {
            g = "tc-widget-root";
            const b = document.createElement("div");
            b.id = g,
            document.body.appendChild(b)
        }
        return g
    }
    checkButtonRootExist(g) {
        if (g != null && !document.getElementById(g))
            throw new TonConnectUIError(`${g} element not found in the document.`)
    }
    getModalsAndNotificationsConfiguration(g) {
        var b, _, $, et, tt, rt;
        const nt = ["before", "success", "error"];
        let it = nt;
        (b = this.actionsConfiguration) != null && b.notifications && ((_ = this.actionsConfiguration) == null ? void 0 : _.notifications) !== "all" && (it = this.actionsConfiguration.notifications),
        g != null && g.notifications && (g.notifications === "all" ? it = nt : it = g.notifications);
        let ot = ["before"];
        ($ = this.actionsConfiguration) != null && $.modals && (this.actionsConfiguration.modals === "all" ? ot = nt : ot = this.actionsConfiguration.modals),
        g != null && g.modals && (g.modals === "all" ? ot = nt : ot = g.modals);
        const at = (g == null ? void 0 : g.returnStrategy) || ((et = this.actionsConfiguration) == null ? void 0 : et.returnStrategy) || "back"
          , st = (g == null ? void 0 : g.twaReturnUrl) || ((tt = this.actionsConfiguration) == null ? void 0 : tt.twaReturnUrl);
        let dt = (g == null ? void 0 : g.skipRedirectToWallet) || ((rt = this.actionsConfiguration) == null ? void 0 : rt.skipRedirectToWallet) || "ios";
        return isInTMA() && (dt = "never"),
        {
            notifications: it,
            modals: ot,
            returnStrategy: at,
            twaReturnUrl: st,
            skipRedirectToWallet: dt
        }
    }
}
var __defProp = Object.defineProperty
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (d,g,b)=>g in d ? __defProp(d, g, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: b
}) : d[g] = b
  , __spreadValues = (d,g)=>{
    for (var b in g || (g = {}))
        __hasOwnProp.call(g, b) && __defNormalProp(d, b, g[b]);
    if (__getOwnPropSymbols)
        for (var b of __getOwnPropSymbols(g))
            __propIsEnum.call(g, b) && __defNormalProp(d, b, g[b]);
    return d
}
  , __objRest = (d,g)=>{
    var b = {};
    for (var _ in d)
        __hasOwnProp.call(d, _) && g.indexOf(_) < 0 && (b[_] = d[_]);
    if (d != null && __getOwnPropSymbols)
        for (var _ of __getOwnPropSymbols(d))
            g.indexOf(_) < 0 && __propIsEnum.call(d, _) && (b[_] = d[_]);
    return b
}
  , jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
    if (hasRequiredReactJsxRuntime_production_min)
        return reactJsxRuntime_production_min;
    hasRequiredReactJsxRuntime_production_min = 1;
    var d = React
      , g = Symbol.for("react.element")
      , b = Symbol.for("react.fragment")
      , _ = Object.prototype.hasOwnProperty
      , $ = d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
      , et = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };
    function tt(rt, nt, it) {
        var ot, at = {}, st = null, dt = null;
        it !== void 0 && (st = "" + it),
        nt.key !== void 0 && (st = "" + nt.key),
        nt.ref !== void 0 && (dt = nt.ref);
        for (ot in nt)
            _.call(nt, ot) && !et.hasOwnProperty(ot) && (at[ot] = nt[ot]);
        if (rt && rt.defaultProps)
            for (ot in nt = rt.defaultProps,
            nt)
                at[ot] === void 0 && (at[ot] = nt[ot]);
        return {
            $$typeof: g,
            type: rt,
            key: st,
            ref: dt,
            props: at,
            _owner: $.current
        }
    }
    return reactJsxRuntime_production_min.Fragment = b,
    reactJsxRuntime_production_min.jsx = tt,
    reactJsxRuntime_production_min.jsxs = tt,
    reactJsxRuntime_production_min
}
(function(d) {
    d.exports = requireReactJsxRuntime_production_min()
}
)(jsxRuntime);
const jsx = jsxRuntime.exports.jsx;
function isClientSide() {
    return typeof window < "u"
}
function isServerSide() {
    return !isClientSide()
}
const TonConnectUIContext = reactExports.createContext(null);
let tonConnectUI = null;
const TonConnectUIProvider = d=>{
    var g = d
      , {children: b} = g
      , _ = __objRest(g, ["children"]);
    return isClientSide() && !tonConnectUI && (tonConnectUI = new TonConnectUI(_)),
    jsx(TonConnectUIContext.Provider, {
        value: tonConnectUI,
        children: b
    })
}
  , TonConnectUIProvider$1 = reactExports.memo(TonConnectUIProvider);
class TonConnectUIReactError extends TonConnectUIError {
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, TonConnectUIReactError.prototype)
    }
}
class TonConnectProviderNotSetError extends TonConnectUIReactError {
    constructor(...g) {
        super(...g),
        Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype)
    }
}
function checkProvider(d) {
    if (!d)
        throw new TonConnectProviderNotSetError("You should add <TonConnectUIProvider> on the top of the app to use TonConnect");
    return !0
}
function useTonConnectUI() {
    const d = reactExports.useContext(TonConnectUIContext)
      , g = reactExports.useCallback(b=>{
        d && (d.uiOptions = b)
    }
    , [d]);
    return isServerSide() ? [null, ()=>{}
    ] : (checkProvider(d),
    [d, g])
}
const buttonRootId = "ton-connect-button"
  , TonConnectButton = ({className: d, style: g})=>{
    const [b,_] = useTonConnectUI();
    return reactExports.useEffect(()=>(_({
        buttonRootId
    }),
    ()=>_({
        buttonRootId: null
    })), [_]),
    jsx("div", {
        id: buttonRootId,
        className: d,
        style: __spreadValues({
            width: "fit-content"
        }, g)
    })
}
;
reactExports.memo(TonConnectButton);
function useTonWallet() {
    const [d] = useTonConnectUI()
      , [g,b] = reactExports.useState((d == null ? void 0 : d.wallet) || null);
    return reactExports.useEffect(()=>{
        if (d)
            return b(d.wallet),
            d.onStatusChange(_=>{
                b(_)
            }
            )
    }
    , [d]),
    g
}
function useTonAddress(d=!0) {
    const g = useTonWallet();
    return reactExports.useMemo(()=>g ? d ? toUserFriendlyAddress(g.account.address, g.account.chain === CHAIN.TESTNET) : g.account.address : "", [g, d, g == null ? void 0 : g.account.address, g == null ? void 0 : g.account.chain])
}
function useTonConnectModal() {
    const [d] = useTonConnectUI()
      , [g,b] = reactExports.useState((d == null ? void 0 : d.modal.state) || null);
    return reactExports.useEffect(()=>{
        if (d)
            return b(d.modal.state),
            d.onModalStateChange(_=>{
                b(_)
            }
            )
    }
    , [d]),
    {
        state: g,
        open: ()=>d == null ? void 0 : d.modal.open(),
        close: ()=>d == null ? void 0 : d.modal.close()
    }
}
function useIsConnectionRestored() {
    const [d,g] = reactExports.useState(!1)
      , [b] = useTonConnectUI();
    return reactExports.useEffect(()=>{
        b && b.connectionRestored.then(()=>g(!0))
    }
    , [b]),
    d
}
class HTTPError extends Error {
    constructor(g, b, _) {
        const $ = g.status || g.status === 0 ? g.status : ""
          , et = g.statusText || ""
          , tt = `${$} ${et}`.trim()
          , rt = tt ? `status code ${tt}` : "an unknown error";
        super(`Request failed with ${rt}`),
        Object.defineProperty(this, "response", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "request", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "options", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.name = "HTTPError",
        this.response = g,
        this.request = b,
        this.options = _
    }
}
class TimeoutError extends Error {
    constructor(g) {
        super("Request timed out"),
        Object.defineProperty(this, "request", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.name = "TimeoutError",
        this.request = g
    }
}
const isObject$7 = d=>d !== null && typeof d == "object"
  , validateAndMerge = (...d)=>{
    for (const g of d)
        if ((!isObject$7(g) || Array.isArray(g)) && typeof g < "u")
            throw new TypeError("The `options` argument must be an object");
    return deepMerge({}, ...d)
}
  , mergeHeaders = (d={},g={})=>{
    const b = new globalThis.Headers(d)
      , _ = g instanceof globalThis.Headers
      , $ = new globalThis.Headers(g);
    for (const [et,tt] of $.entries())
        _ && tt === "undefined" || tt === void 0 ? b.delete(et) : b.set(et, tt);
    return b
}
  , deepMerge = (...d)=>{
    let g = {}
      , b = {};
    for (const _ of d)
        if (Array.isArray(_))
            Array.isArray(g) || (g = []),
            g = [...g, ..._];
        else if (isObject$7(_)) {
            for (let[$,et] of Object.entries(_))
                isObject$7(et) && $ in g && (et = deepMerge(g[$], et)),
                g = {
                    ...g,
                    [$]: et
                };
            isObject$7(_.headers) && (b = mergeHeaders(b, _.headers),
            g.headers = b)
        }
    return g
}
  , supportsRequestStreams = (()=>{
    let d = !1
      , g = !1;
    const b = typeof globalThis.ReadableStream == "function"
      , _ = typeof globalThis.Request == "function";
    return b && _ && (g = new globalThis.Request("https://a.com",{
        body: new globalThis.ReadableStream,
        method: "POST",
        get duplex() {
            return d = !0,
            "half"
        }
    }).headers.has("Content-Type")),
    d && !g
}
)()
  , supportsAbortController = typeof globalThis.AbortController == "function"
  , supportsResponseStreams = typeof globalThis.ReadableStream == "function"
  , supportsFormData = typeof globalThis.FormData == "function"
  , requestMethods = ["get", "post", "put", "patch", "head", "delete"]
  , responseTypes = {
    json: "application/json",
    text: "text/*",
    formData: "multipart/form-data",
    arrayBuffer: "*/*",
    blob: "*/*"
}
  , maxSafeTimeout = 2147483647
  , stop = Symbol("stop")
  , normalizeRequestMethod = d=>requestMethods.includes(d) ? d.toUpperCase() : d
  , retryMethods = ["get", "put", "head", "delete", "options", "trace"]
  , retryStatusCodes = [408, 413, 429, 500, 502, 503, 504]
  , retryAfterStatusCodes = [413, 429, 503]
  , defaultRetryOptions = {
    limit: 2,
    methods: retryMethods,
    statusCodes: retryStatusCodes,
    afterStatusCodes: retryAfterStatusCodes,
    maxRetryAfter: Number.POSITIVE_INFINITY,
    backoffLimit: Number.POSITIVE_INFINITY
}
  , normalizeRetryOptions = (d={})=>{
    if (typeof d == "number")
        return {
            ...defaultRetryOptions,
            limit: d
        };
    if (d.methods && !Array.isArray(d.methods))
        throw new Error("retry.methods must be an array");
    if (d.statusCodes && !Array.isArray(d.statusCodes))
        throw new Error("retry.statusCodes must be an array");
    return {
        ...defaultRetryOptions,
        ...d,
        afterStatusCodes: retryAfterStatusCodes
    }
}
;
async function timeout(d, g, b) {
    return new Promise((_,$)=>{
        const et = setTimeout(()=>{
            g && g.abort(),
            $(new TimeoutError(d))
        }
        , b.timeout);
        b.fetch(d).then(_).catch($).then(()=>{
            clearTimeout(et)
        }
        )
    }
    )
}
const isDomExceptionSupported = !!globalThis.DOMException;
function composeAbortError(d) {
    if (isDomExceptionSupported)
        return new DOMException((d == null ? void 0 : d.reason) ?? "The operation was aborted.","AbortError");
    const g = new Error((d == null ? void 0 : d.reason) ?? "The operation was aborted.");
    return g.name = "AbortError",
    g
}
async function delay$1(d, {signal: g}) {
    return new Promise((b,_)=>{
        if (g) {
            if (g.aborted) {
                _(composeAbortError(g));
                return
            }
            g.addEventListener("abort", $, {
                once: !0
            })
        }
        function $() {
            _(composeAbortError(g)),
            clearTimeout(et)
        }
        const et = setTimeout(()=>{
            g == null || g.removeEventListener("abort", $),
            b()
        }
        , d)
    }
    )
}
class Ky {
    static create(g, b) {
        const _ = new Ky(g,b)
          , $ = async()=>{
            if (_._options.timeout > maxSafeTimeout)
                throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
            await Promise.resolve();
            let rt = await _._fetch();
            for (const nt of _._options.hooks.afterResponse) {
                const it = await nt(_.request, _._options, _._decorateResponse(rt.clone()));
                it instanceof globalThis.Response && (rt = it)
            }
            if (_._decorateResponse(rt),
            !rt.ok && _._options.throwHttpErrors) {
                let nt = new HTTPError(rt,_.request,_._options);
                for (const it of _._options.hooks.beforeError)
                    nt = await it(nt);
                throw nt
            }
            if (_._options.onDownloadProgress) {
                if (typeof _._options.onDownloadProgress != "function")
                    throw new TypeError("The `onDownloadProgress` option must be a function");
                if (!supportsResponseStreams)
                    throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
                return _._stream(rt.clone(), _._options.onDownloadProgress)
            }
            return rt
        }
          , tt = _._options.retry.methods.includes(_.request.method.toLowerCase()) ? _._retry($) : $();
        for (const [rt,nt] of Object.entries(responseTypes))
            tt[rt] = async()=>{
                _.request.headers.set("accept", _.request.headers.get("accept") || nt);
                const ot = (await tt).clone();
                if (rt === "json") {
                    if (ot.status === 204 || (await ot.clone().arrayBuffer()).byteLength === 0)
                        return "";
                    if (b.parseJson)
                        return b.parseJson(await ot.text())
                }
                return ot[rt]()
            }
            ;
        return tt
    }
    constructor(g, b={}) {
        if (Object.defineProperty(this, "request", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "abortController", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "_retryCount", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: 0
        }),
        Object.defineProperty(this, "_input", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "_options", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this._input = g,
        this._options = {
            credentials: this._input.credentials || "same-origin",
            ...b,
            headers: mergeHeaders(this._input.headers, b.headers),
            hooks: deepMerge({
                beforeRequest: [],
                beforeRetry: [],
                beforeError: [],
                afterResponse: []
            }, b.hooks),
            method: normalizeRequestMethod(b.method ?? this._input.method),
            prefixUrl: String(b.prefixUrl || ""),
            retry: normalizeRetryOptions(b.retry),
            throwHttpErrors: b.throwHttpErrors !== !1,
            timeout: typeof b.timeout > "u" ? 1e4 : b.timeout,
            fetch: b.fetch ?? globalThis.fetch.bind(globalThis)
        },
        typeof this._input != "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request))
            throw new TypeError("`input` must be a string, URL, or Request");
        if (this._options.prefixUrl && typeof this._input == "string") {
            if (this._input.startsWith("/"))
                throw new Error("`input` must not begin with a slash when using `prefixUrl`");
            this._options.prefixUrl.endsWith("/") || (this._options.prefixUrl += "/"),
            this._input = this._options.prefixUrl + this._input
        }
        if (supportsAbortController) {
            if (this.abortController = new globalThis.AbortController,
            this._options.signal) {
                const _ = this._options.signal;
                this._options.signal.addEventListener("abort", ()=>{
                    this.abortController.abort(_.reason)
                }
                )
            }
            this._options.signal = this.abortController.signal
        }
        if (supportsRequestStreams && (this._options.duplex = "half"),
        this.request = new globalThis.Request(this._input,this._options),
        this._options.searchParams) {
            const $ = "?" + (typeof this._options.searchParams == "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString())
              , et = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, $);
            (supportsFormData && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"]) && this.request.headers.delete("content-type"),
            this.request = new globalThis.Request(new globalThis.Request(et,{
                ...this.request
            }),this._options)
        }
        this._options.json !== void 0 && (this._options.body = JSON.stringify(this._options.json),
        this.request.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json"),
        this.request = new globalThis.Request(this.request,{
            body: this._options.body
        }))
    }
    _calculateRetryDelay(g) {
        if (this._retryCount++,
        this._retryCount < this._options.retry.limit && !(g instanceof TimeoutError)) {
            if (g instanceof HTTPError) {
                if (!this._options.retry.statusCodes.includes(g.response.status))
                    return 0;
                const _ = g.response.headers.get("Retry-After");
                if (_ && this._options.retry.afterStatusCodes.includes(g.response.status)) {
                    let $ = Number(_);
                    return Number.isNaN($) ? $ = Date.parse(_) - Date.now() : $ *= 1e3,
                    typeof this._options.retry.maxRetryAfter < "u" && $ > this._options.retry.maxRetryAfter ? 0 : $
                }
                if (g.response.status === 413)
                    return 0
            }
            const b = .3;
            return Math.min(this._options.retry.backoffLimit, b * 2 ** (this._retryCount - 1) * 1e3)
        }
        return 0
    }
    _decorateResponse(g) {
        return this._options.parseJson && (g.json = async()=>this._options.parseJson(await g.text())),
        g
    }
    async _retry(g) {
        try {
            return await g()
        } catch (b) {
            const _ = Math.min(this._calculateRetryDelay(b), maxSafeTimeout);
            if (_ !== 0 && this._retryCount > 0) {
                await delay$1(_, {
                    signal: this._options.signal
                });
                for (const $ of this._options.hooks.beforeRetry)
                    if (await $({
                        request: this.request,
                        options: this._options,
                        error: b,
                        retryCount: this._retryCount
                    }) === stop)
                        return;
                return this._retry(g)
            }
            throw b
        }
    }
    async _fetch() {
        for (const g of this._options.hooks.beforeRequest) {
            const b = await g(this.request, this._options);
            if (b instanceof Request) {
                this.request = b;
                break
            }
            if (b instanceof Response)
                return b
        }
        return this._options.timeout === !1 ? this._options.fetch(this.request.clone()) : timeout(this.request.clone(), this.abortController, this._options)
    }
    _stream(g, b) {
        const _ = Number(g.headers.get("content-length")) || 0;
        let $ = 0;
        return g.status === 204 ? (b && b({
            percent: 1,
            totalBytes: _,
            transferredBytes: $
        }, new Uint8Array),
        new globalThis.Response(null,{
            status: g.status,
            statusText: g.statusText,
            headers: g.headers
        })) : new globalThis.Response(new globalThis.ReadableStream({
            async start(et) {
                const tt = g.body.getReader();
                b && b({
                    percent: 0,
                    transferredBytes: 0,
                    totalBytes: _
                }, new Uint8Array);
                async function rt() {
                    const {done: nt, value: it} = await tt.read();
                    if (nt) {
                        et.close();
                        return
                    }
                    if (b) {
                        $ += it.byteLength;
                        const ot = _ === 0 ? 0 : $ / _;
                        b({
                            percent: ot,
                            transferredBytes: $,
                            totalBytes: _
                        }, it)
                    }
                    et.enqueue(it),
                    await rt()
                }
                await rt()
            }
        }),{
            status: g.status,
            statusText: g.statusText,
            headers: g.headers
        })
    }
}
/*! MIT License © Sindre Sorhus */
const createInstance = d=>{
    const g = (b,_)=>Ky.create(b, validateAndMerge(d, _));
    for (const b of requestMethods)
        g[b] = (_,$)=>Ky.create(_, validateAndMerge(d, $, {
            method: b
        }));
    return g.create = b=>createInstance(validateAndMerge(b)),
    g.extend = b=>createInstance(validateAndMerge(d, b)),
    g.stop = stop,
    g
}
  , ky = createInstance()
  , ky$1 = ky
  , createStoreImpl = d=>{
    let g;
    const b = new Set
      , _ = (ot,at)=>{
        const st = typeof ot == "function" ? ot(g) : ot;
        if (!Object.is(st, g)) {
            const dt = g;
            g = at ?? (typeof st != "object" || st === null) ? st : Object.assign({}, g, st),
            b.forEach(ft=>ft(g, dt))
        }
    }
      , $ = ()=>g
      , nt = {
        setState: _,
        getState: $,
        getInitialState: ()=>it,
        subscribe: ot=>(b.add(ot),
        ()=>b.delete(ot)),
        destroy: ()=>{
            b.clear()
        }
    }
      , it = g = d(_, $, nt);
    return nt
}
  , createStore = d=>d ? createStoreImpl(d) : createStoreImpl;
var withSelector = {
    exports: {}
}
  , withSelector_production_min = {}
  , shim = {
    exports: {}
}
  , useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e = reactExports;
function h$1(d, g) {
    return d === g && (d !== 0 || 1 / d === 1 / g) || d !== d && g !== g
}
var k$1 = typeof Object.is == "function" ? Object.is : h$1
  , l = e.useState
  , m = e.useEffect
  , n$1 = e.useLayoutEffect
  , p$1 = e.useDebugValue;
function q$1(d, g) {
    var b = g()
      , _ = l({
        inst: {
            value: b,
            getSnapshot: g
        }
    })
      , $ = _[0].inst
      , et = _[1];
    return n$1(function() {
        $.value = b,
        $.getSnapshot = g,
        r$1($) && et({
            inst: $
        })
    }, [d, b, g]),
    m(function() {
        return r$1($) && et({
            inst: $
        }),
        d(function() {
            r$1($) && et({
                inst: $
            })
        })
    }, [d]),
    p$1(b),
    b
}
function r$1(d) {
    var g = d.getSnapshot;
    d = d.value;
    try {
        var b = g();
        return !k$1(d, b)
    } catch {
        return !0
    }
}
function t$1(d, g) {
    return g()
}
var u$1 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? t$1 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u$1;
shim.exports = useSyncExternalStoreShim_production_min;
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = reactExports
  , n = shimExports;
function p(d, g) {
    return d === g && (d !== 0 || 1 / d === 1 / g) || d !== d && g !== g
}
var q = typeof Object.is == "function" ? Object.is : p
  , r = n.useSyncExternalStore
  , t = h.useRef
  , u = h.useEffect
  , v = h.useMemo
  , w = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(d, g, b, _, $) {
    var et = t(null);
    if (et.current === null) {
        var tt = {
            hasValue: !1,
            value: null
        };
        et.current = tt
    } else
        tt = et.current;
    et = v(function() {
        function nt(dt) {
            if (!it) {
                if (it = !0,
                ot = dt,
                dt = _(dt),
                $ !== void 0 && tt.hasValue) {
                    var ft = tt.value;
                    if ($(ft, dt))
                        return at = ft
                }
                return at = dt
            }
            if (ft = at,
            q(ot, dt))
                return ft;
            var ht = _(dt);
            return $ !== void 0 && $(ft, ht) ? ft : (ot = dt,
            at = ht)
        }
        var it = !1, ot, at, st = b === void 0 ? null : b;
        return [function() {
            return nt(g())
        }
        , st === null ? void 0 : function() {
            return nt(st())
        }
        ]
    }, [g, b, _, $]);
    var rt = r(d, et[0], et[1]);
    return u(function() {
        tt.hasValue = !0,
        tt.value = rt
    }, [rt]),
    w(rt),
    rt
}
;
withSelector.exports = withSelector_production_min;
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = getDefaultExportFromCjs(withSelectorExports)
  , {useDebugValue} = React
  , {useSyncExternalStoreWithSelector} = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = !1;
const identity = d=>d;
function useStore(d, g=identity, b) {
    const _ = useSyncExternalStoreWithSelector(d.subscribe, d.getState, d.getServerState || d.getInitialState, g, b);
    return useDebugValue(_),
    _
}
const createImpl = d=>{
    const g = typeof d == "function" ? createStore(d) : d
      , b = (_,$)=>useStore(g, _, $);
    return Object.assign(b, g),
    b
}
  , create$3 = d=>d ? createImpl(d) : createImpl
  , MotionConfigContext = reactExports.createContext({
    transformPagePoint: d=>d,
    isStatic: !1,
    reducedMotion: "never"
})
  , MotionContext = reactExports.createContext({})
  , PresenceContext = reactExports.createContext(null)
  , isBrowser = typeof document < "u"
  , useIsomorphicLayoutEffect$1 = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect
  , LazyContext = reactExports.createContext({
    strict: !1
})
  , camelToDash = d=>d.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
  , optimizedAppearDataId = "framerAppearId"
  , optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function useVisualElement(d, g, b, _) {
    const {visualElement: $} = reactExports.useContext(MotionContext)
      , et = reactExports.useContext(LazyContext)
      , tt = reactExports.useContext(PresenceContext)
      , rt = reactExports.useContext(MotionConfigContext).reducedMotion
      , nt = reactExports.useRef();
    _ = _ || et.renderer,
    !nt.current && _ && (nt.current = _(d, {
        visualState: g,
        parent: $,
        props: b,
        presenceContext: tt,
        blockInitialAnimation: tt ? tt.initial === !1 : !1,
        reducedMotionConfig: rt
    }));
    const it = nt.current;
    reactExports.useInsertionEffect(()=>{
        it && it.update(b, tt)
    }
    );
    const ot = reactExports.useRef(!!(b[optimizedAppearDataAttribute] && !window.HandoffComplete));
    return useIsomorphicLayoutEffect$1(()=>{
        it && (it.render(),
        ot.current && it.animationState && it.animationState.animateChanges())
    }
    ),
    reactExports.useEffect(()=>{
        it && (it.updateFeatures(),
        !ot.current && it.animationState && it.animationState.animateChanges(),
        ot.current && (ot.current = !1,
        window.HandoffComplete = !0))
    }
    ),
    it
}
function isRefObject(d) {
    return d && typeof d == "object" && Object.prototype.hasOwnProperty.call(d, "current")
}
function useMotionRef(d, g, b) {
    return reactExports.useCallback(_=>{
        _ && d.mount && d.mount(_),
        g && (_ ? g.mount(_) : g.unmount()),
        b && (typeof b == "function" ? b(_) : isRefObject(b) && (b.current = _))
    }
    , [g])
}
function isVariantLabel(d) {
    return typeof d == "string" || Array.isArray(d)
}
function isAnimationControls(d) {
    return d !== null && typeof d == "object" && typeof d.start == "function"
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(d) {
    return isAnimationControls(d.animate) || variantProps.some(g=>isVariantLabel(d[g]))
}
function isVariantNode(d) {
    return !!(isControllingVariants(d) || d.variants)
}
function getCurrentTreeVariants(d, g) {
    if (isControllingVariants(d)) {
        const {initial: b, animate: _} = d;
        return {
            initial: b === !1 || isVariantLabel(b) ? b : void 0,
            animate: isVariantLabel(_) ? _ : void 0
        }
    }
    return d.inherit !== !1 ? g : {}
}
function useCreateMotionContext(d) {
    const {initial: g, animate: b} = getCurrentTreeVariants(d, reactExports.useContext(MotionContext));
    return reactExports.useMemo(()=>({
        initial: g,
        animate: b
    }), [variantLabelsAsDependency(g), variantLabelsAsDependency(b)])
}
function variantLabelsAsDependency(d) {
    return Array.isArray(d) ? d.join(" ") : d
}
const featureProps = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , featureDefinitions = {};
for (const d in featureProps)
    featureDefinitions[d] = {
        isEnabled: g=>featureProps[d].some(b=>!!g[b])
    };
function loadFeatures(d) {
    for (const g in d)
        featureDefinitions[g] = {
            ...featureDefinitions[g],
            ...d[g]
        }
}
const LayoutGroupContext = reactExports.createContext({})
  , SwitchLayoutGroupContext = reactExports.createContext({})
  , motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({preloadedFeatures: d, createVisualElement: g, useRender: b, useVisualState: _, Component: $}) {
    d && loadFeatures(d);
    function et(rt, nt) {
        let it;
        const ot = {
            ...reactExports.useContext(MotionConfigContext),
            ...rt,
            layoutId: useLayoutId(rt)
        }
          , {isStatic: at} = ot
          , st = useCreateMotionContext(rt)
          , dt = _(rt, at);
        if (!at && isBrowser) {
            st.visualElement = useVisualElement($, dt, ot, g);
            const ft = reactExports.useContext(SwitchLayoutGroupContext)
              , ht = reactExports.useContext(LazyContext).strict;
            st.visualElement && (it = st.visualElement.loadFeatures(ot, ht, d, ft))
        }
        return reactExports.createElement(MotionContext.Provider, {
            value: st
        }, it && st.visualElement ? reactExports.createElement(it, {
            visualElement: st.visualElement,
            ...ot
        }) : null, b($, rt, useMotionRef(dt, st.visualElement, nt), dt, at, st.visualElement))
    }
    const tt = reactExports.forwardRef(et);
    return tt[motionComponentSymbol] = $,
    tt
}
function useLayoutId({layoutId: d}) {
    const g = reactExports.useContext(LayoutGroupContext).id;
    return g && d !== void 0 ? g + "-" + d : d
}
function createMotionProxy(d) {
    function g(_, $={}) {
        return createMotionComponent(d(_, $))
    }
    if (typeof Proxy > "u")
        return g;
    const b = new Map;
    return new Proxy(g,{
        get: (_,$)=>(b.has($) || b.set($, g($)),
        b.get($))
    })
}
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function isSVGComponent(d) {
    return typeof d != "string" || d.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(d) > -1 || /[A-Z]/.test(d))
}
const scaleCorrectors = {};
function addScaleCorrector(d) {
    Object.assign(scaleCorrectors, d)
}
const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , transformProps = new Set(transformPropOrder);
function isForcedMotionValue(d, {layout: g, layoutId: b}) {
    return transformProps.has(d) || d.startsWith("origin") || (g || b !== void 0) && (!!scaleCorrectors[d] || d === "opacity")
}
const isMotionValue = d=>!!(d && d.getVelocity)
  , translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , numTransforms = transformPropOrder.length;
function buildTransform(d, {enableHardwareAcceleration: g=!0, allowTransformNone: b=!0}, _, $) {
    let et = "";
    for (let tt = 0; tt < numTransforms; tt++) {
        const rt = transformPropOrder[tt];
        if (d[rt] !== void 0) {
            const nt = translateAlias[rt] || rt;
            et += `${nt}(${d[rt]}) `
        }
    }
    return g && !d.z && (et += "translateZ(0)"),
    et = et.trim(),
    $ ? et = $(d, _ ? "" : et) : b && _ && (et = "none"),
    et
}
const checkStringStartsWith = d=>g=>typeof g == "string" && g.startsWith(d)
  , isCSSVariableName = checkStringStartsWith("--")
  , isCSSVariableToken = checkStringStartsWith("var(--")
  , cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g
  , getValueAsType = (d,g)=>g && typeof d == "number" ? g.transform(d) : d
  , clamp = (d,g,b)=>Math.min(Math.max(b, d), g)
  , number = {
    test: d=>typeof d == "number",
    parse: parseFloat,
    transform: d=>d
}
  , alpha = {
    ...number,
    transform: d=>clamp(0, 1, d)
}
  , scale = {
    ...number,
    default: 1
}
  , sanitize = d=>Math.round(d * 1e5) / 1e5
  , floatRegex = /(-)?([\d]*\.?[\d])+/g
  , colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi
  , singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(d) {
    return typeof d == "string"
}
const createUnitType = d=>({
    test: g=>isString(g) && g.endsWith(d) && g.split(" ").length === 1,
    parse: parseFloat,
    transform: g=>`${g}${d}`
})
  , degrees = createUnitType("deg")
  , percent = createUnitType("%")
  , px$1 = createUnitType("px")
  , vh = createUnitType("vh")
  , vw = createUnitType("vw")
  , progressPercentage = {
    ...percent,
    parse: d=>percent.parse(d) / 100,
    transform: d=>percent.transform(d * 100)
}
  , int = {
    ...number,
    transform: Math.round
}
  , numberValueTypes = {
    borderWidth: px$1,
    borderTopWidth: px$1,
    borderRightWidth: px$1,
    borderBottomWidth: px$1,
    borderLeftWidth: px$1,
    borderRadius: px$1,
    radius: px$1,
    borderTopLeftRadius: px$1,
    borderTopRightRadius: px$1,
    borderBottomRightRadius: px$1,
    borderBottomLeftRadius: px$1,
    width: px$1,
    maxWidth: px$1,
    height: px$1,
    maxHeight: px$1,
    size: px$1,
    top: px$1,
    right: px$1,
    bottom: px$1,
    left: px$1,
    padding: px$1,
    paddingTop: px$1,
    paddingRight: px$1,
    paddingBottom: px$1,
    paddingLeft: px$1,
    margin: px$1,
    marginTop: px$1,
    marginRight: px$1,
    marginBottom: px$1,
    marginLeft: px$1,
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px$1,
    translateX: px$1,
    translateY: px$1,
    translateZ: px$1,
    x: px$1,
    y: px$1,
    z: px$1,
    perspective: px$1,
    transformPerspective: px$1,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px$1,
    zIndex: int,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
};
function buildHTMLStyles(d, g, b, _) {
    const {style: $, vars: et, transform: tt, transformOrigin: rt} = d;
    let nt = !1
      , it = !1
      , ot = !0;
    for (const at in g) {
        const st = g[at];
        if (isCSSVariableName(at)) {
            et[at] = st;
            continue
        }
        const dt = numberValueTypes[at]
          , ft = getValueAsType(st, dt);
        if (transformProps.has(at)) {
            if (nt = !0,
            tt[at] = ft,
            !ot)
                continue;
            st !== (dt.default || 0) && (ot = !1)
        } else
            at.startsWith("origin") ? (it = !0,
            rt[at] = ft) : $[at] = ft
    }
    if (g.transform || (nt || _ ? $.transform = buildTransform(d.transform, b, ot, _) : $.transform && ($.transform = "none")),
    it) {
        const {originX: at="50%", originY: st="50%", originZ: dt=0} = rt;
        $.transformOrigin = `${at} ${st} ${dt}`
    }
}
const createHtmlRenderState = ()=>({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function copyRawValuesOnly(d, g, b) {
    for (const _ in g)
        !isMotionValue(g[_]) && !isForcedMotionValue(_, b) && (d[_] = g[_])
}
function useInitialMotionValues({transformTemplate: d}, g, b) {
    return reactExports.useMemo(()=>{
        const _ = createHtmlRenderState();
        return buildHTMLStyles(_, g, {
            enableHardwareAcceleration: !b
        }, d),
        Object.assign({}, _.vars, _.style)
    }
    , [g])
}
function useStyle(d, g, b) {
    const _ = d.style || {}
      , $ = {};
    return copyRawValuesOnly($, _, d),
    Object.assign($, useInitialMotionValues(d, g, b)),
    d.transformValues ? d.transformValues($) : $
}
function useHTMLProps(d, g, b) {
    const _ = {}
      , $ = useStyle(d, g, b);
    return d.drag && d.dragListener !== !1 && (_.draggable = !1,
    $.userSelect = $.WebkitUserSelect = $.WebkitTouchCallout = "none",
    $.touchAction = d.drag === !0 ? "none" : `pan-${d.drag === "x" ? "y" : "x"}`),
    d.tabIndex === void 0 && (d.onTap || d.onTapStart || d.whileTap) && (_.tabIndex = 0),
    _.style = $,
    _
}
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "transformValues", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function isValidMotionProp(d) {
    return d.startsWith("while") || d.startsWith("drag") && d !== "draggable" || d.startsWith("layout") || d.startsWith("onTap") || d.startsWith("onPan") || d.startsWith("onLayout") || validMotionProps.has(d)
}
let shouldForward = d=>!isValidMotionProp(d);
function loadExternalIsValidProp(d) {
    d && (shouldForward = g=>g.startsWith("on") ? !isValidMotionProp(g) : d(g))
}
try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch {}
function filterProps(d, g, b) {
    const _ = {};
    for (const $ in d)
        $ === "values" && typeof d.values == "object" || (shouldForward($) || b === !0 && isValidMotionProp($) || !g && !isValidMotionProp($) || d.draggable && $.startsWith("onDrag")) && (_[$] = d[$]);
    return _
}
function calcOrigin$1(d, g, b) {
    return typeof d == "string" ? d : px$1.transform(g + b * d)
}
function calcSVGTransformOrigin(d, g, b) {
    const _ = calcOrigin$1(g, d.x, d.width)
      , $ = calcOrigin$1(b, d.y, d.height);
    return `${_} ${$}`
}
const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function buildSVGPath(d, g, b=1, _=0, $=!0) {
    d.pathLength = 1;
    const et = $ ? dashKeys : camelKeys;
    d[et.offset] = px$1.transform(-_);
    const tt = px$1.transform(g)
      , rt = px$1.transform(b);
    d[et.array] = `${tt} ${rt}`
}
function buildSVGAttrs(d, {attrX: g, attrY: b, attrScale: _, originX: $, originY: et, pathLength: tt, pathSpacing: rt=1, pathOffset: nt=0, ...it}, ot, at, st) {
    if (buildHTMLStyles(d, it, ot, st),
    at) {
        d.style.viewBox && (d.attrs.viewBox = d.style.viewBox);
        return
    }
    d.attrs = d.style,
    d.style = {};
    const {attrs: dt, style: ft, dimensions: ht} = d;
    dt.transform && (ht && (ft.transform = dt.transform),
    delete dt.transform),
    ht && ($ !== void 0 || et !== void 0 || ft.transform) && (ft.transformOrigin = calcSVGTransformOrigin(ht, $ !== void 0 ? $ : .5, et !== void 0 ? et : .5)),
    g !== void 0 && (dt.x = g),
    b !== void 0 && (dt.y = b),
    _ !== void 0 && (dt.scale = _),
    tt !== void 0 && buildSVGPath(dt, tt, rt, nt, !1)
}
const createSvgRenderState = ()=>({
    ...createHtmlRenderState(),
    attrs: {}
})
  , isSVGTag = d=>typeof d == "string" && d.toLowerCase() === "svg";
function useSVGProps(d, g, b, _) {
    const $ = reactExports.useMemo(()=>{
        const et = createSvgRenderState();
        return buildSVGAttrs(et, g, {
            enableHardwareAcceleration: !1
        }, isSVGTag(_), d.transformTemplate),
        {
            ...et.attrs,
            style: {
                ...et.style
            }
        }
    }
    , [g]);
    if (d.style) {
        const et = {};
        copyRawValuesOnly(et, d.style, d),
        $.style = {
            ...et,
            ...$.style
        }
    }
    return $
}
function createUseRender(d=!1) {
    return (b,_,$,{latestValues: et},tt)=>{
        const nt = (isSVGComponent(b) ? useSVGProps : useHTMLProps)(_, et, tt, b)
          , ot = {
            ...filterProps(_, typeof b == "string", d),
            ...nt,
            ref: $
        }
          , {children: at} = _
          , st = reactExports.useMemo(()=>isMotionValue(at) ? at.get() : at, [at]);
        return reactExports.createElement(b, {
            ...ot,
            children: st
        })
    }
}
function renderHTML(d, {style: g, vars: b}, _, $) {
    Object.assign(d.style, g, $ && $.getProjectionStyles(_));
    for (const et in b)
        d.style.setProperty(et, b[et])
}
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function renderSVG(d, g, b, _) {
    renderHTML(d, g, void 0, _);
    for (const $ in g.attrs)
        d.setAttribute(camelCaseAttributes.has($) ? $ : camelToDash($), g.attrs[$])
}
function scrapeMotionValuesFromProps$1(d, g) {
    const {style: b} = d
      , _ = {};
    for (const $ in b)
        (isMotionValue(b[$]) || g.style && isMotionValue(g.style[$]) || isForcedMotionValue($, d)) && (_[$] = b[$]);
    return _
}
function scrapeMotionValuesFromProps(d, g) {
    const b = scrapeMotionValuesFromProps$1(d, g);
    for (const _ in d)
        if (isMotionValue(d[_]) || isMotionValue(g[_])) {
            const $ = transformPropOrder.indexOf(_) !== -1 ? "attr" + _.charAt(0).toUpperCase() + _.substring(1) : _;
            b[$] = d[_]
        }
    return b
}
function resolveVariantFromProps(d, g, b, _={}, $={}) {
    return typeof g == "function" && (g = g(b !== void 0 ? b : d.custom, _, $)),
    typeof g == "string" && (g = d.variants && d.variants[g]),
    typeof g == "function" && (g = g(b !== void 0 ? b : d.custom, _, $)),
    g
}
function useConstant(d) {
    const g = reactExports.useRef(null);
    return g.current === null && (g.current = d()),
    g.current
}
const isKeyframesTarget = d=>Array.isArray(d)
  , isCustomValue = d=>!!(d && typeof d == "object" && d.mix && d.toValue)
  , resolveFinalValueInKeyframes = d=>isKeyframesTarget(d) ? d[d.length - 1] || 0 : d;
function resolveMotionValue(d) {
    const g = isMotionValue(d) ? d.get() : d;
    return isCustomValue(g) ? g.toValue() : g
}
function makeState({scrapeMotionValuesFromProps: d, createRenderState: g, onMount: b}, _, $, et) {
    const tt = {
        latestValues: makeLatestValues(_, $, et, d),
        renderState: g()
    };
    return b && (tt.mount = rt=>b(_, rt, tt)),
    tt
}
const makeUseVisualState = d=>(g,b)=>{
    const _ = reactExports.useContext(MotionContext)
      , $ = reactExports.useContext(PresenceContext)
      , et = ()=>makeState(d, g, _, $);
    return b ? et() : useConstant(et)
}
;
function makeLatestValues(d, g, b, _) {
    const $ = {}
      , et = _(d, {});
    for (const st in et)
        $[st] = resolveMotionValue(et[st]);
    let {initial: tt, animate: rt} = d;
    const nt = isControllingVariants(d)
      , it = isVariantNode(d);
    g && it && !nt && d.inherit !== !1 && (tt === void 0 && (tt = g.initial),
    rt === void 0 && (rt = g.animate));
    let ot = b ? b.initial === !1 : !1;
    ot = ot || tt === !1;
    const at = ot ? rt : tt;
    return at && typeof at != "boolean" && !isAnimationControls(at) && (Array.isArray(at) ? at : [at]).forEach(dt=>{
        const ft = resolveVariantFromProps(d, dt);
        if (!ft)
            return;
        const {transitionEnd: ht, transition: xt, ...lt} = ft;
        for (const ct in lt) {
            let ut = lt[ct];
            if (Array.isArray(ut)) {
                const pt = ot ? ut.length - 1 : 0;
                ut = ut[pt]
            }
            ut !== null && ($[ct] = ut)
        }
        for (const ct in ht)
            $[ct] = ht[ct]
    }
    ),
    $
}
const noop = d=>d;
class Queue {
    constructor() {
        this.order = [],
        this.scheduled = new Set
    }
    add(g) {
        if (!this.scheduled.has(g))
            return this.scheduled.add(g),
            this.order.push(g),
            !0
    }
    remove(g) {
        const b = this.order.indexOf(g);
        b !== -1 && (this.order.splice(b, 1),
        this.scheduled.delete(g))
    }
    clear() {
        this.order.length = 0,
        this.scheduled.clear()
    }
}
function createRenderStep(d) {
    let g = new Queue
      , b = new Queue
      , _ = 0
      , $ = !1
      , et = !1;
    const tt = new WeakSet
      , rt = {
        schedule: (nt,it=!1,ot=!1)=>{
            const at = ot && $
              , st = at ? g : b;
            return it && tt.add(nt),
            st.add(nt) && at && $ && (_ = g.order.length),
            nt
        }
        ,
        cancel: nt=>{
            b.remove(nt),
            tt.delete(nt)
        }
        ,
        process: nt=>{
            if ($) {
                et = !0;
                return
            }
            if ($ = !0,
            [g,b] = [b, g],
            b.clear(),
            _ = g.order.length,
            _)
                for (let it = 0; it < _; it++) {
                    const ot = g.order[it];
                    ot(nt),
                    tt.has(ot) && (rt.schedule(ot),
                    d())
                }
            $ = !1,
            et && (et = !1,
            rt.process(nt))
        }
    };
    return rt
}
const stepsOrder = ["prepare", "read", "update", "preRender", "render", "postRender"]
  , maxElapsed = 40;
function createRenderBatcher(d, g) {
    let b = !1
      , _ = !0;
    const $ = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , et = stepsOrder.reduce((at,st)=>(at[st] = createRenderStep(()=>b = !0),
    at), {})
      , tt = at=>et[at].process($)
      , rt = ()=>{
        const at = performance.now();
        b = !1,
        $.delta = _ ? 1e3 / 60 : Math.max(Math.min(at - $.timestamp, maxElapsed), 1),
        $.timestamp = at,
        $.isProcessing = !0,
        stepsOrder.forEach(tt),
        $.isProcessing = !1,
        b && g && (_ = !1,
        d(rt))
    }
      , nt = ()=>{
        b = !0,
        _ = !0,
        $.isProcessing || d(rt)
    }
    ;
    return {
        schedule: stepsOrder.reduce((at,st)=>{
            const dt = et[st];
            return at[st] = (ft,ht=!1,xt=!1)=>(b || nt(),
            dt.schedule(ft, ht, xt)),
            at
        }
        , {}),
        cancel: at=>stepsOrder.forEach(st=>et[st].cancel(at)),
        state: $,
        steps: et
    }
}
const {schedule: frame, cancel: cancelFrame, state: frameData, steps} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0)
  , svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (d,g,{renderState: b, latestValues: _})=>{
            frame.read(()=>{
                try {
                    b.dimensions = typeof g.getBBox == "function" ? g.getBBox() : g.getBoundingClientRect()
                } catch {
                    b.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            frame.render(()=>{
                buildSVGAttrs(b, _, {
                    enableHardwareAcceleration: !1
                }, isSVGTag(g.tagName), d.transformTemplate),
                renderSVG(g, b)
            }
            )
        }
    })
}
  , htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
    })
};
function createDomMotionConfig(d, {forwardMotionProps: g=!1}, b, _) {
    return {
        ...isSVGComponent(d) ? svgMotionConfig : htmlMotionConfig,
        preloadedFeatures: b,
        useRender: createUseRender(g),
        createVisualElement: _,
        Component: d
    }
}
function addDomEvent(d, g, b, _={
    passive: !0
}) {
    return d.addEventListener(g, b, _),
    ()=>d.removeEventListener(g, b)
}
const isPrimaryPointer = d=>d.pointerType === "mouse" ? typeof d.button != "number" || d.button <= 0 : d.isPrimary !== !1;
function extractEventInfo(d, g="page") {
    return {
        point: {
            x: d[g + "X"],
            y: d[g + "Y"]
        }
    }
}
const addPointerInfo = d=>g=>isPrimaryPointer(g) && d(g, extractEventInfo(g));
function addPointerEvent(d, g, b, _) {
    return addDomEvent(d, g, addPointerInfo(b), _)
}
const combineFunctions = (d,g)=>b=>g(d(b))
  , pipe = (...d)=>d.reduce(combineFunctions);
function createLock(d) {
    let g = null;
    return ()=>{
        const b = ()=>{
            g = null
        }
        ;
        return g === null ? (g = d,
        b) : !1
    }
}
const globalHorizontalLock = createLock("dragHorizontal")
  , globalVerticalLock = createLock("dragVertical");
function getGlobalLock(d) {
    let g = !1;
    if (d === "y")
        g = globalVerticalLock();
    else if (d === "x")
        g = globalHorizontalLock();
    else {
        const b = globalHorizontalLock()
          , _ = globalVerticalLock();
        b && _ ? g = ()=>{
            b(),
            _()
        }
        : (b && b(),
        _ && _())
    }
    return g
}
function isDragActive() {
    const d = getGlobalLock(!0);
    return d ? (d(),
    !1) : !0
}
class Feature {
    constructor(g) {
        this.isMounted = !1,
        this.node = g
    }
    update() {}
}
function addHoverEvent(d, g) {
    const b = "pointer" + (g ? "enter" : "leave")
      , _ = "onHover" + (g ? "Start" : "End")
      , $ = (et,tt)=>{
        if (et.pointerType === "touch" || isDragActive())
            return;
        const rt = d.getProps();
        d.animationState && rt.whileHover && d.animationState.setActive("whileHover", g),
        rt[_] && frame.update(()=>rt[_](et, tt))
    }
    ;
    return addPointerEvent(d.current, b, $, {
        passive: !d.getProps()[_]
    })
}
class HoverGesture extends Feature {
    mount() {
        this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
    }
    unmount() {}
}
class FocusGesture extends Feature {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let g = !1;
        try {
            g = this.node.current.matches(":focus-visible")
        } catch {
            g = !0
        }
        !g || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", ()=>this.onFocus()), addDomEvent(this.node.current, "blur", ()=>this.onBlur()))
    }
    unmount() {}
}
const isNodeOrChild = (d,g)=>g ? d === g ? !0 : isNodeOrChild(d, g.parentElement) : !1;
function fireSyntheticPointerEvent(d, g) {
    if (!g)
        return;
    const b = new PointerEvent("pointer" + d);
    g(b, extractEventInfo(b))
}
class PressGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removeStartListeners = noop,
        this.removeEndListeners = noop,
        this.removeAccessibleListeners = noop,
        this.startPointerPress = (g,b)=>{
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const _ = this.node.getProps()
              , et = addPointerEvent(window, "pointerup", (rt,nt)=>{
                if (!this.checkPressEnd())
                    return;
                const {onTap: it, onTapCancel: ot, globalTapTarget: at} = this.node.getProps();
                frame.update(()=>{
                    !at && !isNodeOrChild(this.node.current, rt.target) ? ot && ot(rt, nt) : it && it(rt, nt)
                }
                )
            }
            , {
                passive: !(_.onTap || _.onPointerUp)
            })
              , tt = addPointerEvent(window, "pointercancel", (rt,nt)=>this.cancelPress(rt, nt), {
                passive: !(_.onTapCancel || _.onPointerCancel)
            });
            this.removeEndListeners = pipe(et, tt),
            this.startPress(g, b)
        }
        ,
        this.startAccessiblePress = ()=>{
            const g = et=>{
                if (et.key !== "Enter" || this.isPressing)
                    return;
                const tt = rt=>{
                    rt.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (nt,it)=>{
                        const {onTap: ot} = this.node.getProps();
                        ot && frame.update(()=>ot(nt, it))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = addDomEvent(this.node.current, "keyup", tt),
                fireSyntheticPointerEvent("down", (rt,nt)=>{
                    this.startPress(rt, nt)
                }
                )
            }
              , b = addDomEvent(this.node.current, "keydown", g)
              , _ = ()=>{
                this.isPressing && fireSyntheticPointerEvent("cancel", (et,tt)=>this.cancelPress(et, tt))
            }
              , $ = addDomEvent(this.node.current, "blur", _);
            this.removeAccessibleListeners = pipe(b, $)
        }
    }
    startPress(g, b) {
        this.isPressing = !0;
        const {onTapStart: _, whileTap: $} = this.node.getProps();
        $ && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        _ && frame.update(()=>_(g, b))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !isDragActive()
    }
    cancelPress(g, b) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: _} = this.node.getProps();
        _ && frame.update(()=>_(g, b))
    }
    mount() {
        const g = this.node.getProps()
          , b = addPointerEvent(g.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(g.onTapStart || g.onPointerStart)
        })
          , _ = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(b, _)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const observerCallbacks = new WeakMap
  , observers = new WeakMap
  , fireObserverCallback = d=>{
    const g = observerCallbacks.get(d.target);
    g && g(d)
}
  , fireAllObserverCallbacks = d=>{
    d.forEach(fireObserverCallback)
}
;
function initIntersectionObserver({root: d, ...g}) {
    const b = d || document;
    observers.has(b) || observers.set(b, {});
    const _ = observers.get(b)
      , $ = JSON.stringify(g);
    return _[$] || (_[$] = new IntersectionObserver(fireAllObserverCallbacks,{
        root: d,
        ...g
    })),
    _[$]
}
function observeIntersection(d, g, b) {
    const _ = initIntersectionObserver(g);
    return observerCallbacks.set(d, b),
    _.observe(d),
    ()=>{
        observerCallbacks.delete(d),
        _.unobserve(d)
    }
}
const thresholdNames = {
    some: 0,
    all: 1
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: g={}} = this.node.getProps()
          , {root: b, margin: _, amount: $="some", once: et} = g
          , tt = {
            root: b ? b.current : void 0,
            rootMargin: _,
            threshold: typeof $ == "number" ? $ : thresholdNames[$]
        }
          , rt = nt=>{
            const {isIntersecting: it} = nt;
            if (this.isInView === it || (this.isInView = it,
            et && !it && this.hasEnteredView))
                return;
            it && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", it);
            const {onViewportEnter: ot, onViewportLeave: at} = this.node.getProps()
              , st = it ? ot : at;
            st && st(nt)
        }
        ;
        return observeIntersection(this.node.current, tt, rt)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: g, prevProps: b} = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(g, b)) && this.startObserver()
    }
    unmount() {}
}
function hasViewportOptionChanged({viewport: d={}}, {viewport: g={}}={}) {
    return b=>d[b] !== g[b]
}
const gestureAnimations = {
    inView: {
        Feature: InViewFeature
    },
    tap: {
        Feature: PressGesture
    },
    focus: {
        Feature: FocusGesture
    },
    hover: {
        Feature: HoverGesture
    }
};
function shallowCompare(d, g) {
    if (!Array.isArray(g))
        return !1;
    const b = g.length;
    if (b !== d.length)
        return !1;
    for (let _ = 0; _ < b; _++)
        if (g[_] !== d[_])
            return !1;
    return !0
}
function getCurrent(d) {
    const g = {};
    return d.values.forEach((b,_)=>g[_] = b.get()),
    g
}
function getVelocity$1(d) {
    const g = {};
    return d.values.forEach((b,_)=>g[_] = b.getVelocity()),
    g
}
function resolveVariant(d, g, b) {
    const _ = d.getProps();
    return resolveVariantFromProps(_, g, b !== void 0 ? b : _.custom, getCurrent(d), getVelocity$1(d))
}
let warning = noop
  , invariant = noop;
const secondsToMilliseconds = d=>d * 1e3
  , millisecondsToSeconds = d=>d / 1e3
  , instantAnimationState = {
    current: !1
}
  , isBezierDefinition = d=>Array.isArray(d) && typeof d[0] == "number";
function isWaapiSupportedEasing(d) {
    return !!(!d || typeof d == "string" && supportedWaapiEasing[d] || isBezierDefinition(d) || Array.isArray(d) && d.every(isWaapiSupportedEasing))
}
const cubicBezierAsString = ([d,g,b,_])=>`cubic-bezier(${d}, ${g}, ${b}, ${_})`
  , supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, .65, .55, 1]),
    circOut: cubicBezierAsString([.55, 0, 1, .45]),
    backIn: cubicBezierAsString([.31, .01, .66, -.59]),
    backOut: cubicBezierAsString([.33, 1.53, .69, .99])
};
function mapEasingToNativeEasing(d) {
    if (d)
        return isBezierDefinition(d) ? cubicBezierAsString(d) : Array.isArray(d) ? d.map(mapEasingToNativeEasing) : supportedWaapiEasing[d]
}
function animateStyle(d, g, b, {delay: _=0, duration: $, repeat: et=0, repeatType: tt="loop", ease: rt, times: nt}={}) {
    const it = {
        [g]: b
    };
    nt && (it.offset = nt);
    const ot = mapEasingToNativeEasing(rt);
    return Array.isArray(ot) && (it.easing = ot),
    d.animate(it, {
        delay: _,
        duration: $,
        easing: Array.isArray(ot) ? "linear" : ot,
        fill: "both",
        iterations: et + 1,
        direction: tt === "reverse" ? "alternate" : "normal"
    })
}
function getFinalKeyframe(d, {repeat: g, repeatType: b="loop"}) {
    const _ = g && b !== "loop" && g % 2 === 1 ? 0 : d.length - 1;
    return d[_]
}
const calcBezier = (d,g,b)=>(((1 - 3 * b + 3 * g) * d + (3 * b - 6 * g)) * d + 3 * g) * d
  , subdivisionPrecision = 1e-7
  , subdivisionMaxIterations = 12;
function binarySubdivide(d, g, b, _, $) {
    let et, tt, rt = 0;
    do
        tt = g + (b - g) / 2,
        et = calcBezier(tt, _, $) - d,
        et > 0 ? b = tt : g = tt;
    while (Math.abs(et) > subdivisionPrecision && ++rt < subdivisionMaxIterations);
    return tt
}
function cubicBezier(d, g, b, _) {
    if (d === g && b === _)
        return noop;
    const $ = et=>binarySubdivide(et, 0, 1, d, b);
    return et=>et === 0 || et === 1 ? et : calcBezier($(et), g, _)
}
const easeIn = cubicBezier(.42, 0, 1, 1)
  , easeOut = cubicBezier(0, 0, .58, 1)
  , easeInOut = cubicBezier(.42, 0, .58, 1)
  , isEasingArray = d=>Array.isArray(d) && typeof d[0] != "number"
  , mirrorEasing = d=>g=>g <= .5 ? d(2 * g) / 2 : (2 - d(2 * (1 - g))) / 2
  , reverseEasing = d=>g=>1 - d(1 - g)
  , circIn = d=>1 - Math.sin(Math.acos(d))
  , circOut = reverseEasing(circIn)
  , circInOut = mirrorEasing(circIn)
  , backOut = cubicBezier(.33, 1.53, .69, .99)
  , backIn = reverseEasing(backOut)
  , backInOut = mirrorEasing(backIn)
  , anticipate = d=>(d *= 2) < 1 ? .5 * backIn(d) : .5 * (2 - Math.pow(2, -10 * (d - 1)))
  , easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
}
  , easingDefinitionToFunction = d=>{
    if (Array.isArray(d)) {
        invariant(d.length === 4);
        const [g,b,_,$] = d;
        return cubicBezier(g, b, _, $)
    } else if (typeof d == "string")
        return easingLookup[d];
    return d
}
  , isColorString = (d,g)=>b=>!!(isString(b) && singleColorRegex.test(b) && b.startsWith(d) || g && Object.prototype.hasOwnProperty.call(b, g))
  , splitColor = (d,g,b)=>_=>{
    if (!isString(_))
        return _;
    const [$,et,tt,rt] = _.match(floatRegex);
    return {
        [d]: parseFloat($),
        [g]: parseFloat(et),
        [b]: parseFloat(tt),
        alpha: rt !== void 0 ? parseFloat(rt) : 1
    }
}
  , clampRgbUnit = d=>clamp(0, 255, d)
  , rgbUnit = {
    ...number,
    transform: d=>Math.round(clampRgbUnit(d))
}
  , rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({red: d, green: g, blue: b, alpha: _=1})=>"rgba(" + rgbUnit.transform(d) + ", " + rgbUnit.transform(g) + ", " + rgbUnit.transform(b) + ", " + sanitize(alpha.transform(_)) + ")"
};
function parseHex(d) {
    let g = ""
      , b = ""
      , _ = ""
      , $ = "";
    return d.length > 5 ? (g = d.substring(1, 3),
    b = d.substring(3, 5),
    _ = d.substring(5, 7),
    $ = d.substring(7, 9)) : (g = d.substring(1, 2),
    b = d.substring(2, 3),
    _ = d.substring(3, 4),
    $ = d.substring(4, 5),
    g += g,
    b += b,
    _ += _,
    $ += $),
    {
        red: parseInt(g, 16),
        green: parseInt(b, 16),
        blue: parseInt(_, 16),
        alpha: $ ? parseInt($, 16) / 255 : 1
    }
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
}
  , hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({hue: d, saturation: g, lightness: b, alpha: _=1})=>"hsla(" + Math.round(d) + ", " + percent.transform(sanitize(g)) + ", " + percent.transform(sanitize(b)) + ", " + sanitize(alpha.transform(_)) + ")"
}
  , color = {
    test: d=>rgba.test(d) || hex.test(d) || hsla.test(d),
    parse: d=>rgba.test(d) ? rgba.parse(d) : hsla.test(d) ? hsla.parse(d) : hex.parse(d),
    transform: d=>isString(d) ? d : d.hasOwnProperty("red") ? rgba.transform(d) : hsla.transform(d)
}
  , mix = (d,g,b)=>-b * d + b * g + d;
function hueToRgb(d, g, b) {
    return b < 0 && (b += 1),
    b > 1 && (b -= 1),
    b < 1 / 6 ? d + (g - d) * 6 * b : b < 1 / 2 ? g : b < 2 / 3 ? d + (g - d) * (2 / 3 - b) * 6 : d
}
function hslaToRgba({hue: d, saturation: g, lightness: b, alpha: _}) {
    d /= 360,
    g /= 100,
    b /= 100;
    let $ = 0
      , et = 0
      , tt = 0;
    if (!g)
        $ = et = tt = b;
    else {
        const rt = b < .5 ? b * (1 + g) : b + g - b * g
          , nt = 2 * b - rt;
        $ = hueToRgb(nt, rt, d + 1 / 3),
        et = hueToRgb(nt, rt, d),
        tt = hueToRgb(nt, rt, d - 1 / 3)
    }
    return {
        red: Math.round($ * 255),
        green: Math.round(et * 255),
        blue: Math.round(tt * 255),
        alpha: _
    }
}
const mixLinearColor = (d,g,b)=>{
    const _ = d * d;
    return Math.sqrt(Math.max(0, b * (g * g - _) + _))
}
  , colorTypes = [hex, rgba, hsla]
  , getColorType = d=>colorTypes.find(g=>g.test(d));
function asRGBA(d) {
    const g = getColorType(d);
    let b = g.parse(d);
    return g === hsla && (b = hslaToRgba(b)),
    b
}
const mixColor = (d,g)=>{
    const b = asRGBA(d)
      , _ = asRGBA(g)
      , $ = {
        ...b
    };
    return et=>($.red = mixLinearColor(b.red, _.red, et),
    $.green = mixLinearColor(b.green, _.green, et),
    $.blue = mixLinearColor(b.blue, _.blue, et),
    $.alpha = mix(b.alpha, _.alpha, et),
    rgba.transform($))
}
;
function test(d) {
    var g, b;
    return isNaN(d) && isString(d) && (((g = d.match(floatRegex)) === null || g === void 0 ? void 0 : g.length) || 0) + (((b = d.match(colorRegex)) === null || b === void 0 ? void 0 : b.length) || 0) > 0
}
const cssVarTokeniser = {
    regex: cssVariableRegex,
    countKey: "Vars",
    token: "${v}",
    parse: noop
}
  , colorTokeniser = {
    regex: colorRegex,
    countKey: "Colors",
    token: "${c}",
    parse: color.parse
}
  , numberTokeniser = {
    regex: floatRegex,
    countKey: "Numbers",
    token: "${n}",
    parse: number.parse
};
function tokenise(d, {regex: g, countKey: b, token: _, parse: $}) {
    const et = d.tokenised.match(g);
    et && (d["num" + b] = et.length,
    d.tokenised = d.tokenised.replace(g, _),
    d.values.push(...et.map($)))
}
function analyseComplexValue(d) {
    const g = d.toString()
      , b = {
        value: g,
        tokenised: g,
        values: [],
        numVars: 0,
        numColors: 0,
        numNumbers: 0
    };
    return b.value.includes("var(--") && tokenise(b, cssVarTokeniser),
    tokenise(b, colorTokeniser),
    tokenise(b, numberTokeniser),
    b
}
function parseComplexValue(d) {
    return analyseComplexValue(d).values
}
function createTransformer(d) {
    const {values: g, numColors: b, numVars: _, tokenised: $} = analyseComplexValue(d)
      , et = g.length;
    return tt=>{
        let rt = $;
        for (let nt = 0; nt < et; nt++)
            nt < _ ? rt = rt.replace(cssVarTokeniser.token, tt[nt]) : nt < _ + b ? rt = rt.replace(colorTokeniser.token, color.transform(tt[nt])) : rt = rt.replace(numberTokeniser.token, sanitize(tt[nt]));
        return rt
    }
}
const convertNumbersToZero = d=>typeof d == "number" ? 0 : d;
function getAnimatableNone$1(d) {
    const g = parseComplexValue(d);
    return createTransformer(d)(g.map(convertNumbersToZero))
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
}
  , mixImmediate = (d,g)=>b=>`${b > 0 ? g : d}`;
function getMixer(d, g) {
    return typeof d == "number" ? b=>mix(d, g, b) : color.test(d) ? mixColor(d, g) : d.startsWith("var(") ? mixImmediate(d, g) : mixComplex(d, g)
}
const mixArray = (d,g)=>{
    const b = [...d]
      , _ = b.length
      , $ = d.map((et,tt)=>getMixer(et, g[tt]));
    return et=>{
        for (let tt = 0; tt < _; tt++)
            b[tt] = $[tt](et);
        return b
    }
}
  , mixObject = (d,g)=>{
    const b = {
        ...d,
        ...g
    }
      , _ = {};
    for (const $ in b)
        d[$] !== void 0 && g[$] !== void 0 && (_[$] = getMixer(d[$], g[$]));
    return $=>{
        for (const et in _)
            b[et] = _[et]($);
        return b
    }
}
  , mixComplex = (d,g)=>{
    const b = complex.createTransformer(g)
      , _ = analyseComplexValue(d)
      , $ = analyseComplexValue(g);
    return _.numVars === $.numVars && _.numColors === $.numColors && _.numNumbers >= $.numNumbers ? pipe(mixArray(_.values, $.values), b) : mixImmediate(d, g)
}
  , progress = (d,g,b)=>{
    const _ = g - d;
    return _ === 0 ? 1 : (b - d) / _
}
  , mixNumber = (d,g)=>b=>mix(d, g, b);
function detectMixerFactory(d) {
    return typeof d == "number" ? mixNumber : typeof d == "string" ? color.test(d) ? mixColor : mixComplex : Array.isArray(d) ? mixArray : typeof d == "object" ? mixObject : mixNumber
}
function createMixers(d, g, b) {
    const _ = []
      , $ = b || detectMixerFactory(d[0])
      , et = d.length - 1;
    for (let tt = 0; tt < et; tt++) {
        let rt = $(d[tt], d[tt + 1]);
        if (g) {
            const nt = Array.isArray(g) ? g[tt] || noop : g;
            rt = pipe(nt, rt)
        }
        _.push(rt)
    }
    return _
}
function interpolate(d, g, {clamp: b=!0, ease: _, mixer: $}={}) {
    const et = d.length;
    if (invariant(et === g.length),
    et === 1)
        return ()=>g[0];
    d[0] > d[et - 1] && (d = [...d].reverse(),
    g = [...g].reverse());
    const tt = createMixers(g, _, $)
      , rt = tt.length
      , nt = it=>{
        let ot = 0;
        if (rt > 1)
            for (; ot < d.length - 2 && !(it < d[ot + 1]); ot++)
                ;
        const at = progress(d[ot], d[ot + 1], it);
        return tt[ot](at)
    }
    ;
    return b ? it=>nt(clamp(d[0], d[et - 1], it)) : nt
}
function fillOffset(d, g) {
    const b = d[d.length - 1];
    for (let _ = 1; _ <= g; _++) {
        const $ = progress(0, g, _);
        d.push(mix(b, 1, $))
    }
}
function defaultOffset(d) {
    const g = [0];
    return fillOffset(g, d.length - 1),
    g
}
function convertOffsetToTimes(d, g) {
    return d.map(b=>b * g)
}
function defaultEasing(d, g) {
    return d.map(()=>g || easeInOut).splice(0, d.length - 1)
}
function keyframes({duration: d=300, keyframes: g, times: b, ease: _="easeInOut"}) {
    const $ = isEasingArray(_) ? _.map(easingDefinitionToFunction) : easingDefinitionToFunction(_)
      , et = {
        done: !1,
        value: g[0]
    }
      , tt = convertOffsetToTimes(b && b.length === g.length ? b : defaultOffset(g), d)
      , rt = interpolate(tt, g, {
        ease: Array.isArray($) ? $ : defaultEasing(g, $)
    });
    return {
        calculatedDuration: d,
        next: nt=>(et.value = rt(nt),
        et.done = nt >= d,
        et)
    }
}
function velocityPerSecond(d, g) {
    return g ? d * (1e3 / g) : 0
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(d, g, b) {
    const _ = Math.max(g - velocitySampleDuration, 0);
    return velocityPerSecond(b - d(_), g - _)
}
const safeMin = .001
  , minDuration = .01
  , maxDuration$1 = 10
  , minDamping = .05
  , maxDamping = 1;
function findSpring({duration: d=800, bounce: g=.25, velocity: b=0, mass: _=1}) {
    let $, et;
    warning(d <= secondsToMilliseconds(maxDuration$1));
    let tt = 1 - g;
    tt = clamp(minDamping, maxDamping, tt),
    d = clamp(minDuration, maxDuration$1, millisecondsToSeconds(d)),
    tt < 1 ? ($ = it=>{
        const ot = it * tt
          , at = ot * d
          , st = ot - b
          , dt = calcAngularFreq(it, tt)
          , ft = Math.exp(-at);
        return safeMin - st / dt * ft
    }
    ,
    et = it=>{
        const at = it * tt * d
          , st = at * b + b
          , dt = Math.pow(tt, 2) * Math.pow(it, 2) * d
          , ft = Math.exp(-at)
          , ht = calcAngularFreq(Math.pow(it, 2), tt);
        return (-$(it) + safeMin > 0 ? -1 : 1) * ((st - dt) * ft) / ht
    }
    ) : ($ = it=>{
        const ot = Math.exp(-it * d)
          , at = (it - b) * d + 1;
        return -safeMin + ot * at
    }
    ,
    et = it=>{
        const ot = Math.exp(-it * d)
          , at = (b - it) * (d * d);
        return ot * at
    }
    );
    const rt = 5 / d
      , nt = approximateRoot($, et, rt);
    if (d = secondsToMilliseconds(d),
    isNaN(nt))
        return {
            stiffness: 100,
            damping: 10,
            duration: d
        };
    {
        const it = Math.pow(nt, 2) * _;
        return {
            stiffness: it,
            damping: tt * 2 * Math.sqrt(_ * it),
            duration: d
        }
    }
}
const rootIterations = 12;
function approximateRoot(d, g, b) {
    let _ = b;
    for (let $ = 1; $ < rootIterations; $++)
        _ = _ - d(_) / g(_);
    return _
}
function calcAngularFreq(d, g) {
    return d * Math.sqrt(1 - g * g)
}
const durationKeys = ["duration", "bounce"]
  , physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(d, g) {
    return g.some(b=>d[b] !== void 0)
}
function getSpringOptions(d) {
    let g = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...d
    };
    if (!isSpringType(d, physicsKeys) && isSpringType(d, durationKeys)) {
        const b = findSpring(d);
        g = {
            ...g,
            ...b,
            mass: 1
        },
        g.isResolvedFromDuration = !0
    }
    return g
}
function spring({keyframes: d, restDelta: g, restSpeed: b, ..._}) {
    const $ = d[0]
      , et = d[d.length - 1]
      , tt = {
        done: !1,
        value: $
    }
      , {stiffness: rt, damping: nt, mass: it, duration: ot, velocity: at, isResolvedFromDuration: st} = getSpringOptions({
        ..._,
        velocity: -millisecondsToSeconds(_.velocity || 0)
    })
      , dt = at || 0
      , ft = nt / (2 * Math.sqrt(rt * it))
      , ht = et - $
      , xt = millisecondsToSeconds(Math.sqrt(rt / it))
      , lt = Math.abs(ht) < 5;
    b || (b = lt ? .01 : 2),
    g || (g = lt ? .005 : .5);
    let ct;
    if (ft < 1) {
        const ut = calcAngularFreq(xt, ft);
        ct = pt=>{
            const vt = Math.exp(-ft * xt * pt);
            return et - vt * ((dt + ft * xt * ht) / ut * Math.sin(ut * pt) + ht * Math.cos(ut * pt))
        }
    } else if (ft === 1)
        ct = ut=>et - Math.exp(-xt * ut) * (ht + (dt + xt * ht) * ut);
    else {
        const ut = xt * Math.sqrt(ft * ft - 1);
        ct = pt=>{
            const vt = Math.exp(-ft * xt * pt)
              , _t = Math.min(ut * pt, 300);
            return et - vt * ((dt + ft * xt * ht) * Math.sinh(_t) + ut * ht * Math.cosh(_t)) / ut
        }
    }
    return {
        calculatedDuration: st && ot || null,
        next: ut=>{
            const pt = ct(ut);
            if (st)
                tt.done = ut >= ot;
            else {
                let vt = dt;
                ut !== 0 && (ft < 1 ? vt = calcGeneratorVelocity(ct, ut, pt) : vt = 0);
                const _t = Math.abs(vt) <= b
                  , Pt = Math.abs(et - pt) <= g;
                tt.done = _t && Pt
            }
            return tt.value = tt.done ? et : pt,
            tt
        }
    }
}
function inertia({keyframes: d, velocity: g=0, power: b=.8, timeConstant: _=325, bounceDamping: $=10, bounceStiffness: et=500, modifyTarget: tt, min: rt, max: nt, restDelta: it=.5, restSpeed: ot}) {
    const at = d[0]
      , st = {
        done: !1,
        value: at
    }
      , dt = kt=>rt !== void 0 && kt < rt || nt !== void 0 && kt > nt
      , ft = kt=>rt === void 0 ? nt : nt === void 0 || Math.abs(rt - kt) < Math.abs(nt - kt) ? rt : nt;
    let ht = b * g;
    const xt = at + ht
      , lt = tt === void 0 ? xt : tt(xt);
    lt !== xt && (ht = lt - at);
    const ct = kt=>-ht * Math.exp(-kt / _)
      , ut = kt=>lt + ct(kt)
      , pt = kt=>{
        const $t = ct(kt)
          , Wt = ut(kt);
        st.done = Math.abs($t) <= it,
        st.value = st.done ? lt : Wt
    }
    ;
    let vt, _t;
    const Pt = kt=>{
        dt(st.value) && (vt = kt,
        _t = spring({
            keyframes: [st.value, ft(st.value)],
            velocity: calcGeneratorVelocity(ut, kt, st.value),
            damping: $,
            stiffness: et,
            restDelta: it,
            restSpeed: ot
        }))
    }
    ;
    return Pt(0),
    {
        calculatedDuration: null,
        next: kt=>{
            let $t = !1;
            return !_t && vt === void 0 && ($t = !0,
            pt(kt),
            Pt(kt)),
            vt !== void 0 && kt > vt ? _t.next(kt - vt) : (!$t && pt(kt),
            st)
        }
    }
}
const frameloopDriver = d=>{
    const g = ({timestamp: b})=>d(b);
    return {
        start: ()=>frame.update(g, !0),
        stop: ()=>cancelFrame(g),
        now: ()=>frameData.isProcessing ? frameData.timestamp : performance.now()
    }
}
  , maxGeneratorDuration = 2e4;
function calcGeneratorDuration(d) {
    let g = 0;
    const b = 50;
    let _ = d.next(g);
    for (; !_.done && g < maxGeneratorDuration; )
        g += b,
        _ = d.next(g);
    return g >= maxGeneratorDuration ? 1 / 0 : g
}
const types = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
};
function animateValue({autoplay: d=!0, delay: g=0, driver: b=frameloopDriver, keyframes: _, type: $="keyframes", repeat: et=0, repeatDelay: tt=0, repeatType: rt="loop", onPlay: nt, onStop: it, onComplete: ot, onUpdate: at, ...st}) {
    let dt = 1, ft = !1, ht, xt;
    const lt = ()=>{
        xt = new Promise(Mt=>{
            ht = Mt
        }
        )
    }
    ;
    lt();
    let ct;
    const ut = types[$] || keyframes;
    let pt;
    ut !== keyframes && typeof _[0] != "number" && (pt = interpolate([0, 100], _, {
        clamp: !1
    }),
    _ = [0, 100]);
    const vt = ut({
        ...st,
        keyframes: _
    });
    let _t;
    rt === "mirror" && (_t = ut({
        ...st,
        keyframes: [..._].reverse(),
        velocity: -(st.velocity || 0)
    }));
    let Pt = "idle"
      , kt = null
      , $t = null
      , Wt = null;
    vt.calculatedDuration === null && et && (vt.calculatedDuration = calcGeneratorDuration(vt));
    const {calculatedDuration: Ht} = vt;
    let Dt = 1 / 0
      , Vt = 1 / 0;
    Ht !== null && (Dt = Ht + tt,
    Vt = Dt * (et + 1) - tt);
    let Ft = 0;
    const Kt = Mt=>{
        if ($t === null)
            return;
        dt > 0 && ($t = Math.min($t, Mt)),
        dt < 0 && ($t = Math.min(Mt - Vt / dt, $t)),
        kt !== null ? Ft = kt : Ft = Math.round(Mt - $t) * dt;
        const ar = Ft - g * (dt >= 0 ? 1 : -1)
          , wr = dt >= 0 ? ar < 0 : ar > Vt;
        Ft = Math.max(ar, 0),
        Pt === "finished" && kt === null && (Ft = Vt);
        let Tr = Ft
          , Pr = vt;
        if (et) {
            const dr = Math.min(Ft, Vt) / Dt;
            let lr = Math.floor(dr)
              , ir = dr % 1;
            !ir && dr >= 1 && (ir = 1),
            ir === 1 && lr--,
            lr = Math.min(lr, et + 1),
            !!(lr % 2) && (rt === "reverse" ? (ir = 1 - ir,
            tt && (ir -= tt / Dt)) : rt === "mirror" && (Pr = _t)),
            Tr = clamp(0, 1, ir) * Dt
        }
        const kr = wr ? {
            done: !1,
            value: _[0]
        } : Pr.next(Tr);
        pt && (kr.value = pt(kr.value));
        let {done: jr} = kr;
        !wr && Ht !== null && (jr = dt >= 0 ? Ft >= Vt : Ft <= 0);
        const cr = kt === null && (Pt === "finished" || Pt === "running" && jr);
        return at && at(kr.value),
        cr && Et(),
        kr
    }
      , Rt = ()=>{
        ct && ct.stop(),
        ct = void 0
    }
      , qt = ()=>{
        Pt = "idle",
        Rt(),
        ht(),
        lt(),
        $t = Wt = null
    }
      , Et = ()=>{
        Pt = "finished",
        ot && ot(),
        Rt(),
        ht()
    }
      , St = ()=>{
        if (ft)
            return;
        ct || (ct = b(Kt));
        const Mt = ct.now();
        nt && nt(),
        kt !== null ? $t = Mt - kt : (!$t || Pt === "finished") && ($t = Mt),
        Pt === "finished" && lt(),
        Wt = $t,
        kt = null,
        Pt = "running",
        ct.start()
    }
    ;
    d && St();
    const Lt = {
        then(Mt, ar) {
            return xt.then(Mt, ar)
        },
        get time() {
            return millisecondsToSeconds(Ft)
        },
        set time(Mt) {
            Mt = secondsToMilliseconds(Mt),
            Ft = Mt,
            kt !== null || !ct || dt === 0 ? kt = Mt : $t = ct.now() - Mt / dt
        },
        get duration() {
            const Mt = vt.calculatedDuration === null ? calcGeneratorDuration(vt) : vt.calculatedDuration;
            return millisecondsToSeconds(Mt)
        },
        get speed() {
            return dt
        },
        set speed(Mt) {
            Mt === dt || !ct || (dt = Mt,
            Lt.time = millisecondsToSeconds(Ft))
        },
        get state() {
            return Pt
        },
        play: St,
        pause: ()=>{
            Pt = "paused",
            kt = Ft
        }
        ,
        stop: ()=>{
            ft = !0,
            Pt !== "idle" && (Pt = "idle",
            it && it(),
            qt())
        }
        ,
        cancel: ()=>{
            Wt !== null && Kt(Wt),
            qt()
        }
        ,
        complete: ()=>{
            Pt = "finished"
        }
        ,
        sample: Mt=>($t = 0,
        Kt(Mt))
    };
    return Lt
}
function memo(d) {
    let g;
    return ()=>(g === void 0 && (g = d()),
    g)
}
const supportsWaapi = memo(()=>Object.hasOwnProperty.call(Element.prototype, "animate"))
  , acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform", "backgroundColor"])
  , sampleDelta = 10
  , maxDuration = 2e4
  , requiresPregeneratedKeyframes = (d,g)=>g.type === "spring" || d === "backgroundColor" || !isWaapiSupportedEasing(g.ease);
function createAcceleratedAnimation(d, g, {onUpdate: b, onComplete: _, ...$}) {
    if (!(supportsWaapi() && acceleratedValues.has(g) && !$.repeatDelay && $.repeatType !== "mirror" && $.damping !== 0 && $.type !== "inertia"))
        return !1;
    let tt = !1, rt, nt, it = !1;
    const ot = ()=>{
        nt = new Promise(ut=>{
            rt = ut
        }
        )
    }
    ;
    ot();
    let {keyframes: at, duration: st=300, ease: dt, times: ft} = $;
    if (requiresPregeneratedKeyframes(g, $)) {
        const ut = animateValue({
            ...$,
            repeat: 0,
            delay: 0
        });
        let pt = {
            done: !1,
            value: at[0]
        };
        const vt = [];
        let _t = 0;
        for (; !pt.done && _t < maxDuration; )
            pt = ut.sample(_t),
            vt.push(pt.value),
            _t += sampleDelta;
        ft = void 0,
        at = vt,
        st = _t - sampleDelta,
        dt = "linear"
    }
    const ht = animateStyle(d.owner.current, g, at, {
        ...$,
        duration: st,
        ease: dt,
        times: ft
    })
      , xt = ()=>{
        it = !1,
        ht.cancel()
    }
      , lt = ()=>{
        it = !0,
        frame.update(xt),
        rt(),
        ot()
    }
    ;
    return ht.onfinish = ()=>{
        it || (d.set(getFinalKeyframe(at, $)),
        _ && _(),
        lt())
    }
    ,
    {
        then(ut, pt) {
            return nt.then(ut, pt)
        },
        attachTimeline(ut) {
            return ht.timeline = ut,
            ht.onfinish = null,
            noop
        },
        get time() {
            return millisecondsToSeconds(ht.currentTime || 0)
        },
        set time(ut) {
            ht.currentTime = secondsToMilliseconds(ut)
        },
        get speed() {
            return ht.playbackRate
        },
        set speed(ut) {
            ht.playbackRate = ut
        },
        get duration() {
            return millisecondsToSeconds(st)
        },
        play: ()=>{
            tt || (ht.play(),
            cancelFrame(xt))
        }
        ,
        pause: ()=>ht.pause(),
        stop: ()=>{
            if (tt = !0,
            ht.playState === "idle")
                return;
            const {currentTime: ut} = ht;
            if (ut) {
                const pt = animateValue({
                    ...$,
                    autoplay: !1
                });
                d.setWithVelocity(pt.sample(ut - sampleDelta).value, pt.sample(ut).value, sampleDelta)
            }
            lt()
        }
        ,
        complete: ()=>{
            it || ht.finish()
        }
        ,
        cancel: lt
    }
}
function createInstantAnimation({keyframes: d, delay: g, onUpdate: b, onComplete: _}) {
    const $ = ()=>(b && b(d[d.length - 1]),
    _ && _(),
    {
        time: 0,
        speed: 1,
        duration: 0,
        play: noop,
        pause: noop,
        stop: noop,
        then: et=>(et(),
        Promise.resolve()),
        cancel: noop,
        complete: noop
    });
    return g ? animateValue({
        keyframes: [0, 1],
        duration: 0,
        delay: g,
        onComplete: $
    }) : $()
}
const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , criticallyDampedSpring = d=>({
    type: "spring",
    stiffness: 550,
    damping: d === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , keyframesTransition = {
    type: "keyframes",
    duration: .8
}
  , ease = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , getDefaultTransition = (d,{keyframes: g})=>g.length > 2 ? keyframesTransition : transformProps.has(d) ? d.startsWith("scale") ? criticallyDampedSpring(g[1]) : underDampedSpring : ease
  , isAnimatable = (d,g)=>d === "zIndex" ? !1 : !!(typeof g == "number" || Array.isArray(g) || typeof g == "string" && (complex.test(g) || g === "0") && !g.startsWith("url("))
  , maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(d) {
    const [g,b] = d.slice(0, -1).split("(");
    if (g === "drop-shadow")
        return d;
    const [_] = b.match(floatRegex) || [];
    if (!_)
        return d;
    const $ = b.replace(_, "");
    let et = maxDefaults.has(g) ? 1 : 0;
    return _ !== b && (et *= 100),
    g + "(" + et + $ + ")"
}
const functionRegex = /([a-z-]*)\(.*?\)/g
  , filter = {
    ...complex,
    getAnimatableNone: d=>{
        const g = d.match(functionRegex);
        return g ? g.map(applyDefaultFilter).join(" ") : d
    }
}
  , defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
}
  , getDefaultValueType = d=>defaultValueTypes[d];
function getAnimatableNone(d, g) {
    let b = getDefaultValueType(d);
    return b !== filter && (b = complex),
    b.getAnimatableNone ? b.getAnimatableNone(g) : void 0
}
const isZeroValueString = d=>/^0[^.\s]+$/.test(d);
function isNone(d) {
    if (typeof d == "number")
        return d === 0;
    if (d !== null)
        return d === "none" || d === "0" || isZeroValueString(d)
}
function getKeyframes(d, g, b, _) {
    const $ = isAnimatable(g, b);
    let et;
    Array.isArray(b) ? et = [...b] : et = [null, b];
    const tt = _.from !== void 0 ? _.from : d.get();
    let rt;
    const nt = [];
    for (let it = 0; it < et.length; it++)
        et[it] === null && (et[it] = it === 0 ? tt : et[it - 1]),
        isNone(et[it]) && nt.push(it),
        typeof et[it] == "string" && et[it] !== "none" && et[it] !== "0" && (rt = et[it]);
    if ($ && nt.length && rt)
        for (let it = 0; it < nt.length; it++) {
            const ot = nt[it];
            et[ot] = getAnimatableNone(g, rt)
        }
    return et
}
function isTransitionDefined({when: d, delay: g, delayChildren: b, staggerChildren: _, staggerDirection: $, repeat: et, repeatType: tt, repeatDelay: rt, from: nt, elapsed: it, ...ot}) {
    return !!Object.keys(ot).length
}
function getValueTransition(d, g) {
    return d[g] || d.default || d
}
const MotionGlobalConfig = {
    skipAnimations: !1
}
  , animateMotionValue = (d,g,b,_={})=>$=>{
    const et = getValueTransition(_, d) || {}
      , tt = et.delay || _.delay || 0;
    let {elapsed: rt=0} = _;
    rt = rt - secondsToMilliseconds(tt);
    const nt = getKeyframes(g, d, b, et)
      , it = nt[0]
      , ot = nt[nt.length - 1]
      , at = isAnimatable(d, it)
      , st = isAnimatable(d, ot);
    let dt = {
        keyframes: nt,
        velocity: g.getVelocity(),
        ease: "easeOut",
        ...et,
        delay: -rt,
        onUpdate: ft=>{
            g.set(ft),
            et.onUpdate && et.onUpdate(ft)
        }
        ,
        onComplete: ()=>{
            $(),
            et.onComplete && et.onComplete()
        }
    };
    if (isTransitionDefined(et) || (dt = {
        ...dt,
        ...getDefaultTransition(d, dt)
    }),
    dt.duration && (dt.duration = secondsToMilliseconds(dt.duration)),
    dt.repeatDelay && (dt.repeatDelay = secondsToMilliseconds(dt.repeatDelay)),
    !at || !st || instantAnimationState.current || et.type === !1 || MotionGlobalConfig.skipAnimations)
        return createInstantAnimation(dt);
    if (!_.isHandoff && g.owner && g.owner.current instanceof HTMLElement && !g.owner.getProps().onUpdate) {
        const ft = createAcceleratedAnimation(g, d, dt);
        if (ft)
            return ft
    }
    return animateValue(dt)
}
;
function isWillChangeMotionValue(d) {
    return !!(isMotionValue(d) && d.add)
}
const isNumericalString = d=>/^\-?\d*\.?\d+$/.test(d);
function addUniqueItem(d, g) {
    d.indexOf(g) === -1 && d.push(g)
}
function removeItem(d, g) {
    const b = d.indexOf(g);
    b > -1 && d.splice(b, 1)
}
class SubscriptionManager {
    constructor() {
        this.subscriptions = []
    }
    add(g) {
        return addUniqueItem(this.subscriptions, g),
        ()=>removeItem(this.subscriptions, g)
    }
    notify(g, b, _) {
        const $ = this.subscriptions.length;
        if ($)
            if ($ === 1)
                this.subscriptions[0](g, b, _);
            else
                for (let et = 0; et < $; et++) {
                    const tt = this.subscriptions[et];
                    tt && tt(g, b, _)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const isFloat = d=>!isNaN(parseFloat(d));
class MotionValue {
    constructor(g, b={}) {
        this.version = "10.18.0",
        this.timeDelta = 0,
        this.lastUpdated = 0,
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (_,$=!0)=>{
            this.prev = this.current,
            this.current = _;
            const {delta: et, timestamp: tt} = frameData;
            this.lastUpdated !== tt && (this.timeDelta = et,
            this.lastUpdated = tt,
            frame.postRender(this.scheduleVelocityCheck)),
            this.prev !== this.current && this.events.change && this.events.change.notify(this.current),
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()),
            $ && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.scheduleVelocityCheck = ()=>frame.postRender(this.velocityCheck),
        this.velocityCheck = ({timestamp: _})=>{
            _ !== this.lastUpdated && (this.prev = this.current,
            this.events.velocityChange && this.events.velocityChange.notify(this.getVelocity()))
        }
        ,
        this.hasAnimated = !1,
        this.prev = this.current = g,
        this.canTrackVelocity = isFloat(this.current),
        this.owner = b.owner
    }
    onChange(g) {
        return this.on("change", g)
    }
    on(g, b) {
        this.events[g] || (this.events[g] = new SubscriptionManager);
        const _ = this.events[g].add(b);
        return g === "change" ? ()=>{
            _(),
            frame.read(()=>{
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : _
    }
    clearListeners() {
        for (const g in this.events)
            this.events[g].clear()
    }
    attach(g, b) {
        this.passiveEffect = g,
        this.stopPassiveEffect = b
    }
    set(g, b=!0) {
        !b || !this.passiveEffect ? this.updateAndNotify(g, b) : this.passiveEffect(g, this.updateAndNotify)
    }
    setWithVelocity(g, b, _) {
        this.set(b),
        this.prev = g,
        this.timeDelta = _
    }
    jump(g) {
        this.updateAndNotify(g),
        this.prev = g,
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0
    }
    start(g) {
        return this.stop(),
        new Promise(b=>{
            this.hasAnimated = !0,
            this.animation = g(b),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then(()=>{
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function motionValue(d, g) {
    return new MotionValue(d,g)
}
const testValueType = d=>g=>g.test(d)
  , auto = {
    test: d=>d === "auto",
    parse: d=>d
}
  , dimensionValueTypes = [number, px$1, percent, degrees, vw, vh, auto]
  , findDimensionValueType = d=>dimensionValueTypes.find(testValueType(d))
  , valueTypes = [...dimensionValueTypes, color, complex]
  , findValueType = d=>valueTypes.find(testValueType(d));
function setMotionValue(d, g, b) {
    d.hasValue(g) ? d.getValue(g).set(b) : d.addValue(g, motionValue(b))
}
function setTarget(d, g) {
    const b = resolveVariant(d, g);
    let {transitionEnd: _={}, transition: $={}, ...et} = b ? d.makeTargetAnimatable(b, !1) : {};
    et = {
        ...et,
        ..._
    };
    for (const tt in et) {
        const rt = resolveFinalValueInKeyframes(et[tt]);
        setMotionValue(d, tt, rt)
    }
}
function checkTargetForNewValues(d, g, b) {
    var _, $;
    const et = Object.keys(g).filter(rt=>!d.hasValue(rt))
      , tt = et.length;
    if (tt)
        for (let rt = 0; rt < tt; rt++) {
            const nt = et[rt]
              , it = g[nt];
            let ot = null;
            Array.isArray(it) && (ot = it[0]),
            ot === null && (ot = ($ = (_ = b[nt]) !== null && _ !== void 0 ? _ : d.readValue(nt)) !== null && $ !== void 0 ? $ : g[nt]),
            ot != null && (typeof ot == "string" && (isNumericalString(ot) || isZeroValueString(ot)) ? ot = parseFloat(ot) : !findValueType(ot) && complex.test(it) && (ot = getAnimatableNone(nt, it)),
            d.addValue(nt, motionValue(ot, {
                owner: d
            })),
            b[nt] === void 0 && (b[nt] = ot),
            ot !== null && d.setBaseTarget(nt, ot))
        }
}
function getOriginFromTransition(d, g) {
    return g ? (g[d] || g.default || g).from : void 0
}
function getOrigin(d, g, b) {
    const _ = {};
    for (const $ in d) {
        const et = getOriginFromTransition($, g);
        if (et !== void 0)
            _[$] = et;
        else {
            const tt = b.getValue($);
            tt && (_[$] = tt.get())
        }
    }
    return _
}
function shouldBlockAnimation({protectedKeys: d, needsAnimating: g}, b) {
    const _ = d.hasOwnProperty(b) && g[b] !== !0;
    return g[b] = !1,
    _
}
function hasKeyframesChanged(d, g) {
    const b = d.get();
    if (Array.isArray(g)) {
        for (let _ = 0; _ < g.length; _++)
            if (g[_] !== b)
                return !0
    } else
        return b !== g
}
function animateTarget(d, g, {delay: b=0, transitionOverride: _, type: $}={}) {
    let {transition: et=d.getDefaultTransition(), transitionEnd: tt, ...rt} = d.makeTargetAnimatable(g);
    const nt = d.getValue("willChange");
    _ && (et = _);
    const it = []
      , ot = $ && d.animationState && d.animationState.getState()[$];
    for (const at in rt) {
        const st = d.getValue(at)
          , dt = rt[at];
        if (!st || dt === void 0 || ot && shouldBlockAnimation(ot, at))
            continue;
        const ft = {
            delay: b,
            elapsed: 0,
            ...getValueTransition(et || {}, at)
        };
        if (window.HandoffAppearAnimations) {
            const lt = d.getProps()[optimizedAppearDataAttribute];
            if (lt) {
                const ct = window.HandoffAppearAnimations(lt, at, st, frame);
                ct !== null && (ft.elapsed = ct,
                ft.isHandoff = !0)
            }
        }
        let ht = !ft.isHandoff && !hasKeyframesChanged(st, dt);
        if (ft.type === "spring" && (st.getVelocity() || ft.velocity) && (ht = !1),
        st.animation && (ht = !1),
        ht)
            continue;
        st.start(animateMotionValue(at, st, dt, d.shouldReduceMotion && transformProps.has(at) ? {
            type: !1
        } : ft));
        const xt = st.animation;
        isWillChangeMotionValue(nt) && (nt.add(at),
        xt.then(()=>nt.remove(at))),
        it.push(xt)
    }
    return tt && Promise.all(it).then(()=>{
        tt && setTarget(d, tt)
    }
    ),
    it
}
function animateVariant(d, g, b={}) {
    const _ = resolveVariant(d, g, b.custom);
    let {transition: $=d.getDefaultTransition() || {}} = _ || {};
    b.transitionOverride && ($ = b.transitionOverride);
    const et = _ ? ()=>Promise.all(animateTarget(d, _, b)) : ()=>Promise.resolve()
      , tt = d.variantChildren && d.variantChildren.size ? (nt=0)=>{
        const {delayChildren: it=0, staggerChildren: ot, staggerDirection: at} = $;
        return animateChildren(d, g, it + nt, ot, at, b)
    }
    : ()=>Promise.resolve()
      , {when: rt} = $;
    if (rt) {
        const [nt,it] = rt === "beforeChildren" ? [et, tt] : [tt, et];
        return nt().then(()=>it())
    } else
        return Promise.all([et(), tt(b.delay)])
}
function animateChildren(d, g, b=0, _=0, $=1, et) {
    const tt = []
      , rt = (d.variantChildren.size - 1) * _
      , nt = $ === 1 ? (it=0)=>it * _ : (it=0)=>rt - it * _;
    return Array.from(d.variantChildren).sort(sortByTreeOrder).forEach((it,ot)=>{
        it.notify("AnimationStart", g),
        tt.push(animateVariant(it, g, {
            ...et,
            delay: b + nt(ot)
        }).then(()=>it.notify("AnimationComplete", g)))
    }
    ),
    Promise.all(tt)
}
function sortByTreeOrder(d, g) {
    return d.sortNodePosition(g)
}
function animateVisualElement(d, g, b={}) {
    d.notify("AnimationStart", g);
    let _;
    if (Array.isArray(g)) {
        const $ = g.map(et=>animateVariant(d, et, b));
        _ = Promise.all($)
    } else if (typeof g == "string")
        _ = animateVariant(d, g, b);
    else {
        const $ = typeof g == "function" ? resolveVariant(d, g, b.custom) : g;
        _ = Promise.all(animateTarget(d, $, b))
    }
    return _.then(()=>d.notify("AnimationComplete", g))
}
const reversePriorityOrder = [...variantPriorityOrder].reverse()
  , numAnimationTypes = variantPriorityOrder.length;
function animateList(d) {
    return g=>Promise.all(g.map(({animation: b, options: _})=>animateVisualElement(d, b, _)))
}
function createAnimationState(d) {
    let g = animateList(d);
    const b = createState();
    let _ = !0;
    const $ = (nt,it)=>{
        const ot = resolveVariant(d, it);
        if (ot) {
            const {transition: at, transitionEnd: st, ...dt} = ot;
            nt = {
                ...nt,
                ...dt,
                ...st
            }
        }
        return nt
    }
    ;
    function et(nt) {
        g = nt(d)
    }
    function tt(nt, it) {
        const ot = d.getProps()
          , at = d.getVariantContext(!0) || {}
          , st = []
          , dt = new Set;
        let ft = {}
          , ht = 1 / 0;
        for (let lt = 0; lt < numAnimationTypes; lt++) {
            const ct = reversePriorityOrder[lt]
              , ut = b[ct]
              , pt = ot[ct] !== void 0 ? ot[ct] : at[ct]
              , vt = isVariantLabel(pt)
              , _t = ct === it ? ut.isActive : null;
            _t === !1 && (ht = lt);
            let Pt = pt === at[ct] && pt !== ot[ct] && vt;
            if (Pt && _ && d.manuallyAnimateOnMount && (Pt = !1),
            ut.protectedKeys = {
                ...ft
            },
            !ut.isActive && _t === null || !pt && !ut.prevProp || isAnimationControls(pt) || typeof pt == "boolean")
                continue;
            let $t = checkVariantsDidChange(ut.prevProp, pt) || ct === it && ut.isActive && !Pt && vt || lt > ht && vt
              , Wt = !1;
            const Ht = Array.isArray(pt) ? pt : [pt];
            let Dt = Ht.reduce($, {});
            _t === !1 && (Dt = {});
            const {prevResolvedValues: Vt={}} = ut
              , Ft = {
                ...Vt,
                ...Dt
            }
              , Kt = Rt=>{
                $t = !0,
                dt.has(Rt) && (Wt = !0,
                dt.delete(Rt)),
                ut.needsAnimating[Rt] = !0
            }
            ;
            for (const Rt in Ft) {
                const qt = Dt[Rt]
                  , Et = Vt[Rt];
                if (ft.hasOwnProperty(Rt))
                    continue;
                let St = !1;
                isKeyframesTarget(qt) && isKeyframesTarget(Et) ? St = !shallowCompare(qt, Et) : St = qt !== Et,
                St ? qt !== void 0 ? Kt(Rt) : dt.add(Rt) : qt !== void 0 && dt.has(Rt) ? Kt(Rt) : ut.protectedKeys[Rt] = !0
            }
            ut.prevProp = pt,
            ut.prevResolvedValues = Dt,
            ut.isActive && (ft = {
                ...ft,
                ...Dt
            }),
            _ && d.blockInitialAnimation && ($t = !1),
            $t && (!Pt || Wt) && st.push(...Ht.map(Rt=>({
                animation: Rt,
                options: {
                    type: ct,
                    ...nt
                }
            })))
        }
        if (dt.size) {
            const lt = {};
            dt.forEach(ct=>{
                const ut = d.getBaseTarget(ct);
                ut !== void 0 && (lt[ct] = ut)
            }
            ),
            st.push({
                animation: lt
            })
        }
        let xt = !!st.length;
        return _ && (ot.initial === !1 || ot.initial === ot.animate) && !d.manuallyAnimateOnMount && (xt = !1),
        _ = !1,
        xt ? g(st) : Promise.resolve()
    }
    function rt(nt, it, ot) {
        var at;
        if (b[nt].isActive === it)
            return Promise.resolve();
        (at = d.variantChildren) === null || at === void 0 || at.forEach(dt=>{
            var ft;
            return (ft = dt.animationState) === null || ft === void 0 ? void 0 : ft.setActive(nt, it)
        }
        ),
        b[nt].isActive = it;
        const st = tt(ot, nt);
        for (const dt in b)
            b[dt].protectedKeys = {};
        return st
    }
    return {
        animateChanges: tt,
        setActive: rt,
        setAnimateFunction: et,
        getState: ()=>b
    }
}
function checkVariantsDidChange(d, g) {
    return typeof g == "string" ? g !== d : Array.isArray(g) ? !shallowCompare(g, d) : !1
}
function createTypeState(d=!1) {
    return {
        isActive: d,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function createState() {
    return {
        animate: createTypeState(!0),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
    }
}
class AnimationFeature extends Feature {
    constructor(g) {
        super(g),
        g.animationState || (g.animationState = createAnimationState(g))
    }
    updateAnimationControlsSubscription() {
        const {animate: g} = this.node.getProps();
        this.unmount(),
        isAnimationControls(g) && (this.unmount = g.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: g} = this.node.getProps()
          , {animate: b} = this.node.prevProps || {};
        g !== b && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let id$3 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments),
        this.id = id$3++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: g, onExitComplete: b, custom: _} = this.node.presenceContext
          , {isPresent: $} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || g === $)
            return;
        const et = this.node.animationState.setActive("exit", !g, {
            custom: _ ?? this.node.getProps().custom
        });
        b && !g && et.then(()=>b(this.id))
    }
    mount() {
        const {register: g} = this.node.presenceContext || {};
        g && (this.unmount = g(this.id))
    }
    unmount() {}
}
const animations = {
    animation: {
        Feature: AnimationFeature
    },
    exit: {
        Feature: ExitAnimationFeature
    }
}
  , distance = (d,g)=>Math.abs(d - g);
function distance2D(d, g) {
    const b = distance(d.x, g.x)
      , _ = distance(d.y, g.y);
    return Math.sqrt(b ** 2 + _ ** 2)
}
class PanSession {
    constructor(g, b, {transformPagePoint: _, contextWindow: $, dragSnapToOrigin: et=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = ()=>{
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const at = getPanInfo(this.lastMoveEventInfo, this.history)
              , st = this.startEvent !== null
              , dt = distance2D(at.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!st && !dt)
                return;
            const {point: ft} = at
              , {timestamp: ht} = frameData;
            this.history.push({
                ...ft,
                timestamp: ht
            });
            const {onStart: xt, onMove: lt} = this.handlers;
            st || (xt && xt(this.lastMoveEvent, at),
            this.startEvent = this.lastMoveEvent),
            lt && lt(this.lastMoveEvent, at)
        }
        ,
        this.handlePointerMove = (at,st)=>{
            this.lastMoveEvent = at,
            this.lastMoveEventInfo = transformPoint(st, this.transformPagePoint),
            frame.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (at,st)=>{
            this.end();
            const {onEnd: dt, onSessionEnd: ft, resumeAnimation: ht} = this.handlers;
            if (this.dragSnapToOrigin && ht && ht(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const xt = getPanInfo(at.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(st, this.transformPagePoint), this.history);
            this.startEvent && dt && dt(at, xt),
            ft && ft(at, xt)
        }
        ,
        !isPrimaryPointer(g))
            return;
        this.dragSnapToOrigin = et,
        this.handlers = b,
        this.transformPagePoint = _,
        this.contextWindow = $ || window;
        const tt = extractEventInfo(g)
          , rt = transformPoint(tt, this.transformPagePoint)
          , {point: nt} = rt
          , {timestamp: it} = frameData;
        this.history = [{
            ...nt,
            timestamp: it
        }];
        const {onSessionStart: ot} = b;
        ot && ot(g, getPanInfo(rt, this.history)),
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(g) {
        this.handlers = g
    }
    end() {
        this.removeListeners && this.removeListeners(),
        cancelFrame(this.updatePoint)
    }
}
function transformPoint(d, g) {
    return g ? {
        point: g(d.point)
    } : d
}
function subtractPoint(d, g) {
    return {
        x: d.x - g.x,
        y: d.y - g.y
    }
}
function getPanInfo({point: d}, g) {
    return {
        point: d,
        delta: subtractPoint(d, lastDevicePoint(g)),
        offset: subtractPoint(d, startDevicePoint(g)),
        velocity: getVelocity(g, .1)
    }
}
function startDevicePoint(d) {
    return d[0]
}
function lastDevicePoint(d) {
    return d[d.length - 1]
}
function getVelocity(d, g) {
    if (d.length < 2)
        return {
            x: 0,
            y: 0
        };
    let b = d.length - 1
      , _ = null;
    const $ = lastDevicePoint(d);
    for (; b >= 0 && (_ = d[b],
    !($.timestamp - _.timestamp > secondsToMilliseconds(g))); )
        b--;
    if (!_)
        return {
            x: 0,
            y: 0
        };
    const et = millisecondsToSeconds($.timestamp - _.timestamp);
    if (et === 0)
        return {
            x: 0,
            y: 0
        };
    const tt = {
        x: ($.x - _.x) / et,
        y: ($.y - _.y) / et
    };
    return tt.x === 1 / 0 && (tt.x = 0),
    tt.y === 1 / 0 && (tt.y = 0),
    tt
}
function calcLength(d) {
    return d.max - d.min
}
function isNear(d, g=0, b=.01) {
    return Math.abs(d - g) <= b
}
function calcAxisDelta(d, g, b, _=.5) {
    d.origin = _,
    d.originPoint = mix(g.min, g.max, d.origin),
    d.scale = calcLength(b) / calcLength(g),
    (isNear(d.scale, 1, 1e-4) || isNaN(d.scale)) && (d.scale = 1),
    d.translate = mix(b.min, b.max, d.origin) - d.originPoint,
    (isNear(d.translate) || isNaN(d.translate)) && (d.translate = 0)
}
function calcBoxDelta(d, g, b, _) {
    calcAxisDelta(d.x, g.x, b.x, _ ? _.originX : void 0),
    calcAxisDelta(d.y, g.y, b.y, _ ? _.originY : void 0)
}
function calcRelativeAxis(d, g, b) {
    d.min = b.min + g.min,
    d.max = d.min + calcLength(g)
}
function calcRelativeBox(d, g, b) {
    calcRelativeAxis(d.x, g.x, b.x),
    calcRelativeAxis(d.y, g.y, b.y)
}
function calcRelativeAxisPosition(d, g, b) {
    d.min = g.min - b.min,
    d.max = d.min + calcLength(g)
}
function calcRelativePosition(d, g, b) {
    calcRelativeAxisPosition(d.x, g.x, b.x),
    calcRelativeAxisPosition(d.y, g.y, b.y)
}
function applyConstraints(d, {min: g, max: b}, _) {
    return g !== void 0 && d < g ? d = _ ? mix(g, d, _.min) : Math.max(d, g) : b !== void 0 && d > b && (d = _ ? mix(b, d, _.max) : Math.min(d, b)),
    d
}
function calcRelativeAxisConstraints(d, g, b) {
    return {
        min: g !== void 0 ? d.min + g : void 0,
        max: b !== void 0 ? d.max + b - (d.max - d.min) : void 0
    }
}
function calcRelativeConstraints(d, {top: g, left: b, bottom: _, right: $}) {
    return {
        x: calcRelativeAxisConstraints(d.x, b, $),
        y: calcRelativeAxisConstraints(d.y, g, _)
    }
}
function calcViewportAxisConstraints(d, g) {
    let b = g.min - d.min
      , _ = g.max - d.max;
    return g.max - g.min < d.max - d.min && ([b,_] = [_, b]),
    {
        min: b,
        max: _
    }
}
function calcViewportConstraints(d, g) {
    return {
        x: calcViewportAxisConstraints(d.x, g.x),
        y: calcViewportAxisConstraints(d.y, g.y)
    }
}
function calcOrigin(d, g) {
    let b = .5;
    const _ = calcLength(d)
      , $ = calcLength(g);
    return $ > _ ? b = progress(g.min, g.max - _, d.min) : _ > $ && (b = progress(d.min, d.max - $, g.min)),
    clamp(0, 1, b)
}
function rebaseAxisConstraints(d, g) {
    const b = {};
    return g.min !== void 0 && (b.min = g.min - d.min),
    g.max !== void 0 && (b.max = g.max - d.min),
    b
}
const defaultElastic = .35;
function resolveDragElastic(d=defaultElastic) {
    return d === !1 ? d = 0 : d === !0 && (d = defaultElastic),
    {
        x: resolveAxisElastic(d, "left", "right"),
        y: resolveAxisElastic(d, "top", "bottom")
    }
}
function resolveAxisElastic(d, g, b) {
    return {
        min: resolvePointElastic(d, g),
        max: resolvePointElastic(d, b)
    }
}
function resolvePointElastic(d, g) {
    return typeof d == "number" ? d : d[g] || 0
}
const createAxisDelta = ()=>({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , createDelta = ()=>({
    x: createAxisDelta(),
    y: createAxisDelta()
})
  , createAxis = ()=>({
    min: 0,
    max: 0
})
  , createBox = ()=>({
    x: createAxis(),
    y: createAxis()
});
function eachAxis(d) {
    return [d("x"), d("y")]
}
function convertBoundingBoxToBox({top: d, left: g, right: b, bottom: _}) {
    return {
        x: {
            min: g,
            max: b
        },
        y: {
            min: d,
            max: _
        }
    }
}
function convertBoxToBoundingBox({x: d, y: g}) {
    return {
        top: g.min,
        right: d.max,
        bottom: g.max,
        left: d.min
    }
}
function transformBoxPoints(d, g) {
    if (!g)
        return d;
    const b = g({
        x: d.left,
        y: d.top
    })
      , _ = g({
        x: d.right,
        y: d.bottom
    });
    return {
        top: b.y,
        left: b.x,
        bottom: _.y,
        right: _.x
    }
}
function isIdentityScale(d) {
    return d === void 0 || d === 1
}
function hasScale({scale: d, scaleX: g, scaleY: b}) {
    return !isIdentityScale(d) || !isIdentityScale(g) || !isIdentityScale(b)
}
function hasTransform(d) {
    return hasScale(d) || has2DTranslate(d) || d.z || d.rotate || d.rotateX || d.rotateY
}
function has2DTranslate(d) {
    return is2DTranslate(d.x) || is2DTranslate(d.y)
}
function is2DTranslate(d) {
    return d && d !== "0%"
}
function scalePoint(d, g, b) {
    const _ = d - b
      , $ = g * _;
    return b + $
}
function applyPointDelta(d, g, b, _, $) {
    return $ !== void 0 && (d = scalePoint(d, $, _)),
    scalePoint(d, b, _) + g
}
function applyAxisDelta(d, g=0, b=1, _, $) {
    d.min = applyPointDelta(d.min, g, b, _, $),
    d.max = applyPointDelta(d.max, g, b, _, $)
}
function applyBoxDelta(d, {x: g, y: b}) {
    applyAxisDelta(d.x, g.translate, g.scale, g.originPoint),
    applyAxisDelta(d.y, b.translate, b.scale, b.originPoint)
}
function applyTreeDeltas(d, g, b, _=!1) {
    const $ = b.length;
    if (!$)
        return;
    g.x = g.y = 1;
    let et, tt;
    for (let rt = 0; rt < $; rt++) {
        et = b[rt],
        tt = et.projectionDelta;
        const nt = et.instance;
        nt && nt.style && nt.style.display === "contents" || (_ && et.options.layoutScroll && et.scroll && et !== et.root && transformBox(d, {
            x: -et.scroll.offset.x,
            y: -et.scroll.offset.y
        }),
        tt && (g.x *= tt.x.scale,
        g.y *= tt.y.scale,
        applyBoxDelta(d, tt)),
        _ && hasTransform(et.latestValues) && transformBox(d, et.latestValues))
    }
    g.x = snapToDefault(g.x),
    g.y = snapToDefault(g.y)
}
function snapToDefault(d) {
    return Number.isInteger(d) || d > 1.0000000000001 || d < .999999999999 ? d : 1
}
function translateAxis(d, g) {
    d.min = d.min + g,
    d.max = d.max + g
}
function transformAxis(d, g, [b,_,$]) {
    const et = g[$] !== void 0 ? g[$] : .5
      , tt = mix(d.min, d.max, et);
    applyAxisDelta(d, g[b], g[_], tt, g.scale)
}
const xKeys$1 = ["x", "scaleX", "originX"]
  , yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(d, g) {
    transformAxis(d.x, g, xKeys$1),
    transformAxis(d.y, g, yKeys$1)
}
function measureViewportBox(d, g) {
    return convertBoundingBoxToBox(transformBoxPoints(d.getBoundingClientRect(), g))
}
function measurePageBox(d, g, b) {
    const _ = measureViewportBox(d, b)
      , {scroll: $} = g;
    return $ && (translateAxis(_.x, $.offset.x),
    translateAxis(_.y, $.offset.y)),
    _
}
const getContextWindow = ({current: d})=>d ? d.ownerDocument.defaultView : null
  , elementDragControls = new WeakMap;
class VisualElementDragControls {
    constructor(g) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = createBox(),
        this.visualElement = g
    }
    start(g, {snapToCursor: b=!1}={}) {
        const {presenceContext: _} = this.visualElement;
        if (_ && _.isPresent === !1)
            return;
        const $ = ot=>{
            const {dragSnapToOrigin: at} = this.getProps();
            at ? this.pauseAnimation() : this.stopAnimation(),
            b && this.snapToCursor(extractEventInfo(ot, "page").point)
        }
          , et = (ot,at)=>{
            const {drag: st, dragPropagation: dt, onDragStart: ft} = this.getProps();
            if (st && !dt && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = getGlobalLock(st),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            eachAxis(xt=>{
                let lt = this.getAxisMotionValue(xt).get() || 0;
                if (percent.test(lt)) {
                    const {projection: ct} = this.visualElement;
                    if (ct && ct.layout) {
                        const ut = ct.layout.layoutBox[xt];
                        ut && (lt = calcLength(ut) * (parseFloat(lt) / 100))
                    }
                }
                this.originPoint[xt] = lt
            }
            ),
            ft && frame.update(()=>ft(ot, at), !1, !0);
            const {animationState: ht} = this.visualElement;
            ht && ht.setActive("whileDrag", !0)
        }
          , tt = (ot,at)=>{
            const {dragPropagation: st, dragDirectionLock: dt, onDirectionLock: ft, onDrag: ht} = this.getProps();
            if (!st && !this.openGlobalLock)
                return;
            const {offset: xt} = at;
            if (dt && this.currentDirection === null) {
                this.currentDirection = getCurrentDirection(xt),
                this.currentDirection !== null && ft && ft(this.currentDirection);
                return
            }
            this.updateAxis("x", at.point, xt),
            this.updateAxis("y", at.point, xt),
            this.visualElement.render(),
            ht && ht(ot, at)
        }
          , rt = (ot,at)=>this.stop(ot, at)
          , nt = ()=>eachAxis(ot=>{
            var at;
            return this.getAnimationState(ot) === "paused" && ((at = this.getAxisMotionValue(ot).animation) === null || at === void 0 ? void 0 : at.play())
        }
        )
          , {dragSnapToOrigin: it} = this.getProps();
        this.panSession = new PanSession(g,{
            onSessionStart: $,
            onStart: et,
            onMove: tt,
            onSessionEnd: rt,
            resumeAnimation: nt
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: it,
            contextWindow: getContextWindow(this.visualElement)
        })
    }
    stop(g, b) {
        const _ = this.isDragging;
        if (this.cancel(),
        !_)
            return;
        const {velocity: $} = b;
        this.startAnimation($);
        const {onDragEnd: et} = this.getProps();
        et && frame.update(()=>et(g, b))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: g, animationState: b} = this.visualElement;
        g && (g.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: _} = this.getProps();
        !_ && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        b && b.setActive("whileDrag", !1)
    }
    updateAxis(g, b, _) {
        const {drag: $} = this.getProps();
        if (!_ || !shouldDrag(g, $, this.currentDirection))
            return;
        const et = this.getAxisMotionValue(g);
        let tt = this.originPoint[g] + _[g];
        this.constraints && this.constraints[g] && (tt = applyConstraints(tt, this.constraints[g], this.elastic[g])),
        et.set(tt)
    }
    resolveConstraints() {
        var g;
        const {dragConstraints: b, dragElastic: _} = this.getProps()
          , $ = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (g = this.visualElement.projection) === null || g === void 0 ? void 0 : g.layout
          , et = this.constraints;
        b && isRefObject(b) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : b && $ ? this.constraints = calcRelativeConstraints($.layoutBox, b) : this.constraints = !1,
        this.elastic = resolveDragElastic(_),
        et !== this.constraints && $ && this.constraints && !this.hasMutatedConstraints && eachAxis(tt=>{
            this.getAxisMotionValue(tt) && (this.constraints[tt] = rebaseAxisConstraints($.layoutBox[tt], this.constraints[tt]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: g, onMeasureDragConstraints: b} = this.getProps();
        if (!g || !isRefObject(g))
            return !1;
        const _ = g.current
          , {projection: $} = this.visualElement;
        if (!$ || !$.layout)
            return !1;
        const et = measurePageBox(_, $.root, this.visualElement.getTransformPagePoint());
        let tt = calcViewportConstraints($.layout.layoutBox, et);
        if (b) {
            const rt = b(convertBoxToBoundingBox(tt));
            this.hasMutatedConstraints = !!rt,
            rt && (tt = convertBoundingBoxToBox(rt))
        }
        return tt
    }
    startAnimation(g) {
        const {drag: b, dragMomentum: _, dragElastic: $, dragTransition: et, dragSnapToOrigin: tt, onDragTransitionEnd: rt} = this.getProps()
          , nt = this.constraints || {}
          , it = eachAxis(ot=>{
            if (!shouldDrag(ot, b, this.currentDirection))
                return;
            let at = nt && nt[ot] || {};
            tt && (at = {
                min: 0,
                max: 0
            });
            const st = $ ? 200 : 1e6
              , dt = $ ? 40 : 1e7
              , ft = {
                type: "inertia",
                velocity: _ ? g[ot] : 0,
                bounceStiffness: st,
                bounceDamping: dt,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...et,
                ...at
            };
            return this.startAxisValueAnimation(ot, ft)
        }
        );
        return Promise.all(it).then(rt)
    }
    startAxisValueAnimation(g, b) {
        const _ = this.getAxisMotionValue(g);
        return _.start(animateMotionValue(g, _, 0, b))
    }
    stopAnimation() {
        eachAxis(g=>this.getAxisMotionValue(g).stop())
    }
    pauseAnimation() {
        eachAxis(g=>{
            var b;
            return (b = this.getAxisMotionValue(g).animation) === null || b === void 0 ? void 0 : b.pause()
        }
        )
    }
    getAnimationState(g) {
        var b;
        return (b = this.getAxisMotionValue(g).animation) === null || b === void 0 ? void 0 : b.state
    }
    getAxisMotionValue(g) {
        const b = "_drag" + g.toUpperCase()
          , _ = this.visualElement.getProps()
          , $ = _[b];
        return $ || this.visualElement.getValue(g, (_.initial ? _.initial[g] : void 0) || 0)
    }
    snapToCursor(g) {
        eachAxis(b=>{
            const {drag: _} = this.getProps();
            if (!shouldDrag(b, _, this.currentDirection))
                return;
            const {projection: $} = this.visualElement
              , et = this.getAxisMotionValue(b);
            if ($ && $.layout) {
                const {min: tt, max: rt} = $.layout.layoutBox[b];
                et.set(g[b] - mix(tt, rt, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: g, dragConstraints: b} = this.getProps()
          , {projection: _} = this.visualElement;
        if (!isRefObject(b) || !_ || !this.constraints)
            return;
        this.stopAnimation();
        const $ = {
            x: 0,
            y: 0
        };
        eachAxis(tt=>{
            const rt = this.getAxisMotionValue(tt);
            if (rt) {
                const nt = rt.get();
                $[tt] = calcOrigin({
                    min: nt,
                    max: nt
                }, this.constraints[tt])
            }
        }
        );
        const {transformTemplate: et} = this.visualElement.getProps();
        this.visualElement.current.style.transform = et ? et({}, "") : "none",
        _.root && _.root.updateScroll(),
        _.updateLayout(),
        this.resolveConstraints(),
        eachAxis(tt=>{
            if (!shouldDrag(tt, g, null))
                return;
            const rt = this.getAxisMotionValue(tt)
              , {min: nt, max: it} = this.constraints[tt];
            rt.set(mix(nt, it, $[tt]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        elementDragControls.set(this.visualElement, this);
        const g = this.visualElement.current
          , b = addPointerEvent(g, "pointerdown", nt=>{
            const {drag: it, dragListener: ot=!0} = this.getProps();
            it && ot && this.start(nt)
        }
        )
          , _ = ()=>{
            const {dragConstraints: nt} = this.getProps();
            isRefObject(nt) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: $} = this.visualElement
          , et = $.addEventListener("measure", _);
        $ && !$.layout && ($.root && $.root.updateScroll(),
        $.updateLayout()),
        _();
        const tt = addDomEvent(window, "resize", ()=>this.scalePositionWithinConstraints())
          , rt = $.addEventListener("didUpdate", ({delta: nt, hasLayoutChanged: it})=>{
            this.isDragging && it && (eachAxis(ot=>{
                const at = this.getAxisMotionValue(ot);
                at && (this.originPoint[ot] += nt[ot].translate,
                at.set(at.get() + nt[ot].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return ()=>{
            tt(),
            b(),
            et(),
            rt && rt()
        }
    }
    getProps() {
        const g = this.visualElement.getProps()
          , {drag: b=!1, dragDirectionLock: _=!1, dragPropagation: $=!1, dragConstraints: et=!1, dragElastic: tt=defaultElastic, dragMomentum: rt=!0} = g;
        return {
            ...g,
            drag: b,
            dragDirectionLock: _,
            dragPropagation: $,
            dragConstraints: et,
            dragElastic: tt,
            dragMomentum: rt
        }
    }
}
function shouldDrag(d, g, b) {
    return (g === !0 || g === d) && (b === null || b === d)
}
function getCurrentDirection(d, g=10) {
    let b = null;
    return Math.abs(d.y) > g ? b = "y" : Math.abs(d.x) > g && (b = "x"),
    b
}
class DragGesture extends Feature {
    constructor(g) {
        super(g),
        this.removeGroupControls = noop,
        this.removeListeners = noop,
        this.controls = new VisualElementDragControls(g)
    }
    mount() {
        const {dragControls: g} = this.node.getProps();
        g && (this.removeGroupControls = g.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || noop
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const asyncHandler = d=>(g,b)=>{
    d && frame.update(()=>d(g, b))
}
;
class PanGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = noop
    }
    onPointerDown(g) {
        this.session = new PanSession(g,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: g, onPanStart: b, onPan: _, onPanEnd: $} = this.node.getProps();
        return {
            onSessionStart: asyncHandler(g),
            onStart: asyncHandler(b),
            onMove: _,
            onEnd: (et,tt)=>{
                delete this.session,
                $ && frame.update(()=>$(et, tt))
            }
        }
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", g=>this.onPointerDown(g))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function usePresence() {
    const d = reactExports.useContext(PresenceContext);
    if (d === null)
        return [!0, null];
    const {isPresent: g, onExitComplete: b, register: _} = d
      , $ = reactExports.useId();
    return reactExports.useEffect(()=>_($), []),
    !g && b ? [!1, ()=>b && b($)] : [!0]
}
const globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function pixelsToPercent(d, g) {
    return g.max === g.min ? 0 : d / (g.max - g.min) * 100
}
const correctBorderRadius = {
    correct: (d,g)=>{
        if (!g.target)
            return d;
        if (typeof d == "string")
            if (px$1.test(d))
                d = parseFloat(d);
            else
                return d;
        const b = pixelsToPercent(d, g.target.x)
          , _ = pixelsToPercent(d, g.target.y);
        return `${b}% ${_}%`
    }
}
  , correctBoxShadow = {
    correct: (d,{treeScale: g, projectionDelta: b})=>{
        const _ = d
          , $ = complex.parse(d);
        if ($.length > 5)
            return _;
        const et = complex.createTransformer(d)
          , tt = typeof $[0] != "number" ? 1 : 0
          , rt = b.x.scale * g.x
          , nt = b.y.scale * g.y;
        $[0 + tt] /= rt,
        $[1 + tt] /= nt;
        const it = mix(rt, nt, .5);
        return typeof $[2 + tt] == "number" && ($[2 + tt] /= it),
        typeof $[3 + tt] == "number" && ($[3 + tt] /= it),
        et($)
    }
};
class MeasureLayoutWithContext extends React.Component {
    componentDidMount() {
        const {visualElement: g, layoutGroup: b, switchLayoutGroup: _, layoutId: $} = this.props
          , {projection: et} = g;
        addScaleCorrector(defaultScaleCorrectors),
        et && (b.group && b.group.add(et),
        _ && _.register && $ && _.register(et),
        et.root.didUpdate(),
        et.addEventListener("animationComplete", ()=>{
            this.safeToRemove()
        }
        ),
        et.setOptions({
            ...et.options,
            onExitComplete: ()=>this.safeToRemove()
        })),
        globalProjectionState.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(g) {
        const {layoutDependency: b, visualElement: _, drag: $, isPresent: et} = this.props
          , tt = _.projection;
        return tt && (tt.isPresent = et,
        $ || g.layoutDependency !== b || b === void 0 ? tt.willUpdate() : this.safeToRemove(),
        g.isPresent !== et && (et ? tt.promote() : tt.relegate() || frame.postRender(()=>{
            const rt = tt.getStack();
            (!rt || !rt.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: g} = this.props.visualElement;
        g && (g.root.didUpdate(),
        queueMicrotask(()=>{
            !g.currentAnimation && g.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: g, layoutGroup: b, switchLayoutGroup: _} = this.props
          , {projection: $} = g;
        $ && ($.scheduleCheckAfterUnmount(),
        b && b.group && b.group.remove($),
        _ && _.deregister && _.deregister($))
    }
    safeToRemove() {
        const {safeToRemove: g} = this.props;
        g && g()
    }
    render() {
        return null
    }
}
function MeasureLayout(d) {
    const [g,b] = usePresence()
      , _ = reactExports.useContext(LayoutGroupContext);
    return React.createElement(MeasureLayoutWithContext, {
        ...d,
        layoutGroup: _,
        switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
        isPresent: g,
        safeToRemove: b
    })
}
const defaultScaleCorrectors = {
    borderRadius: {
        ...correctBorderRadius,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
}
  , borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , numBorders = borders.length
  , asNumber = d=>typeof d == "string" ? parseFloat(d) : d
  , isPx = d=>typeof d == "number" || px$1.test(d);
function mixValues(d, g, b, _, $, et) {
    $ ? (d.opacity = mix(0, b.opacity !== void 0 ? b.opacity : 1, easeCrossfadeIn(_)),
    d.opacityExit = mix(g.opacity !== void 0 ? g.opacity : 1, 0, easeCrossfadeOut(_))) : et && (d.opacity = mix(g.opacity !== void 0 ? g.opacity : 1, b.opacity !== void 0 ? b.opacity : 1, _));
    for (let tt = 0; tt < numBorders; tt++) {
        const rt = `border${borders[tt]}Radius`;
        let nt = getRadius(g, rt)
          , it = getRadius(b, rt);
        if (nt === void 0 && it === void 0)
            continue;
        nt || (nt = 0),
        it || (it = 0),
        nt === 0 || it === 0 || isPx(nt) === isPx(it) ? (d[rt] = Math.max(mix(asNumber(nt), asNumber(it), _), 0),
        (percent.test(it) || percent.test(nt)) && (d[rt] += "%")) : d[rt] = it
    }
    (g.rotate || b.rotate) && (d.rotate = mix(g.rotate || 0, b.rotate || 0, _))
}
function getRadius(d, g) {
    return d[g] !== void 0 ? d[g] : d.borderRadius
}
const easeCrossfadeIn = compress(0, .5, circOut)
  , easeCrossfadeOut = compress(.5, .95, noop);
function compress(d, g, b) {
    return _=>_ < d ? 0 : _ > g ? 1 : b(progress(d, g, _))
}
function copyAxisInto(d, g) {
    d.min = g.min,
    d.max = g.max
}
function copyBoxInto(d, g) {
    copyAxisInto(d.x, g.x),
    copyAxisInto(d.y, g.y)
}
function removePointDelta(d, g, b, _, $) {
    return d -= g,
    d = scalePoint(d, 1 / b, _),
    $ !== void 0 && (d = scalePoint(d, 1 / $, _)),
    d
}
function removeAxisDelta(d, g=0, b=1, _=.5, $, et=d, tt=d) {
    if (percent.test(g) && (g = parseFloat(g),
    g = mix(tt.min, tt.max, g / 100) - tt.min),
    typeof g != "number")
        return;
    let rt = mix(et.min, et.max, _);
    d === et && (rt -= g),
    d.min = removePointDelta(d.min, g, b, rt, $),
    d.max = removePointDelta(d.max, g, b, rt, $)
}
function removeAxisTransforms(d, g, [b,_,$], et, tt) {
    removeAxisDelta(d, g[b], g[_], g[$], g.scale, et, tt)
}
const xKeys = ["x", "scaleX", "originX"]
  , yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(d, g, b, _) {
    removeAxisTransforms(d.x, g, xKeys, b ? b.x : void 0, _ ? _.x : void 0),
    removeAxisTransforms(d.y, g, yKeys, b ? b.y : void 0, _ ? _.y : void 0)
}
function isAxisDeltaZero(d) {
    return d.translate === 0 && d.scale === 1
}
function isDeltaZero(d) {
    return isAxisDeltaZero(d.x) && isAxisDeltaZero(d.y)
}
function boxEquals(d, g) {
    return d.x.min === g.x.min && d.x.max === g.x.max && d.y.min === g.y.min && d.y.max === g.y.max
}
function boxEqualsRounded(d, g) {
    return Math.round(d.x.min) === Math.round(g.x.min) && Math.round(d.x.max) === Math.round(g.x.max) && Math.round(d.y.min) === Math.round(g.y.min) && Math.round(d.y.max) === Math.round(g.y.max)
}
function aspectRatio(d) {
    return calcLength(d.x) / calcLength(d.y)
}
class NodeStack {
    constructor() {
        this.members = []
    }
    add(g) {
        addUniqueItem(this.members, g),
        g.scheduleRender()
    }
    remove(g) {
        if (removeItem(this.members, g),
        g === this.prevLead && (this.prevLead = void 0),
        g === this.lead) {
            const b = this.members[this.members.length - 1];
            b && this.promote(b)
        }
    }
    relegate(g) {
        const b = this.members.findIndex($=>g === $);
        if (b === 0)
            return !1;
        let _;
        for (let $ = b; $ >= 0; $--) {
            const et = this.members[$];
            if (et.isPresent !== !1) {
                _ = et;
                break
            }
        }
        return _ ? (this.promote(_),
        !0) : !1
    }
    promote(g, b) {
        const _ = this.lead;
        if (g !== _ && (this.prevLead = _,
        this.lead = g,
        g.show(),
        _)) {
            _.instance && _.scheduleRender(),
            g.scheduleRender(),
            g.resumeFrom = _,
            b && (g.resumeFrom.preserveOpacity = !0),
            _.snapshot && (g.snapshot = _.snapshot,
            g.snapshot.latestValues = _.animationValues || _.latestValues),
            g.root && g.root.isUpdating && (g.isLayoutDirty = !0);
            const {crossfade: $} = g.options;
            $ === !1 && _.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(g=>{
            const {options: b, resumingFrom: _} = g;
            b.onExitComplete && b.onExitComplete(),
            _ && _.options.onExitComplete && _.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(g=>{
            g.instance && g.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function buildProjectionTransform(d, g, b) {
    let _ = "";
    const $ = d.x.translate / g.x
      , et = d.y.translate / g.y;
    if (($ || et) && (_ = `translate3d(${$}px, ${et}px, 0) `),
    (g.x !== 1 || g.y !== 1) && (_ += `scale(${1 / g.x}, ${1 / g.y}) `),
    b) {
        const {rotate: nt, rotateX: it, rotateY: ot} = b;
        nt && (_ += `rotate(${nt}deg) `),
        it && (_ += `rotateX(${it}deg) `),
        ot && (_ += `rotateY(${ot}deg) `)
    }
    const tt = d.x.scale * g.x
      , rt = d.y.scale * g.y;
    return (tt !== 1 || rt !== 1) && (_ += `scale(${tt}, ${rt})`),
    _ || "none"
}
const compareByDepth = (d,g)=>d.depth - g.depth;
class FlatTree {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(g) {
        addUniqueItem(this.children, g),
        this.isDirty = !0
    }
    remove(g) {
        removeItem(this.children, g),
        this.isDirty = !0
    }
    forEach(g) {
        this.isDirty && this.children.sort(compareByDepth),
        this.isDirty = !1,
        this.children.forEach(g)
    }
}
function delay(d, g) {
    const b = performance.now()
      , _ = ({timestamp: $})=>{
        const et = $ - b;
        et >= g && (cancelFrame(_),
        d(et - g))
    }
    ;
    return frame.read(_, !0),
    ()=>cancelFrame(_)
}
function record(d) {
    window.MotionDebug && window.MotionDebug.record(d)
}
function isSVGElement(d) {
    return d instanceof SVGElement && d.tagName !== "svg"
}
function animateSingleValue(d, g, b) {
    const _ = isMotionValue(d) ? d : motionValue(d);
    return _.start(animateMotionValue("", _, g, b)),
    _.animation
}
const transformAxes = ["", "X", "Y", "Z"]
  , hiddenVisibility = {
    visibility: "hidden"
}
  , animationTarget = 1e3;
let id$2 = 0;
const projectionFrameData = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function createProjectionNode({attachResizeListener: d, defaultParent: g, measureScroll: b, checkIsScrollRoot: _, resetTransform: $}) {
    return class {
        constructor(tt={}, rt=g == null ? void 0 : g()) {
            this.id = id$2++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = ()=>{
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = ()=>{
                this.projectionUpdateScheduled = !1,
                projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0,
                this.nodes.forEach(propagateDirtyNodes),
                this.nodes.forEach(resolveTargetDelta),
                this.nodes.forEach(calcProjection),
                this.nodes.forEach(cleanDirtyNodes),
                record(projectionFrameData)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = tt,
            this.root = rt ? rt.root || rt : this,
            this.path = rt ? [...rt.path, rt] : [],
            this.parent = rt,
            this.depth = rt ? rt.depth + 1 : 0;
            for (let nt = 0; nt < this.path.length; nt++)
                this.path[nt].shouldResetTransform = !0;
            this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(tt, rt) {
            return this.eventHandlers.has(tt) || this.eventHandlers.set(tt, new SubscriptionManager),
            this.eventHandlers.get(tt).add(rt)
        }
        notifyListeners(tt, ...rt) {
            const nt = this.eventHandlers.get(tt);
            nt && nt.notify(...rt)
        }
        hasListeners(tt) {
            return this.eventHandlers.has(tt)
        }
        mount(tt, rt=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = isSVGElement(tt),
            this.instance = tt;
            const {layoutId: nt, layout: it, visualElement: ot} = this.options;
            if (ot && !ot.current && ot.mount(tt),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            rt && (it || nt) && (this.isLayoutDirty = !0),
            d) {
                let at;
                const st = ()=>this.root.updateBlockedByResize = !1;
                d(tt, ()=>{
                    this.root.updateBlockedByResize = !0,
                    at && at(),
                    at = delay(st, 250),
                    globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(finishAnimation))
                }
                )
            }
            nt && this.root.registerSharedNode(nt, this),
            this.options.animate !== !1 && ot && (nt || it) && this.addEventListener("didUpdate", ({delta: at, hasLayoutChanged: st, hasRelativeTargetChanged: dt, layout: ft})=>{
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const ht = this.options.transition || ot.getDefaultTransition() || defaultLayoutTransition
                  , {onLayoutAnimationStart: xt, onLayoutAnimationComplete: lt} = ot.getProps()
                  , ct = !this.targetLayout || !boxEqualsRounded(this.targetLayout, ft) || dt
                  , ut = !st && dt;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || ut || st && (ct || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(at, ut);
                    const pt = {
                        ...getValueTransition(ht, "layout"),
                        onPlay: xt,
                        onComplete: lt
                    };
                    (ot.shouldReduceMotion || this.options.layoutRoot) && (pt.delay = 0,
                    pt.type = !1),
                    this.startAnimation(pt)
                } else
                    st || finishAnimation(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = ft
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const tt = this.getStack();
            tt && tt.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            cancelFrame(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(resetRotation),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: tt} = this.options;
            return tt && tt.getProps().transformTemplate
        }
        willUpdate(tt=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let ot = 0; ot < this.path.length; ot++) {
                const at = this.path[ot];
                at.shouldResetTransform = !0,
                at.updateScroll("snapshot"),
                at.options.layoutRoot && at.willUpdate(!1)
            }
            const {layoutId: rt, layout: nt} = this.options;
            if (rt === void 0 && !nt)
                return;
            const it = this.getTransformTemplate();
            this.prevTransformTemplateValue = it ? it(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            tt && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(clearMeasurements);
                return
            }
            this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
            this.isUpdating = !1,
            this.nodes.forEach(resetTransformStyle),
            this.nodes.forEach(updateLayout),
            this.nodes.forEach(notifyLayoutUpdate),
            this.clearAllSnapshots();
            const rt = performance.now();
            frameData.delta = clamp(0, 1e3 / 60, rt - frameData.timestamp),
            frameData.timestamp = rt,
            frameData.isProcessing = !0,
            steps.update.process(frameData),
            steps.preRender.process(frameData),
            steps.render.process(frameData),
            frameData.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            queueMicrotask(()=>this.update()))
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot),
            this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            frame.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            frame.postRender(()=>{
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let nt = 0; nt < this.path.length; nt++)
                    this.path[nt].updateScroll();
            const tt = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = createBox(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: rt} = this.options;
            rt && rt.notify("LayoutMeasure", this.layout.layoutBox, tt ? tt.layoutBox : void 0)
        }
        updateScroll(tt="measure") {
            let rt = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === tt && (rt = !1),
            rt && (this.scroll = {
                animationId: this.root.animationId,
                phase: tt,
                isRoot: _(this.instance),
                offset: b(this.instance)
            })
        }
        resetTransform() {
            if (!$)
                return;
            const tt = this.isLayoutDirty || this.shouldResetTransform
              , rt = this.projectionDelta && !isDeltaZero(this.projectionDelta)
              , nt = this.getTransformTemplate()
              , it = nt ? nt(this.latestValues, "") : void 0
              , ot = it !== this.prevTransformTemplateValue;
            tt && (rt || hasTransform(this.latestValues) || ot) && ($(this.instance, it),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(tt=!0) {
            const rt = this.measurePageBox();
            let nt = this.removeElementScroll(rt);
            return tt && (nt = this.removeTransform(nt)),
            roundBox(nt),
            {
                animationId: this.root.animationId,
                measuredBox: rt,
                layoutBox: nt,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: tt} = this.options;
            if (!tt)
                return createBox();
            const rt = tt.measureViewportBox()
              , {scroll: nt} = this.root;
            return nt && (translateAxis(rt.x, nt.offset.x),
            translateAxis(rt.y, nt.offset.y)),
            rt
        }
        removeElementScroll(tt) {
            const rt = createBox();
            copyBoxInto(rt, tt);
            for (let nt = 0; nt < this.path.length; nt++) {
                const it = this.path[nt]
                  , {scroll: ot, options: at} = it;
                if (it !== this.root && ot && at.layoutScroll) {
                    if (ot.isRoot) {
                        copyBoxInto(rt, tt);
                        const {scroll: st} = this.root;
                        st && (translateAxis(rt.x, -st.offset.x),
                        translateAxis(rt.y, -st.offset.y))
                    }
                    translateAxis(rt.x, ot.offset.x),
                    translateAxis(rt.y, ot.offset.y)
                }
            }
            return rt
        }
        applyTransform(tt, rt=!1) {
            const nt = createBox();
            copyBoxInto(nt, tt);
            for (let it = 0; it < this.path.length; it++) {
                const ot = this.path[it];
                !rt && ot.options.layoutScroll && ot.scroll && ot !== ot.root && transformBox(nt, {
                    x: -ot.scroll.offset.x,
                    y: -ot.scroll.offset.y
                }),
                hasTransform(ot.latestValues) && transformBox(nt, ot.latestValues)
            }
            return hasTransform(this.latestValues) && transformBox(nt, this.latestValues),
            nt
        }
        removeTransform(tt) {
            const rt = createBox();
            copyBoxInto(rt, tt);
            for (let nt = 0; nt < this.path.length; nt++) {
                const it = this.path[nt];
                if (!it.instance || !hasTransform(it.latestValues))
                    continue;
                hasScale(it.latestValues) && it.updateSnapshot();
                const ot = createBox()
                  , at = it.measurePageBox();
                copyBoxInto(ot, at),
                removeBoxTransforms(rt, it.latestValues, it.snapshot ? it.snapshot.layoutBox : void 0, ot)
            }
            return hasTransform(this.latestValues) && removeBoxTransforms(rt, this.latestValues),
            rt
        }
        setTargetDelta(tt) {
            this.targetDelta = tt,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(tt) {
            this.options = {
                ...this.options,
                ...tt,
                crossfade: tt.crossfade !== void 0 ? tt.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(tt=!1) {
            var rt;
            const nt = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = nt.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = nt.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = nt.isSharedProjectionDirty);
            const it = !!this.resumingFrom || this !== nt;
            if (!(tt || it && this.isSharedProjectionDirty || this.isProjectionDirty || !((rt = this.parent) === null || rt === void 0) && rt.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: at, layoutId: st} = this.options;
            if (!(!this.layout || !(at || st))) {
                if (this.resolvedRelativeTargetAt = frameData.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const dt = this.getClosestProjectingParent();
                    dt && dt.layout && this.animationProgress !== 1 ? (this.relativeParent = dt,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = createBox(),
                    this.relativeTargetOrigin = createBox(),
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, dt.layout.layoutBox),
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = createBox(),
                    this.targetWithTransforms = createBox()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                    applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const dt = this.getClosestProjectingParent();
                        dt && !!dt.resumingFrom == !!this.resumingFrom && !dt.options.layoutScroll && dt.target && this.animationProgress !== 1 ? (this.relativeParent = dt,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = createBox(),
                        this.relativeTargetOrigin = createBox(),
                        calcRelativePosition(this.relativeTargetOrigin, this.target, dt.target),
                        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    projectionFrameData.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var tt;
            const rt = this.getLead()
              , nt = !!this.resumingFrom || this !== rt;
            let it = !0;
            if ((this.isProjectionDirty || !((tt = this.parent) === null || tt === void 0) && tt.isProjectionDirty) && (it = !1),
            nt && (this.isSharedProjectionDirty || this.isTransformDirty) && (it = !1),
            this.resolvedRelativeTargetAt === frameData.timestamp && (it = !1),
            it)
                return;
            const {layout: ot, layoutId: at} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(ot || at))
                return;
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            const st = this.treeScale.x
              , dt = this.treeScale.y;
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, nt),
            rt.layout && !rt.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (rt.target = rt.layout.layoutBox);
            const {target: ft} = rt;
            if (!ft) {
                this.projectionTransform && (this.projectionDelta = createDelta(),
                this.projectionTransform = "none",
                this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = createDelta(),
            this.projectionDeltaWithTransform = createDelta());
            const ht = this.projectionTransform;
            calcBoxDelta(this.projectionDelta, this.layoutCorrected, ft, this.latestValues),
            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== ht || this.treeScale.x !== st || this.treeScale.y !== dt) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", ft)),
            projectionFrameData.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(tt=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            tt) {
                const rt = this.getStack();
                rt && rt.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(tt, rt=!1) {
            const nt = this.snapshot
              , it = nt ? nt.latestValues : {}
              , ot = {
                ...this.latestValues
            }
              , at = createDelta();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !rt;
            const st = createBox()
              , dt = nt ? nt.source : void 0
              , ft = this.layout ? this.layout.source : void 0
              , ht = dt !== ft
              , xt = this.getStack()
              , lt = !xt || xt.members.length <= 1
              , ct = !!(ht && !lt && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let ut;
            this.mixTargetDelta = pt=>{
                const vt = pt / 1e3;
                mixAxisDelta(at.x, tt.x, vt),
                mixAxisDelta(at.y, tt.y, vt),
                this.setTargetDelta(at),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(st, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                mixBox(this.relativeTarget, this.relativeTargetOrigin, st, vt),
                ut && boxEquals(this.relativeTarget, ut) && (this.isProjectionDirty = !1),
                ut || (ut = createBox()),
                copyBoxInto(ut, this.relativeTarget)),
                ht && (this.animationValues = ot,
                mixValues(ot, it, this.latestValues, vt, ct, lt)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = vt
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(tt) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (cancelFrame(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = frame.update(()=>{
                globalProjectionState.hasAnimatedSinceResize = !0,
                this.currentAnimation = animateSingleValue(0, animationTarget, {
                    ...tt,
                    onUpdate: rt=>{
                        this.mixTargetDelta(rt),
                        tt.onUpdate && tt.onUpdate(rt)
                    }
                    ,
                    onComplete: ()=>{
                        tt.onComplete && tt.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const tt = this.getStack();
            tt && tt.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const tt = this.getLead();
            let {targetWithTransforms: rt, target: nt, layout: it, latestValues: ot} = tt;
            if (!(!rt || !nt || !it)) {
                if (this !== tt && this.layout && it && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, it.layoutBox)) {
                    nt = this.target || createBox();
                    const at = calcLength(this.layout.layoutBox.x);
                    nt.x.min = tt.target.x.min,
                    nt.x.max = nt.x.min + at;
                    const st = calcLength(this.layout.layoutBox.y);
                    nt.y.min = tt.target.y.min,
                    nt.y.max = nt.y.min + st
                }
                copyBoxInto(rt, nt),
                transformBox(rt, ot),
                calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, rt, ot)
            }
        }
        registerSharedNode(tt, rt) {
            this.sharedNodes.has(tt) || this.sharedNodes.set(tt, new NodeStack),
            this.sharedNodes.get(tt).add(rt);
            const it = rt.options.initialPromotionConfig;
            rt.promote({
                transition: it ? it.transition : void 0,
                preserveFollowOpacity: it && it.shouldPreserveFollowOpacity ? it.shouldPreserveFollowOpacity(rt) : void 0
            })
        }
        isLead() {
            const tt = this.getStack();
            return tt ? tt.lead === this : !0
        }
        getLead() {
            var tt;
            const {layoutId: rt} = this.options;
            return rt ? ((tt = this.getStack()) === null || tt === void 0 ? void 0 : tt.lead) || this : this
        }
        getPrevLead() {
            var tt;
            const {layoutId: rt} = this.options;
            return rt ? (tt = this.getStack()) === null || tt === void 0 ? void 0 : tt.prevLead : void 0
        }
        getStack() {
            const {layoutId: tt} = this.options;
            if (tt)
                return this.root.sharedNodes.get(tt)
        }
        promote({needsReset: tt, transition: rt, preserveFollowOpacity: nt}={}) {
            const it = this.getStack();
            it && it.promote(this, nt),
            tt && (this.projectionDelta = void 0,
            this.needsReset = !0),
            rt && this.setOptions({
                transition: rt
            })
        }
        relegate() {
            const tt = this.getStack();
            return tt ? tt.relegate(this) : !1
        }
        resetRotation() {
            const {visualElement: tt} = this.options;
            if (!tt)
                return;
            let rt = !1;
            const {latestValues: nt} = tt;
            if ((nt.rotate || nt.rotateX || nt.rotateY || nt.rotateZ) && (rt = !0),
            !rt)
                return;
            const it = {};
            for (let ot = 0; ot < transformAxes.length; ot++) {
                const at = "rotate" + transformAxes[ot];
                nt[at] && (it[at] = nt[at],
                tt.setStaticValue(at, 0))
            }
            tt.render();
            for (const ot in it)
                tt.setStaticValue(ot, it[ot]);
            tt.scheduleRender()
        }
        getProjectionStyles(tt) {
            var rt, nt;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return hiddenVisibility;
            const it = {
                visibility: ""
            }
              , ot = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                it.opacity = "",
                it.pointerEvents = resolveMotionValue(tt == null ? void 0 : tt.pointerEvents) || "",
                it.transform = ot ? ot(this.latestValues, "") : "none",
                it;
            const at = this.getLead();
            if (!this.projectionDelta || !this.layout || !at.target) {
                const ht = {};
                return this.options.layoutId && (ht.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                ht.pointerEvents = resolveMotionValue(tt == null ? void 0 : tt.pointerEvents) || ""),
                this.hasProjected && !hasTransform(this.latestValues) && (ht.transform = ot ? ot({}, "") : "none",
                this.hasProjected = !1),
                ht
            }
            const st = at.animationValues || at.latestValues;
            this.applyTransformsToTarget(),
            it.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, st),
            ot && (it.transform = ot(st, it.transform));
            const {x: dt, y: ft} = this.projectionDelta;
            it.transformOrigin = `${dt.origin * 100}% ${ft.origin * 100}% 0`,
            at.animationValues ? it.opacity = at === this ? (nt = (rt = st.opacity) !== null && rt !== void 0 ? rt : this.latestValues.opacity) !== null && nt !== void 0 ? nt : 1 : this.preserveOpacity ? this.latestValues.opacity : st.opacityExit : it.opacity = at === this ? st.opacity !== void 0 ? st.opacity : "" : st.opacityExit !== void 0 ? st.opacityExit : 0;
            for (const ht in scaleCorrectors) {
                if (st[ht] === void 0)
                    continue;
                const {correct: xt, applyTo: lt} = scaleCorrectors[ht]
                  , ct = it.transform === "none" ? st[ht] : xt(st[ht], at);
                if (lt) {
                    const ut = lt.length;
                    for (let pt = 0; pt < ut; pt++)
                        it[lt[pt]] = ct
                } else
                    it[ht] = ct
            }
            return this.options.layoutId && (it.pointerEvents = at === this ? resolveMotionValue(tt == null ? void 0 : tt.pointerEvents) || "" : "none"),
            it
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(tt=>{
                var rt;
                return (rt = tt.currentAnimation) === null || rt === void 0 ? void 0 : rt.stop()
            }
            ),
            this.root.nodes.forEach(clearMeasurements),
            this.root.sharedNodes.clear()
        }
    }
}
function updateLayout(d) {
    d.updateLayout()
}
function notifyLayoutUpdate(d) {
    var g;
    const b = ((g = d.resumeFrom) === null || g === void 0 ? void 0 : g.snapshot) || d.snapshot;
    if (d.isLead() && d.layout && b && d.hasListeners("didUpdate")) {
        const {layoutBox: _, measuredBox: $} = d.layout
          , {animationType: et} = d.options
          , tt = b.source !== d.layout.source;
        et === "size" ? eachAxis(at=>{
            const st = tt ? b.measuredBox[at] : b.layoutBox[at]
              , dt = calcLength(st);
            st.min = _[at].min,
            st.max = st.min + dt
        }
        ) : shouldAnimatePositionOnly(et, b.layoutBox, _) && eachAxis(at=>{
            const st = tt ? b.measuredBox[at] : b.layoutBox[at]
              , dt = calcLength(_[at]);
            st.max = st.min + dt,
            d.relativeTarget && !d.currentAnimation && (d.isProjectionDirty = !0,
            d.relativeTarget[at].max = d.relativeTarget[at].min + dt)
        }
        );
        const rt = createDelta();
        calcBoxDelta(rt, _, b.layoutBox);
        const nt = createDelta();
        tt ? calcBoxDelta(nt, d.applyTransform($, !0), b.measuredBox) : calcBoxDelta(nt, _, b.layoutBox);
        const it = !isDeltaZero(rt);
        let ot = !1;
        if (!d.resumeFrom) {
            const at = d.getClosestProjectingParent();
            if (at && !at.resumeFrom) {
                const {snapshot: st, layout: dt} = at;
                if (st && dt) {
                    const ft = createBox();
                    calcRelativePosition(ft, b.layoutBox, st.layoutBox);
                    const ht = createBox();
                    calcRelativePosition(ht, _, dt.layoutBox),
                    boxEqualsRounded(ft, ht) || (ot = !0),
                    at.options.layoutRoot && (d.relativeTarget = ht,
                    d.relativeTargetOrigin = ft,
                    d.relativeParent = at)
                }
            }
        }
        d.notifyListeners("didUpdate", {
            layout: _,
            snapshot: b,
            delta: nt,
            layoutDelta: rt,
            hasLayoutChanged: it,
            hasRelativeTargetChanged: ot
        })
    } else if (d.isLead()) {
        const {onExitComplete: _} = d.options;
        _ && _()
    }
    d.options.transition = void 0
}
function propagateDirtyNodes(d) {
    projectionFrameData.totalNodes++,
    d.parent && (d.isProjecting() || (d.isProjectionDirty = d.parent.isProjectionDirty),
    d.isSharedProjectionDirty || (d.isSharedProjectionDirty = !!(d.isProjectionDirty || d.parent.isProjectionDirty || d.parent.isSharedProjectionDirty)),
    d.isTransformDirty || (d.isTransformDirty = d.parent.isTransformDirty))
}
function cleanDirtyNodes(d) {
    d.isProjectionDirty = d.isSharedProjectionDirty = d.isTransformDirty = !1
}
function clearSnapshot(d) {
    d.clearSnapshot()
}
function clearMeasurements(d) {
    d.clearMeasurements()
}
function clearIsLayoutDirty(d) {
    d.isLayoutDirty = !1
}
function resetTransformStyle(d) {
    const {visualElement: g} = d.options;
    g && g.getProps().onBeforeLayoutMeasure && g.notify("BeforeLayoutMeasure"),
    d.resetTransform()
}
function finishAnimation(d) {
    d.finishAnimation(),
    d.targetDelta = d.relativeTarget = d.target = void 0,
    d.isProjectionDirty = !0
}
function resolveTargetDelta(d) {
    d.resolveTargetDelta()
}
function calcProjection(d) {
    d.calcProjection()
}
function resetRotation(d) {
    d.resetRotation()
}
function removeLeadSnapshots(d) {
    d.removeLeadSnapshot()
}
function mixAxisDelta(d, g, b) {
    d.translate = mix(g.translate, 0, b),
    d.scale = mix(g.scale, 1, b),
    d.origin = g.origin,
    d.originPoint = g.originPoint
}
function mixAxis(d, g, b, _) {
    d.min = mix(g.min, b.min, _),
    d.max = mix(g.max, b.max, _)
}
function mixBox(d, g, b, _) {
    mixAxis(d.x, g.x, b.x, _),
    mixAxis(d.y, g.y, b.y, _)
}
function hasOpacityCrossfade(d) {
    return d.animationValues && d.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , userAgentContains = d=>typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(d)
  , roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(d) {
    d.min = roundPoint(d.min),
    d.max = roundPoint(d.max)
}
function roundBox(d) {
    roundAxis(d.x),
    roundAxis(d.y)
}
function shouldAnimatePositionOnly(d, g, b) {
    return d === "position" || d === "preserve-aspect" && !isNear(aspectRatio(g), aspectRatio(b), .2)
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (d,g)=>addDomEvent(d, "resize", g),
    measureScroll: ()=>({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: ()=>!0
})
  , rootProjectionNode = {
    current: void 0
}
  , HTMLProjectionNode = createProjectionNode({
    measureScroll: d=>({
        x: d.scrollLeft,
        y: d.scrollTop
    }),
    defaultParent: ()=>{
        if (!rootProjectionNode.current) {
            const d = new DocumentProjectionNode({});
            d.mount(window),
            d.setOptions({
                layoutScroll: !0
            }),
            rootProjectionNode.current = d
        }
        return rootProjectionNode.current
    }
    ,
    resetTransform: (d,g)=>{
        d.style.transform = g !== void 0 ? g : "none"
    }
    ,
    checkIsScrollRoot: d=>window.getComputedStyle(d).position === "fixed"
})
  , drag = {
    pan: {
        Feature: PanGesture
    },
    drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(d) {
    const g = splitCSSVariableRegex.exec(d);
    if (!g)
        return [, ];
    const [,b,_] = g;
    return [b, _]
}
function getVariableValue(d, g, b=1) {
    const [_,$] = parseCSSVariable(d);
    if (!_)
        return;
    const et = window.getComputedStyle(g).getPropertyValue(_);
    if (et) {
        const tt = et.trim();
        return isNumericalString(tt) ? parseFloat(tt) : tt
    } else
        return isCSSVariableToken($) ? getVariableValue($, g, b + 1) : $
}
function resolveCSSVariables(d, {...g}, b) {
    const _ = d.current;
    if (!(_ instanceof Element))
        return {
            target: g,
            transitionEnd: b
        };
    b && (b = {
        ...b
    }),
    d.values.forEach($=>{
        const et = $.get();
        if (!isCSSVariableToken(et))
            return;
        const tt = getVariableValue(et, _);
        tt && $.set(tt)
    }
    );
    for (const $ in g) {
        const et = g[$];
        if (!isCSSVariableToken(et))
            continue;
        const tt = getVariableValue(et, _);
        tt && (g[$] = tt,
        b || (b = {}),
        b[$] === void 0 && (b[$] = et))
    }
    return {
        target: g,
        transitionEnd: b
    }
}
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , isPositionalKey = d=>positionalKeys.has(d)
  , hasPositionalKey = d=>Object.keys(d).some(isPositionalKey)
  , isNumOrPxType = d=>d === number || d === px$1
  , getPosFromMatrix = (d,g)=>parseFloat(d.split(", ")[g])
  , getTranslateFromMatrix = (d,g)=>(b,{transform: _})=>{
    if (_ === "none" || !_)
        return 0;
    const $ = _.match(/^matrix3d\((.+)\)$/);
    if ($)
        return getPosFromMatrix($[1], g);
    {
        const et = _.match(/^matrix\((.+)\)$/);
        return et ? getPosFromMatrix(et[1], d) : 0
    }
}
  , transformKeys = new Set(["x", "y", "z"])
  , nonTranslationalTransformKeys = transformPropOrder.filter(d=>!transformKeys.has(d));
function removeNonTranslationalTransform(d) {
    const g = [];
    return nonTranslationalTransformKeys.forEach(b=>{
        const _ = d.getValue(b);
        _ !== void 0 && (g.push([b, _.get()]),
        _.set(b.startsWith("scale") ? 1 : 0))
    }
    ),
    g.length && d.render(),
    g
}
const positionalValues = {
    width: ({x: d},{paddingLeft: g="0", paddingRight: b="0"})=>d.max - d.min - parseFloat(g) - parseFloat(b),
    height: ({y: d},{paddingTop: g="0", paddingBottom: b="0"})=>d.max - d.min - parseFloat(g) - parseFloat(b),
    top: (d,{top: g})=>parseFloat(g),
    left: (d,{left: g})=>parseFloat(g),
    bottom: ({y: d},{top: g})=>parseFloat(g) + (d.max - d.min),
    right: ({x: d},{left: g})=>parseFloat(g) + (d.max - d.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const convertChangedValueTypes = (d,g,b)=>{
    const _ = g.measureViewportBox()
      , $ = g.current
      , et = getComputedStyle($)
      , {display: tt} = et
      , rt = {};
    tt === "none" && g.setStaticValue("display", d.display || "block"),
    b.forEach(it=>{
        rt[it] = positionalValues[it](_, et)
    }
    ),
    g.render();
    const nt = g.measureViewportBox();
    return b.forEach(it=>{
        const ot = g.getValue(it);
        ot && ot.jump(rt[it]),
        d[it] = positionalValues[it](nt, et)
    }
    ),
    d
}
  , checkAndConvertChangedValueTypes = (d,g,b={},_={})=>{
    g = {
        ...g
    },
    _ = {
        ..._
    };
    const $ = Object.keys(g).filter(isPositionalKey);
    let et = []
      , tt = !1;
    const rt = [];
    if ($.forEach(nt=>{
        const it = d.getValue(nt);
        if (!d.hasValue(nt))
            return;
        let ot = b[nt]
          , at = findDimensionValueType(ot);
        const st = g[nt];
        let dt;
        if (isKeyframesTarget(st)) {
            const ft = st.length
              , ht = st[0] === null ? 1 : 0;
            ot = st[ht],
            at = findDimensionValueType(ot);
            for (let xt = ht; xt < ft && st[xt] !== null; xt++)
                dt ? invariant(findDimensionValueType(st[xt]) === dt) : dt = findDimensionValueType(st[xt])
        } else
            dt = findDimensionValueType(st);
        if (at !== dt)
            if (isNumOrPxType(at) && isNumOrPxType(dt)) {
                const ft = it.get();
                typeof ft == "string" && it.set(parseFloat(ft)),
                typeof st == "string" ? g[nt] = parseFloat(st) : Array.isArray(st) && dt === px$1 && (g[nt] = st.map(parseFloat))
            } else
                at != null && at.transform && (dt != null && dt.transform) && (ot === 0 || st === 0) ? ot === 0 ? it.set(dt.transform(ot)) : g[nt] = at.transform(st) : (tt || (et = removeNonTranslationalTransform(d),
                tt = !0),
                rt.push(nt),
                _[nt] = _[nt] !== void 0 ? _[nt] : g[nt],
                it.jump(st))
    }
    ),
    rt.length) {
        const nt = rt.indexOf("height") >= 0 ? window.pageYOffset : null
          , it = convertChangedValueTypes(g, d, rt);
        return et.length && et.forEach(([ot,at])=>{
            d.getValue(ot).set(at)
        }
        ),
        d.render(),
        isBrowser && nt !== null && window.scrollTo({
            top: nt
        }),
        {
            target: it,
            transitionEnd: _
        }
    } else
        return {
            target: g,
            transitionEnd: _
        }
}
;
function unitConversion(d, g, b, _) {
    return hasPositionalKey(g) ? checkAndConvertChangedValueTypes(d, g, b, _) : {
        target: g,
        transitionEnd: _
    }
}
const parseDomVariant = (d,g,b,_)=>{
    const $ = resolveCSSVariables(d, g, _);
    return g = $.target,
    _ = $.transitionEnd,
    unitConversion(d, g, b, _)
}
  , prefersReducedMotion = {
    current: null
}
  , hasReducedMotionListener = {
    current: !1
};
function initPrefersReducedMotion() {
    if (hasReducedMotionListener.current = !0,
    !!isBrowser)
        if (window.matchMedia) {
            const d = window.matchMedia("(prefers-reduced-motion)")
              , g = ()=>prefersReducedMotion.current = d.matches;
            d.addListener(g),
            g()
        } else
            prefersReducedMotion.current = !1
}
function updateMotionValuesFromProps(d, g, b) {
    const {willChange: _} = g;
    for (const $ in g) {
        const et = g[$]
          , tt = b[$];
        if (isMotionValue(et))
            d.addValue($, et),
            isWillChangeMotionValue(_) && _.add($);
        else if (isMotionValue(tt))
            d.addValue($, motionValue(et, {
                owner: d
            })),
            isWillChangeMotionValue(_) && _.remove($);
        else if (tt !== et)
            if (d.hasValue($)) {
                const rt = d.getValue($);
                !rt.hasAnimated && rt.set(et)
            } else {
                const rt = d.getStaticValue($);
                d.addValue($, motionValue(rt !== void 0 ? rt : et, {
                    owner: d
                }))
            }
    }
    for (const $ in b)
        g[$] === void 0 && d.removeValue($);
    return g
}
const visualElementStore = new WeakMap
  , featureNames = Object.keys(featureDefinitions)
  , numFeatures = featureNames.length
  , propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , numVariantProps = variantProps.length;
class VisualElement {
    constructor({parent: g, props: b, presenceContext: _, reducedMotionConfig: $, visualState: et}, tt={}) {
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = ()=>this.notify("Update", this.latestValues),
        this.render = ()=>{
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = ()=>frame.render(this.render, !1, !0);
        const {latestValues: rt, renderState: nt} = et;
        this.latestValues = rt,
        this.baseTarget = {
            ...rt
        },
        this.initialValues = b.initial ? {
            ...rt
        } : {},
        this.renderState = nt,
        this.parent = g,
        this.props = b,
        this.presenceContext = _,
        this.depth = g ? g.depth + 1 : 0,
        this.reducedMotionConfig = $,
        this.options = tt,
        this.isControllingVariants = isControllingVariants(b),
        this.isVariantNode = isVariantNode(b),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(g && g.current);
        const {willChange: it, ...ot} = this.scrapeMotionValuesFromProps(b, {});
        for (const at in ot) {
            const st = ot[at];
            rt[at] !== void 0 && isMotionValue(st) && (st.set(rt[at], !1),
            isWillChangeMotionValue(it) && it.add(at))
        }
    }
    scrapeMotionValuesFromProps(g, b) {
        return {}
    }
    mount(g) {
        this.current = g,
        visualElementStore.set(g, this),
        this.projection && !this.projection.instance && this.projection.mount(g),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((b,_)=>this.bindToMotionValue(_, b)),
        hasReducedMotionListener.current || initPrefersReducedMotion(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        visualElementStore.delete(this.current),
        this.projection && this.projection.unmount(),
        cancelFrame(this.notifyUpdate),
        cancelFrame(this.render),
        this.valueSubscriptions.forEach(g=>g()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const g in this.events)
            this.events[g].clear();
        for (const g in this.features)
            this.features[g].unmount();
        this.current = null
    }
    bindToMotionValue(g, b) {
        const _ = transformProps.has(g)
          , $ = b.on("change", tt=>{
            this.latestValues[g] = tt,
            this.props.onUpdate && frame.update(this.notifyUpdate, !1, !0),
            _ && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , et = b.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(g, ()=>{
            $(),
            et()
        }
        )
    }
    sortNodePosition(g) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== g.type ? 0 : this.sortInstanceNodePosition(this.current, g.current)
    }
    loadFeatures({children: g, ...b}, _, $, et) {
        let tt, rt;
        for (let nt = 0; nt < numFeatures; nt++) {
            const it = featureNames[nt]
              , {isEnabled: ot, Feature: at, ProjectionNode: st, MeasureLayout: dt} = featureDefinitions[it];
            st && (tt = st),
            ot(b) && (!this.features[it] && at && (this.features[it] = new at(this)),
            dt && (rt = dt))
        }
        if ((this.type === "html" || this.type === "svg") && !this.projection && tt) {
            this.projection = new tt(this.latestValues,this.parent && this.parent.projection);
            const {layoutId: nt, layout: it, drag: ot, dragConstraints: at, layoutScroll: st, layoutRoot: dt} = b;
            this.projection.setOptions({
                layoutId: nt,
                layout: it,
                alwaysMeasureLayout: !!ot || at && isRefObject(at),
                visualElement: this,
                scheduleRender: ()=>this.scheduleRender(),
                animationType: typeof it == "string" ? it : "both",
                initialPromotionConfig: et,
                layoutScroll: st,
                layoutRoot: dt
            })
        }
        return rt
    }
    updateFeatures() {
        for (const g in this.features) {
            const b = this.features[g];
            b.isMounted ? b.update() : (b.mount(),
            b.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
    }
    getStaticValue(g) {
        return this.latestValues[g]
    }
    setStaticValue(g, b) {
        this.latestValues[g] = b
    }
    makeTargetAnimatable(g, b=!0) {
        return this.makeTargetAnimatableFromInstance(g, this.props, b)
    }
    update(g, b) {
        (g.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = g,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = b;
        for (let _ = 0; _ < propEventHandlers.length; _++) {
            const $ = propEventHandlers[_];
            this.propEventSubscriptions[$] && (this.propEventSubscriptions[$](),
            delete this.propEventSubscriptions[$]);
            const et = g["on" + $];
            et && (this.propEventSubscriptions[$] = this.on($, et))
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(g, this.prevProps), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(g) {
        return this.props.variants ? this.props.variants[g] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(g=!1) {
        if (g)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const _ = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (_.initial = this.props.initial),
            _
        }
        const b = {};
        for (let _ = 0; _ < numVariantProps; _++) {
            const $ = variantProps[_]
              , et = this.props[$];
            (isVariantLabel(et) || et === !1) && (b[$] = et)
        }
        return b
    }
    addVariantChild(g) {
        const b = this.getClosestVariantNode();
        if (b)
            return b.variantChildren && b.variantChildren.add(g),
            ()=>b.variantChildren.delete(g)
    }
    addValue(g, b) {
        b !== this.values.get(g) && (this.removeValue(g),
        this.bindToMotionValue(g, b)),
        this.values.set(g, b),
        this.latestValues[g] = b.get()
    }
    removeValue(g) {
        this.values.delete(g);
        const b = this.valueSubscriptions.get(g);
        b && (b(),
        this.valueSubscriptions.delete(g)),
        delete this.latestValues[g],
        this.removeValueFromRenderState(g, this.renderState)
    }
    hasValue(g) {
        return this.values.has(g)
    }
    getValue(g, b) {
        if (this.props.values && this.props.values[g])
            return this.props.values[g];
        let _ = this.values.get(g);
        return _ === void 0 && b !== void 0 && (_ = motionValue(b, {
            owner: this
        }),
        this.addValue(g, _)),
        _
    }
    readValue(g) {
        var b;
        return this.latestValues[g] !== void 0 || !this.current ? this.latestValues[g] : (b = this.getBaseTargetFromProps(this.props, g)) !== null && b !== void 0 ? b : this.readValueFromInstance(this.current, g, this.options)
    }
    setBaseTarget(g, b) {
        this.baseTarget[g] = b
    }
    getBaseTarget(g) {
        var b;
        const {initial: _} = this.props
          , $ = typeof _ == "string" || typeof _ == "object" ? (b = resolveVariantFromProps(this.props, _)) === null || b === void 0 ? void 0 : b[g] : void 0;
        if (_ && $ !== void 0)
            return $;
        const et = this.getBaseTargetFromProps(this.props, g);
        return et !== void 0 && !isMotionValue(et) ? et : this.initialValues[g] !== void 0 && $ === void 0 ? void 0 : this.baseTarget[g]
    }
    on(g, b) {
        return this.events[g] || (this.events[g] = new SubscriptionManager),
        this.events[g].add(b)
    }
    notify(g, ...b) {
        this.events[g] && this.events[g].notify(...b)
    }
}
class DOMVisualElement extends VisualElement {
    sortInstanceNodePosition(g, b) {
        return g.compareDocumentPosition(b) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(g, b) {
        return g.style ? g.style[b] : void 0
    }
    removeValueFromRenderState(g, {vars: b, style: _}) {
        delete b[g],
        delete _[g]
    }
    makeTargetAnimatableFromInstance({transition: g, transitionEnd: b, ..._}, {transformValues: $}, et) {
        let tt = getOrigin(_, g || {}, this);
        if ($ && (b && (b = $(b)),
        _ && (_ = $(_)),
        tt && (tt = $(tt))),
        et) {
            checkTargetForNewValues(this, _, tt);
            const rt = parseDomVariant(this, _, tt, b);
            b = rt.transitionEnd,
            _ = rt.target
        }
        return {
            transition: g,
            transitionEnd: b,
            ..._
        }
    }
}
function getComputedStyle$2(d) {
    return window.getComputedStyle(d)
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "html"
    }
    readValueFromInstance(g, b) {
        if (transformProps.has(b)) {
            const _ = getDefaultValueType(b);
            return _ && _.default || 0
        } else {
            const _ = getComputedStyle$2(g)
              , $ = (isCSSVariableName(b) ? _.getPropertyValue(b) : _[b]) || 0;
            return typeof $ == "string" ? $.trim() : $
        }
    }
    measureInstanceViewportBox(g, {transformPagePoint: b}) {
        return measureViewportBox(g, b)
    }
    build(g, b, _, $) {
        buildHTMLStyles(g, b, _, $.transformTemplate)
    }
    scrapeMotionValuesFromProps(g, b) {
        return scrapeMotionValuesFromProps$1(g, b)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: g} = this.props;
        isMotionValue(g) && (this.childSubscription = g.on("change", b=>{
            this.current && (this.current.textContent = `${b}`)
        }
        ))
    }
    renderInstance(g, b, _, $) {
        renderHTML(g, b, _, $)
    }
}
class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(g, b) {
        return g[b]
    }
    readValueFromInstance(g, b) {
        if (transformProps.has(b)) {
            const _ = getDefaultValueType(b);
            return _ && _.default || 0
        }
        return b = camelCaseAttributes.has(b) ? b : camelToDash(b),
        g.getAttribute(b)
    }
    measureInstanceViewportBox() {
        return createBox()
    }
    scrapeMotionValuesFromProps(g, b) {
        return scrapeMotionValuesFromProps(g, b)
    }
    build(g, b, _, $) {
        buildSVGAttrs(g, b, _, this.isSVGTag, $.transformTemplate)
    }
    renderInstance(g, b, _, $) {
        renderSVG(g, b, _, $)
    }
    mount(g) {
        this.isSVGTag = isSVGTag(g.tagName),
        super.mount(g)
    }
}
const createDomVisualElement = (d,g)=>isSVGComponent(d) ? new SVGVisualElement(g,{
    enableHardwareAcceleration: !1
}) : new HTMLVisualElement(g,{
    enableHardwareAcceleration: !0
})
  , layout = {
    layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
}
  , motion = createMotionProxy((d,g)=>createDomMotionConfig(d, g, preloadedFeatures, createDomVisualElement));
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal
  , _freeGlobal = freeGlobal$1
  , freeGlobal = _freeGlobal
  , freeSelf = typeof self == "object" && self && self.Object === Object && self
  , root$1 = freeGlobal || freeSelf || Function("return this")()
  , _root = root$1
  , root = _root
  , Symbol$4 = root.Symbol
  , _Symbol = Symbol$4
  , Symbol$3 = _Symbol;
Symbol$3 && Symbol$3.toStringTag;
var Symbol$2 = _Symbol;
Symbol$2 && Symbol$2.toStringTag;
function isObject$6(d) {
    return d !== null && typeof d == "object" && "constructor"in d && d.constructor === Object
}
function extend$2(d, g) {
    d === void 0 && (d = {}),
    g === void 0 && (g = {}),
    Object.keys(g).forEach(b=>{
        typeof d[b] > "u" ? d[b] = g[b] : isObject$6(g[b]) && isObject$6(d[b]) && Object.keys(g[b]).length > 0 && extend$2(d[b], g[b])
    }
    )
}
const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    const d = typeof document < "u" ? document : {};
    return extend$2(d, ssrDocument),
    d
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(d) {
        return typeof setTimeout > "u" ? (d(),
        null) : setTimeout(d, 0)
    },
    cancelAnimationFrame(d) {
        typeof setTimeout > "u" || clearTimeout(d)
    }
};
function getWindow() {
    const d = typeof window < "u" ? window : {};
    return extend$2(d, ssrWindow),
    d
}
function classesToTokens(d) {
    return d === void 0 && (d = ""),
    d.trim().split(" ").filter(g=>!!g.trim())
}
function deleteProps(d) {
    const g = d;
    Object.keys(g).forEach(b=>{
        try {
            g[b] = null
        } catch {}
        try {
            delete g[b]
        } catch {}
    }
    )
}
function nextTick(d, g) {
    return g === void 0 && (g = 0),
    setTimeout(d, g)
}
function now() {
    return Date.now()
}
function getComputedStyle$1(d) {
    const g = getWindow();
    let b;
    return g.getComputedStyle && (b = g.getComputedStyle(d, null)),
    !b && d.currentStyle && (b = d.currentStyle),
    b || (b = d.style),
    b
}
function getTranslate(d, g) {
    g === void 0 && (g = "x");
    const b = getWindow();
    let _, $, et;
    const tt = getComputedStyle$1(d);
    return b.WebKitCSSMatrix ? ($ = tt.transform || tt.webkitTransform,
    $.split(",").length > 6 && ($ = $.split(", ").map(rt=>rt.replace(",", ".")).join(", ")),
    et = new b.WebKitCSSMatrix($ === "none" ? "" : $)) : (et = tt.MozTransform || tt.OTransform || tt.MsTransform || tt.msTransform || tt.transform || tt.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    _ = et.toString().split(",")),
    g === "x" && (b.WebKitCSSMatrix ? $ = et.m41 : _.length === 16 ? $ = parseFloat(_[12]) : $ = parseFloat(_[4])),
    g === "y" && (b.WebKitCSSMatrix ? $ = et.m42 : _.length === 16 ? $ = parseFloat(_[13]) : $ = parseFloat(_[5])),
    $ || 0
}
function isObject$5(d) {
    return typeof d == "object" && d !== null && d.constructor && Object.prototype.toString.call(d).slice(8, -1) === "Object"
}
function isNode(d) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? d instanceof HTMLElement : d && (d.nodeType === 1 || d.nodeType === 11)
}
function extend$1() {
    const d = Object(arguments.length <= 0 ? void 0 : arguments[0])
      , g = ["__proto__", "constructor", "prototype"];
    for (let b = 1; b < arguments.length; b += 1) {
        const _ = b < 0 || arguments.length <= b ? void 0 : arguments[b];
        if (_ != null && !isNode(_)) {
            const $ = Object.keys(Object(_)).filter(et=>g.indexOf(et) < 0);
            for (let et = 0, tt = $.length; et < tt; et += 1) {
                const rt = $[et]
                  , nt = Object.getOwnPropertyDescriptor(_, rt);
                nt !== void 0 && nt.enumerable && (isObject$5(d[rt]) && isObject$5(_[rt]) ? _[rt].__swiper__ ? d[rt] = _[rt] : extend$1(d[rt], _[rt]) : !isObject$5(d[rt]) && isObject$5(_[rt]) ? (d[rt] = {},
                _[rt].__swiper__ ? d[rt] = _[rt] : extend$1(d[rt], _[rt])) : d[rt] = _[rt])
            }
        }
    }
    return d
}
function setCSSProperty(d, g, b) {
    d.style.setProperty(g, b)
}
function animateCSSModeScroll(d) {
    let {swiper: g, targetPosition: b, side: _} = d;
    const $ = getWindow()
      , et = -g.translate;
    let tt = null, rt;
    const nt = g.params.speed;
    g.wrapperEl.style.scrollSnapType = "none",
    $.cancelAnimationFrame(g.cssModeFrameID);
    const it = b > et ? "next" : "prev"
      , ot = (st,dt)=>it === "next" && st >= dt || it === "prev" && st <= dt
      , at = ()=>{
        rt = new Date().getTime(),
        tt === null && (tt = rt);
        const st = Math.max(Math.min((rt - tt) / nt, 1), 0)
          , dt = .5 - Math.cos(st * Math.PI) / 2;
        let ft = et + dt * (b - et);
        if (ot(ft, b) && (ft = b),
        g.wrapperEl.scrollTo({
            [_]: ft
        }),
        ot(ft, b)) {
            g.wrapperEl.style.overflow = "hidden",
            g.wrapperEl.style.scrollSnapType = "",
            setTimeout(()=>{
                g.wrapperEl.style.overflow = "",
                g.wrapperEl.scrollTo({
                    [_]: ft
                })
            }
            ),
            $.cancelAnimationFrame(g.cssModeFrameID);
            return
        }
        g.cssModeFrameID = $.requestAnimationFrame(at)
    }
    ;
    at()
}
function elementChildren(d, g) {
    return g === void 0 && (g = ""),
    [...d.children].filter(b=>b.matches(g))
}
function showWarning(d) {
    try {
        console.warn(d);
        return
    } catch {}
}
function createElement(d, g) {
    g === void 0 && (g = []);
    const b = document.createElement(d);
    return b.classList.add(...Array.isArray(g) ? g : classesToTokens(g)),
    b
}
function elementPrevAll(d, g) {
    const b = [];
    for (; d.previousElementSibling; ) {
        const _ = d.previousElementSibling;
        g ? _.matches(g) && b.push(_) : b.push(_),
        d = _
    }
    return b
}
function elementNextAll(d, g) {
    const b = [];
    for (; d.nextElementSibling; ) {
        const _ = d.nextElementSibling;
        g ? _.matches(g) && b.push(_) : b.push(_),
        d = _
    }
    return b
}
function elementStyle(d, g) {
    return getWindow().getComputedStyle(d, null).getPropertyValue(g)
}
function elementIndex(d) {
    let g = d, b;
    if (g) {
        for (b = 0; (g = g.previousSibling) !== null; )
            g.nodeType === 1 && (b += 1);
        return b
    }
}
function elementParents(d, g) {
    const b = [];
    let _ = d.parentElement;
    for (; _; )
        g ? _.matches(g) && b.push(_) : b.push(_),
        _ = _.parentElement;
    return b
}
function elementOuterSize(d, g, b) {
    const _ = getWindow();
    return b ? d[g === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(_.getComputedStyle(d, null).getPropertyValue(g === "width" ? "margin-right" : "margin-top")) + parseFloat(_.getComputedStyle(d, null).getPropertyValue(g === "width" ? "margin-left" : "margin-bottom")) : d.offsetWidth
}
function makeElementsArray(d) {
    return (Array.isArray(d) ? d : [d]).filter(g=>!!g)
}
function createElementIfNotDefined(d, g, b, _) {
    return d.params.createElements && Object.keys(_).forEach($=>{
        if (!b[$] && b.auto === !0) {
            let et = elementChildren(d.el, `.${_[$]}`)[0];
            et || (et = createElement("div", _[$]),
            et.className = _[$],
            d.el.append(et)),
            b[$] = et,
            g[$] = et
        }
    }
    ),
    b
}
function classesToSelector(d) {
    return d === void 0 && (d = ""),
    `.${d.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
}
function Pagination(d) {
    let {swiper: g, extendParams: b, on: _, emit: $} = d;
    const et = "swiper-pagination";
    b({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: !1,
            hideOnClick: !1,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: !1,
            type: "bullets",
            dynamicBullets: !1,
            dynamicMainBullets: 1,
            formatFractionCurrent: lt=>lt,
            formatFractionTotal: lt=>lt,
            bulletClass: `${et}-bullet`,
            bulletActiveClass: `${et}-bullet-active`,
            modifierClass: `${et}-`,
            currentClass: `${et}-current`,
            totalClass: `${et}-total`,
            hiddenClass: `${et}-hidden`,
            progressbarFillClass: `${et}-progressbar-fill`,
            progressbarOppositeClass: `${et}-progressbar-opposite`,
            clickableClass: `${et}-clickable`,
            lockClass: `${et}-lock`,
            horizontalClass: `${et}-horizontal`,
            verticalClass: `${et}-vertical`,
            paginationDisabledClass: `${et}-disabled`
        }
    }),
    g.pagination = {
        el: null,
        bullets: []
    };
    let tt, rt = 0;
    function nt() {
        return !g.params.pagination.el || !g.pagination.el || Array.isArray(g.pagination.el) && g.pagination.el.length === 0
    }
    function it(lt, ct) {
        const {bulletActiveClass: ut} = g.params.pagination;
        lt && (lt = lt[`${ct === "prev" ? "previous" : "next"}ElementSibling`],
        lt && (lt.classList.add(`${ut}-${ct}`),
        lt = lt[`${ct === "prev" ? "previous" : "next"}ElementSibling`],
        lt && lt.classList.add(`${ut}-${ct}-${ct}`)))
    }
    function ot(lt) {
        const ct = lt.target.closest(classesToSelector(g.params.pagination.bulletClass));
        if (!ct)
            return;
        lt.preventDefault();
        const ut = elementIndex(ct) * g.params.slidesPerGroup;
        if (g.params.loop) {
            if (g.realIndex === ut)
                return;
            g.slideToLoop(ut)
        } else
            g.slideTo(ut)
    }
    function at() {
        const lt = g.rtl
          , ct = g.params.pagination;
        if (nt())
            return;
        let ut = g.pagination.el;
        ut = makeElementsArray(ut);
        let pt, vt;
        const _t = g.virtual && g.params.virtual.enabled ? g.virtual.slides.length : g.slides.length
          , Pt = g.params.loop ? Math.ceil(_t / g.params.slidesPerGroup) : g.snapGrid.length;
        if (g.params.loop ? (vt = g.previousRealIndex || 0,
        pt = g.params.slidesPerGroup > 1 ? Math.floor(g.realIndex / g.params.slidesPerGroup) : g.realIndex) : typeof g.snapIndex < "u" ? (pt = g.snapIndex,
        vt = g.previousSnapIndex) : (vt = g.previousIndex || 0,
        pt = g.activeIndex || 0),
        ct.type === "bullets" && g.pagination.bullets && g.pagination.bullets.length > 0) {
            const kt = g.pagination.bullets;
            let $t, Wt, Ht;
            if (ct.dynamicBullets && (tt = elementOuterSize(kt[0], g.isHorizontal() ? "width" : "height", !0),
            ut.forEach(Dt=>{
                Dt.style[g.isHorizontal() ? "width" : "height"] = `${tt * (ct.dynamicMainBullets + 4)}px`
            }
            ),
            ct.dynamicMainBullets > 1 && vt !== void 0 && (rt += pt - (vt || 0),
            rt > ct.dynamicMainBullets - 1 ? rt = ct.dynamicMainBullets - 1 : rt < 0 && (rt = 0)),
            $t = Math.max(pt - rt, 0),
            Wt = $t + (Math.min(kt.length, ct.dynamicMainBullets) - 1),
            Ht = (Wt + $t) / 2),
            kt.forEach(Dt=>{
                const Vt = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(Ft=>`${ct.bulletActiveClass}${Ft}`)].map(Ft=>typeof Ft == "string" && Ft.includes(" ") ? Ft.split(" ") : Ft).flat();
                Dt.classList.remove(...Vt)
            }
            ),
            ut.length > 1)
                kt.forEach(Dt=>{
                    const Vt = elementIndex(Dt);
                    Vt === pt ? Dt.classList.add(...ct.bulletActiveClass.split(" ")) : g.isElement && Dt.setAttribute("part", "bullet"),
                    ct.dynamicBullets && (Vt >= $t && Vt <= Wt && Dt.classList.add(...`${ct.bulletActiveClass}-main`.split(" ")),
                    Vt === $t && it(Dt, "prev"),
                    Vt === Wt && it(Dt, "next"))
                }
                );
            else {
                const Dt = kt[pt];
                if (Dt && Dt.classList.add(...ct.bulletActiveClass.split(" ")),
                g.isElement && kt.forEach((Vt,Ft)=>{
                    Vt.setAttribute("part", Ft === pt ? "bullet-active" : "bullet")
                }
                ),
                ct.dynamicBullets) {
                    const Vt = kt[$t]
                      , Ft = kt[Wt];
                    for (let Kt = $t; Kt <= Wt; Kt += 1)
                        kt[Kt] && kt[Kt].classList.add(...`${ct.bulletActiveClass}-main`.split(" "));
                    it(Vt, "prev"),
                    it(Ft, "next")
                }
            }
            if (ct.dynamicBullets) {
                const Dt = Math.min(kt.length, ct.dynamicMainBullets + 4)
                  , Vt = (tt * Dt - tt) / 2 - Ht * tt
                  , Ft = lt ? "right" : "left";
                kt.forEach(Kt=>{
                    Kt.style[g.isHorizontal() ? Ft : "top"] = `${Vt}px`
                }
                )
            }
        }
        ut.forEach((kt,$t)=>{
            if (ct.type === "fraction" && (kt.querySelectorAll(classesToSelector(ct.currentClass)).forEach(Wt=>{
                Wt.textContent = ct.formatFractionCurrent(pt + 1)
            }
            ),
            kt.querySelectorAll(classesToSelector(ct.totalClass)).forEach(Wt=>{
                Wt.textContent = ct.formatFractionTotal(Pt)
            }
            )),
            ct.type === "progressbar") {
                let Wt;
                ct.progressbarOpposite ? Wt = g.isHorizontal() ? "vertical" : "horizontal" : Wt = g.isHorizontal() ? "horizontal" : "vertical";
                const Ht = (pt + 1) / Pt;
                let Dt = 1
                  , Vt = 1;
                Wt === "horizontal" ? Dt = Ht : Vt = Ht,
                kt.querySelectorAll(classesToSelector(ct.progressbarFillClass)).forEach(Ft=>{
                    Ft.style.transform = `translate3d(0,0,0) scaleX(${Dt}) scaleY(${Vt})`,
                    Ft.style.transitionDuration = `${g.params.speed}ms`
                }
                )
            }
            ct.type === "custom" && ct.renderCustom ? (kt.innerHTML = ct.renderCustom(g, pt + 1, Pt),
            $t === 0 && $("paginationRender", kt)) : ($t === 0 && $("paginationRender", kt),
            $("paginationUpdate", kt)),
            g.params.watchOverflow && g.enabled && kt.classList[g.isLocked ? "add" : "remove"](ct.lockClass)
        }
        )
    }
    function st() {
        const lt = g.params.pagination;
        if (nt())
            return;
        const ct = g.virtual && g.params.virtual.enabled ? g.virtual.slides.length : g.grid && g.params.grid.rows > 1 ? g.slides.length / Math.ceil(g.params.grid.rows) : g.slides.length;
        let ut = g.pagination.el;
        ut = makeElementsArray(ut);
        let pt = "";
        if (lt.type === "bullets") {
            let vt = g.params.loop ? Math.ceil(ct / g.params.slidesPerGroup) : g.snapGrid.length;
            g.params.freeMode && g.params.freeMode.enabled && vt > ct && (vt = ct);
            for (let _t = 0; _t < vt; _t += 1)
                lt.renderBullet ? pt += lt.renderBullet.call(g, _t, lt.bulletClass) : pt += `<${lt.bulletElement} ${g.isElement ? 'part="bullet"' : ""} class="${lt.bulletClass}"></${lt.bulletElement}>`
        }
        lt.type === "fraction" && (lt.renderFraction ? pt = lt.renderFraction.call(g, lt.currentClass, lt.totalClass) : pt = `<span class="${lt.currentClass}"></span> / <span class="${lt.totalClass}"></span>`),
        lt.type === "progressbar" && (lt.renderProgressbar ? pt = lt.renderProgressbar.call(g, lt.progressbarFillClass) : pt = `<span class="${lt.progressbarFillClass}"></span>`),
        g.pagination.bullets = [],
        ut.forEach(vt=>{
            lt.type !== "custom" && (vt.innerHTML = pt || ""),
            lt.type === "bullets" && g.pagination.bullets.push(...vt.querySelectorAll(classesToSelector(lt.bulletClass)))
        }
        ),
        lt.type !== "custom" && $("paginationRender", ut[0])
    }
    function dt() {
        g.params.pagination = createElementIfNotDefined(g, g.originalParams.pagination, g.params.pagination, {
            el: "swiper-pagination"
        });
        const lt = g.params.pagination;
        if (!lt.el)
            return;
        let ct;
        typeof lt.el == "string" && g.isElement && (ct = g.el.querySelector(lt.el)),
        !ct && typeof lt.el == "string" && (ct = [...document.querySelectorAll(lt.el)]),
        ct || (ct = lt.el),
        !(!ct || ct.length === 0) && (g.params.uniqueNavElements && typeof lt.el == "string" && Array.isArray(ct) && ct.length > 1 && (ct = [...g.el.querySelectorAll(lt.el)],
        ct.length > 1 && (ct = ct.filter(ut=>elementParents(ut, ".swiper")[0] === g.el)[0])),
        Array.isArray(ct) && ct.length === 1 && (ct = ct[0]),
        Object.assign(g.pagination, {
            el: ct
        }),
        ct = makeElementsArray(ct),
        ct.forEach(ut=>{
            lt.type === "bullets" && lt.clickable && ut.classList.add(...(lt.clickableClass || "").split(" ")),
            ut.classList.add(lt.modifierClass + lt.type),
            ut.classList.add(g.isHorizontal() ? lt.horizontalClass : lt.verticalClass),
            lt.type === "bullets" && lt.dynamicBullets && (ut.classList.add(`${lt.modifierClass}${lt.type}-dynamic`),
            rt = 0,
            lt.dynamicMainBullets < 1 && (lt.dynamicMainBullets = 1)),
            lt.type === "progressbar" && lt.progressbarOpposite && ut.classList.add(lt.progressbarOppositeClass),
            lt.clickable && ut.addEventListener("click", ot),
            g.enabled || ut.classList.add(lt.lockClass)
        }
        ))
    }
    function ft() {
        const lt = g.params.pagination;
        if (nt())
            return;
        let ct = g.pagination.el;
        ct && (ct = makeElementsArray(ct),
        ct.forEach(ut=>{
            ut.classList.remove(lt.hiddenClass),
            ut.classList.remove(lt.modifierClass + lt.type),
            ut.classList.remove(g.isHorizontal() ? lt.horizontalClass : lt.verticalClass),
            lt.clickable && (ut.classList.remove(...(lt.clickableClass || "").split(" ")),
            ut.removeEventListener("click", ot))
        }
        )),
        g.pagination.bullets && g.pagination.bullets.forEach(ut=>ut.classList.remove(...lt.bulletActiveClass.split(" ")))
    }
    _("changeDirection", ()=>{
        if (!g.pagination || !g.pagination.el)
            return;
        const lt = g.params.pagination;
        let {el: ct} = g.pagination;
        ct = makeElementsArray(ct),
        ct.forEach(ut=>{
            ut.classList.remove(lt.horizontalClass, lt.verticalClass),
            ut.classList.add(g.isHorizontal() ? lt.horizontalClass : lt.verticalClass)
        }
        )
    }
    ),
    _("init", ()=>{
        g.params.pagination.enabled === !1 ? xt() : (dt(),
        st(),
        at())
    }
    ),
    _("activeIndexChange", ()=>{
        typeof g.snapIndex > "u" && at()
    }
    ),
    _("snapIndexChange", ()=>{
        at()
    }
    ),
    _("snapGridLengthChange", ()=>{
        st(),
        at()
    }
    ),
    _("destroy", ()=>{
        ft()
    }
    ),
    _("enable disable", ()=>{
        let {el: lt} = g.pagination;
        lt && (lt = makeElementsArray(lt),
        lt.forEach(ct=>ct.classList[g.enabled ? "remove" : "add"](g.params.pagination.lockClass)))
    }
    ),
    _("lock unlock", ()=>{
        at()
    }
    ),
    _("click", (lt,ct)=>{
        const ut = ct.target
          , pt = makeElementsArray(g.pagination.el);
        if (g.params.pagination.el && g.params.pagination.hideOnClick && pt && pt.length > 0 && !ut.classList.contains(g.params.pagination.bulletClass)) {
            if (g.navigation && (g.navigation.nextEl && ut === g.navigation.nextEl || g.navigation.prevEl && ut === g.navigation.prevEl))
                return;
            const vt = pt[0].classList.contains(g.params.pagination.hiddenClass);
            $(vt === !0 ? "paginationShow" : "paginationHide"),
            pt.forEach(_t=>_t.classList.toggle(g.params.pagination.hiddenClass))
        }
    }
    );
    const ht = ()=>{
        g.el.classList.remove(g.params.pagination.paginationDisabledClass);
        let {el: lt} = g.pagination;
        lt && (lt = makeElementsArray(lt),
        lt.forEach(ct=>ct.classList.remove(g.params.pagination.paginationDisabledClass))),
        dt(),
        st(),
        at()
    }
      , xt = ()=>{
        g.el.classList.add(g.params.pagination.paginationDisabledClass);
        let {el: lt} = g.pagination;
        lt && (lt = makeElementsArray(lt),
        lt.forEach(ct=>ct.classList.add(g.params.pagination.paginationDisabledClass))),
        ft()
    }
    ;
    Object.assign(g.pagination, {
        enable: ht,
        disable: xt,
        render: st,
        update: at,
        init: dt,
        destroy: ft
    })
}
let support;
function calcSupport() {
    const d = getWindow()
      , g = getDocument();
    return {
        smoothScroll: g.documentElement && g.documentElement.style && "scrollBehavior"in g.documentElement.style,
        touch: !!("ontouchstart"in d || d.DocumentTouch && g instanceof d.DocumentTouch)
    }
}
function getSupport() {
    return support || (support = calcSupport()),
    support
}
let deviceCached;
function calcDevice(d) {
    let {userAgent: g} = d === void 0 ? {} : d;
    const b = getSupport()
      , _ = getWindow()
      , $ = _.navigator.platform
      , et = g || _.navigator.userAgent
      , tt = {
        ios: !1,
        android: !1
    }
      , rt = _.screen.width
      , nt = _.screen.height
      , it = et.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ot = et.match(/(iPad).*OS\s([\d_]+)/);
    const at = et.match(/(iPod)(.*OS\s([\d_]+))?/)
      , st = !ot && et.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , dt = $ === "Win32";
    let ft = $ === "MacIntel";
    const ht = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !ot && ft && b.touch && ht.indexOf(`${rt}x${nt}`) >= 0 && (ot = et.match(/(Version)\/([\d.]+)/),
    ot || (ot = [0, 1, "13_0_0"]),
    ft = !1),
    it && !dt && (tt.os = "android",
    tt.android = !0),
    (ot || st || at) && (tt.os = "ios",
    tt.ios = !0),
    tt
}
function getDevice(d) {
    return d === void 0 && (d = {}),
    deviceCached || (deviceCached = calcDevice(d)),
    deviceCached
}
let browser$1;
function calcBrowser() {
    const d = getWindow()
      , g = getDevice();
    let b = !1;
    function _() {
        const rt = d.navigator.userAgent.toLowerCase();
        return rt.indexOf("safari") >= 0 && rt.indexOf("chrome") < 0 && rt.indexOf("android") < 0
    }
    if (_()) {
        const rt = String(d.navigator.userAgent);
        if (rt.includes("Version/")) {
            const [nt,it] = rt.split("Version/")[1].split(" ")[0].split(".").map(ot=>Number(ot));
            b = nt < 16 || nt === 16 && it < 2
        }
    }
    const $ = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(d.navigator.userAgent)
      , et = _()
      , tt = et || $ && g.ios;
    return {
        isSafari: b || et,
        needPerspectiveFix: b,
        need3dFix: tt,
        isWebView: $
    }
}
function getBrowser() {
    return browser$1 || (browser$1 = calcBrowser()),
    browser$1
}
function Resize(d) {
    let {swiper: g, on: b, emit: _} = d;
    const $ = getWindow();
    let et = null
      , tt = null;
    const rt = ()=>{
        !g || g.destroyed || !g.initialized || (_("beforeResize"),
        _("resize"))
    }
      , nt = ()=>{
        !g || g.destroyed || !g.initialized || (et = new ResizeObserver(at=>{
            tt = $.requestAnimationFrame(()=>{
                const {width: st, height: dt} = g;
                let ft = st
                  , ht = dt;
                at.forEach(xt=>{
                    let {contentBoxSize: lt, contentRect: ct, target: ut} = xt;
                    ut && ut !== g.el || (ft = ct ? ct.width : (lt[0] || lt).inlineSize,
                    ht = ct ? ct.height : (lt[0] || lt).blockSize)
                }
                ),
                (ft !== st || ht !== dt) && rt()
            }
            )
        }
        ),
        et.observe(g.el))
    }
      , it = ()=>{
        tt && $.cancelAnimationFrame(tt),
        et && et.unobserve && g.el && (et.unobserve(g.el),
        et = null)
    }
      , ot = ()=>{
        !g || g.destroyed || !g.initialized || _("orientationchange")
    }
    ;
    b("init", ()=>{
        if (g.params.resizeObserver && typeof $.ResizeObserver < "u") {
            nt();
            return
        }
        $.addEventListener("resize", rt),
        $.addEventListener("orientationchange", ot)
    }
    ),
    b("destroy", ()=>{
        it(),
        $.removeEventListener("resize", rt),
        $.removeEventListener("orientationchange", ot)
    }
    )
}
function Observer(d) {
    let {swiper: g, extendParams: b, on: _, emit: $} = d;
    const et = []
      , tt = getWindow()
      , rt = function(ot, at) {
        at === void 0 && (at = {});
        const st = tt.MutationObserver || tt.WebkitMutationObserver
          , dt = new st(ft=>{
            if (g.__preventObserver__)
                return;
            if (ft.length === 1) {
                $("observerUpdate", ft[0]);
                return
            }
            const ht = function() {
                $("observerUpdate", ft[0])
            };
            tt.requestAnimationFrame ? tt.requestAnimationFrame(ht) : tt.setTimeout(ht, 0)
        }
        );
        dt.observe(ot, {
            attributes: typeof at.attributes > "u" ? !0 : at.attributes,
            childList: g.isElement || (typeof at.childList > "u" ? !0 : at).childList,
            characterData: typeof at.characterData > "u" ? !0 : at.characterData
        }),
        et.push(dt)
    }
      , nt = ()=>{
        if (g.params.observer) {
            if (g.params.observeParents) {
                const ot = elementParents(g.hostEl);
                for (let at = 0; at < ot.length; at += 1)
                    rt(ot[at])
            }
            rt(g.hostEl, {
                childList: g.params.observeSlideChildren
            }),
            rt(g.wrapperEl, {
                attributes: !1
            })
        }
    }
      , it = ()=>{
        et.forEach(ot=>{
            ot.disconnect()
        }
        ),
        et.splice(0, et.length)
    }
    ;
    b({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    _("init", nt),
    _("destroy", it)
}
var eventsEmitter = {
    on(d, g, b) {
        const _ = this;
        if (!_.eventsListeners || _.destroyed || typeof g != "function")
            return _;
        const $ = b ? "unshift" : "push";
        return d.split(" ").forEach(et=>{
            _.eventsListeners[et] || (_.eventsListeners[et] = []),
            _.eventsListeners[et][$](g)
        }
        ),
        _
    },
    once(d, g, b) {
        const _ = this;
        if (!_.eventsListeners || _.destroyed || typeof g != "function")
            return _;
        function $() {
            _.off(d, $),
            $.__emitterProxy && delete $.__emitterProxy;
            for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++)
                tt[rt] = arguments[rt];
            g.apply(_, tt)
        }
        return $.__emitterProxy = g,
        _.on(d, $, b)
    },
    onAny(d, g) {
        const b = this;
        if (!b.eventsListeners || b.destroyed || typeof d != "function")
            return b;
        const _ = g ? "unshift" : "push";
        return b.eventsAnyListeners.indexOf(d) < 0 && b.eventsAnyListeners[_](d),
        b
    },
    offAny(d) {
        const g = this;
        if (!g.eventsListeners || g.destroyed || !g.eventsAnyListeners)
            return g;
        const b = g.eventsAnyListeners.indexOf(d);
        return b >= 0 && g.eventsAnyListeners.splice(b, 1),
        g
    },
    off(d, g) {
        const b = this;
        return !b.eventsListeners || b.destroyed || !b.eventsListeners || d.split(" ").forEach(_=>{
            typeof g > "u" ? b.eventsListeners[_] = [] : b.eventsListeners[_] && b.eventsListeners[_].forEach(($,et)=>{
                ($ === g || $.__emitterProxy && $.__emitterProxy === g) && b.eventsListeners[_].splice(et, 1)
            }
            )
        }
        ),
        b
    },
    emit() {
        const d = this;
        if (!d.eventsListeners || d.destroyed || !d.eventsListeners)
            return d;
        let g, b, _;
        for (var $ = arguments.length, et = new Array($), tt = 0; tt < $; tt++)
            et[tt] = arguments[tt];
        return typeof et[0] == "string" || Array.isArray(et[0]) ? (g = et[0],
        b = et.slice(1, et.length),
        _ = d) : (g = et[0].events,
        b = et[0].data,
        _ = et[0].context || d),
        b.unshift(_),
        (Array.isArray(g) ? g : g.split(" ")).forEach(nt=>{
            d.eventsAnyListeners && d.eventsAnyListeners.length && d.eventsAnyListeners.forEach(it=>{
                it.apply(_, [nt, ...b])
            }
            ),
            d.eventsListeners && d.eventsListeners[nt] && d.eventsListeners[nt].forEach(it=>{
                it.apply(_, b)
            }
            )
        }
        ),
        d
    }
};
function updateSize() {
    const d = this;
    let g, b;
    const _ = d.el;
    typeof d.params.width < "u" && d.params.width !== null ? g = d.params.width : g = _.clientWidth,
    typeof d.params.height < "u" && d.params.height !== null ? b = d.params.height : b = _.clientHeight,
    !(g === 0 && d.isHorizontal() || b === 0 && d.isVertical()) && (g = g - parseInt(elementStyle(_, "padding-left") || 0, 10) - parseInt(elementStyle(_, "padding-right") || 0, 10),
    b = b - parseInt(elementStyle(_, "padding-top") || 0, 10) - parseInt(elementStyle(_, "padding-bottom") || 0, 10),
    Number.isNaN(g) && (g = 0),
    Number.isNaN(b) && (b = 0),
    Object.assign(d, {
        width: g,
        height: b,
        size: d.isHorizontal() ? g : b
    }))
}
function updateSlides() {
    const d = this;
    function g(Wt, Ht) {
        return parseFloat(Wt.getPropertyValue(d.getDirectionLabel(Ht)) || 0)
    }
    const b = d.params
      , {wrapperEl: _, slidesEl: $, size: et, rtlTranslate: tt, wrongRTL: rt} = d
      , nt = d.virtual && b.virtual.enabled
      , it = nt ? d.virtual.slides.length : d.slides.length
      , ot = elementChildren($, `.${d.params.slideClass}, swiper-slide`)
      , at = nt ? d.virtual.slides.length : ot.length;
    let st = [];
    const dt = []
      , ft = [];
    let ht = b.slidesOffsetBefore;
    typeof ht == "function" && (ht = b.slidesOffsetBefore.call(d));
    let xt = b.slidesOffsetAfter;
    typeof xt == "function" && (xt = b.slidesOffsetAfter.call(d));
    const lt = d.snapGrid.length
      , ct = d.slidesGrid.length;
    let ut = b.spaceBetween
      , pt = -ht
      , vt = 0
      , _t = 0;
    if (typeof et > "u")
        return;
    typeof ut == "string" && ut.indexOf("%") >= 0 ? ut = parseFloat(ut.replace("%", "")) / 100 * et : typeof ut == "string" && (ut = parseFloat(ut)),
    d.virtualSize = -ut,
    ot.forEach(Wt=>{
        tt ? Wt.style.marginLeft = "" : Wt.style.marginRight = "",
        Wt.style.marginBottom = "",
        Wt.style.marginTop = ""
    }
    ),
    b.centeredSlides && b.cssMode && (setCSSProperty(_, "--swiper-centered-offset-before", ""),
    setCSSProperty(_, "--swiper-centered-offset-after", ""));
    const Pt = b.grid && b.grid.rows > 1 && d.grid;
    Pt ? d.grid.initSlides(ot) : d.grid && d.grid.unsetSlides();
    let kt;
    const $t = b.slidesPerView === "auto" && b.breakpoints && Object.keys(b.breakpoints).filter(Wt=>typeof b.breakpoints[Wt].slidesPerView < "u").length > 0;
    for (let Wt = 0; Wt < at; Wt += 1) {
        kt = 0;
        let Ht;
        if (ot[Wt] && (Ht = ot[Wt]),
        Pt && d.grid.updateSlide(Wt, Ht, ot),
        !(ot[Wt] && elementStyle(Ht, "display") === "none")) {
            if (b.slidesPerView === "auto") {
                $t && (ot[Wt].style[d.getDirectionLabel("width")] = "");
                const Dt = getComputedStyle(Ht)
                  , Vt = Ht.style.transform
                  , Ft = Ht.style.webkitTransform;
                if (Vt && (Ht.style.transform = "none"),
                Ft && (Ht.style.webkitTransform = "none"),
                b.roundLengths)
                    kt = d.isHorizontal() ? elementOuterSize(Ht, "width", !0) : elementOuterSize(Ht, "height", !0);
                else {
                    const Kt = g(Dt, "width")
                      , Rt = g(Dt, "padding-left")
                      , qt = g(Dt, "padding-right")
                      , Et = g(Dt, "margin-left")
                      , St = g(Dt, "margin-right")
                      , Lt = Dt.getPropertyValue("box-sizing");
                    if (Lt && Lt === "border-box")
                        kt = Kt + Et + St;
                    else {
                        const {clientWidth: Mt, offsetWidth: ar} = Ht;
                        kt = Kt + Rt + qt + Et + St + (ar - Mt)
                    }
                }
                Vt && (Ht.style.transform = Vt),
                Ft && (Ht.style.webkitTransform = Ft),
                b.roundLengths && (kt = Math.floor(kt))
            } else
                kt = (et - (b.slidesPerView - 1) * ut) / b.slidesPerView,
                b.roundLengths && (kt = Math.floor(kt)),
                ot[Wt] && (ot[Wt].style[d.getDirectionLabel("width")] = `${kt}px`);
            ot[Wt] && (ot[Wt].swiperSlideSize = kt),
            ft.push(kt),
            b.centeredSlides ? (pt = pt + kt / 2 + vt / 2 + ut,
            vt === 0 && Wt !== 0 && (pt = pt - et / 2 - ut),
            Wt === 0 && (pt = pt - et / 2 - ut),
            Math.abs(pt) < 1 / 1e3 && (pt = 0),
            b.roundLengths && (pt = Math.floor(pt)),
            _t % b.slidesPerGroup === 0 && st.push(pt),
            dt.push(pt)) : (b.roundLengths && (pt = Math.floor(pt)),
            (_t - Math.min(d.params.slidesPerGroupSkip, _t)) % d.params.slidesPerGroup === 0 && st.push(pt),
            dt.push(pt),
            pt = pt + kt + ut),
            d.virtualSize += kt + ut,
            vt = kt,
            _t += 1
        }
    }
    if (d.virtualSize = Math.max(d.virtualSize, et) + xt,
    tt && rt && (b.effect === "slide" || b.effect === "coverflow") && (_.style.width = `${d.virtualSize + ut}px`),
    b.setWrapperSize && (_.style[d.getDirectionLabel("width")] = `${d.virtualSize + ut}px`),
    Pt && d.grid.updateWrapperSize(kt, st),
    !b.centeredSlides) {
        const Wt = [];
        for (let Ht = 0; Ht < st.length; Ht += 1) {
            let Dt = st[Ht];
            b.roundLengths && (Dt = Math.floor(Dt)),
            st[Ht] <= d.virtualSize - et && Wt.push(Dt)
        }
        st = Wt,
        Math.floor(d.virtualSize - et) - Math.floor(st[st.length - 1]) > 1 && st.push(d.virtualSize - et)
    }
    if (nt && b.loop) {
        const Wt = ft[0] + ut;
        if (b.slidesPerGroup > 1) {
            const Ht = Math.ceil((d.virtual.slidesBefore + d.virtual.slidesAfter) / b.slidesPerGroup)
              , Dt = Wt * b.slidesPerGroup;
            for (let Vt = 0; Vt < Ht; Vt += 1)
                st.push(st[st.length - 1] + Dt)
        }
        for (let Ht = 0; Ht < d.virtual.slidesBefore + d.virtual.slidesAfter; Ht += 1)
            b.slidesPerGroup === 1 && st.push(st[st.length - 1] + Wt),
            dt.push(dt[dt.length - 1] + Wt),
            d.virtualSize += Wt
    }
    if (st.length === 0 && (st = [0]),
    ut !== 0) {
        const Wt = d.isHorizontal() && tt ? "marginLeft" : d.getDirectionLabel("marginRight");
        ot.filter((Ht,Dt)=>!b.cssMode || b.loop ? !0 : Dt !== ot.length - 1).forEach(Ht=>{
            Ht.style[Wt] = `${ut}px`
        }
        )
    }
    if (b.centeredSlides && b.centeredSlidesBounds) {
        let Wt = 0;
        ft.forEach(Dt=>{
            Wt += Dt + (ut || 0)
        }
        ),
        Wt -= ut;
        const Ht = Wt - et;
        st = st.map(Dt=>Dt <= 0 ? -ht : Dt > Ht ? Ht + xt : Dt)
    }
    if (b.centerInsufficientSlides) {
        let Wt = 0;
        ft.forEach(Dt=>{
            Wt += Dt + (ut || 0)
        }
        ),
        Wt -= ut;
        const Ht = (b.slidesOffsetBefore || 0) + (b.slidesOffsetAfter || 0);
        if (Wt + Ht < et) {
            const Dt = (et - Wt - Ht) / 2;
            st.forEach((Vt,Ft)=>{
                st[Ft] = Vt - Dt
            }
            ),
            dt.forEach((Vt,Ft)=>{
                dt[Ft] = Vt + Dt
            }
            )
        }
    }
    if (Object.assign(d, {
        slides: ot,
        snapGrid: st,
        slidesGrid: dt,
        slidesSizesGrid: ft
    }),
    b.centeredSlides && b.cssMode && !b.centeredSlidesBounds) {
        setCSSProperty(_, "--swiper-centered-offset-before", `${-st[0]}px`),
        setCSSProperty(_, "--swiper-centered-offset-after", `${d.size / 2 - ft[ft.length - 1] / 2}px`);
        const Wt = -d.snapGrid[0]
          , Ht = -d.slidesGrid[0];
        d.snapGrid = d.snapGrid.map(Dt=>Dt + Wt),
        d.slidesGrid = d.slidesGrid.map(Dt=>Dt + Ht)
    }
    if (at !== it && d.emit("slidesLengthChange"),
    st.length !== lt && (d.params.watchOverflow && d.checkOverflow(),
    d.emit("snapGridLengthChange")),
    dt.length !== ct && d.emit("slidesGridLengthChange"),
    b.watchSlidesProgress && d.updateSlidesOffset(),
    d.emit("slidesUpdated"),
    !nt && !b.cssMode && (b.effect === "slide" || b.effect === "fade")) {
        const Wt = `${b.containerModifierClass}backface-hidden`
          , Ht = d.el.classList.contains(Wt);
        at <= b.maxBackfaceHiddenSlides ? Ht || d.el.classList.add(Wt) : Ht && d.el.classList.remove(Wt)
    }
}
function updateAutoHeight(d) {
    const g = this
      , b = []
      , _ = g.virtual && g.params.virtual.enabled;
    let $ = 0, et;
    typeof d == "number" ? g.setTransition(d) : d === !0 && g.setTransition(g.params.speed);
    const tt = rt=>_ ? g.slides[g.getSlideIndexByData(rt)] : g.slides[rt];
    if (g.params.slidesPerView !== "auto" && g.params.slidesPerView > 1)
        if (g.params.centeredSlides)
            (g.visibleSlides || []).forEach(rt=>{
                b.push(rt)
            }
            );
        else
            for (et = 0; et < Math.ceil(g.params.slidesPerView); et += 1) {
                const rt = g.activeIndex + et;
                if (rt > g.slides.length && !_)
                    break;
                b.push(tt(rt))
            }
    else
        b.push(tt(g.activeIndex));
    for (et = 0; et < b.length; et += 1)
        if (typeof b[et] < "u") {
            const rt = b[et].offsetHeight;
            $ = rt > $ ? rt : $
        }
    ($ || $ === 0) && (g.wrapperEl.style.height = `${$}px`)
}
function updateSlidesOffset() {
    const d = this
      , g = d.slides
      , b = d.isElement ? d.isHorizontal() ? d.wrapperEl.offsetLeft : d.wrapperEl.offsetTop : 0;
    for (let _ = 0; _ < g.length; _ += 1)
        g[_].swiperSlideOffset = (d.isHorizontal() ? g[_].offsetLeft : g[_].offsetTop) - b - d.cssOverflowAdjustment()
}
const toggleSlideClasses$1 = (d,g,b)=>{
    g && !d.classList.contains(b) ? d.classList.add(b) : !g && d.classList.contains(b) && d.classList.remove(b)
}
;
function updateSlidesProgress(d) {
    d === void 0 && (d = this && this.translate || 0);
    const g = this
      , b = g.params
      , {slides: _, rtlTranslate: $, snapGrid: et} = g;
    if (_.length === 0)
        return;
    typeof _[0].swiperSlideOffset > "u" && g.updateSlidesOffset();
    let tt = -d;
    $ && (tt = d),
    g.visibleSlidesIndexes = [],
    g.visibleSlides = [];
    let rt = b.spaceBetween;
    typeof rt == "string" && rt.indexOf("%") >= 0 ? rt = parseFloat(rt.replace("%", "")) / 100 * g.size : typeof rt == "string" && (rt = parseFloat(rt));
    for (let nt = 0; nt < _.length; nt += 1) {
        const it = _[nt];
        let ot = it.swiperSlideOffset;
        b.cssMode && b.centeredSlides && (ot -= _[0].swiperSlideOffset);
        const at = (tt + (b.centeredSlides ? g.minTranslate() : 0) - ot) / (it.swiperSlideSize + rt)
          , st = (tt - et[0] + (b.centeredSlides ? g.minTranslate() : 0) - ot) / (it.swiperSlideSize + rt)
          , dt = -(tt - ot)
          , ft = dt + g.slidesSizesGrid[nt]
          , ht = dt >= 0 && dt <= g.size - g.slidesSizesGrid[nt]
          , xt = dt >= 0 && dt < g.size - 1 || ft > 1 && ft <= g.size || dt <= 0 && ft >= g.size;
        xt && (g.visibleSlides.push(it),
        g.visibleSlidesIndexes.push(nt)),
        toggleSlideClasses$1(it, xt, b.slideVisibleClass),
        toggleSlideClasses$1(it, ht, b.slideFullyVisibleClass),
        it.progress = $ ? -at : at,
        it.originalProgress = $ ? -st : st
    }
}
function updateProgress(d) {
    const g = this;
    if (typeof d > "u") {
        const ot = g.rtlTranslate ? -1 : 1;
        d = g && g.translate && g.translate * ot || 0
    }
    const b = g.params
      , _ = g.maxTranslate() - g.minTranslate();
    let {progress: $, isBeginning: et, isEnd: tt, progressLoop: rt} = g;
    const nt = et
      , it = tt;
    if (_ === 0)
        $ = 0,
        et = !0,
        tt = !0;
    else {
        $ = (d - g.minTranslate()) / _;
        const ot = Math.abs(d - g.minTranslate()) < 1
          , at = Math.abs(d - g.maxTranslate()) < 1;
        et = ot || $ <= 0,
        tt = at || $ >= 1,
        ot && ($ = 0),
        at && ($ = 1)
    }
    if (b.loop) {
        const ot = g.getSlideIndexByData(0)
          , at = g.getSlideIndexByData(g.slides.length - 1)
          , st = g.slidesGrid[ot]
          , dt = g.slidesGrid[at]
          , ft = g.slidesGrid[g.slidesGrid.length - 1]
          , ht = Math.abs(d);
        ht >= st ? rt = (ht - st) / ft : rt = (ht + ft - dt) / ft,
        rt > 1 && (rt -= 1)
    }
    Object.assign(g, {
        progress: $,
        progressLoop: rt,
        isBeginning: et,
        isEnd: tt
    }),
    (b.watchSlidesProgress || b.centeredSlides && b.autoHeight) && g.updateSlidesProgress(d),
    et && !nt && g.emit("reachBeginning toEdge"),
    tt && !it && g.emit("reachEnd toEdge"),
    (nt && !et || it && !tt) && g.emit("fromEdge"),
    g.emit("progress", $)
}
const toggleSlideClasses = (d,g,b)=>{
    g && !d.classList.contains(b) ? d.classList.add(b) : !g && d.classList.contains(b) && d.classList.remove(b)
}
;
function updateSlidesClasses() {
    const d = this
      , {slides: g, params: b, slidesEl: _, activeIndex: $} = d
      , et = d.virtual && b.virtual.enabled
      , tt = d.grid && b.grid && b.grid.rows > 1
      , rt = at=>elementChildren(_, `.${b.slideClass}${at}, swiper-slide${at}`)[0];
    let nt, it, ot;
    if (et)
        if (b.loop) {
            let at = $ - d.virtual.slidesBefore;
            at < 0 && (at = d.virtual.slides.length + at),
            at >= d.virtual.slides.length && (at -= d.virtual.slides.length),
            nt = rt(`[data-swiper-slide-index="${at}"]`)
        } else
            nt = rt(`[data-swiper-slide-index="${$}"]`);
    else
        tt ? (nt = g.filter(at=>at.column === $)[0],
        ot = g.filter(at=>at.column === $ + 1)[0],
        it = g.filter(at=>at.column === $ - 1)[0]) : nt = g[$];
    nt && (tt || (ot = elementNextAll(nt, `.${b.slideClass}, swiper-slide`)[0],
    b.loop && !ot && (ot = g[0]),
    it = elementPrevAll(nt, `.${b.slideClass}, swiper-slide`)[0],
    b.loop && !it === 0 && (it = g[g.length - 1]))),
    g.forEach(at=>{
        toggleSlideClasses(at, at === nt, b.slideActiveClass),
        toggleSlideClasses(at, at === ot, b.slideNextClass),
        toggleSlideClasses(at, at === it, b.slidePrevClass)
    }
    ),
    d.emitSlidesClasses()
}
const processLazyPreloader = (d,g)=>{
    if (!d || d.destroyed || !d.params)
        return;
    const b = ()=>d.isElement ? "swiper-slide" : `.${d.params.slideClass}`
      , _ = g.closest(b());
    if (_) {
        let $ = _.querySelector(`.${d.params.lazyPreloaderClass}`);
        !$ && d.isElement && (_.shadowRoot ? $ = _.shadowRoot.querySelector(`.${d.params.lazyPreloaderClass}`) : requestAnimationFrame(()=>{
            _.shadowRoot && ($ = _.shadowRoot.querySelector(`.${d.params.lazyPreloaderClass}`),
            $ && $.remove())
        }
        )),
        $ && $.remove()
    }
}
  , unlazy = (d,g)=>{
    if (!d.slides[g])
        return;
    const b = d.slides[g].querySelector('[loading="lazy"]');
    b && b.removeAttribute("loading")
}
  , preload = d=>{
    if (!d || d.destroyed || !d.params)
        return;
    let g = d.params.lazyPreloadPrevNext;
    const b = d.slides.length;
    if (!b || !g || g < 0)
        return;
    g = Math.min(g, b);
    const _ = d.params.slidesPerView === "auto" ? d.slidesPerViewDynamic() : Math.ceil(d.params.slidesPerView)
      , $ = d.activeIndex;
    if (d.params.grid && d.params.grid.rows > 1) {
        const tt = $
          , rt = [tt - g];
        rt.push(...Array.from({
            length: g
        }).map((nt,it)=>tt + _ + it)),
        d.slides.forEach((nt,it)=>{
            rt.includes(nt.column) && unlazy(d, it)
        }
        );
        return
    }
    const et = $ + _ - 1;
    if (d.params.rewind || d.params.loop)
        for (let tt = $ - g; tt <= et + g; tt += 1) {
            const rt = (tt % b + b) % b;
            (rt < $ || rt > et) && unlazy(d, rt)
        }
    else
        for (let tt = Math.max($ - g, 0); tt <= Math.min(et + g, b - 1); tt += 1)
            tt !== $ && (tt > et || tt < $) && unlazy(d, tt)
}
;
function getActiveIndexByTranslate(d) {
    const {slidesGrid: g, params: b} = d
      , _ = d.rtlTranslate ? d.translate : -d.translate;
    let $;
    for (let et = 0; et < g.length; et += 1)
        typeof g[et + 1] < "u" ? _ >= g[et] && _ < g[et + 1] - (g[et + 1] - g[et]) / 2 ? $ = et : _ >= g[et] && _ < g[et + 1] && ($ = et + 1) : _ >= g[et] && ($ = et);
    return b.normalizeSlideIndex && ($ < 0 || typeof $ > "u") && ($ = 0),
    $
}
function updateActiveIndex(d) {
    const g = this
      , b = g.rtlTranslate ? g.translate : -g.translate
      , {snapGrid: _, params: $, activeIndex: et, realIndex: tt, snapIndex: rt} = g;
    let nt = d, it;
    const ot = dt=>{
        let ft = dt - g.virtual.slidesBefore;
        return ft < 0 && (ft = g.virtual.slides.length + ft),
        ft >= g.virtual.slides.length && (ft -= g.virtual.slides.length),
        ft
    }
    ;
    if (typeof nt > "u" && (nt = getActiveIndexByTranslate(g)),
    _.indexOf(b) >= 0)
        it = _.indexOf(b);
    else {
        const dt = Math.min($.slidesPerGroupSkip, nt);
        it = dt + Math.floor((nt - dt) / $.slidesPerGroup)
    }
    if (it >= _.length && (it = _.length - 1),
    nt === et && !g.params.loop) {
        it !== rt && (g.snapIndex = it,
        g.emit("snapIndexChange"));
        return
    }
    if (nt === et && g.params.loop && g.virtual && g.params.virtual.enabled) {
        g.realIndex = ot(nt);
        return
    }
    const at = g.grid && $.grid && $.grid.rows > 1;
    let st;
    if (g.virtual && $.virtual.enabled && $.loop)
        st = ot(nt);
    else if (at) {
        const dt = g.slides.filter(ht=>ht.column === nt)[0];
        let ft = parseInt(dt.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(ft) && (ft = Math.max(g.slides.indexOf(dt), 0)),
        st = Math.floor(ft / $.grid.rows)
    } else if (g.slides[nt]) {
        const dt = g.slides[nt].getAttribute("data-swiper-slide-index");
        dt ? st = parseInt(dt, 10) : st = nt
    } else
        st = nt;
    Object.assign(g, {
        previousSnapIndex: rt,
        snapIndex: it,
        previousRealIndex: tt,
        realIndex: st,
        previousIndex: et,
        activeIndex: nt
    }),
    g.initialized && preload(g),
    g.emit("activeIndexChange"),
    g.emit("snapIndexChange"),
    (g.initialized || g.params.runCallbacksOnInit) && (tt !== st && g.emit("realIndexChange"),
    g.emit("slideChange"))
}
function updateClickedSlide(d, g) {
    const b = this
      , _ = b.params;
    let $ = d.closest(`.${_.slideClass}, swiper-slide`);
    !$ && b.isElement && g && g.length > 1 && g.includes(d) && [...g.slice(g.indexOf(d) + 1, g.length)].forEach(rt=>{
        !$ && rt.matches && rt.matches(`.${_.slideClass}, swiper-slide`) && ($ = rt)
    }
    );
    let et = !1, tt;
    if ($) {
        for (let rt = 0; rt < b.slides.length; rt += 1)
            if (b.slides[rt] === $) {
                et = !0,
                tt = rt;
                break
            }
    }
    if ($ && et)
        b.clickedSlide = $,
        b.virtual && b.params.virtual.enabled ? b.clickedIndex = parseInt($.getAttribute("data-swiper-slide-index"), 10) : b.clickedIndex = tt;
    else {
        b.clickedSlide = void 0,
        b.clickedIndex = void 0;
        return
    }
    _.slideToClickedSlide && b.clickedIndex !== void 0 && b.clickedIndex !== b.activeIndex && b.slideToClickedSlide()
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(d) {
    d === void 0 && (d = this.isHorizontal() ? "x" : "y");
    const g = this
      , {params: b, rtlTranslate: _, translate: $, wrapperEl: et} = g;
    if (b.virtualTranslate)
        return _ ? -$ : $;
    if (b.cssMode)
        return $;
    let tt = getTranslate(et, d);
    return tt += g.cssOverflowAdjustment(),
    _ && (tt = -tt),
    tt || 0
}
function setTranslate(d, g) {
    const b = this
      , {rtlTranslate: _, params: $, wrapperEl: et, progress: tt} = b;
    let rt = 0
      , nt = 0;
    const it = 0;
    b.isHorizontal() ? rt = _ ? -d : d : nt = d,
    $.roundLengths && (rt = Math.floor(rt),
    nt = Math.floor(nt)),
    b.previousTranslate = b.translate,
    b.translate = b.isHorizontal() ? rt : nt,
    $.cssMode ? et[b.isHorizontal() ? "scrollLeft" : "scrollTop"] = b.isHorizontal() ? -rt : -nt : $.virtualTranslate || (b.isHorizontal() ? rt -= b.cssOverflowAdjustment() : nt -= b.cssOverflowAdjustment(),
    et.style.transform = `translate3d(${rt}px, ${nt}px, ${it}px)`);
    let ot;
    const at = b.maxTranslate() - b.minTranslate();
    at === 0 ? ot = 0 : ot = (d - b.minTranslate()) / at,
    ot !== tt && b.updateProgress(d),
    b.emit("setTranslate", b.translate, g)
}
function minTranslate() {
    return -this.snapGrid[0]
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function translateTo(d, g, b, _, $) {
    d === void 0 && (d = 0),
    g === void 0 && (g = this.params.speed),
    b === void 0 && (b = !0),
    _ === void 0 && (_ = !0);
    const et = this
      , {params: tt, wrapperEl: rt} = et;
    if (et.animating && tt.preventInteractionOnTransition)
        return !1;
    const nt = et.minTranslate()
      , it = et.maxTranslate();
    let ot;
    if (_ && d > nt ? ot = nt : _ && d < it ? ot = it : ot = d,
    et.updateProgress(ot),
    tt.cssMode) {
        const at = et.isHorizontal();
        if (g === 0)
            rt[at ? "scrollLeft" : "scrollTop"] = -ot;
        else {
            if (!et.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: et,
                    targetPosition: -ot,
                    side: at ? "left" : "top"
                }),
                !0;
            rt.scrollTo({
                [at ? "left" : "top"]: -ot,
                behavior: "smooth"
            })
        }
        return !0
    }
    return g === 0 ? (et.setTransition(0),
    et.setTranslate(ot),
    b && (et.emit("beforeTransitionStart", g, $),
    et.emit("transitionEnd"))) : (et.setTransition(g),
    et.setTranslate(ot),
    b && (et.emit("beforeTransitionStart", g, $),
    et.emit("transitionStart")),
    et.animating || (et.animating = !0,
    et.onTranslateToWrapperTransitionEnd || (et.onTranslateToWrapperTransitionEnd = function(st) {
        !et || et.destroyed || st.target === this && (et.wrapperEl.removeEventListener("transitionend", et.onTranslateToWrapperTransitionEnd),
        et.onTranslateToWrapperTransitionEnd = null,
        delete et.onTranslateToWrapperTransitionEnd,
        et.animating = !1,
        b && et.emit("transitionEnd"))
    }
    ),
    et.wrapperEl.addEventListener("transitionend", et.onTranslateToWrapperTransitionEnd))),
    !0
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(d, g) {
    const b = this;
    b.params.cssMode || (b.wrapperEl.style.transitionDuration = `${d}ms`,
    b.wrapperEl.style.transitionDelay = d === 0 ? "0ms" : ""),
    b.emit("setTransition", d, g)
}
function transitionEmit(d) {
    let {swiper: g, runCallbacks: b, direction: _, step: $} = d;
    const {activeIndex: et, previousIndex: tt} = g;
    let rt = _;
    if (rt || (et > tt ? rt = "next" : et < tt ? rt = "prev" : rt = "reset"),
    g.emit(`transition${$}`),
    b && et !== tt) {
        if (rt === "reset") {
            g.emit(`slideResetTransition${$}`);
            return
        }
        g.emit(`slideChangeTransition${$}`),
        rt === "next" ? g.emit(`slideNextTransition${$}`) : g.emit(`slidePrevTransition${$}`)
    }
}
function transitionStart(d, g) {
    d === void 0 && (d = !0);
    const b = this
      , {params: _} = b;
    _.cssMode || (_.autoHeight && b.updateAutoHeight(),
    transitionEmit({
        swiper: b,
        runCallbacks: d,
        direction: g,
        step: "Start"
    }))
}
function transitionEnd(d, g) {
    d === void 0 && (d = !0);
    const b = this
      , {params: _} = b;
    b.animating = !1,
    !_.cssMode && (b.setTransition(0),
    transitionEmit({
        swiper: b,
        runCallbacks: d,
        direction: g,
        step: "End"
    }))
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(d, g, b, _, $) {
    d === void 0 && (d = 0),
    b === void 0 && (b = !0),
    typeof d == "string" && (d = parseInt(d, 10));
    const et = this;
    let tt = d;
    tt < 0 && (tt = 0);
    const {params: rt, snapGrid: nt, slidesGrid: it, previousIndex: ot, activeIndex: at, rtlTranslate: st, wrapperEl: dt, enabled: ft} = et;
    if (!ft && !_ && !$ || et.destroyed || et.animating && rt.preventInteractionOnTransition)
        return !1;
    typeof g > "u" && (g = et.params.speed);
    const ht = Math.min(et.params.slidesPerGroupSkip, tt);
    let xt = ht + Math.floor((tt - ht) / et.params.slidesPerGroup);
    xt >= nt.length && (xt = nt.length - 1);
    const lt = -nt[xt];
    if (rt.normalizeSlideIndex)
        for (let ut = 0; ut < it.length; ut += 1) {
            const pt = -Math.floor(lt * 100)
              , vt = Math.floor(it[ut] * 100)
              , _t = Math.floor(it[ut + 1] * 100);
            typeof it[ut + 1] < "u" ? pt >= vt && pt < _t - (_t - vt) / 2 ? tt = ut : pt >= vt && pt < _t && (tt = ut + 1) : pt >= vt && (tt = ut)
        }
    if (et.initialized && tt !== at && (!et.allowSlideNext && (st ? lt > et.translate && lt > et.minTranslate() : lt < et.translate && lt < et.minTranslate()) || !et.allowSlidePrev && lt > et.translate && lt > et.maxTranslate() && (at || 0) !== tt))
        return !1;
    tt !== (ot || 0) && b && et.emit("beforeSlideChangeStart"),
    et.updateProgress(lt);
    let ct;
    if (tt > at ? ct = "next" : tt < at ? ct = "prev" : ct = "reset",
    st && -lt === et.translate || !st && lt === et.translate)
        return et.updateActiveIndex(tt),
        rt.autoHeight && et.updateAutoHeight(),
        et.updateSlidesClasses(),
        rt.effect !== "slide" && et.setTranslate(lt),
        ct !== "reset" && (et.transitionStart(b, ct),
        et.transitionEnd(b, ct)),
        !1;
    if (rt.cssMode) {
        const ut = et.isHorizontal()
          , pt = st ? lt : -lt;
        if (g === 0) {
            const vt = et.virtual && et.params.virtual.enabled;
            vt && (et.wrapperEl.style.scrollSnapType = "none",
            et._immediateVirtual = !0),
            vt && !et._cssModeVirtualInitialSet && et.params.initialSlide > 0 ? (et._cssModeVirtualInitialSet = !0,
            requestAnimationFrame(()=>{
                dt[ut ? "scrollLeft" : "scrollTop"] = pt
            }
            )) : dt[ut ? "scrollLeft" : "scrollTop"] = pt,
            vt && requestAnimationFrame(()=>{
                et.wrapperEl.style.scrollSnapType = "",
                et._immediateVirtual = !1
            }
            )
        } else {
            if (!et.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: et,
                    targetPosition: pt,
                    side: ut ? "left" : "top"
                }),
                !0;
            dt.scrollTo({
                [ut ? "left" : "top"]: pt,
                behavior: "smooth"
            })
        }
        return !0
    }
    return et.setTransition(g),
    et.setTranslate(lt),
    et.updateActiveIndex(tt),
    et.updateSlidesClasses(),
    et.emit("beforeTransitionStart", g, _),
    et.transitionStart(b, ct),
    g === 0 ? et.transitionEnd(b, ct) : et.animating || (et.animating = !0,
    et.onSlideToWrapperTransitionEnd || (et.onSlideToWrapperTransitionEnd = function(pt) {
        !et || et.destroyed || pt.target === this && (et.wrapperEl.removeEventListener("transitionend", et.onSlideToWrapperTransitionEnd),
        et.onSlideToWrapperTransitionEnd = null,
        delete et.onSlideToWrapperTransitionEnd,
        et.transitionEnd(b, ct))
    }
    ),
    et.wrapperEl.addEventListener("transitionend", et.onSlideToWrapperTransitionEnd)),
    !0
}
function slideToLoop(d, g, b, _) {
    d === void 0 && (d = 0),
    b === void 0 && (b = !0),
    typeof d == "string" && (d = parseInt(d, 10));
    const $ = this;
    if ($.destroyed)
        return;
    typeof g > "u" && (g = $.params.speed);
    const et = $.grid && $.params.grid && $.params.grid.rows > 1;
    let tt = d;
    if ($.params.loop)
        if ($.virtual && $.params.virtual.enabled)
            tt = tt + $.virtual.slidesBefore;
        else {
            let rt;
            if (et) {
                const st = tt * $.params.grid.rows;
                rt = $.slides.filter(dt=>dt.getAttribute("data-swiper-slide-index") * 1 === st)[0].column
            } else
                rt = $.getSlideIndexByData(tt);
            const nt = et ? Math.ceil($.slides.length / $.params.grid.rows) : $.slides.length
              , {centeredSlides: it} = $.params;
            let ot = $.params.slidesPerView;
            ot === "auto" ? ot = $.slidesPerViewDynamic() : (ot = Math.ceil(parseFloat($.params.slidesPerView, 10)),
            it && ot % 2 === 0 && (ot = ot + 1));
            let at = nt - rt < ot;
            if (it && (at = at || rt < Math.ceil(ot / 2)),
            _ && it && $.params.slidesPerView !== "auto" && !et && (at = !1),
            at) {
                const st = it ? rt < $.activeIndex ? "prev" : "next" : rt - $.activeIndex - 1 < $.params.slidesPerView ? "next" : "prev";
                $.loopFix({
                    direction: st,
                    slideTo: !0,
                    activeSlideIndex: st === "next" ? rt + 1 : rt - nt + 1,
                    slideRealIndex: st === "next" ? $.realIndex : void 0
                })
            }
            if (et) {
                const st = tt * $.params.grid.rows;
                tt = $.slides.filter(dt=>dt.getAttribute("data-swiper-slide-index") * 1 === st)[0].column
            } else
                tt = $.getSlideIndexByData(tt)
        }
    return requestAnimationFrame(()=>{
        $.slideTo(tt, g, b, _)
    }
    ),
    $
}
function slideNext(d, g, b) {
    g === void 0 && (g = !0);
    const _ = this
      , {enabled: $, params: et, animating: tt} = _;
    if (!$ || _.destroyed)
        return _;
    typeof d > "u" && (d = _.params.speed);
    let rt = et.slidesPerGroup;
    et.slidesPerView === "auto" && et.slidesPerGroup === 1 && et.slidesPerGroupAuto && (rt = Math.max(_.slidesPerViewDynamic("current", !0), 1));
    const nt = _.activeIndex < et.slidesPerGroupSkip ? 1 : rt
      , it = _.virtual && et.virtual.enabled;
    if (et.loop) {
        if (tt && !it && et.loopPreventsSliding)
            return !1;
        if (_.loopFix({
            direction: "next"
        }),
        _._clientLeft = _.wrapperEl.clientLeft,
        _.activeIndex === _.slides.length - 1 && et.cssMode)
            return requestAnimationFrame(()=>{
                _.slideTo(_.activeIndex + nt, d, g, b)
            }
            ),
            !0
    }
    return et.rewind && _.isEnd ? _.slideTo(0, d, g, b) : _.slideTo(_.activeIndex + nt, d, g, b)
}
function slidePrev(d, g, b) {
    g === void 0 && (g = !0);
    const _ = this
      , {params: $, snapGrid: et, slidesGrid: tt, rtlTranslate: rt, enabled: nt, animating: it} = _;
    if (!nt || _.destroyed)
        return _;
    typeof d > "u" && (d = _.params.speed);
    const ot = _.virtual && $.virtual.enabled;
    if ($.loop) {
        if (it && !ot && $.loopPreventsSliding)
            return !1;
        _.loopFix({
            direction: "prev"
        }),
        _._clientLeft = _.wrapperEl.clientLeft
    }
    const at = rt ? _.translate : -_.translate;
    function st(lt) {
        return lt < 0 ? -Math.floor(Math.abs(lt)) : Math.floor(lt)
    }
    const dt = st(at)
      , ft = et.map(lt=>st(lt));
    let ht = et[ft.indexOf(dt) - 1];
    if (typeof ht > "u" && $.cssMode) {
        let lt;
        et.forEach((ct,ut)=>{
            dt >= ct && (lt = ut)
        }
        ),
        typeof lt < "u" && (ht = et[lt > 0 ? lt - 1 : lt])
    }
    let xt = 0;
    if (typeof ht < "u" && (xt = tt.indexOf(ht),
    xt < 0 && (xt = _.activeIndex - 1),
    $.slidesPerView === "auto" && $.slidesPerGroup === 1 && $.slidesPerGroupAuto && (xt = xt - _.slidesPerViewDynamic("previous", !0) + 1,
    xt = Math.max(xt, 0))),
    $.rewind && _.isBeginning) {
        const lt = _.params.virtual && _.params.virtual.enabled && _.virtual ? _.virtual.slides.length - 1 : _.slides.length - 1;
        return _.slideTo(lt, d, g, b)
    } else if ($.loop && _.activeIndex === 0 && $.cssMode)
        return requestAnimationFrame(()=>{
            _.slideTo(xt, d, g, b)
        }
        ),
        !0;
    return _.slideTo(xt, d, g, b)
}
function slideReset(d, g, b) {
    g === void 0 && (g = !0);
    const _ = this;
    if (!_.destroyed)
        return typeof d > "u" && (d = _.params.speed),
        _.slideTo(_.activeIndex, d, g, b)
}
function slideToClosest(d, g, b, _) {
    g === void 0 && (g = !0),
    _ === void 0 && (_ = .5);
    const $ = this;
    if ($.destroyed)
        return;
    typeof d > "u" && (d = $.params.speed);
    let et = $.activeIndex;
    const tt = Math.min($.params.slidesPerGroupSkip, et)
      , rt = tt + Math.floor((et - tt) / $.params.slidesPerGroup)
      , nt = $.rtlTranslate ? $.translate : -$.translate;
    if (nt >= $.snapGrid[rt]) {
        const it = $.snapGrid[rt]
          , ot = $.snapGrid[rt + 1];
        nt - it > (ot - it) * _ && (et += $.params.slidesPerGroup)
    } else {
        const it = $.snapGrid[rt - 1]
          , ot = $.snapGrid[rt];
        nt - it <= (ot - it) * _ && (et -= $.params.slidesPerGroup)
    }
    return et = Math.max(et, 0),
    et = Math.min(et, $.slidesGrid.length - 1),
    $.slideTo(et, d, g, b)
}
function slideToClickedSlide() {
    const d = this;
    if (d.destroyed)
        return;
    const {params: g, slidesEl: b} = d
      , _ = g.slidesPerView === "auto" ? d.slidesPerViewDynamic() : g.slidesPerView;
    let $ = d.clickedIndex, et;
    const tt = d.isElement ? "swiper-slide" : `.${g.slideClass}`;
    if (g.loop) {
        if (d.animating)
            return;
        et = parseInt(d.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
        g.centeredSlides ? $ < d.loopedSlides - _ / 2 || $ > d.slides.length - d.loopedSlides + _ / 2 ? (d.loopFix(),
        $ = d.getSlideIndex(elementChildren(b, `${tt}[data-swiper-slide-index="${et}"]`)[0]),
        nextTick(()=>{
            d.slideTo($)
        }
        )) : d.slideTo($) : $ > d.slides.length - _ ? (d.loopFix(),
        $ = d.getSlideIndex(elementChildren(b, `${tt}[data-swiper-slide-index="${et}"]`)[0]),
        nextTick(()=>{
            d.slideTo($)
        }
        )) : d.slideTo($)
    } else
        d.slideTo($)
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(d) {
    const g = this
      , {params: b, slidesEl: _} = g;
    if (!b.loop || g.virtual && g.params.virtual.enabled)
        return;
    const $ = ()=>{
        elementChildren(_, `.${b.slideClass}, swiper-slide`).forEach((at,st)=>{
            at.setAttribute("data-swiper-slide-index", st)
        }
        )
    }
      , et = g.grid && b.grid && b.grid.rows > 1
      , tt = b.slidesPerGroup * (et ? b.grid.rows : 1)
      , rt = g.slides.length % tt !== 0
      , nt = et && g.slides.length % b.grid.rows !== 0
      , it = ot=>{
        for (let at = 0; at < ot; at += 1) {
            const st = g.isElement ? createElement("swiper-slide", [b.slideBlankClass]) : createElement("div", [b.slideClass, b.slideBlankClass]);
            g.slidesEl.append(st)
        }
    }
    ;
    if (rt) {
        if (b.loopAddBlankSlides) {
            const ot = tt - g.slides.length % tt;
            it(ot),
            g.recalcSlides(),
            g.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        $()
    } else if (nt) {
        if (b.loopAddBlankSlides) {
            const ot = b.grid.rows - g.slides.length % b.grid.rows;
            it(ot),
            g.recalcSlides(),
            g.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        $()
    } else
        $();
    g.loopFix({
        slideRealIndex: d,
        direction: b.centeredSlides ? void 0 : "next"
    })
}
function loopFix(d) {
    let {slideRealIndex: g, slideTo: b=!0, direction: _, setTranslate: $, activeSlideIndex: et, byController: tt, byMousewheel: rt} = d === void 0 ? {} : d;
    const nt = this;
    if (!nt.params.loop)
        return;
    nt.emit("beforeLoopFix");
    const {slides: it, allowSlidePrev: ot, allowSlideNext: at, slidesEl: st, params: dt} = nt
      , {centeredSlides: ft} = dt;
    if (nt.allowSlidePrev = !0,
    nt.allowSlideNext = !0,
    nt.virtual && dt.virtual.enabled) {
        b && (!dt.centeredSlides && nt.snapIndex === 0 ? nt.slideTo(nt.virtual.slides.length, 0, !1, !0) : dt.centeredSlides && nt.snapIndex < dt.slidesPerView ? nt.slideTo(nt.virtual.slides.length + nt.snapIndex, 0, !1, !0) : nt.snapIndex === nt.snapGrid.length - 1 && nt.slideTo(nt.virtual.slidesBefore, 0, !1, !0)),
        nt.allowSlidePrev = ot,
        nt.allowSlideNext = at,
        nt.emit("loopFix");
        return
    }
    let ht = dt.slidesPerView;
    ht === "auto" ? ht = nt.slidesPerViewDynamic() : (ht = Math.ceil(parseFloat(dt.slidesPerView, 10)),
    ft && ht % 2 === 0 && (ht = ht + 1));
    const xt = dt.slidesPerGroupAuto ? ht : dt.slidesPerGroup;
    let lt = xt;
    lt % xt !== 0 && (lt += xt - lt % xt),
    lt += dt.loopAdditionalSlides,
    nt.loopedSlides = lt;
    const ct = nt.grid && dt.grid && dt.grid.rows > 1;
    it.length < ht + lt ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : ct && dt.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const ut = []
      , pt = [];
    let vt = nt.activeIndex;
    typeof et > "u" ? et = nt.getSlideIndex(it.filter(Vt=>Vt.classList.contains(dt.slideActiveClass))[0]) : vt = et;
    const _t = _ === "next" || !_
      , Pt = _ === "prev" || !_;
    let kt = 0
      , $t = 0;
    const Wt = ct ? Math.ceil(it.length / dt.grid.rows) : it.length
      , Dt = (ct ? it[et].column : et) + (ft && typeof $ > "u" ? -ht / 2 + .5 : 0);
    if (Dt < lt) {
        kt = Math.max(lt - Dt, xt);
        for (let Vt = 0; Vt < lt - Dt; Vt += 1) {
            const Ft = Vt - Math.floor(Vt / Wt) * Wt;
            if (ct) {
                const Kt = Wt - Ft - 1;
                for (let Rt = it.length - 1; Rt >= 0; Rt -= 1)
                    it[Rt].column === Kt && ut.push(Rt)
            } else
                ut.push(Wt - Ft - 1)
        }
    } else if (Dt + ht > Wt - lt) {
        $t = Math.max(Dt - (Wt - lt * 2), xt);
        for (let Vt = 0; Vt < $t; Vt += 1) {
            const Ft = Vt - Math.floor(Vt / Wt) * Wt;
            ct ? it.forEach((Kt,Rt)=>{
                Kt.column === Ft && pt.push(Rt)
            }
            ) : pt.push(Ft)
        }
    }
    if (nt.__preventObserver__ = !0,
    requestAnimationFrame(()=>{
        nt.__preventObserver__ = !1
    }
    ),
    Pt && ut.forEach(Vt=>{
        it[Vt].swiperLoopMoveDOM = !0,
        st.prepend(it[Vt]),
        it[Vt].swiperLoopMoveDOM = !1
    }
    ),
    _t && pt.forEach(Vt=>{
        it[Vt].swiperLoopMoveDOM = !0,
        st.append(it[Vt]),
        it[Vt].swiperLoopMoveDOM = !1
    }
    ),
    nt.recalcSlides(),
    dt.slidesPerView === "auto" ? nt.updateSlides() : ct && (ut.length > 0 && Pt || pt.length > 0 && _t) && nt.slides.forEach((Vt,Ft)=>{
        nt.grid.updateSlide(Ft, Vt, nt.slides)
    }
    ),
    dt.watchSlidesProgress && nt.updateSlidesOffset(),
    b) {
        if (ut.length > 0 && Pt) {
            if (typeof g > "u") {
                const Vt = nt.slidesGrid[vt]
                  , Kt = nt.slidesGrid[vt + kt] - Vt;
                rt ? nt.setTranslate(nt.translate - Kt) : (nt.slideTo(vt + Math.ceil(kt), 0, !1, !0),
                $ && (nt.touchEventsData.startTranslate = nt.touchEventsData.startTranslate - Kt,
                nt.touchEventsData.currentTranslate = nt.touchEventsData.currentTranslate - Kt))
            } else if ($) {
                const Vt = ct ? ut.length / dt.grid.rows : ut.length;
                nt.slideTo(nt.activeIndex + Vt, 0, !1, !0),
                nt.touchEventsData.currentTranslate = nt.translate
            }
        } else if (pt.length > 0 && _t)
            if (typeof g > "u") {
                const Vt = nt.slidesGrid[vt]
                  , Kt = nt.slidesGrid[vt - $t] - Vt;
                rt ? nt.setTranslate(nt.translate - Kt) : (nt.slideTo(vt - $t, 0, !1, !0),
                $ && (nt.touchEventsData.startTranslate = nt.touchEventsData.startTranslate - Kt,
                nt.touchEventsData.currentTranslate = nt.touchEventsData.currentTranslate - Kt))
            } else {
                const Vt = ct ? pt.length / dt.grid.rows : pt.length;
                nt.slideTo(nt.activeIndex - Vt, 0, !1, !0)
            }
    }
    if (nt.allowSlidePrev = ot,
    nt.allowSlideNext = at,
    nt.controller && nt.controller.control && !tt) {
        const Vt = {
            slideRealIndex: g,
            direction: _,
            setTranslate: $,
            activeSlideIndex: et,
            byController: !0
        };
        Array.isArray(nt.controller.control) ? nt.controller.control.forEach(Ft=>{
            !Ft.destroyed && Ft.params.loop && Ft.loopFix({
                ...Vt,
                slideTo: Ft.params.slidesPerView === dt.slidesPerView ? b : !1
            })
        }
        ) : nt.controller.control instanceof nt.constructor && nt.controller.control.params.loop && nt.controller.control.loopFix({
            ...Vt,
            slideTo: nt.controller.control.params.slidesPerView === dt.slidesPerView ? b : !1
        })
    }
    nt.emit("loopFix")
}
function loopDestroy() {
    const d = this
      , {params: g, slidesEl: b} = d;
    if (!g.loop || d.virtual && d.params.virtual.enabled)
        return;
    d.recalcSlides();
    const _ = [];
    d.slides.forEach($=>{
        const et = typeof $.swiperSlideIndex > "u" ? $.getAttribute("data-swiper-slide-index") * 1 : $.swiperSlideIndex;
        _[et] = $
    }
    ),
    d.slides.forEach($=>{
        $.removeAttribute("data-swiper-slide-index")
    }
    ),
    _.forEach($=>{
        b.append($)
    }
    ),
    d.recalcSlides(),
    d.slideTo(d.realIndex, 0)
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(d) {
    const g = this;
    if (!g.params.simulateTouch || g.params.watchOverflow && g.isLocked || g.params.cssMode)
        return;
    const b = g.params.touchEventsTarget === "container" ? g.el : g.wrapperEl;
    g.isElement && (g.__preventObserver__ = !0),
    b.style.cursor = "move",
    b.style.cursor = d ? "grabbing" : "grab",
    g.isElement && requestAnimationFrame(()=>{
        g.__preventObserver__ = !1
    }
    )
}
function unsetGrabCursor() {
    const d = this;
    d.params.watchOverflow && d.isLocked || d.params.cssMode || (d.isElement && (d.__preventObserver__ = !0),
    d[d.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    d.isElement && requestAnimationFrame(()=>{
        d.__preventObserver__ = !1
    }
    ))
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function closestElement(d, g) {
    g === void 0 && (g = this);
    function b(_) {
        if (!_ || _ === getDocument() || _ === getWindow())
            return null;
        _.assignedSlot && (_ = _.assignedSlot);
        const $ = _.closest(d);
        return !$ && !_.getRootNode ? null : $ || b(_.getRootNode().host)
    }
    return b(g)
}
function preventEdgeSwipe(d, g, b) {
    const _ = getWindow()
      , {params: $} = d
      , et = $.edgeSwipeDetection
      , tt = $.edgeSwipeThreshold;
    return et && (b <= tt || b >= _.innerWidth - tt) ? et === "prevent" ? (g.preventDefault(),
    !0) : !1 : !0
}
function onTouchStart(d) {
    const g = this
      , b = getDocument();
    let _ = d;
    _.originalEvent && (_ = _.originalEvent);
    const $ = g.touchEventsData;
    if (_.type === "pointerdown") {
        if ($.pointerId !== null && $.pointerId !== _.pointerId)
            return;
        $.pointerId = _.pointerId
    } else
        _.type === "touchstart" && _.targetTouches.length === 1 && ($.touchId = _.targetTouches[0].identifier);
    if (_.type === "touchstart") {
        preventEdgeSwipe(g, _, _.targetTouches[0].pageX);
        return
    }
    const {params: et, touches: tt, enabled: rt} = g;
    if (!rt || !et.simulateTouch && _.pointerType === "mouse" || g.animating && et.preventInteractionOnTransition)
        return;
    !g.animating && et.cssMode && et.loop && g.loopFix();
    let nt = _.target;
    if (et.touchEventsTarget === "wrapper" && !g.wrapperEl.contains(nt) || "which"in _ && _.which === 3 || "button"in _ && _.button > 0 || $.isTouched && $.isMoved)
        return;
    const it = !!et.noSwipingClass && et.noSwipingClass !== ""
      , ot = _.composedPath ? _.composedPath() : _.path;
    it && _.target && _.target.shadowRoot && ot && (nt = ot[0]);
    const at = et.noSwipingSelector ? et.noSwipingSelector : `.${et.noSwipingClass}`
      , st = !!(_.target && _.target.shadowRoot);
    if (et.noSwiping && (st ? closestElement(at, nt) : nt.closest(at))) {
        g.allowClick = !0;
        return
    }
    if (et.swipeHandler && !nt.closest(et.swipeHandler))
        return;
    tt.currentX = _.pageX,
    tt.currentY = _.pageY;
    const dt = tt.currentX
      , ft = tt.currentY;
    if (!preventEdgeSwipe(g, _, dt))
        return;
    Object.assign($, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    tt.startX = dt,
    tt.startY = ft,
    $.touchStartTime = now(),
    g.allowClick = !0,
    g.updateSize(),
    g.swipeDirection = void 0,
    et.threshold > 0 && ($.allowThresholdMove = !1);
    let ht = !0;
    nt.matches($.focusableElements) && (ht = !1,
    nt.nodeName === "SELECT" && ($.isTouched = !1)),
    b.activeElement && b.activeElement.matches($.focusableElements) && b.activeElement !== nt && b.activeElement.blur();
    const xt = ht && g.allowTouchMove && et.touchStartPreventDefault;
    (et.touchStartForcePreventDefault || xt) && !nt.isContentEditable && _.preventDefault(),
    et.freeMode && et.freeMode.enabled && g.freeMode && g.animating && !et.cssMode && g.freeMode.onTouchStart(),
    g.emit("touchStart", _)
}
function onTouchMove(d) {
    const g = getDocument()
      , b = this
      , _ = b.touchEventsData
      , {params: $, touches: et, rtlTranslate: tt, enabled: rt} = b;
    if (!rt || !$.simulateTouch && d.pointerType === "mouse")
        return;
    let nt = d;
    if (nt.originalEvent && (nt = nt.originalEvent),
    nt.type === "pointermove" && (_.touchId !== null || nt.pointerId !== _.pointerId))
        return;
    let it;
    if (nt.type === "touchmove") {
        if (it = [...nt.changedTouches].filter(_t=>_t.identifier === _.touchId)[0],
        !it || it.identifier !== _.touchId)
            return
    } else
        it = nt;
    if (!_.isTouched) {
        _.startMoving && _.isScrolling && b.emit("touchMoveOpposite", nt);
        return
    }
    const ot = it.pageX
      , at = it.pageY;
    if (nt.preventedByNestedSwiper) {
        et.startX = ot,
        et.startY = at;
        return
    }
    if (!b.allowTouchMove) {
        nt.target.matches(_.focusableElements) || (b.allowClick = !1),
        _.isTouched && (Object.assign(et, {
            startX: ot,
            startY: at,
            currentX: ot,
            currentY: at
        }),
        _.touchStartTime = now());
        return
    }
    if ($.touchReleaseOnEdges && !$.loop) {
        if (b.isVertical()) {
            if (at < et.startY && b.translate <= b.maxTranslate() || at > et.startY && b.translate >= b.minTranslate()) {
                _.isTouched = !1,
                _.isMoved = !1;
                return
            }
        } else if (ot < et.startX && b.translate <= b.maxTranslate() || ot > et.startX && b.translate >= b.minTranslate())
            return
    }
    if (g.activeElement && nt.target === g.activeElement && nt.target.matches(_.focusableElements)) {
        _.isMoved = !0,
        b.allowClick = !1;
        return
    }
    _.allowTouchCallbacks && b.emit("touchMove", nt),
    et.previousX = et.currentX,
    et.previousY = et.currentY,
    et.currentX = ot,
    et.currentY = at;
    const st = et.currentX - et.startX
      , dt = et.currentY - et.startY;
    if (b.params.threshold && Math.sqrt(st ** 2 + dt ** 2) < b.params.threshold)
        return;
    if (typeof _.isScrolling > "u") {
        let _t;
        b.isHorizontal() && et.currentY === et.startY || b.isVertical() && et.currentX === et.startX ? _.isScrolling = !1 : st * st + dt * dt >= 25 && (_t = Math.atan2(Math.abs(dt), Math.abs(st)) * 180 / Math.PI,
        _.isScrolling = b.isHorizontal() ? _t > $.touchAngle : 90 - _t > $.touchAngle)
    }
    if (_.isScrolling && b.emit("touchMoveOpposite", nt),
    typeof _.startMoving > "u" && (et.currentX !== et.startX || et.currentY !== et.startY) && (_.startMoving = !0),
    _.isScrolling || nt.type === "touchmove" && _.preventTouchMoveFromPointerMove) {
        _.isTouched = !1;
        return
    }
    if (!_.startMoving)
        return;
    b.allowClick = !1,
    !$.cssMode && nt.cancelable && nt.preventDefault(),
    $.touchMoveStopPropagation && !$.nested && nt.stopPropagation();
    let ft = b.isHorizontal() ? st : dt
      , ht = b.isHorizontal() ? et.currentX - et.previousX : et.currentY - et.previousY;
    $.oneWayMovement && (ft = Math.abs(ft) * (tt ? 1 : -1),
    ht = Math.abs(ht) * (tt ? 1 : -1)),
    et.diff = ft,
    ft *= $.touchRatio,
    tt && (ft = -ft,
    ht = -ht);
    const xt = b.touchesDirection;
    b.swipeDirection = ft > 0 ? "prev" : "next",
    b.touchesDirection = ht > 0 ? "prev" : "next";
    const lt = b.params.loop && !$.cssMode
      , ct = b.touchesDirection === "next" && b.allowSlideNext || b.touchesDirection === "prev" && b.allowSlidePrev;
    if (!_.isMoved) {
        if (lt && ct && b.loopFix({
            direction: b.swipeDirection
        }),
        _.startTranslate = b.getTranslate(),
        b.setTransition(0),
        b.animating) {
            const _t = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    bySwiperTouchMove: !0
                }
            });
            b.wrapperEl.dispatchEvent(_t)
        }
        _.allowMomentumBounce = !1,
        $.grabCursor && (b.allowSlideNext === !0 || b.allowSlidePrev === !0) && b.setGrabCursor(!0),
        b.emit("sliderFirstMove", nt)
    }
    let ut;
    if (new Date().getTime(),
    _.isMoved && _.allowThresholdMove && xt !== b.touchesDirection && lt && ct && Math.abs(ft) >= 1) {
        Object.assign(et, {
            startX: ot,
            startY: at,
            currentX: ot,
            currentY: at,
            startTranslate: _.currentTranslate
        }),
        _.loopSwapReset = !0,
        _.startTranslate = _.currentTranslate;
        return
    }
    b.emit("sliderMove", nt),
    _.isMoved = !0,
    _.currentTranslate = ft + _.startTranslate;
    let pt = !0
      , vt = $.resistanceRatio;
    if ($.touchReleaseOnEdges && (vt = 0),
    ft > 0 ? (lt && ct && !ut && _.allowThresholdMove && _.currentTranslate > ($.centeredSlides ? b.minTranslate() - b.slidesSizesGrid[b.activeIndex + 1] : b.minTranslate()) && b.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    _.currentTranslate > b.minTranslate() && (pt = !1,
    $.resistance && (_.currentTranslate = b.minTranslate() - 1 + (-b.minTranslate() + _.startTranslate + ft) ** vt))) : ft < 0 && (lt && ct && !ut && _.allowThresholdMove && _.currentTranslate < ($.centeredSlides ? b.maxTranslate() + b.slidesSizesGrid[b.slidesSizesGrid.length - 1] : b.maxTranslate()) && b.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: b.slides.length - ($.slidesPerView === "auto" ? b.slidesPerViewDynamic() : Math.ceil(parseFloat($.slidesPerView, 10)))
    }),
    _.currentTranslate < b.maxTranslate() && (pt = !1,
    $.resistance && (_.currentTranslate = b.maxTranslate() + 1 - (b.maxTranslate() - _.startTranslate - ft) ** vt))),
    pt && (nt.preventedByNestedSwiper = !0),
    !b.allowSlideNext && b.swipeDirection === "next" && _.currentTranslate < _.startTranslate && (_.currentTranslate = _.startTranslate),
    !b.allowSlidePrev && b.swipeDirection === "prev" && _.currentTranslate > _.startTranslate && (_.currentTranslate = _.startTranslate),
    !b.allowSlidePrev && !b.allowSlideNext && (_.currentTranslate = _.startTranslate),
    $.threshold > 0)
        if (Math.abs(ft) > $.threshold || _.allowThresholdMove) {
            if (!_.allowThresholdMove) {
                _.allowThresholdMove = !0,
                et.startX = et.currentX,
                et.startY = et.currentY,
                _.currentTranslate = _.startTranslate,
                et.diff = b.isHorizontal() ? et.currentX - et.startX : et.currentY - et.startY;
                return
            }
        } else {
            _.currentTranslate = _.startTranslate;
            return
        }
    !$.followFinger || $.cssMode || (($.freeMode && $.freeMode.enabled && b.freeMode || $.watchSlidesProgress) && (b.updateActiveIndex(),
    b.updateSlidesClasses()),
    $.freeMode && $.freeMode.enabled && b.freeMode && b.freeMode.onTouchMove(),
    b.updateProgress(_.currentTranslate),
    b.setTranslate(_.currentTranslate))
}
function onTouchEnd(d) {
    const g = this
      , b = g.touchEventsData;
    let _ = d;
    _.originalEvent && (_ = _.originalEvent);
    let $;
    if (_.type === "touchend" || _.type === "touchcancel") {
        if ($ = [..._.changedTouches].filter(vt=>vt.identifier === b.touchId)[0],
        !$ || $.identifier !== b.touchId)
            return
    } else {
        if (b.touchId !== null || _.pointerId !== b.pointerId)
            return;
        $ = _
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(_.type) && !(["pointercancel", "contextmenu"].includes(_.type) && (g.browser.isSafari || g.browser.isWebView)))
        return;
    b.pointerId = null,
    b.touchId = null;
    const {params: tt, touches: rt, rtlTranslate: nt, slidesGrid: it, enabled: ot} = g;
    if (!ot || !tt.simulateTouch && _.pointerType === "mouse")
        return;
    if (b.allowTouchCallbacks && g.emit("touchEnd", _),
    b.allowTouchCallbacks = !1,
    !b.isTouched) {
        b.isMoved && tt.grabCursor && g.setGrabCursor(!1),
        b.isMoved = !1,
        b.startMoving = !1;
        return
    }
    tt.grabCursor && b.isMoved && b.isTouched && (g.allowSlideNext === !0 || g.allowSlidePrev === !0) && g.setGrabCursor(!1);
    const at = now()
      , st = at - b.touchStartTime;
    if (g.allowClick) {
        const vt = _.path || _.composedPath && _.composedPath();
        g.updateClickedSlide(vt && vt[0] || _.target, vt),
        g.emit("tap click", _),
        st < 300 && at - b.lastClickTime < 300 && g.emit("doubleTap doubleClick", _)
    }
    if (b.lastClickTime = now(),
    nextTick(()=>{
        g.destroyed || (g.allowClick = !0)
    }
    ),
    !b.isTouched || !b.isMoved || !g.swipeDirection || rt.diff === 0 && !b.loopSwapReset || b.currentTranslate === b.startTranslate && !b.loopSwapReset) {
        b.isTouched = !1,
        b.isMoved = !1,
        b.startMoving = !1;
        return
    }
    b.isTouched = !1,
    b.isMoved = !1,
    b.startMoving = !1;
    let dt;
    if (tt.followFinger ? dt = nt ? g.translate : -g.translate : dt = -b.currentTranslate,
    tt.cssMode)
        return;
    if (tt.freeMode && tt.freeMode.enabled) {
        g.freeMode.onTouchEnd({
            currentPos: dt
        });
        return
    }
    const ft = dt >= -g.maxTranslate() && !g.params.loop;
    let ht = 0
      , xt = g.slidesSizesGrid[0];
    for (let vt = 0; vt < it.length; vt += vt < tt.slidesPerGroupSkip ? 1 : tt.slidesPerGroup) {
        const _t = vt < tt.slidesPerGroupSkip - 1 ? 1 : tt.slidesPerGroup;
        typeof it[vt + _t] < "u" ? (ft || dt >= it[vt] && dt < it[vt + _t]) && (ht = vt,
        xt = it[vt + _t] - it[vt]) : (ft || dt >= it[vt]) && (ht = vt,
        xt = it[it.length - 1] - it[it.length - 2])
    }
    let lt = null
      , ct = null;
    tt.rewind && (g.isBeginning ? ct = tt.virtual && tt.virtual.enabled && g.virtual ? g.virtual.slides.length - 1 : g.slides.length - 1 : g.isEnd && (lt = 0));
    const ut = (dt - it[ht]) / xt
      , pt = ht < tt.slidesPerGroupSkip - 1 ? 1 : tt.slidesPerGroup;
    if (st > tt.longSwipesMs) {
        if (!tt.longSwipes) {
            g.slideTo(g.activeIndex);
            return
        }
        g.swipeDirection === "next" && (ut >= tt.longSwipesRatio ? g.slideTo(tt.rewind && g.isEnd ? lt : ht + pt) : g.slideTo(ht)),
        g.swipeDirection === "prev" && (ut > 1 - tt.longSwipesRatio ? g.slideTo(ht + pt) : ct !== null && ut < 0 && Math.abs(ut) > tt.longSwipesRatio ? g.slideTo(ct) : g.slideTo(ht))
    } else {
        if (!tt.shortSwipes) {
            g.slideTo(g.activeIndex);
            return
        }
        g.navigation && (_.target === g.navigation.nextEl || _.target === g.navigation.prevEl) ? _.target === g.navigation.nextEl ? g.slideTo(ht + pt) : g.slideTo(ht) : (g.swipeDirection === "next" && g.slideTo(lt !== null ? lt : ht + pt),
        g.swipeDirection === "prev" && g.slideTo(ct !== null ? ct : ht))
    }
}
function onResize() {
    const d = this
      , {params: g, el: b} = d;
    if (b && b.offsetWidth === 0)
        return;
    g.breakpoints && d.setBreakpoint();
    const {allowSlideNext: _, allowSlidePrev: $, snapGrid: et} = d
      , tt = d.virtual && d.params.virtual.enabled;
    d.allowSlideNext = !0,
    d.allowSlidePrev = !0,
    d.updateSize(),
    d.updateSlides(),
    d.updateSlidesClasses();
    const rt = tt && g.loop;
    (g.slidesPerView === "auto" || g.slidesPerView > 1) && d.isEnd && !d.isBeginning && !d.params.centeredSlides && !rt ? d.slideTo(d.slides.length - 1, 0, !1, !0) : d.params.loop && !tt ? d.slideToLoop(d.realIndex, 0, !1, !0) : d.slideTo(d.activeIndex, 0, !1, !0),
    d.autoplay && d.autoplay.running && d.autoplay.paused && (clearTimeout(d.autoplay.resizeTimeout),
    d.autoplay.resizeTimeout = setTimeout(()=>{
        d.autoplay && d.autoplay.running && d.autoplay.paused && d.autoplay.resume()
    }
    , 500)),
    d.allowSlidePrev = $,
    d.allowSlideNext = _,
    d.params.watchOverflow && et !== d.snapGrid && d.checkOverflow()
}
function onClick(d) {
    const g = this;
    g.enabled && (g.allowClick || (g.params.preventClicks && d.preventDefault(),
    g.params.preventClicksPropagation && g.animating && (d.stopPropagation(),
    d.stopImmediatePropagation())))
}
function onScroll() {
    const d = this
      , {wrapperEl: g, rtlTranslate: b, enabled: _} = d;
    if (!_)
        return;
    d.previousTranslate = d.translate,
    d.isHorizontal() ? d.translate = -g.scrollLeft : d.translate = -g.scrollTop,
    d.translate === 0 && (d.translate = 0),
    d.updateActiveIndex(),
    d.updateSlidesClasses();
    let $;
    const et = d.maxTranslate() - d.minTranslate();
    et === 0 ? $ = 0 : $ = (d.translate - d.minTranslate()) / et,
    $ !== d.progress && d.updateProgress(b ? -d.translate : d.translate),
    d.emit("setTranslate", d.translate, !1)
}
function onLoad(d) {
    const g = this;
    processLazyPreloader(g, d.target),
    !(g.params.cssMode || g.params.slidesPerView !== "auto" && !g.params.autoHeight) && g.update()
}
function onDocumentTouchStart() {
    const d = this;
    d.documentTouchHandlerProceeded || (d.documentTouchHandlerProceeded = !0,
    d.params.touchReleaseOnEdges && (d.el.style.touchAction = "auto"))
}
const events = (d,g)=>{
    const b = getDocument()
      , {params: _, el: $, wrapperEl: et, device: tt} = d
      , rt = !!_.nested
      , nt = g === "on" ? "addEventListener" : "removeEventListener"
      , it = g;
    !$ || typeof $ == "string" || (b[nt]("touchstart", d.onDocumentTouchStart, {
        passive: !1,
        capture: rt
    }),
    $[nt]("touchstart", d.onTouchStart, {
        passive: !1
    }),
    $[nt]("pointerdown", d.onTouchStart, {
        passive: !1
    }),
    b[nt]("touchmove", d.onTouchMove, {
        passive: !1,
        capture: rt
    }),
    b[nt]("pointermove", d.onTouchMove, {
        passive: !1,
        capture: rt
    }),
    b[nt]("touchend", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("pointerup", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("pointercancel", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("touchcancel", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("pointerout", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("pointerleave", d.onTouchEnd, {
        passive: !0
    }),
    b[nt]("contextmenu", d.onTouchEnd, {
        passive: !0
    }),
    (_.preventClicks || _.preventClicksPropagation) && $[nt]("click", d.onClick, !0),
    _.cssMode && et[nt]("scroll", d.onScroll),
    _.updateOnWindowResize ? d[it](tt.ios || tt.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : d[it]("observerUpdate", onResize, !0),
    $[nt]("load", d.onLoad, {
        capture: !0
    }))
}
;
function attachEvents() {
    const d = this
      , {params: g} = d;
    d.onTouchStart = onTouchStart.bind(d),
    d.onTouchMove = onTouchMove.bind(d),
    d.onTouchEnd = onTouchEnd.bind(d),
    d.onDocumentTouchStart = onDocumentTouchStart.bind(d),
    g.cssMode && (d.onScroll = onScroll.bind(d)),
    d.onClick = onClick.bind(d),
    d.onLoad = onLoad.bind(d),
    events(d, "on")
}
function detachEvents() {
    events(this, "off")
}
var events$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (d,g)=>d.grid && g.grid && g.grid.rows > 1;
function setBreakpoint() {
    const d = this
      , {realIndex: g, initialized: b, params: _, el: $} = d
      , et = _.breakpoints;
    if (!et || et && Object.keys(et).length === 0)
        return;
    const tt = d.getBreakpoint(et, d.params.breakpointsBase, d.el);
    if (!tt || d.currentBreakpoint === tt)
        return;
    const nt = (tt in et ? et[tt] : void 0) || d.originalParams
      , it = isGridEnabled(d, _)
      , ot = isGridEnabled(d, nt)
      , at = d.params.grabCursor
      , st = nt.grabCursor
      , dt = _.enabled;
    it && !ot ? ($.classList.remove(`${_.containerModifierClass}grid`, `${_.containerModifierClass}grid-column`),
    d.emitContainerClasses()) : !it && ot && ($.classList.add(`${_.containerModifierClass}grid`),
    (nt.grid.fill && nt.grid.fill === "column" || !nt.grid.fill && _.grid.fill === "column") && $.classList.add(`${_.containerModifierClass}grid-column`),
    d.emitContainerClasses()),
    at && !st ? d.unsetGrabCursor() : !at && st && d.setGrabCursor(),
    ["navigation", "pagination", "scrollbar"].forEach(ut=>{
        if (typeof nt[ut] > "u")
            return;
        const pt = _[ut] && _[ut].enabled
          , vt = nt[ut] && nt[ut].enabled;
        pt && !vt && d[ut].disable(),
        !pt && vt && d[ut].enable()
    }
    );
    const ft = nt.direction && nt.direction !== _.direction
      , ht = _.loop && (nt.slidesPerView !== _.slidesPerView || ft)
      , xt = _.loop;
    ft && b && d.changeDirection(),
    extend$1(d.params, nt);
    const lt = d.params.enabled
      , ct = d.params.loop;
    Object.assign(d, {
        allowTouchMove: d.params.allowTouchMove,
        allowSlideNext: d.params.allowSlideNext,
        allowSlidePrev: d.params.allowSlidePrev
    }),
    dt && !lt ? d.disable() : !dt && lt && d.enable(),
    d.currentBreakpoint = tt,
    d.emit("_beforeBreakpoint", nt),
    b && (ht ? (d.loopDestroy(),
    d.loopCreate(g),
    d.updateSlides()) : !xt && ct ? (d.loopCreate(g),
    d.updateSlides()) : xt && !ct && d.loopDestroy()),
    d.emit("breakpoint", nt)
}
function getBreakpoint(d, g, b) {
    if (g === void 0 && (g = "window"),
    !d || g === "container" && !b)
        return;
    let _ = !1;
    const $ = getWindow()
      , et = g === "window" ? $.innerHeight : b.clientHeight
      , tt = Object.keys(d).map(rt=>{
        if (typeof rt == "string" && rt.indexOf("@") === 0) {
            const nt = parseFloat(rt.substr(1));
            return {
                value: et * nt,
                point: rt
            }
        }
        return {
            value: rt,
            point: rt
        }
    }
    );
    tt.sort((rt,nt)=>parseInt(rt.value, 10) - parseInt(nt.value, 10));
    for (let rt = 0; rt < tt.length; rt += 1) {
        const {point: nt, value: it} = tt[rt];
        g === "window" ? $.matchMedia(`(min-width: ${it}px)`).matches && (_ = nt) : it <= b.clientWidth && (_ = nt)
    }
    return _ || "max"
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(d, g) {
    const b = [];
    return d.forEach(_=>{
        typeof _ == "object" ? Object.keys(_).forEach($=>{
            _[$] && b.push(g + $)
        }
        ) : typeof _ == "string" && b.push(g + _)
    }
    ),
    b
}
function addClasses() {
    const d = this
      , {classNames: g, params: b, rtl: _, el: $, device: et} = d
      , tt = prepareClasses(["initialized", b.direction, {
        "free-mode": d.params.freeMode && b.freeMode.enabled
    }, {
        autoheight: b.autoHeight
    }, {
        rtl: _
    }, {
        grid: b.grid && b.grid.rows > 1
    }, {
        "grid-column": b.grid && b.grid.rows > 1 && b.grid.fill === "column"
    }, {
        android: et.android
    }, {
        ios: et.ios
    }, {
        "css-mode": b.cssMode
    }, {
        centered: b.cssMode && b.centeredSlides
    }, {
        "watch-progress": b.watchSlidesProgress
    }], b.containerModifierClass);
    g.push(...tt),
    $.classList.add(...g),
    d.emitContainerClasses()
}
function removeClasses() {
    const d = this
      , {el: g, classNames: b} = d;
    !g || typeof g == "string" || (g.classList.remove(...b),
    d.emitContainerClasses())
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const d = this
      , {isLocked: g, params: b} = d
      , {slidesOffsetBefore: _} = b;
    if (_) {
        const $ = d.slides.length - 1
          , et = d.slidesGrid[$] + d.slidesSizesGrid[$] + _ * 2;
        d.isLocked = d.size > et
    } else
        d.isLocked = d.snapGrid.length === 1;
    b.allowSlideNext === !0 && (d.allowSlideNext = !d.isLocked),
    b.allowSlidePrev === !0 && (d.allowSlidePrev = !d.isLocked),
    g && g !== d.isLocked && (d.isEnd = !1),
    g !== d.isLocked && d.emit(d.isLocked ? "lock" : "unlock")
}
var checkOverflow$1 = {
    checkOverflow
}
  , defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function moduleExtendParams(d, g) {
    return function(_) {
        _ === void 0 && (_ = {});
        const $ = Object.keys(_)[0]
          , et = _[$];
        if (typeof et != "object" || et === null) {
            extend$1(g, _);
            return
        }
        if (d[$] === !0 && (d[$] = {
            enabled: !0
        }),
        $ === "navigation" && d[$] && d[$].enabled && !d[$].prevEl && !d[$].nextEl && (d[$].auto = !0),
        ["pagination", "scrollbar"].indexOf($) >= 0 && d[$] && d[$].enabled && !d[$].el && (d[$].auto = !0),
        !($ in d && "enabled"in et)) {
            extend$1(g, _);
            return
        }
        typeof d[$] == "object" && !("enabled"in d[$]) && (d[$].enabled = !0),
        d[$] || (d[$] = {
            enabled: !1
        }),
        extend$1(g, _)
    }
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
}
  , extendedDefaults = {};
let Swiper$1 = class bo {
    constructor() {
        let g, b;
        for (var _ = arguments.length, $ = new Array(_), et = 0; et < _; et++)
            $[et] = arguments[et];
        $.length === 1 && $[0].constructor && Object.prototype.toString.call($[0]).slice(8, -1) === "Object" ? b = $[0] : [g,b] = $,
        b || (b = {}),
        b = extend$1({}, b),
        g && !b.el && (b.el = g);
        const tt = getDocument();
        if (b.el && typeof b.el == "string" && tt.querySelectorAll(b.el).length > 1) {
            const ot = [];
            return tt.querySelectorAll(b.el).forEach(at=>{
                const st = extend$1({}, b, {
                    el: at
                });
                ot.push(new bo(st))
            }
            ),
            ot
        }
        const rt = this;
        rt.__swiper__ = !0,
        rt.support = getSupport(),
        rt.device = getDevice({
            userAgent: b.userAgent
        }),
        rt.browser = getBrowser(),
        rt.eventsListeners = {},
        rt.eventsAnyListeners = [],
        rt.modules = [...rt.__modules__],
        b.modules && Array.isArray(b.modules) && rt.modules.push(...b.modules);
        const nt = {};
        rt.modules.forEach(ot=>{
            ot({
                params: b,
                swiper: rt,
                extendParams: moduleExtendParams(b, nt),
                on: rt.on.bind(rt),
                once: rt.once.bind(rt),
                off: rt.off.bind(rt),
                emit: rt.emit.bind(rt)
            })
        }
        );
        const it = extend$1({}, defaults, nt);
        return rt.params = extend$1({}, it, extendedDefaults, b),
        rt.originalParams = extend$1({}, rt.params),
        rt.passedParams = extend$1({}, b),
        rt.params && rt.params.on && Object.keys(rt.params.on).forEach(ot=>{
            rt.on(ot, rt.params.on[ot])
        }
        ),
        rt.params && rt.params.onAny && rt.onAny(rt.params.onAny),
        Object.assign(rt, {
            enabled: rt.params.enabled,
            el: g,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return rt.params.direction === "horizontal"
            },
            isVertical() {
                return rt.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: rt.params.allowSlideNext,
            allowSlidePrev: rt.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: rt.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: rt.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        rt.emit("_swiper"),
        rt.params.init && rt.init(),
        rt
    }
    getDirectionLabel(g) {
        return this.isHorizontal() ? g : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[g]
    }
    getSlideIndex(g) {
        const {slidesEl: b, params: _} = this
          , $ = elementChildren(b, `.${_.slideClass}, swiper-slide`)
          , et = elementIndex($[0]);
        return elementIndex(g) - et
    }
    getSlideIndexByData(g) {
        return this.getSlideIndex(this.slides.filter(b=>b.getAttribute("data-swiper-slide-index") * 1 === g)[0])
    }
    recalcSlides() {
        const g = this
          , {slidesEl: b, params: _} = g;
        g.slides = elementChildren(b, `.${_.slideClass}, swiper-slide`)
    }
    enable() {
        const g = this;
        g.enabled || (g.enabled = !0,
        g.params.grabCursor && g.setGrabCursor(),
        g.emit("enable"))
    }
    disable() {
        const g = this;
        g.enabled && (g.enabled = !1,
        g.params.grabCursor && g.unsetGrabCursor(),
        g.emit("disable"))
    }
    setProgress(g, b) {
        const _ = this;
        g = Math.min(Math.max(g, 0), 1);
        const $ = _.minTranslate()
          , tt = (_.maxTranslate() - $) * g + $;
        _.translateTo(tt, typeof b > "u" ? 0 : b),
        _.updateActiveIndex(),
        _.updateSlidesClasses()
    }
    emitContainerClasses() {
        const g = this;
        if (!g.params._emitClasses || !g.el)
            return;
        const b = g.el.className.split(" ").filter(_=>_.indexOf("swiper") === 0 || _.indexOf(g.params.containerModifierClass) === 0);
        g.emit("_containerClasses", b.join(" "))
    }
    getSlideClasses(g) {
        const b = this;
        return b.destroyed ? "" : g.className.split(" ").filter(_=>_.indexOf("swiper-slide") === 0 || _.indexOf(b.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const g = this;
        if (!g.params._emitClasses || !g.el)
            return;
        const b = [];
        g.slides.forEach(_=>{
            const $ = g.getSlideClasses(_);
            b.push({
                slideEl: _,
                classNames: $
            }),
            g.emit("_slideClass", _, $)
        }
        ),
        g.emit("_slideClasses", b)
    }
    slidesPerViewDynamic(g, b) {
        g === void 0 && (g = "current"),
        b === void 0 && (b = !1);
        const _ = this
          , {params: $, slides: et, slidesGrid: tt, slidesSizesGrid: rt, size: nt, activeIndex: it} = _;
        let ot = 1;
        if (typeof $.slidesPerView == "number")
            return $.slidesPerView;
        if ($.centeredSlides) {
            let at = et[it] ? Math.ceil(et[it].swiperSlideSize) : 0, st;
            for (let dt = it + 1; dt < et.length; dt += 1)
                et[dt] && !st && (at += Math.ceil(et[dt].swiperSlideSize),
                ot += 1,
                at > nt && (st = !0));
            for (let dt = it - 1; dt >= 0; dt -= 1)
                et[dt] && !st && (at += et[dt].swiperSlideSize,
                ot += 1,
                at > nt && (st = !0))
        } else if (g === "current")
            for (let at = it + 1; at < et.length; at += 1)
                (b ? tt[at] + rt[at] - tt[it] < nt : tt[at] - tt[it] < nt) && (ot += 1);
        else
            for (let at = it - 1; at >= 0; at -= 1)
                tt[it] - tt[at] < nt && (ot += 1);
        return ot
    }
    update() {
        const g = this;
        if (!g || g.destroyed)
            return;
        const {snapGrid: b, params: _} = g;
        _.breakpoints && g.setBreakpoint(),
        [...g.el.querySelectorAll('[loading="lazy"]')].forEach(tt=>{
            tt.complete && processLazyPreloader(g, tt)
        }
        ),
        g.updateSize(),
        g.updateSlides(),
        g.updateProgress(),
        g.updateSlidesClasses();
        function $() {
            const tt = g.rtlTranslate ? g.translate * -1 : g.translate
              , rt = Math.min(Math.max(tt, g.maxTranslate()), g.minTranslate());
            g.setTranslate(rt),
            g.updateActiveIndex(),
            g.updateSlidesClasses()
        }
        let et;
        if (_.freeMode && _.freeMode.enabled && !_.cssMode)
            $(),
            _.autoHeight && g.updateAutoHeight();
        else {
            if ((_.slidesPerView === "auto" || _.slidesPerView > 1) && g.isEnd && !_.centeredSlides) {
                const tt = g.virtual && _.virtual.enabled ? g.virtual.slides : g.slides;
                et = g.slideTo(tt.length - 1, 0, !1, !0)
            } else
                et = g.slideTo(g.activeIndex, 0, !1, !0);
            et || $()
        }
        _.watchOverflow && b !== g.snapGrid && g.checkOverflow(),
        g.emit("update")
    }
    changeDirection(g, b) {
        b === void 0 && (b = !0);
        const _ = this
          , $ = _.params.direction;
        return g || (g = $ === "horizontal" ? "vertical" : "horizontal"),
        g === $ || g !== "horizontal" && g !== "vertical" || (_.el.classList.remove(`${_.params.containerModifierClass}${$}`),
        _.el.classList.add(`${_.params.containerModifierClass}${g}`),
        _.emitContainerClasses(),
        _.params.direction = g,
        _.slides.forEach(et=>{
            g === "vertical" ? et.style.width = "" : et.style.height = ""
        }
        ),
        _.emit("changeDirection"),
        b && _.update()),
        _
    }
    changeLanguageDirection(g) {
        const b = this;
        b.rtl && g === "rtl" || !b.rtl && g === "ltr" || (b.rtl = g === "rtl",
        b.rtlTranslate = b.params.direction === "horizontal" && b.rtl,
        b.rtl ? (b.el.classList.add(`${b.params.containerModifierClass}rtl`),
        b.el.dir = "rtl") : (b.el.classList.remove(`${b.params.containerModifierClass}rtl`),
        b.el.dir = "ltr"),
        b.update())
    }
    mount(g) {
        const b = this;
        if (b.mounted)
            return !0;
        let _ = g || b.params.el;
        if (typeof _ == "string" && (_ = document.querySelector(_)),
        !_)
            return !1;
        _.swiper = b,
        _.parentNode && _.parentNode.host && _.parentNode.host.nodeName === b.params.swiperElementNodeName.toUpperCase() && (b.isElement = !0);
        const $ = ()=>`.${(b.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let tt = (()=>_ && _.shadowRoot && _.shadowRoot.querySelector ? _.shadowRoot.querySelector($()) : elementChildren(_, $())[0])();
        return !tt && b.params.createElements && (tt = createElement("div", b.params.wrapperClass),
        _.append(tt),
        elementChildren(_, `.${b.params.slideClass}`).forEach(rt=>{
            tt.append(rt)
        }
        )),
        Object.assign(b, {
            el: _,
            wrapperEl: tt,
            slidesEl: b.isElement && !_.parentNode.host.slideSlots ? _.parentNode.host : tt,
            hostEl: b.isElement ? _.parentNode.host : _,
            mounted: !0,
            rtl: _.dir.toLowerCase() === "rtl" || elementStyle(_, "direction") === "rtl",
            rtlTranslate: b.params.direction === "horizontal" && (_.dir.toLowerCase() === "rtl" || elementStyle(_, "direction") === "rtl"),
            wrongRTL: elementStyle(tt, "display") === "-webkit-box"
        }),
        !0
    }
    init(g) {
        const b = this;
        if (b.initialized || b.mount(g) === !1)
            return b;
        b.emit("beforeInit"),
        b.params.breakpoints && b.setBreakpoint(),
        b.addClasses(),
        b.updateSize(),
        b.updateSlides(),
        b.params.watchOverflow && b.checkOverflow(),
        b.params.grabCursor && b.enabled && b.setGrabCursor(),
        b.params.loop && b.virtual && b.params.virtual.enabled ? b.slideTo(b.params.initialSlide + b.virtual.slidesBefore, 0, b.params.runCallbacksOnInit, !1, !0) : b.slideTo(b.params.initialSlide, 0, b.params.runCallbacksOnInit, !1, !0),
        b.params.loop && b.loopCreate(),
        b.attachEvents();
        const $ = [...b.el.querySelectorAll('[loading="lazy"]')];
        return b.isElement && $.push(...b.hostEl.querySelectorAll('[loading="lazy"]')),
        $.forEach(et=>{
            et.complete ? processLazyPreloader(b, et) : et.addEventListener("load", tt=>{
                processLazyPreloader(b, tt.target)
            }
            )
        }
        ),
        preload(b),
        b.initialized = !0,
        preload(b),
        b.emit("init"),
        b.emit("afterInit"),
        b
    }
    destroy(g, b) {
        g === void 0 && (g = !0),
        b === void 0 && (b = !0);
        const _ = this
          , {params: $, el: et, wrapperEl: tt, slides: rt} = _;
        return typeof _.params > "u" || _.destroyed || (_.emit("beforeDestroy"),
        _.initialized = !1,
        _.detachEvents(),
        $.loop && _.loopDestroy(),
        b && (_.removeClasses(),
        et && typeof et != "string" && et.removeAttribute("style"),
        tt && tt.removeAttribute("style"),
        rt && rt.length && rt.forEach(nt=>{
            nt.classList.remove($.slideVisibleClass, $.slideFullyVisibleClass, $.slideActiveClass, $.slideNextClass, $.slidePrevClass),
            nt.removeAttribute("style"),
            nt.removeAttribute("data-swiper-slide-index")
        }
        )),
        _.emit("destroy"),
        Object.keys(_.eventsListeners).forEach(nt=>{
            _.off(nt)
        }
        ),
        g !== !1 && (_.el && typeof _.el != "string" && (_.el.swiper = null),
        deleteProps(_)),
        _.destroyed = !0),
        null
    }
    static extendDefaults(g) {
        extend$1(extendedDefaults, g)
    }
    static get extendedDefaults() {
        return extendedDefaults
    }
    static get defaults() {
        return defaults
    }
    static installModule(g) {
        bo.prototype.__modules__ || (bo.prototype.__modules__ = []);
        const b = bo.prototype.__modules__;
        typeof g == "function" && b.indexOf(g) < 0 && b.push(g)
    }
    static use(g) {
        return Array.isArray(g) ? (g.forEach(b=>bo.installModule(b)),
        bo) : (bo.installModule(g),
        bo)
    }
}
;
Object.keys(prototypes).forEach(d=>{
    Object.keys(prototypes[d]).forEach(g=>{
        Swiper$1.prototype[g] = prototypes[d][g]
    }
    )
}
);
Swiper$1.use([Resize, Observer]);
const paramsList = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];
function isObject$4(d) {
    return typeof d == "object" && d !== null && d.constructor && Object.prototype.toString.call(d).slice(8, -1) === "Object" && !d.__swiper__
}
function extend(d, g) {
    const b = ["__proto__", "constructor", "prototype"];
    Object.keys(g).filter(_=>b.indexOf(_) < 0).forEach(_=>{
        typeof d[_] > "u" ? d[_] = g[_] : isObject$4(g[_]) && isObject$4(d[_]) && Object.keys(g[_]).length > 0 ? g[_].__swiper__ ? d[_] = g[_] : extend(d[_], g[_]) : d[_] = g[_]
    }
    )
}
function needsNavigation(d) {
    return d === void 0 && (d = {}),
    d.navigation && typeof d.navigation.nextEl > "u" && typeof d.navigation.prevEl > "u"
}
function needsPagination(d) {
    return d === void 0 && (d = {}),
    d.pagination && typeof d.pagination.el > "u"
}
function needsScrollbar(d) {
    return d === void 0 && (d = {}),
    d.scrollbar && typeof d.scrollbar.el > "u"
}
function uniqueClasses(d) {
    d === void 0 && (d = "");
    const g = d.split(" ").map(_=>_.trim()).filter(_=>!!_)
      , b = [];
    return g.forEach(_=>{
        b.indexOf(_) < 0 && b.push(_)
    }
    ),
    b.join(" ")
}
function wrapperClass(d) {
    return d === void 0 && (d = ""),
    d ? d.includes("swiper-wrapper") ? d : `swiper-wrapper ${d}` : "swiper-wrapper"
}
function updateSwiper(d) {
    let {swiper: g, slides: b, passedParams: _, changedParams: $, nextEl: et, prevEl: tt, scrollbarEl: rt, paginationEl: nt} = d;
    const it = $.filter($t=>$t !== "children" && $t !== "direction" && $t !== "wrapperClass")
      , {params: ot, pagination: at, navigation: st, scrollbar: dt, virtual: ft, thumbs: ht} = g;
    let xt, lt, ct, ut, pt, vt, _t, Pt;
    $.includes("thumbs") && _.thumbs && _.thumbs.swiper && ot.thumbs && !ot.thumbs.swiper && (xt = !0),
    $.includes("controller") && _.controller && _.controller.control && ot.controller && !ot.controller.control && (lt = !0),
    $.includes("pagination") && _.pagination && (_.pagination.el || nt) && (ot.pagination || ot.pagination === !1) && at && !at.el && (ct = !0),
    $.includes("scrollbar") && _.scrollbar && (_.scrollbar.el || rt) && (ot.scrollbar || ot.scrollbar === !1) && dt && !dt.el && (ut = !0),
    $.includes("navigation") && _.navigation && (_.navigation.prevEl || tt) && (_.navigation.nextEl || et) && (ot.navigation || ot.navigation === !1) && st && !st.prevEl && !st.nextEl && (pt = !0);
    const kt = $t=>{
        g[$t] && (g[$t].destroy(),
        $t === "navigation" ? (g.isElement && (g[$t].prevEl.remove(),
        g[$t].nextEl.remove()),
        ot[$t].prevEl = void 0,
        ot[$t].nextEl = void 0,
        g[$t].prevEl = void 0,
        g[$t].nextEl = void 0) : (g.isElement && g[$t].el.remove(),
        ot[$t].el = void 0,
        g[$t].el = void 0))
    }
    ;
    $.includes("loop") && g.isElement && (ot.loop && !_.loop ? vt = !0 : !ot.loop && _.loop ? _t = !0 : Pt = !0),
    it.forEach($t=>{
        if (isObject$4(ot[$t]) && isObject$4(_[$t]))
            Object.assign(ot[$t], _[$t]),
            ($t === "navigation" || $t === "pagination" || $t === "scrollbar") && "enabled"in _[$t] && !_[$t].enabled && kt($t);
        else {
            const Wt = _[$t];
            (Wt === !0 || Wt === !1) && ($t === "navigation" || $t === "pagination" || $t === "scrollbar") ? Wt === !1 && kt($t) : ot[$t] = _[$t]
        }
    }
    ),
    it.includes("controller") && !lt && g.controller && g.controller.control && ot.controller && ot.controller.control && (g.controller.control = ot.controller.control),
    $.includes("children") && b && ft && ot.virtual.enabled ? (ft.slides = b,
    ft.update(!0)) : $.includes("virtual") && ft && ot.virtual.enabled && (b && (ft.slides = b),
    ft.update(!0)),
    $.includes("children") && b && ot.loop && (Pt = !0),
    xt && ht.init() && ht.update(!0),
    lt && (g.controller.control = ot.controller.control),
    ct && (g.isElement && (!nt || typeof nt == "string") && (nt = document.createElement("div"),
    nt.classList.add("swiper-pagination"),
    nt.part.add("pagination"),
    g.el.appendChild(nt)),
    nt && (ot.pagination.el = nt),
    at.init(),
    at.render(),
    at.update()),
    ut && (g.isElement && (!rt || typeof rt == "string") && (rt = document.createElement("div"),
    rt.classList.add("swiper-scrollbar"),
    rt.part.add("scrollbar"),
    g.el.appendChild(rt)),
    rt && (ot.scrollbar.el = rt),
    dt.init(),
    dt.updateSize(),
    dt.setTranslate()),
    pt && (g.isElement && ((!et || typeof et == "string") && (et = document.createElement("div"),
    et.classList.add("swiper-button-next"),
    et.innerHTML = g.hostEl.constructor.nextButtonSvg,
    et.part.add("button-next"),
    g.el.appendChild(et)),
    (!tt || typeof tt == "string") && (tt = document.createElement("div"),
    tt.classList.add("swiper-button-prev"),
    tt.innerHTML = g.hostEl.constructor.prevButtonSvg,
    tt.part.add("button-prev"),
    g.el.appendChild(tt))),
    et && (ot.navigation.nextEl = et),
    tt && (ot.navigation.prevEl = tt),
    st.init(),
    st.update()),
    $.includes("allowSlideNext") && (g.allowSlideNext = _.allowSlideNext),
    $.includes("allowSlidePrev") && (g.allowSlidePrev = _.allowSlidePrev),
    $.includes("direction") && g.changeDirection(_.direction, !1),
    (vt || Pt) && g.loopDestroy(),
    (_t || Pt) && g.loopCreate(),
    g.update()
}
function getParams(d, g) {
    d === void 0 && (d = {}),
    g === void 0 && (g = !0);
    const b = {
        on: {}
    }
      , _ = {}
      , $ = {};
    extend(b, defaults),
    b._emitClasses = !0,
    b.init = !1;
    const et = {}
      , tt = paramsList.map(nt=>nt.replace(/_/, ""))
      , rt = Object.assign({}, d);
    return Object.keys(rt).forEach(nt=>{
        typeof d[nt] > "u" || (tt.indexOf(nt) >= 0 ? isObject$4(d[nt]) ? (b[nt] = {},
        $[nt] = {},
        extend(b[nt], d[nt]),
        extend($[nt], d[nt])) : (b[nt] = d[nt],
        $[nt] = d[nt]) : nt.search(/on[A-Z]/) === 0 && typeof d[nt] == "function" ? g ? _[`${nt[2].toLowerCase()}${nt.substr(3)}`] = d[nt] : b.on[`${nt[2].toLowerCase()}${nt.substr(3)}`] = d[nt] : et[nt] = d[nt])
    }
    ),
    ["navigation", "pagination", "scrollbar"].forEach(nt=>{
        b[nt] === !0 && (b[nt] = {}),
        b[nt] === !1 && delete b[nt]
    }
    ),
    {
        params: b,
        passedParams: $,
        rest: et,
        events: _
    }
}
function mountSwiper(d, g) {
    let {el: b, nextEl: _, prevEl: $, paginationEl: et, scrollbarEl: tt, swiper: rt} = d;
    needsNavigation(g) && _ && $ && (rt.params.navigation.nextEl = _,
    rt.originalParams.navigation.nextEl = _,
    rt.params.navigation.prevEl = $,
    rt.originalParams.navigation.prevEl = $),
    needsPagination(g) && et && (rt.params.pagination.el = et,
    rt.originalParams.pagination.el = et),
    needsScrollbar(g) && tt && (rt.params.scrollbar.el = tt,
    rt.originalParams.scrollbar.el = tt),
    rt.init(b)
}
function getChangedParams(d, g, b, _, $) {
    const et = [];
    if (!g)
        return et;
    const tt = nt=>{
        et.indexOf(nt) < 0 && et.push(nt)
    }
    ;
    if (b && _) {
        const nt = _.map($)
          , it = b.map($);
        nt.join("") !== it.join("") && tt("children"),
        _.length !== b.length && tt("children")
    }
    return paramsList.filter(nt=>nt[0] === "_").map(nt=>nt.replace(/_/, "")).forEach(nt=>{
        if (nt in d && nt in g)
            if (isObject$4(d[nt]) && isObject$4(g[nt])) {
                const it = Object.keys(d[nt])
                  , ot = Object.keys(g[nt]);
                it.length !== ot.length ? tt(nt) : (it.forEach(at=>{
                    d[nt][at] !== g[nt][at] && tt(nt)
                }
                ),
                ot.forEach(at=>{
                    d[nt][at] !== g[nt][at] && tt(nt)
                }
                ))
            } else
                d[nt] !== g[nt] && tt(nt)
    }
    ),
    et
}
const updateOnVirtualData = d=>{
    !d || d.destroyed || !d.params.virtual || d.params.virtual && !d.params.virtual.enabled || (d.updateSlides(),
    d.updateProgress(),
    d.updateSlidesClasses(),
    d.parallax && d.params.parallax && d.params.parallax.enabled && d.parallax.setTranslate())
}
;
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(d) {
        for (var g = 1; g < arguments.length; g++) {
            var b = arguments[g];
            for (var _ in b)
                Object.prototype.hasOwnProperty.call(b, _) && (d[_] = b[_])
        }
        return d
    }
    ,
    _extends$1.apply(this, arguments)
}
function isChildSwiperSlide(d) {
    return d.type && d.type.displayName && d.type.displayName.includes("SwiperSlide")
}
function processChildren(d) {
    const g = [];
    return React.Children.toArray(d).forEach(b=>{
        isChildSwiperSlide(b) ? g.push(b) : b.props && b.props.children && processChildren(b.props.children).forEach(_=>g.push(_))
    }
    ),
    g
}
function getChildren(d) {
    const g = []
      , b = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
    };
    return React.Children.toArray(d).forEach(_=>{
        if (isChildSwiperSlide(_))
            g.push(_);
        else if (_.props && _.props.slot && b[_.props.slot])
            b[_.props.slot].push(_);
        else if (_.props && _.props.children) {
            const $ = processChildren(_.props.children);
            $.length > 0 ? $.forEach(et=>g.push(et)) : b["container-end"].push(_)
        } else
            b["container-end"].push(_)
    }
    ),
    {
        slides: g,
        slots: b
    }
}
function renderVirtual(d, g, b) {
    if (!b)
        return null;
    const _ = ot=>{
        let at = ot;
        return ot < 0 ? at = g.length + ot : at >= g.length && (at = at - g.length),
        at
    }
      , $ = d.isHorizontal() ? {
        [d.rtlTranslate ? "right" : "left"]: `${b.offset}px`
    } : {
        top: `${b.offset}px`
    }
      , {from: et, to: tt} = b
      , rt = d.params.loop ? -g.length : 0
      , nt = d.params.loop ? g.length * 2 : g.length
      , it = [];
    for (let ot = rt; ot < nt; ot += 1)
        ot >= et && ot <= tt && it.push(g[_(ot)]);
    return it.map((ot,at)=>React.cloneElement(ot, {
        swiper: d,
        style: $,
        key: ot.props.virtualIndex || ot.key || `slide-${at}`
    }))
}
function useIsomorphicLayoutEffect(d, g) {
    return typeof window > "u" ? reactExports.useEffect(d, g) : reactExports.useLayoutEffect(d, g)
}
const SwiperSlideContext = reactExports.createContext(null)
  , SwiperContext = reactExports.createContext(null)
  , Swiper = reactExports.forwardRef(function(d, g) {
    let {className: b, tag: _="div", wrapperTag: $="div", children: et, onSwiper: tt, ...rt} = d === void 0 ? {} : d
      , nt = !1;
    const [it,ot] = reactExports.useState("swiper")
      , [at,st] = reactExports.useState(null)
      , [dt,ft] = reactExports.useState(!1)
      , ht = reactExports.useRef(!1)
      , xt = reactExports.useRef(null)
      , lt = reactExports.useRef(null)
      , ct = reactExports.useRef(null)
      , ut = reactExports.useRef(null)
      , pt = reactExports.useRef(null)
      , vt = reactExports.useRef(null)
      , _t = reactExports.useRef(null)
      , Pt = reactExports.useRef(null)
      , {params: kt, passedParams: $t, rest: Wt, events: Ht} = getParams(rt)
      , {slides: Dt, slots: Vt} = getChildren(et)
      , Ft = ()=>{
        ft(!dt)
    }
    ;
    Object.assign(kt.on, {
        _containerClasses(St, Lt) {
            ot(Lt)
        }
    });
    const Kt = ()=>{
        Object.assign(kt.on, Ht),
        nt = !0;
        const St = {
            ...kt
        };
        if (delete St.wrapperClass,
        lt.current = new Swiper$1(St),
        lt.current.virtual && lt.current.params.virtual.enabled) {
            lt.current.virtual.slides = Dt;
            const Lt = {
                cache: !1,
                slides: Dt,
                renderExternal: st,
                renderExternalUpdate: !1
            };
            extend(lt.current.params.virtual, Lt),
            extend(lt.current.originalParams.virtual, Lt)
        }
    }
    ;
    xt.current || Kt(),
    lt.current && lt.current.on("_beforeBreakpoint", Ft);
    const Rt = ()=>{
        nt || !Ht || !lt.current || Object.keys(Ht).forEach(St=>{
            lt.current.on(St, Ht[St])
        }
        )
    }
      , qt = ()=>{
        !Ht || !lt.current || Object.keys(Ht).forEach(St=>{
            lt.current.off(St, Ht[St])
        }
        )
    }
    ;
    reactExports.useEffect(()=>()=>{
        lt.current && lt.current.off("_beforeBreakpoint", Ft)
    }
    ),
    reactExports.useEffect(()=>{
        !ht.current && lt.current && (lt.current.emitSlidesClasses(),
        ht.current = !0)
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        if (g && (g.current = xt.current),
        !!xt.current)
            return lt.current.destroyed && Kt(),
            mountSwiper({
                el: xt.current,
                nextEl: pt.current,
                prevEl: vt.current,
                paginationEl: _t.current,
                scrollbarEl: Pt.current,
                swiper: lt.current
            }, kt),
            tt && !lt.current.destroyed && tt(lt.current),
            ()=>{
                lt.current && !lt.current.destroyed && lt.current.destroy(!0, !1)
            }
    }
    , []),
    useIsomorphicLayoutEffect(()=>{
        Rt();
        const St = getChangedParams($t, ct.current, Dt, ut.current, Lt=>Lt.key);
        return ct.current = $t,
        ut.current = Dt,
        St.length && lt.current && !lt.current.destroyed && updateSwiper({
            swiper: lt.current,
            slides: Dt,
            passedParams: $t,
            changedParams: St,
            nextEl: pt.current,
            prevEl: vt.current,
            scrollbarEl: Pt.current,
            paginationEl: _t.current
        }),
        ()=>{
            qt()
        }
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        updateOnVirtualData(lt.current)
    }
    , [at]);
    function Et() {
        return kt.virtual ? renderVirtual(lt.current, Dt, at) : Dt.map((St,Lt)=>React.cloneElement(St, {
            swiper: lt.current,
            swiperSlideIndex: Lt
        }))
    }
    return React.createElement(_, _extends$1({
        ref: xt,
        className: uniqueClasses(`${it}${b ? ` ${b}` : ""}`)
    }, Wt), React.createElement(SwiperContext.Provider, {
        value: lt.current
    }, Vt["container-start"], React.createElement($, {
        className: wrapperClass(kt.wrapperClass)
    }, Vt["wrapper-start"], Et(), Vt["wrapper-end"]), needsNavigation(kt) && React.createElement(React.Fragment, null, React.createElement("div", {
        ref: vt,
        className: "swiper-button-prev"
    }), React.createElement("div", {
        ref: pt,
        className: "swiper-button-next"
    })), needsScrollbar(kt) && React.createElement("div", {
        ref: Pt,
        className: "swiper-scrollbar"
    }), needsPagination(kt) && React.createElement("div", {
        ref: _t,
        className: "swiper-pagination"
    }), Vt["container-end"]))
});
Swiper.displayName = "Swiper";
const SwiperSlide = reactExports.forwardRef(function(d, g) {
    let {tag: b="div", children: _, className: $="", swiper: et, zoom: tt, lazy: rt, virtualIndex: nt, swiperSlideIndex: it, ...ot} = d === void 0 ? {} : d;
    const at = reactExports.useRef(null)
      , [st,dt] = reactExports.useState("swiper-slide")
      , [ft,ht] = reactExports.useState(!1);
    function xt(pt, vt, _t) {
        vt === at.current && dt(_t)
    }
    useIsomorphicLayoutEffect(()=>{
        if (typeof it < "u" && (at.current.swiperSlideIndex = it),
        g && (g.current = at.current),
        !(!at.current || !et)) {
            if (et.destroyed) {
                st !== "swiper-slide" && dt("swiper-slide");
                return
            }
            return et.on("_slideClass", xt),
            ()=>{
                et && et.off("_slideClass", xt)
            }
        }
    }
    ),
    useIsomorphicLayoutEffect(()=>{
        et && at.current && !et.destroyed && dt(et.getSlideClasses(at.current))
    }
    , [et]);
    const lt = {
        isActive: st.indexOf("swiper-slide-active") >= 0,
        isVisible: st.indexOf("swiper-slide-visible") >= 0,
        isPrev: st.indexOf("swiper-slide-prev") >= 0,
        isNext: st.indexOf("swiper-slide-next") >= 0
    }
      , ct = ()=>typeof _ == "function" ? _(lt) : _
      , ut = ()=>{
        ht(!0)
    }
    ;
    return React.createElement(b, _extends$1({
        ref: at,
        className: uniqueClasses(`${st}${$ ? ` ${$}` : ""}`),
        "data-swiper-slide-index": nt,
        onLoad: ut
    }, ot), tt && React.createElement(SwiperSlideContext.Provider, {
        value: lt
    }, React.createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof tt == "number" ? tt : void 0
    }, ct(), rt && !ft && React.createElement("div", {
        className: "swiper-lazy-preloader"
    }))), !tt && React.createElement(SwiperSlideContext.Provider, {
        value: lt
    }, ct(), rt && !ft && React.createElement("div", {
        className: "swiper-lazy-preloader"
    })))
});
SwiperSlide.displayName = "SwiperSlide";
var dist$2 = {}
  , Address$1 = {};
const SymbolInspect = Symbol.for("nodejs.util.inspect.custom");
var symbol_inspect = SymbolInspect
  , crc16$2 = {};
Object.defineProperty(crc16$2, "__esModule", {
    value: !0
});
crc16$2.crc16 = void 0;
function crc16$1(d) {
    let b = 0;
    const _ = dist$3.Buffer.alloc(d.length + 2);
    _.set(d);
    for (let $ of _) {
        let et = 128;
        for (; et > 0; )
            b <<= 1,
            $ & et && (b += 1),
            et >>= 1,
            b > 65535 && (b &= 65535,
            b ^= 4129)
    }
    return dist$3.Buffer.from([Math.floor(b / 256), b % 256])
}
crc16$2.crc16 = crc16$1;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
, _a$2;
Object.defineProperty(Address$1, "__esModule", {
    value: !0
});
Address$1.address = Address$1.Address = void 0;
const symbol_inspect_1$2 = __importDefault$7(symbol_inspect)
  , crc16_1$1 = crc16$2
  , bounceable_tag = 17
  , non_bounceable_tag = 81
  , test_flag = 128;
function parseFriendlyAddress(d) {
    if (typeof d == "string" && !Address.isFriendly(d))
        throw new Error("Unknown address type");
    const g = dist$3.Buffer.isBuffer(d) ? d : dist$3.Buffer.from(d, "base64");
    if (g.length !== 36)
        throw new Error("Unknown address type: byte length is not equal to 36");
    const b = g.subarray(0, 34)
      , _ = g.subarray(34, 36)
      , $ = (0,
    crc16_1$1.crc16)(b);
    if (!($[0] === _[0] && $[1] === _[1]))
        throw new Error("Invalid checksum: " + d);
    let et = b[0]
      , tt = !1
      , rt = !1;
    if (et & test_flag && (tt = !0,
    et = et ^ test_flag),
    et !== bounceable_tag && et !== non_bounceable_tag)
        throw "Unknown address tag";
    rt = et === bounceable_tag;
    let nt = null;
    b[1] === 255 ? nt = -1 : nt = b[1];
    const it = b.subarray(2, 34);
    return {
        isTestOnly: tt,
        isBounceable: rt,
        workchain: nt,
        hashPart: it
    }
}
class Address {
    static isAddress(g) {
        return g instanceof Address
    }
    static isFriendly(g) {
        return !(g.length !== 48 || !/[A-Za-z0-9+/_-]+/.test(g))
    }
    static isRaw(g) {
        if (g.indexOf(":") === -1)
            return !1;
        let[b,_] = g.split(":");
        return !(!Number.isInteger(parseFloat(b)) || !/[a-f0-9]+/.test(_.toLowerCase()) || _.length !== 64)
    }
    static normalize(g) {
        return typeof g == "string" ? Address.parse(g).toString() : g.toString()
    }
    static parse(g) {
        if (Address.isFriendly(g))
            return this.parseFriendly(g).address;
        if (Address.isRaw(g))
            return this.parseRaw(g);
        throw new Error("Unknown address type: " + g)
    }
    static parseRaw(g) {
        let b = parseInt(g.split(":")[0])
          , _ = dist$3.Buffer.from(g.split(":")[1], "hex");
        return new Address(b,_)
    }
    static parseFriendly(g) {
        if (dist$3.Buffer.isBuffer(g)) {
            let b = parseFriendlyAddress(g);
            return {
                isBounceable: b.isBounceable,
                isTestOnly: b.isTestOnly,
                address: new Address(b.workchain,b.hashPart)
            }
        } else {
            let b = g.replace(/\-/g, "+").replace(/_/g, "/")
              , _ = parseFriendlyAddress(b);
            return {
                isBounceable: _.isBounceable,
                isTestOnly: _.isTestOnly,
                address: new Address(_.workchain,_.hashPart)
            }
        }
    }
    constructor(g, b) {
        if (this.toRawString = ()=>this.workChain + ":" + this.hash.toString("hex"),
        this.toRaw = ()=>{
            const _ = dist$3.Buffer.alloc(36);
            return _.set(this.hash),
            _.set([this.workChain, this.workChain, this.workChain, this.workChain], 32),
            _
        }
        ,
        this.toStringBuffer = _=>{
            let $ = _ && _.testOnly !== void 0 ? _.testOnly : !1
              , tt = (_ && _.bounceable !== void 0 ? _.bounceable : !0) ? bounceable_tag : non_bounceable_tag;
            $ && (tt |= test_flag);
            const rt = dist$3.Buffer.alloc(34);
            rt[0] = tt,
            rt[1] = this.workChain,
            rt.set(this.hash, 2);
            const nt = dist$3.Buffer.alloc(36);
            return nt.set(rt),
            nt.set((0,
            crc16_1$1.crc16)(rt), 34),
            nt
        }
        ,
        this.toString = _=>{
            let $ = _ && _.urlSafe !== void 0 ? _.urlSafe : !0
              , et = this.toStringBuffer(_);
            return $ ? et.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : et.toString("base64")
        }
        ,
        this[_a$2] = ()=>this.toString(),
        b.length !== 32)
            throw new Error("Invalid address hash length: " + b.length);
        this.workChain = g,
        this.hash = b,
        Object.freeze(this)
    }
    equals(g) {
        return g.workChain !== this.workChain ? !1 : g.hash.equals(this.hash)
    }
}
Address$1.Address = Address;
_a$2 = symbol_inspect_1$2.default;
function address(d) {
    return Address.parse(d)
}
Address$1.address = address;
var ExternalAddress$1 = {}, __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
, _a$1;
Object.defineProperty(ExternalAddress$1, "__esModule", {
    value: !0
});
ExternalAddress$1.ExternalAddress = void 0;
const symbol_inspect_1$1 = __importDefault$6(symbol_inspect);
class ExternalAddress {
    static isAddress(g) {
        return g instanceof ExternalAddress
    }
    constructor(g, b) {
        this[_a$1] = ()=>this.toString(),
        this.value = g,
        this.bits = b
    }
    toString() {
        return `External<${this.bits}:${this.value}>`
    }
}
ExternalAddress$1.ExternalAddress = ExternalAddress;
_a$1 = symbol_inspect_1$1.default;
var ADNLAddress$1 = {}
  , base32 = {};
Object.defineProperty(base32, "__esModule", {
    value: !0
});
base32.base32Decode = base32.base32Encode = void 0;
const alphabet = "abcdefghijklmnopqrstuvwxyz234567";
function base32Encode(d) {
    const g = d.byteLength;
    let b = 0
      , _ = 0
      , $ = "";
    for (let et = 0; et < g; et++)
        for (_ = _ << 8 | d[et],
        b += 8; b >= 5; )
            $ += alphabet[_ >>> b - 5 & 31],
            b -= 5;
    return b > 0 && ($ += alphabet[_ << 5 - b & 31]),
    $
}
base32.base32Encode = base32Encode;
function readChar(d, g) {
    const b = d.indexOf(g);
    if (b === -1)
        throw new Error("Invalid character found: " + g);
    return b
}
function base32Decode(d) {
    let g;
    g = d.toLowerCase();
    const {length: b} = g;
    let _ = 0
      , $ = 0
      , et = 0;
    const tt = dist$3.Buffer.alloc(b * 5 / 8 | 0);
    for (let rt = 0; rt < b; rt++)
        $ = $ << 5 | readChar(alphabet, g[rt]),
        _ += 5,
        _ >= 8 && (tt[et++] = $ >>> _ - 8 & 255,
        _ -= 8);
    return tt
}
base32.base32Decode = base32Decode;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
, _a;
Object.defineProperty(ADNLAddress$1, "__esModule", {
    value: !0
});
ADNLAddress$1.ADNLAddress = void 0;
const symbol_inspect_1 = __importDefault$5(symbol_inspect)
  , base32_1 = base32
  , crc16_1 = crc16$2;
class ADNLAddress {
    static parseFriendly(g) {
        if (g.length !== 55)
            throw Error("Invalid address");
        g = "f" + g;
        let b = (0,
        base32_1.base32Decode)(g);
        if (b[0] !== 45)
            throw Error("Invalid address");
        let _ = b.slice(33);
        if (!(0,
        crc16_1.crc16)(b.slice(0, 33)).equals(_))
            throw Error("Invalid address");
        return new ADNLAddress(b.slice(1, 33))
    }
    static parseRaw(g) {
        const b = dist$3.Buffer.from(g, "base64");
        return new ADNLAddress(b)
    }
    constructor(g) {
        if (this.toRaw = ()=>this.address.toString("hex").toUpperCase(),
        this.toString = ()=>{
            let b = dist$3.Buffer.concat([dist$3.Buffer.from([45]), this.address])
              , _ = (0,
            crc16_1.crc16)(b);
            return b = dist$3.Buffer.concat([b, _]),
            (0,
            base32_1.base32Encode)(b).slice(1)
        }
        ,
        this[_a] = ()=>this.toString(),
        g.length !== 32)
            throw Error("Invalid address");
        this.address = g
    }
    equals(g) {
        return this.address.equals(g.address)
    }
}
ADNLAddress$1.ADNLAddress = ADNLAddress;
_a = symbol_inspect_1.default;
var contractAddress$1 = {}, Builder = {}, BitBuilder = {}, BitString = {}, paddedBits = {}, hasRequiredPaddedBits;
function requirePaddedBits() {
    if (hasRequiredPaddedBits)
        return paddedBits;
    hasRequiredPaddedBits = 1,
    Object.defineProperty(paddedBits, "__esModule", {
        value: !0
    }),
    paddedBits.paddedBufferToBits = paddedBits.bitsToPaddedBuffer = void 0;
    const d = requireBitBuilder()
      , g = requireBitString();
    function b($) {
        let et = new d.BitBuilder(Math.ceil($.length / 8) * 8);
        et.writeBits($);
        let tt = Math.ceil($.length / 8) * 8 - $.length;
        for (let rt = 0; rt < tt; rt++)
            rt === 0 ? et.writeBit(1) : et.writeBit(0);
        return et.buffer()
    }
    paddedBits.bitsToPaddedBuffer = b;
    function _($) {
        let et = 0;
        for (let tt = $.length - 1; tt >= 0; tt--)
            if ($[tt] !== 0) {
                const rt = $[tt];
                let nt = rt & -rt;
                nt & 1 || (nt = Math.log2(nt) + 1),
                tt > 0 && (et = tt << 3),
                et += 8 - nt;
                break
            }
        return new g.BitString($,0,et)
    }
    return paddedBits.paddedBufferToBits = _,
    paddedBits
}
var hasRequiredBitString;
function requireBitString() {
    if (hasRequiredBitString)
        return BitString;
    hasRequiredBitString = 1;
    var d = commonjsGlobal && commonjsGlobal.__importDefault || function(et) {
        return et && et.__esModule ? et : {
            default: et
        }
    }
    , g;
    Object.defineProperty(BitString, "__esModule", {
        value: !0
    }),
    BitString.BitString = void 0;
    const b = requirePaddedBits()
      , _ = d(symbol_inspect);
    let $ = class ns {
        static isBitString(tt) {
            return tt instanceof ns
        }
        constructor(tt, rt, nt) {
            if (this[g] = ()=>this.toString(),
            nt < 0)
                throw new Error(`Length ${nt} is out of bounds`);
            this._length = nt,
            this._data = tt,
            this._offset = rt
        }
        get length() {
            return this._length
        }
        at(tt) {
            if (tt >= this._length)
                throw new Error(`Index ${tt} > ${this._length} is out of bounds`);
            if (tt < 0)
                throw new Error(`Index ${tt} < 0 is out of bounds`);
            let rt = this._offset + tt >> 3
              , nt = 7 - (this._offset + tt) % 8;
            return (this._data[rt] & 1 << nt) !== 0
        }
        substring(tt, rt) {
            if (tt > this._length)
                throw new Error(`Offset(${tt}) > ${this._length} is out of bounds`);
            if (tt < 0)
                throw new Error(`Offset(${tt}) < 0 is out of bounds`);
            if (rt === 0)
                return ns.EMPTY;
            if (tt + rt > this._length)
                throw new Error(`Offset ${tt} + Length ${rt} > ${this._length} is out of bounds`);
            return new ns(this._data,this._offset + tt,rt)
        }
        subbuffer(tt, rt) {
            if (tt > this._length)
                throw new Error(`Offset ${tt} is out of bounds`);
            if (tt < 0)
                throw new Error(`Offset ${tt} is out of bounds`);
            if (tt + rt > this._length)
                throw new Error(`Offset + Lenght = ${tt + rt} is out of bounds`);
            if (rt % 8 !== 0 || (this._offset + tt) % 8 !== 0)
                return null;
            let nt = this._offset + tt >> 3
              , it = nt + (rt >> 3);
            return this._data.subarray(nt, it)
        }
        equals(tt) {
            if (this._length !== tt._length)
                return !1;
            for (let rt = 0; rt < this._length; rt++)
                if (this.at(rt) !== tt.at(rt))
                    return !1;
            return !0
        }
        toString() {
            const tt = (0,
            b.bitsToPaddedBuffer)(this);
            if (this._length % 4 === 0) {
                const rt = tt.subarray(0, Math.ceil(this._length / 8)).toString("hex").toUpperCase();
                return this._length % 8 === 0 ? rt : rt.substring(0, rt.length - 1)
            } else {
                const rt = tt.toString("hex").toUpperCase();
                return this._length % 8 <= 4 ? rt.substring(0, rt.length - 1) + "_" : rt + "_"
            }
        }
    }
    ;
    return BitString.BitString = $,
    g = _.default,
    $.EMPTY = new $(dist$3.Buffer.alloc(0),0,0),
    BitString
}
var hasRequiredBitBuilder;
function requireBitBuilder() {
    if (hasRequiredBitBuilder)
        return BitBuilder;
    hasRequiredBitBuilder = 1,
    Object.defineProperty(BitBuilder, "__esModule", {
        value: !0
    }),
    BitBuilder.BitBuilder = void 0;
    const d = Address$1
      , g = ExternalAddress$1
      , b = requireBitString();
    let _ = class {
        constructor(et=1023) {
            this._buffer = dist$3.Buffer.alloc(Math.ceil(et / 8)),
            this._length = 0
        }
        get length() {
            return this._length
        }
        writeBit(et) {
            let tt = this._length;
            if (tt > this._buffer.length * 8)
                throw new Error("BitBuilder overflow");
            (et === !0 || et > 0) && (this._buffer[tt / 8 | 0] |= 1 << 7 - tt % 8),
            this._length++
        }
        writeBits(et) {
            for (let tt = 0; tt < et.length; tt++)
                this.writeBit(et.at(tt))
        }
        writeBuffer(et) {
            if (this._length % 8 === 0) {
                if (this._length + et.length * 8 > this._buffer.length * 8)
                    throw new Error("BitBuilder overflow");
                et.copy(this._buffer, this._length / 8),
                this._length += et.length * 8
            } else
                for (let tt = 0; tt < et.length; tt++)
                    this.writeUint(et[tt], 8)
        }
        writeUint(et, tt) {
            if (tt === 8 && this._length % 8 === 0) {
                let ot = Number(et);
                if (ot < 0 || ot > 255 || !Number.isSafeInteger(ot))
                    throw Error(`value is out of range for ${tt} bits. Got ${et}`);
                this._buffer[this._length / 8] = Number(et),
                this._length += 8;
                return
            }
            if (tt === 16 && this._length % 8 === 0) {
                let ot = Number(et);
                if (ot < 0 || ot > 65536 || !Number.isSafeInteger(ot))
                    throw Error(`value is out of range for ${tt} bits. Got ${et}`);
                this._buffer[this._length / 8] = ot >> 8,
                this._buffer[this._length / 8 + 1] = ot & 255,
                this._length += 16;
                return
            }
            let rt = BigInt(et);
            if (tt < 0 || !Number.isSafeInteger(tt))
                throw Error(`invalid bit length. Got ${tt}`);
            if (tt === 0) {
                if (et !== 0n)
                    throw Error(`value is not zero for ${tt} bits. Got ${et}`);
                return
            }
            let nt = 1n << BigInt(tt);
            if (rt < 0 || rt >= nt)
                throw Error(`bitLength is too small for a value ${et}. Got ${tt}`);
            let it = [];
            for (; rt > 0; )
                it.push(rt % 2n === 1n),
                rt /= 2n;
            for (let ot = 0; ot < tt; ot++) {
                let at = tt - ot - 1;
                at < it.length ? this.writeBit(it[at]) : this.writeBit(!1)
            }
        }
        writeInt(et, tt) {
            let rt = BigInt(et);
            if (tt < 0 || !Number.isSafeInteger(tt))
                throw Error(`invalid bit length. Got ${tt}`);
            if (tt === 0) {
                if (et !== 0n)
                    throw Error(`value is not zero for ${tt} bits. Got ${et}`);
                return
            }
            if (tt === 1) {
                if (et !== -1n && et !== 0n)
                    throw Error(`value is not zero or -1 for ${tt} bits. Got ${et}`);
                this.writeBit(et === -1n);
                return
            }
            let nt = 1n << BigInt(tt) - 1n;
            if (rt < -nt || rt >= nt)
                throw Error(`value is out of range for ${tt} bits. Got ${et}`);
            rt < 0 ? (this.writeBit(!0),
            rt = nt + rt) : this.writeBit(!1),
            this.writeUint(rt, tt - 1)
        }
        writeVarUint(et, tt) {
            let rt = BigInt(et);
            if (tt < 0 || !Number.isSafeInteger(tt))
                throw Error(`invalid bit length. Got ${tt}`);
            if (rt < 0)
                throw Error(`value is negative. Got ${et}`);
            if (rt === 0n) {
                this.writeUint(0, tt);
                return
            }
            const nt = Math.ceil(rt.toString(2).length / 8)
              , it = nt * 8;
            this.writeUint(nt, tt),
            this.writeUint(rt, it)
        }
        writeVarInt(et, tt) {
            let rt = BigInt(et);
            if (tt < 0 || !Number.isSafeInteger(tt))
                throw Error(`invalid bit length. Got ${tt}`);
            if (rt === 0n) {
                this.writeUint(0, tt);
                return
            }
            let nt = rt > 0 ? rt : -rt;
            const it = 1 + Math.ceil(nt.toString(2).length / 8)
              , ot = it * 8;
            this.writeUint(it, tt),
            this.writeInt(rt, ot)
        }
        writeCoins(et) {
            this.writeVarUint(et, 4)
        }
        writeAddress(et) {
            if (et == null) {
                this.writeUint(0, 2);
                return
            }
            if (d.Address.isAddress(et)) {
                this.writeUint(2, 2),
                this.writeUint(0, 1),
                this.writeInt(et.workChain, 8),
                this.writeBuffer(et.hash);
                return
            }
            if (g.ExternalAddress.isAddress(et)) {
                this.writeUint(1, 2),
                this.writeUint(et.bits, 9),
                this.writeUint(et.value, et.bits);
                return
            }
            throw Error(`Invalid address. Got ${et}`)
        }
        build() {
            return new b.BitString(this._buffer,0,this._length)
        }
        buffer() {
            if (this._length % 8 !== 0)
                throw new Error("BitBuilder buffer is not byte aligned");
            return this._buffer.subarray(0, this._length / 8)
        }
    }
    ;
    return BitBuilder.BitBuilder = _,
    BitBuilder
}
var Cell = {}
  , CellType = {};
(function(d) {
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.CellType = void 0,
    function(g) {
        g[g.Ordinary = -1] = "Ordinary",
        g[g.PrunedBranch = 1] = "PrunedBranch",
        g[g.Library = 2] = "Library",
        g[g.MerkleProof = 3] = "MerkleProof",
        g[g.MerkleUpdate = 4] = "MerkleUpdate"
    }(d.CellType || (d.CellType = {}))
}
)(CellType);
var Slice = {}
  , Dictionary = {}
  , generateMerkleProof = {}
  , readUnaryLength$2 = {};
Object.defineProperty(readUnaryLength$2, "__esModule", {
    value: !0
});
readUnaryLength$2.readUnaryLength = void 0;
function readUnaryLength$1(d) {
    let g = 0;
    for (; d.loadBit(); )
        g++;
    return g
}
readUnaryLength$2.readUnaryLength = readUnaryLength$1;
var hasRequiredGenerateMerkleProof;
function requireGenerateMerkleProof() {
    if (hasRequiredGenerateMerkleProof)
        return generateMerkleProof;
    hasRequiredGenerateMerkleProof = 1,
    Object.defineProperty(generateMerkleProof, "__esModule", {
        value: !0
    }),
    generateMerkleProof.generateMerkleProof = void 0;
    const d = requireBuilder()
      , g = requireCell()
      , b = readUnaryLength$2;
    function _(rt) {
        return new g.Cell({
            exotic: !0,
            bits: (0,
            d.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(rt.hash(0)).storeUint(rt.depth(0), 16).endCell().beginParse().loadBits(288)
        })
    }
    function $(rt) {
        return new g.Cell({
            exotic: !0,
            bits: (0,
            d.beginCell)().storeUint(3, 8).storeBuffer(rt.hash(0)).storeUint(rt.depth(0), 16).endCell().beginParse().loadBits(280),
            refs: [rt]
        })
    }
    function et(rt, nt, it, ot) {
        const at = nt.asCell();
        let st = nt.loadBit() ? 1 : 0
          , dt = 0
          , ft = rt;
        if (st === 0) {
            dt = (0,
            b.readUnaryLength)(nt);
            for (let ht = 0; ht < dt; ht++)
                ft += nt.loadBit() ? "1" : "0"
        } else if ((nt.loadBit() ? 1 : 0) === 0) {
            dt = nt.loadUint(Math.ceil(Math.log2(it + 1)));
            for (let xt = 0; xt < dt; xt++)
                ft += nt.loadBit() ? "1" : "0"
        } else {
            let xt = nt.loadBit() ? "1" : "0";
            dt = nt.loadUint(Math.ceil(Math.log2(it + 1)));
            for (let lt = 0; lt < dt; lt++)
                ft += xt
        }
        if (it - dt === 0)
            return at;
        {
            let ht = at.beginParse()
              , xt = ht.loadRef()
              , lt = ht.loadRef();
            return xt.isExotic || (ft + "0" === ot.slice(0, ft.length + 1) ? xt = et(ft + "0", xt.beginParse(), it - dt - 1, ot) : xt = _(xt)),
            lt.isExotic || (ft + "1" === ot.slice(0, ft.length + 1) ? lt = et(ft + "1", lt.beginParse(), it - dt - 1, ot) : lt = _(lt)),
            (0,
            d.beginCell)().storeSlice(ht).storeRef(xt).storeRef(lt).endCell()
        }
    }
    function tt(rt, nt, it) {
        const ot = (0,
        d.beginCell)().storeDictDirect(rt).endCell().beginParse();
        return $(et("", ot, it.bits, it.serialize(nt).toString(2).padStart(it.bits, "0")))
    }
    return generateMerkleProof.generateMerkleProof = tt,
    generateMerkleProof
}
var generateMerkleUpdate = {}, hasRequiredGenerateMerkleUpdate;
function requireGenerateMerkleUpdate() {
    if (hasRequiredGenerateMerkleUpdate)
        return generateMerkleUpdate;
    hasRequiredGenerateMerkleUpdate = 1,
    Object.defineProperty(generateMerkleUpdate, "__esModule", {
        value: !0
    }),
    generateMerkleUpdate.generateMerkleUpdate = void 0;
    const d = requireBuilder()
      , g = requireCell()
      , b = requireGenerateMerkleProof();
    function _(et, tt) {
        return new g.Cell({
            exotic: !0,
            bits: (0,
            d.beginCell)().storeUint(4, 8).storeBuffer(et.hash(0)).storeBuffer(tt.hash(0)).storeUint(et.depth(0), 16).storeUint(tt.depth(0), 16).endCell().beginParse().loadBits(552),
            refs: [et, tt]
        })
    }
    function $(et, tt, rt, nt) {
        const it = (0,
        b.generateMerkleProof)(et, tt, rt).refs[0];
        et.set(tt, nt);
        const ot = (0,
        b.generateMerkleProof)(et, tt, rt).refs[0];
        return _(it, ot)
    }
    return generateMerkleUpdate.generateMerkleUpdate = $,
    generateMerkleUpdate
}
var parseDict$1 = {};
Object.defineProperty(parseDict$1, "__esModule", {
    value: !0
});
parseDict$1.parseDict = void 0;
function readUnaryLength(d) {
    let g = 0;
    for (; d.loadBit(); )
        g++;
    return g
}
function doParse(d, g, b, _, $) {
    let et = g.loadBit() ? 1 : 0
      , tt = 0
      , rt = d;
    if (et === 0) {
        tt = readUnaryLength(g);
        for (let nt = 0; nt < tt; nt++)
            rt += g.loadBit() ? "1" : "0"
    } else if ((g.loadBit() ? 1 : 0) === 0) {
        tt = g.loadUint(Math.ceil(Math.log2(b + 1)));
        for (let it = 0; it < tt; it++)
            rt += g.loadBit() ? "1" : "0"
    } else {
        let it = g.loadBit() ? "1" : "0";
        tt = g.loadUint(Math.ceil(Math.log2(b + 1)));
        for (let ot = 0; ot < tt; ot++)
            rt += it
    }
    if (b - tt === 0)
        _.set(BigInt("0b" + rt), $(g));
    else {
        let nt = g.loadRef()
          , it = g.loadRef();
        nt.isExotic || doParse(rt + "0", nt.beginParse(), b - tt - 1, _, $),
        it.isExotic || doParse(rt + "1", it.beginParse(), b - tt - 1, _, $)
    }
}
function parseDict(d, g, b) {
    let _ = new Map;
    return d && doParse("", d, g, _, b),
    _
}
parseDict$1.parseDict = parseDict;
var serializeDict = {}
  , findCommonPrefix$1 = {};
Object.defineProperty(findCommonPrefix$1, "__esModule", {
    value: !0
});
findCommonPrefix$1.findCommonPrefix = void 0;
function findCommonPrefix(d) {
    if (d.length === 0)
        return "";
    if (d.length === 1)
        return d[0];
    const g = [...d].sort();
    let b = 0;
    for (let _ = 0; _ < g[0].length && g[0][_] === g[g.length - 1][_]; _++)
        b++;
    return d[0].slice(0, b)
}
findCommonPrefix$1.findCommonPrefix = findCommonPrefix;
var hasRequiredSerializeDict;
function requireSerializeDict() {
    if (hasRequiredSerializeDict)
        return serializeDict;
    hasRequiredSerializeDict = 1,
    Object.defineProperty(serializeDict, "__esModule", {
        value: !0
    }),
    serializeDict.serializeDict = serializeDict.detectLabelType = serializeDict.writeLabelSame = serializeDict.writeLabelLong = serializeDict.writeLabelShort = serializeDict.buildTree = void 0;
    const d = requireBuilder()
      , g = findCommonPrefix$1;
    function b(pt, vt) {
        for (; pt.length < vt; )
            pt = "0" + pt;
        return pt
    }
    function _(pt, vt) {
        if (vt === 0)
            return pt;
        {
            let _t = new Map;
            for (let Pt of pt.keys()) {
                let kt = pt.get(Pt);
                _t.set(Pt.slice(vt), kt)
            }
            return _t
        }
    }
    function $(pt) {
        if (pt.size === 0)
            throw Error("Internal inconsistency");
        let vt = new Map
          , _t = new Map;
        for (let Pt of pt.keys()) {
            let kt = pt.get(Pt);
            Pt.startsWith("0") ? vt.set(Pt.substr(1), kt) : _t.set(Pt.substr(1), kt)
        }
        if (vt.size === 0)
            throw Error("Internal inconsistency. Left emtpy.");
        if (_t.size === 0)
            throw Error("Internal inconsistency. Right emtpy.");
        return {
            left: vt,
            right: _t
        }
    }
    function et(pt) {
        if (pt.size === 0)
            throw Error("Internal inconsistency");
        if (pt.size === 1)
            return {
                type: "leaf",
                value: Array.from(pt.values())[0]
            };
        let {left: vt, right: _t} = $(pt);
        return {
            type: "fork",
            left: tt(vt),
            right: tt(_t)
        }
    }
    function tt(pt) {
        if (pt.size === 0)
            throw Error("Internal inconsistency");
        const vt = (0,
        g.findCommonPrefix)(Array.from(pt.keys()));
        return {
            label: vt,
            node: et(_(pt, vt.length))
        }
    }
    function rt(pt, vt) {
        let _t = new Map;
        for (let Pt of Array.from(pt.keys())) {
            const kt = b(Pt.toString(2), vt);
            _t.set(kt, pt.get(Pt))
        }
        return tt(_t)
    }
    serializeDict.buildTree = rt;
    function nt(pt, vt) {
        vt.storeBit(0);
        for (let _t = 0; _t < pt.length; _t++)
            vt.storeBit(1);
        vt.storeBit(0);
        for (let _t = 0; _t < pt.length; _t++)
            vt.storeBit(pt[_t] === "1");
        return vt
    }
    serializeDict.writeLabelShort = nt;
    function it(pt) {
        return 1 + pt.length + 1 + pt.length
    }
    function ot(pt, vt, _t) {
        _t.storeBit(1),
        _t.storeBit(0);
        let Pt = Math.ceil(Math.log2(vt + 1));
        _t.storeUint(pt.length, Pt);
        for (let kt = 0; kt < pt.length; kt++)
            _t.storeBit(pt[kt] === "1");
        return _t
    }
    serializeDict.writeLabelLong = ot;
    function at(pt, vt) {
        return 1 + 1 + Math.ceil(Math.log2(vt + 1)) + pt.length
    }
    function st(pt, vt, _t, Pt) {
        Pt.storeBit(1),
        Pt.storeBit(1),
        Pt.storeBit(pt);
        let kt = Math.ceil(Math.log2(_t + 1));
        Pt.storeUint(vt, kt)
    }
    serializeDict.writeLabelSame = st;
    function dt(pt) {
        return 1 + 1 + 1 + Math.ceil(Math.log2(pt + 1))
    }
    function ft(pt) {
        if (pt.length === 0 || pt.length === 1)
            return !0;
        for (let vt = 1; vt < pt.length; vt++)
            if (pt[vt] !== pt[0])
                return !1;
        return !0
    }
    function ht(pt, vt) {
        let _t = "short"
          , Pt = it(pt)
          , kt = at(pt, vt);
        if (kt < Pt && (Pt = kt,
        _t = "long"),
        ft(pt)) {
            let $t = dt(vt);
            $t < Pt && (Pt = $t,
            _t = "same")
        }
        return _t
    }
    serializeDict.detectLabelType = ht;
    function xt(pt, vt, _t) {
        let Pt = ht(pt, vt);
        Pt === "short" && nt(pt, _t),
        Pt === "long" && ot(pt, vt, _t),
        Pt === "same" && st(pt[0] === "1", pt.length, vt, _t)
    }
    function lt(pt, vt, _t, Pt) {
        if (pt.type === "leaf" && _t(pt.value, Pt),
        pt.type === "fork") {
            const kt = (0,
            d.beginCell)()
              , $t = (0,
            d.beginCell)();
            ct(pt.left, vt - 1, _t, kt),
            ct(pt.right, vt - 1, _t, $t),
            Pt.storeRef(kt),
            Pt.storeRef($t)
        }
    }
    function ct(pt, vt, _t, Pt) {
        xt(pt.label, vt, Pt),
        lt(pt.node, vt - pt.label.length, _t, Pt)
    }
    function ut(pt, vt, _t, Pt) {
        const kt = rt(pt, vt);
        ct(kt, vt, _t, Pt)
    }
    return serializeDict.serializeDict = ut,
    serializeDict
}
var internalKeySerializer = {};
Object.defineProperty(internalKeySerializer, "__esModule", {
    value: !0
});
internalKeySerializer.deserializeInternalKey = internalKeySerializer.serializeInternalKey = void 0;
const Address_1$4 = Address$1
  , BitString_1$1 = requireBitString()
  , paddedBits_1$1 = requirePaddedBits();
function serializeInternalKey(d) {
    if (typeof d == "number") {
        if (!Number.isSafeInteger(d))
            throw Error("Invalid key type: not a safe integer: " + d);
        return "n:" + d.toString(10)
    } else {
        if (typeof d == "bigint")
            return "b:" + d.toString(10);
        if (Address_1$4.Address.isAddress(d))
            return "a:" + d.toString();
        if (dist$3.Buffer.isBuffer(d))
            return "f:" + d.toString("hex");
        if (BitString_1$1.BitString.isBitString(d))
            return "B:" + d.toString();
        throw Error("Invalid key type")
    }
}
internalKeySerializer.serializeInternalKey = serializeInternalKey;
function deserializeInternalKey(d) {
    let g = d.slice(0, 2)
      , b = d.slice(2);
    if (g === "n:")
        return parseInt(b, 10);
    if (g === "b:")
        return BigInt(b);
    if (g === "a:")
        return Address_1$4.Address.parse(b);
    if (g === "f:")
        return dist$3.Buffer.from(b, "hex");
    if (g === "B:") {
        const _ = b.slice(-1) == "_";
        if (_ || b.length % 2 != 0) {
            let et = _ ? b.length - 1 : b.length;
            const tt = b.substr(0, et) + "0";
            return !_ && et & 1 ? new BitString_1$1.BitString(dist$3.Buffer.from(tt, "hex"),0,et << 2) : (0,
            paddedBits_1$1.paddedBufferToBits)(dist$3.Buffer.from(tt, "hex"))
        } else
            return new BitString_1$1.BitString(dist$3.Buffer.from(b, "hex"),0,b.length << 2)
    }
    throw Error("Invalid key type: " + g)
}
internalKeySerializer.deserializeInternalKey = deserializeInternalKey;
var hasRequiredDictionary;
function requireDictionary() {
    if (hasRequiredDictionary)
        return Dictionary;
    hasRequiredDictionary = 1,
    Object.defineProperty(Dictionary, "__esModule", {
        value: !0
    }),
    Dictionary.Dictionary = void 0;
    const d = Address$1
      , g = requireBuilder()
      , b = requireCell()
      , _ = requireBitString()
      , $ = requireGenerateMerkleProof()
      , et = requireGenerateMerkleUpdate()
      , tt = parseDict$1
      , rt = requireSerializeDict()
      , nt = internalKeySerializer;
    let it = class So {
        static empty(Ft, Kt) {
            return Ft && Kt ? new So(new Map,Ft,Kt) : new So(new Map,null,null)
        }
        static load(Ft, Kt, Rt) {
            let qt;
            if (Rt instanceof b.Cell) {
                if (Rt.isExotic)
                    return So.empty(Ft, Kt);
                qt = Rt.beginParse()
            } else
                qt = Rt;
            let Et = qt.loadMaybeRef();
            return Et && !Et.isExotic ? So.loadDirect(Ft, Kt, Et.beginParse()) : So.empty(Ft, Kt)
        }
        static loadDirect(Ft, Kt, Rt) {
            if (!Rt)
                return So.empty(Ft, Kt);
            let qt;
            Rt instanceof b.Cell ? qt = Rt.beginParse() : qt = Rt;
            let Et = (0,
            tt.parseDict)(qt, Ft.bits, Kt.parse)
              , St = new Map;
            for (let[Lt,Mt] of Et)
                St.set((0,
                nt.serializeInternalKey)(Ft.parse(Lt)), Mt);
            return new So(St,Ft,Kt)
        }
        constructor(Ft, Kt, Rt) {
            this._key = Kt,
            this._value = Rt,
            this._map = Ft
        }
        get size() {
            return this._map.size
        }
        get(Ft) {
            return this._map.get((0,
            nt.serializeInternalKey)(Ft))
        }
        has(Ft) {
            return this._map.has((0,
            nt.serializeInternalKey)(Ft))
        }
        set(Ft, Kt) {
            return this._map.set((0,
            nt.serializeInternalKey)(Ft), Kt),
            this
        }
        delete(Ft) {
            const Kt = (0,
            nt.serializeInternalKey)(Ft);
            return this._map.delete(Kt)
        }
        clear() {
            this._map.clear()
        }
        *[Symbol.iterator]() {
            for (const [Ft,Kt] of this._map)
                yield[(0,
                nt.deserializeInternalKey)(Ft), Kt]
        }
        keys() {
            return Array.from(this._map.keys()).map(Ft=>(0,
            nt.deserializeInternalKey)(Ft))
        }
        values() {
            return Array.from(this._map.values())
        }
        store(Ft, Kt, Rt) {
            if (this._map.size === 0)
                Ft.storeBit(0);
            else {
                let qt = this._key;
                Kt != null && (qt = Kt);
                let Et = this._value;
                if (Rt != null && (Et = Rt),
                !qt)
                    throw Error("Key serializer is not defined");
                if (!Et)
                    throw Error("Value serializer is not defined");
                let St = new Map;
                for (const [Mt,ar] of this._map)
                    St.set(qt.serialize((0,
                    nt.deserializeInternalKey)(Mt)), ar);
                Ft.storeBit(1);
                let Lt = (0,
                g.beginCell)();
                (0,
                rt.serializeDict)(St, qt.bits, Et.serialize, Lt),
                Ft.storeRef(Lt.endCell())
            }
        }
        storeDirect(Ft, Kt, Rt) {
            if (this._map.size === 0)
                throw Error("Cannot store empty dictionary directly");
            let qt = this._key;
            Kt != null && (qt = Kt);
            let Et = this._value;
            if (Rt != null && (Et = Rt),
            !qt)
                throw Error("Key serializer is not defined");
            if (!Et)
                throw Error("Value serializer is not defined");
            let St = new Map;
            for (const [Lt,Mt] of this._map)
                St.set(qt.serialize((0,
                nt.deserializeInternalKey)(Lt)), Mt);
            (0,
            rt.serializeDict)(St, qt.bits, Et.serialize, Ft)
        }
        generateMerkleProof(Ft) {
            return (0,
            $.generateMerkleProof)(this, Ft, this._key)
        }
        generateMerkleUpdate(Ft, Kt) {
            return (0,
            et.generateMerkleUpdate)(this, Ft, this._key, Kt)
        }
    }
    ;
    Dictionary.Dictionary = it,
    it.Keys = {
        Address: ()=>ot(),
        BigInt: Vt=>at(Vt),
        Int: Vt=>st(Vt),
        BigUint: Vt=>dt(Vt),
        Uint: Vt=>ft(Vt),
        Buffer: Vt=>ht(Vt),
        BitString: Vt=>xt(Vt)
    },
    it.Values = {
        BigInt: Vt=>ct(Vt),
        Int: Vt=>lt(Vt),
        BigVarInt: Vt=>ut(Vt),
        BigUint: Vt=>_t(Vt),
        Uint: Vt=>vt(Vt),
        BigVarUint: Vt=>pt(Vt),
        Bool: ()=>Pt(),
        Address: ()=>kt(),
        Cell: ()=>$t(),
        Buffer: Vt=>Ht(Vt),
        BitString: Vt=>Dt(Vt),
        Dictionary: (Vt,Ft)=>Wt(Vt, Ft)
    };
    function ot() {
        return {
            bits: 267,
            serialize: Vt=>{
                if (!d.Address.isAddress(Vt))
                    throw Error("Key is not an address");
                return (0,
                g.beginCell)().storeAddress(Vt).endCell().beginParse().preloadUintBig(267)
            }
            ,
            parse: Vt=>(0,
            g.beginCell)().storeUint(Vt, 267).endCell().beginParse().loadAddress()
        }
    }
    function at(Vt) {
        return {
            bits: Vt,
            serialize: Ft=>{
                if (typeof Ft != "bigint")
                    throw Error("Key is not a bigint");
                return (0,
                g.beginCell)().storeInt(Ft, Vt).endCell().beginParse().loadUintBig(Vt)
            }
            ,
            parse: Ft=>(0,
            g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadIntBig(Vt)
        }
    }
    function st(Vt) {
        return {
            bits: Vt,
            serialize: Ft=>{
                if (typeof Ft != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(Ft))
                    throw Error("Key is not a safe integer: " + Ft);
                return (0,
                g.beginCell)().storeInt(Ft, Vt).endCell().beginParse().loadUintBig(Vt)
            }
            ,
            parse: Ft=>(0,
            g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadInt(Vt)
        }
    }
    function dt(Vt) {
        return {
            bits: Vt,
            serialize: Ft=>{
                if (typeof Ft != "bigint")
                    throw Error("Key is not a bigint");
                if (Ft < 0)
                    throw Error("Key is negative: " + Ft);
                return (0,
                g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadUintBig(Vt)
            }
            ,
            parse: Ft=>(0,
            g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadUintBig(Vt)
        }
    }
    function ft(Vt) {
        return {
            bits: Vt,
            serialize: Ft=>{
                if (typeof Ft != "number")
                    throw Error("Key is not a number");
                if (!Number.isSafeInteger(Ft))
                    throw Error("Key is not a safe integer: " + Ft);
                if (Ft < 0)
                    throw Error("Key is negative: " + Ft);
                return (0,
                g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadUintBig(Vt)
            }
            ,
            parse: Ft=>Number((0,
            g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadUint(Vt))
        }
    }
    function ht(Vt) {
        return {
            bits: Vt * 8,
            serialize: Ft=>{
                if (!dist$3.Buffer.isBuffer(Ft))
                    throw Error("Key is not a buffer");
                return (0,
                g.beginCell)().storeBuffer(Ft).endCell().beginParse().loadUintBig(Vt * 8)
            }
            ,
            parse: Ft=>(0,
            g.beginCell)().storeUint(Ft, Vt * 8).endCell().beginParse().loadBuffer(Vt)
        }
    }
    function xt(Vt) {
        return {
            bits: Vt,
            serialize: Ft=>{
                if (!_.BitString.isBitString(Ft))
                    throw Error("Key is not a BitString");
                return (0,
                g.beginCell)().storeBits(Ft).endCell().beginParse().loadUintBig(Vt)
            }
            ,
            parse: Ft=>(0,
            g.beginCell)().storeUint(Ft, Vt).endCell().beginParse().loadBits(Vt)
        }
    }
    function lt(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeInt(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadInt(Vt)
        }
    }
    function ct(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeInt(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadIntBig(Vt)
        }
    }
    function ut(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeVarInt(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadVarIntBig(Vt)
        }
    }
    function pt(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeVarUint(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadVarUintBig(Vt)
        }
    }
    function vt(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeUint(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadUint(Vt)
        }
    }
    function _t(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                Kt.storeUint(Ft, Vt)
            }
            ,
            parse: Ft=>Ft.loadUintBig(Vt)
        }
    }
    function Pt() {
        return {
            serialize: (Vt,Ft)=>{
                Ft.storeBit(Vt)
            }
            ,
            parse: Vt=>Vt.loadBit()
        }
    }
    function kt() {
        return {
            serialize: (Vt,Ft)=>{
                Ft.storeAddress(Vt)
            }
            ,
            parse: Vt=>Vt.loadAddress()
        }
    }
    function $t() {
        return {
            serialize: (Vt,Ft)=>{
                Ft.storeRef(Vt)
            }
            ,
            parse: Vt=>Vt.loadRef()
        }
    }
    function Wt(Vt, Ft) {
        return {
            serialize: (Kt,Rt)=>{
                Kt.store(Rt)
            }
            ,
            parse: Kt=>it.load(Vt, Ft, Kt)
        }
    }
    function Ht(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                if (Ft.length !== Vt)
                    throw Error("Invalid buffer size");
                Kt.storeBuffer(Ft)
            }
            ,
            parse: Ft=>Ft.loadBuffer(Vt)
        }
    }
    function Dt(Vt) {
        return {
            serialize: (Ft,Kt)=>{
                if (Ft.length !== Vt)
                    throw Error("Invalid BitString size");
                Kt.storeBits(Ft)
            }
            ,
            parse: Ft=>Ft.loadBits(Vt)
        }
    }
    return Dictionary
}
var strings = {}, hasRequiredStrings;
function requireStrings() {
    if (hasRequiredStrings)
        return strings;
    hasRequiredStrings = 1,
    Object.defineProperty(strings, "__esModule", {
        value: !0
    }),
    strings.writeString = strings.stringToCell = strings.readString = void 0;
    const d = requireBuilder();
    function g(tt) {
        if (tt.remainingBits % 8 !== 0)
            throw new Error(`Invalid string length: ${tt.remainingBits}`);
        if (tt.remainingRefs !== 0 && tt.remainingRefs !== 1)
            throw new Error(`invalid number of refs: ${tt.remainingRefs}`);
        let rt;
        return tt.remainingBits === 0 ? rt = dist$3.Buffer.alloc(0) : rt = tt.loadBuffer(tt.remainingBits / 8),
        tt.remainingRefs === 1 && (rt = dist$3.Buffer.concat([rt, g(tt.loadRef().beginParse())])),
        rt
    }
    function b(tt) {
        return g(tt).toString()
    }
    strings.readString = b;
    function _(tt, rt) {
        if (tt.length > 0) {
            let nt = Math.floor(rt.availableBits / 8);
            if (tt.length > nt) {
                let it = tt.subarray(0, nt)
                  , ot = tt.subarray(nt);
                rt = rt.storeBuffer(it);
                let at = (0,
                d.beginCell)();
                _(ot, at),
                rt = rt.storeRef(at.endCell())
            } else
                rt = rt.storeBuffer(tt)
        }
    }
    function $(tt) {
        let rt = (0,
        d.beginCell)();
        return _(dist$3.Buffer.from(tt), rt),
        rt.endCell()
    }
    strings.stringToCell = $;
    function et(tt, rt) {
        _(dist$3.Buffer.from(tt), rt)
    }
    return strings.writeString = et,
    strings
}
var hasRequiredSlice;
function requireSlice() {
    if (hasRequiredSlice)
        return Slice;
    hasRequiredSlice = 1;
    var d = commonjsGlobal && commonjsGlobal.__importDefault || function(rt) {
        return rt && rt.__esModule ? rt : {
            default: rt
        }
    }
    , g;
    Object.defineProperty(Slice, "__esModule", {
        value: !0
    }),
    Slice.Slice = void 0;
    const b = d(symbol_inspect)
      , _ = requireDictionary()
      , $ = requireBuilder()
      , et = requireStrings();
    let tt = class As {
        constructor(nt, it) {
            this[g] = ()=>this.toString(),
            this._reader = nt.clone(),
            this._refs = [...it],
            this._refsOffset = 0
        }
        get remainingBits() {
            return this._reader.remaining
        }
        get offsetBits() {
            return this._reader.offset
        }
        get remainingRefs() {
            return this._refs.length - this._refsOffset
        }
        get offsetRefs() {
            return this._refsOffset
        }
        skip(nt) {
            return this._reader.skip(nt),
            this
        }
        loadBit() {
            return this._reader.loadBit()
        }
        preloadBit() {
            return this._reader.preloadBit()
        }
        loadBoolean() {
            return this.loadBit()
        }
        loadMaybeBoolean() {
            return this.loadBit() ? this.loadBoolean() : null
        }
        loadBits(nt) {
            return this._reader.loadBits(nt)
        }
        preloadBits(nt) {
            return this._reader.preloadBits(nt)
        }
        loadUint(nt) {
            return this._reader.loadUint(nt)
        }
        loadUintBig(nt) {
            return this._reader.loadUintBig(nt)
        }
        preloadUint(nt) {
            return this._reader.preloadUint(nt)
        }
        preloadUintBig(nt) {
            return this._reader.preloadUintBig(nt)
        }
        loadMaybeUint(nt) {
            return this.loadBit() ? this.loadUint(nt) : null
        }
        loadMaybeUintBig(nt) {
            return this.loadBit() ? this.loadUintBig(nt) : null
        }
        loadInt(nt) {
            return this._reader.loadInt(nt)
        }
        loadIntBig(nt) {
            return this._reader.loadIntBig(nt)
        }
        preloadInt(nt) {
            return this._reader.preloadInt(nt)
        }
        preloadIntBig(nt) {
            return this._reader.preloadIntBig(nt)
        }
        loadMaybeInt(nt) {
            return this.loadBit() ? this.loadInt(nt) : null
        }
        loadMaybeIntBig(nt) {
            return this.loadBit() ? this.loadIntBig(nt) : null
        }
        loadVarUint(nt) {
            return this._reader.loadVarUint(nt)
        }
        loadVarUintBig(nt) {
            return this._reader.loadVarUintBig(nt)
        }
        preloadVarUint(nt) {
            return this._reader.preloadVarUint(nt)
        }
        preloadVarUintBig(nt) {
            return this._reader.preloadVarUintBig(nt)
        }
        loadVarInt(nt) {
            return this._reader.loadVarInt(nt)
        }
        loadVarIntBig(nt) {
            return this._reader.loadVarIntBig(nt)
        }
        preloadVarInt(nt) {
            return this._reader.preloadVarInt(nt)
        }
        preloadVarIntBig(nt) {
            return this._reader.preloadVarIntBig(nt)
        }
        loadCoins() {
            return this._reader.loadCoins()
        }
        preloadCoins() {
            return this._reader.preloadCoins()
        }
        loadMaybeCoins() {
            return this._reader.loadBit() ? this._reader.loadCoins() : null
        }
        loadAddress() {
            return this._reader.loadAddress()
        }
        loadMaybeAddress() {
            return this._reader.loadMaybeAddress()
        }
        loadExternalAddress() {
            return this._reader.loadExternalAddress()
        }
        loadMaybeExternalAddress() {
            return this._reader.loadMaybeExternalAddress()
        }
        loadAddressAny() {
            return this._reader.loadAddressAny()
        }
        loadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset++]
        }
        preloadRef() {
            if (this._refsOffset >= this._refs.length)
                throw new Error("No more references");
            return this._refs[this._refsOffset]
        }
        loadMaybeRef() {
            return this.loadBit() ? this.loadRef() : null
        }
        preloadMaybeRef() {
            return this.preloadBit() ? this.preloadRef() : null
        }
        loadBuffer(nt) {
            return this._reader.loadBuffer(nt)
        }
        preloadBuffer(nt) {
            return this._reader.preloadBuffer(nt)
        }
        loadStringTail() {
            return (0,
            et.readString)(this)
        }
        loadMaybeStringTail() {
            return this.loadBit() ? (0,
            et.readString)(this) : null
        }
        loadStringRefTail() {
            return (0,
            et.readString)(this.loadRef().beginParse())
        }
        loadMaybeStringRefTail() {
            const nt = this.loadMaybeRef();
            return nt ? (0,
            et.readString)(nt.beginParse()) : null
        }
        loadDict(nt, it) {
            return _.Dictionary.load(nt, it, this)
        }
        loadDictDirect(nt, it) {
            return _.Dictionary.loadDirect(nt, it, this)
        }
        endParse() {
            if (this.remainingBits > 0 || this.remainingRefs > 0)
                throw new Error("Slice is not empty")
        }
        asCell() {
            return (0,
            $.beginCell)().storeSlice(this).endCell()
        }
        asBuilder() {
            return (0,
            $.beginCell)().storeSlice(this)
        }
        clone(nt=!1) {
            if (nt) {
                let it = this._reader.clone();
                return it.reset(),
                new As(it,this._refs)
            } else {
                let it = new As(this._reader,this._refs);
                return it._refsOffset = this._refsOffset,
                it
            }
        }
        toString() {
            return this.asCell().toString()
        }
    }
    ;
    return Slice.Slice = tt,
    g = b.default,
    Slice
}
var resolveExotic$1 = {}
  , BitReader$1 = {};
Object.defineProperty(BitReader$1, "__esModule", {
    value: !0
});
BitReader$1.BitReader = void 0;
const Address_1$3 = Address$1
  , ExternalAddress_1 = ExternalAddress$1;
class BitReader {
    constructor(g, b=0) {
        this._checkpoints = [],
        this._bits = g,
        this._offset = b
    }
    get offset() {
        return this._offset
    }
    get remaining() {
        return this._bits.length - this._offset
    }
    skip(g) {
        if (g < 0 || this._offset + g > this._bits.length)
            throw new Error(`Index ${this._offset + g} is out of bounds`);
        this._offset += g
    }
    reset() {
        this._checkpoints.length > 0 ? this._offset = this._checkpoints.pop() : this._offset = 0
    }
    save() {
        this._checkpoints.push(this._offset)
    }
    loadBit() {
        let g = this._bits.at(this._offset);
        return this._offset++,
        g
    }
    preloadBit() {
        return this._bits.at(this._offset)
    }
    loadBits(g) {
        let b = this._bits.substring(this._offset, g);
        return this._offset += g,
        b
    }
    preloadBits(g) {
        return this._bits.substring(this._offset, g)
    }
    loadBuffer(g) {
        let b = this._preloadBuffer(g, this._offset);
        return this._offset += g * 8,
        b
    }
    preloadBuffer(g) {
        return this._preloadBuffer(g, this._offset)
    }
    loadUint(g) {
        return Number(this.loadUintBig(g))
    }
    loadUintBig(g) {
        let b = this.preloadUintBig(g);
        return this._offset += g,
        b
    }
    preloadUint(g) {
        return Number(this._preloadUint(g, this._offset))
    }
    preloadUintBig(g) {
        return this._preloadUint(g, this._offset)
    }
    loadInt(g) {
        let b = this._preloadInt(g, this._offset);
        return this._offset += g,
        Number(b)
    }
    loadIntBig(g) {
        let b = this._preloadInt(g, this._offset);
        return this._offset += g,
        b
    }
    preloadInt(g) {
        return Number(this._preloadInt(g, this._offset))
    }
    preloadIntBig(g) {
        return this._preloadInt(g, this._offset)
    }
    loadVarUint(g) {
        let b = Number(this.loadUint(g));
        return Number(this.loadUintBig(b * 8))
    }
    loadVarUintBig(g) {
        let b = Number(this.loadUint(g));
        return this.loadUintBig(b * 8)
    }
    preloadVarUint(g) {
        let b = Number(this._preloadUint(g, this._offset));
        return Number(this._preloadUint(b * 8, this._offset + g))
    }
    preloadVarUintBig(g) {
        let b = Number(this._preloadUint(g, this._offset));
        return this._preloadUint(b * 8, this._offset + g)
    }
    loadVarInt(g) {
        let b = Number(this.loadUint(g));
        return Number(this.loadIntBig(b * 8))
    }
    loadVarIntBig(g) {
        let b = Number(this.loadUint(g));
        return this.loadIntBig(b * 8)
    }
    preloadVarInt(g) {
        let b = Number(this._preloadUint(g, this._offset));
        return Number(this._preloadInt(b * 8, this._offset + g))
    }
    preloadVarIntBig(g) {
        let b = Number(this._preloadUint(g, this._offset));
        return this._preloadInt(b * 8, this._offset + g)
    }
    loadCoins() {
        return this.loadVarUintBig(4)
    }
    preloadCoins() {
        return this.preloadVarUintBig(4)
    }
    loadAddress() {
        let g = Number(this._preloadUint(2, this._offset));
        if (g === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address: " + g)
    }
    loadMaybeAddress() {
        let g = Number(this._preloadUint(2, this._offset));
        if (g === 0)
            return this._offset += 2,
            null;
        if (g === 2)
            return this._loadInternalAddress();
        throw new Error("Invalid address")
    }
    loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadMaybeExternalAddress() {
        let g = Number(this._preloadUint(2, this._offset));
        if (g === 0)
            return this._offset += 2,
            null;
        if (g === 1)
            return this._loadExternalAddress();
        throw new Error("Invalid address")
    }
    loadAddressAny() {
        let g = Number(this._preloadUint(2, this._offset));
        if (g === 0)
            return this._offset += 2,
            null;
        if (g === 2)
            return this._loadInternalAddress();
        if (g === 1)
            return this._loadExternalAddress();
        throw Error(g === 3 ? "Unsupported" : "Unreachable")
    }
    loadPaddedBits(g) {
        if (g % 8 !== 0)
            throw new Error("Invalid number of bits");
        let b = g;
        for (; ; )
            if (this._bits.at(this._offset + b - 1)) {
                b--;
                break
            } else
                b--;
        let _ = this._bits.substring(this._offset, b);
        return this._offset += g,
        _
    }
    clone() {
        return new BitReader(this._bits,this._offset)
    }
    _preloadInt(g, b) {
        if (g == 0)
            return 0n;
        let _ = this._bits.at(b)
          , $ = 0n;
        for (let et = 0; et < g - 1; et++)
            this._bits.at(b + 1 + et) && ($ += 1n << BigInt(g - et - 1 - 1));
        return _ && ($ = $ - (1n << BigInt(g - 1))),
        $
    }
    _preloadUint(g, b) {
        if (g == 0)
            return 0n;
        let _ = 0n;
        for (let $ = 0; $ < g; $++)
            this._bits.at(b + $) && (_ += 1n << BigInt(g - $ - 1));
        return _
    }
    _preloadBuffer(g, b) {
        let _ = this._bits.subbuffer(b, g * 8);
        if (_)
            return _;
        let $ = dist$3.Buffer.alloc(g);
        for (let et = 0; et < g; et++)
            $[et] = Number(this._preloadUint(8, b + et * 8));
        return $
    }
    _loadInternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 2 || this._preloadUint(1, this._offset + 2) !== 0n)
            throw Error("Invalid address");
        let b = Number(this._preloadInt(8, this._offset + 3))
          , _ = this._preloadBuffer(32, this._offset + 11);
        return this._offset += 267,
        new Address_1$3.Address(b,_)
    }
    _loadExternalAddress() {
        if (Number(this._preloadUint(2, this._offset)) !== 1)
            throw Error("Invalid address");
        let b = Number(this._preloadUint(9, this._offset + 2))
          , _ = this._preloadUint(b, this._offset + 11);
        return this._offset += 11 + b,
        new ExternalAddress_1.ExternalAddress(_,b)
    }
}
BitReader$1.BitReader = BitReader;
var exoticLibrary$1 = {};
Object.defineProperty(exoticLibrary$1, "__esModule", {
    value: !0
});
exoticLibrary$1.exoticLibrary = void 0;
const BitReader_1$4 = BitReader$1;
function exoticLibrary(d, g) {
    const b = new BitReader_1$4.BitReader(d)
      , _ = 8 + 256;
    if (d.length !== _)
        throw new Error(`Library cell must have exactly (8 + 256) bits, got "${d.length}"`);
    let $ = b.loadUint(8);
    if ($ !== 2)
        throw new Error(`Library cell must have type 2, got "${$}"`);
    return {}
}
exoticLibrary$1.exoticLibrary = exoticLibrary;
var exoticMerkleProof$1 = {};
Object.defineProperty(exoticMerkleProof$1, "__esModule", {
    value: !0
});
exoticMerkleProof$1.exoticMerkleProof = void 0;
const BitReader_1$3 = BitReader$1;
function exoticMerkleProof(d, g) {
    const b = new BitReader_1$3.BitReader(d)
      , _ = 8 + 256 + 16;
    if (d.length !== _)
        throw new Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${d.length}"`);
    if (g.length !== 1)
        throw new Error(`Merkle Proof cell must have exactly 1 ref, got "${g.length}"`);
    let $ = b.loadUint(8);
    if ($ !== 3)
        throw new Error(`Merkle Proof cell must have type 3, got "${$}"`);
    const et = b.loadBuffer(32)
      , tt = b.loadUint(16)
      , rt = g[0].hash(0)
      , nt = g[0].depth(0);
    if (tt !== nt)
        throw new Error(`Merkle Proof cell ref depth must be exactly "${tt}", got "${nt}"`);
    if (!et.equals(rt))
        throw new Error(`Merkle Proof cell ref hash must be exactly "${et.toString("hex")}", got "${rt.toString("hex")}"`);
    return {
        proofDepth: tt,
        proofHash: et
    }
}
exoticMerkleProof$1.exoticMerkleProof = exoticMerkleProof;
var exoticMerkleUpdate$1 = {};
Object.defineProperty(exoticMerkleUpdate$1, "__esModule", {
    value: !0
});
exoticMerkleUpdate$1.exoticMerkleUpdate = void 0;
const BitReader_1$2 = BitReader$1;
function exoticMerkleUpdate(d, g) {
    const b = new BitReader_1$2.BitReader(d)
      , _ = 8 + 2 * (256 + 16);
    if (d.length !== _)
        throw new Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${d.length}"`);
    if (g.length !== 2)
        throw new Error(`Merkle Update cell must have exactly 2 refs, got "${g.length}"`);
    let $ = b.loadUint(8);
    if ($ !== 4)
        throw new Error(`Merkle Update cell type must be exactly 4, got "${$}"`);
    const et = b.loadBuffer(32)
      , tt = b.loadBuffer(32)
      , rt = b.loadUint(16)
      , nt = b.loadUint(16);
    if (rt !== g[0].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${rt}", got "${g[0].depth(0)}"`);
    if (!et.equals(g[0].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${et.toString("hex")}", got "${g[0].hash(0).toString("hex")}"`);
    if (nt !== g[1].depth(0))
        throw new Error(`Merkle Update cell ref depth must be exactly "${nt}", got "${g[1].depth(0)}"`);
    if (!tt.equals(g[1].hash(0)))
        throw new Error(`Merkle Update cell ref hash must be exactly "${tt.toString("hex")}", got "${g[1].hash(0).toString("hex")}"`);
    return {
        proofDepth1: rt,
        proofDepth2: nt,
        proofHash1: et,
        proofHash2: tt
    }
}
exoticMerkleUpdate$1.exoticMerkleUpdate = exoticMerkleUpdate;
var exoticPruned$1 = {}
  , LevelMask$1 = {};
Object.defineProperty(LevelMask$1, "__esModule", {
    value: !0
});
LevelMask$1.LevelMask = void 0;
class LevelMask {
    constructor(g=0) {
        this._mask = 0,
        this._mask = g,
        this._hashIndex = countSetBits(this._mask),
        this._hashCount = this._hashIndex + 1
    }
    get value() {
        return this._mask
    }
    get level() {
        return 32 - Math.clz32(this._mask)
    }
    get hashIndex() {
        return this._hashIndex
    }
    get hashCount() {
        return this._hashCount
    }
    apply(g) {
        return new LevelMask(this._mask & (1 << g) - 1)
    }
    isSignificant(g) {
        return g === 0 || (this._mask >> g - 1) % 2 !== 0
    }
}
LevelMask$1.LevelMask = LevelMask;
function countSetBits(d) {
    return d = d - (d >> 1 & 1431655765),
    d = (d & 858993459) + (d >> 2 & 858993459),
    (d + (d >> 4) & 252645135) * 16843009 >> 24
}
Object.defineProperty(exoticPruned$1, "__esModule", {
    value: !0
});
exoticPruned$1.exoticPruned = void 0;
const BitReader_1$1 = BitReader$1
  , LevelMask_1$2 = LevelMask$1;
function exoticPruned(d, g) {
    let b = new BitReader_1$1.BitReader(d)
      , _ = b.loadUint(8);
    if (_ !== 1)
        throw new Error(`Pruned branch cell must have type 1, got "${_}"`);
    if (g.length !== 0)
        throw new Error(`Pruned Branch cell can't has refs, got "${g.length}"`);
    let $;
    if (d.length === 280)
        $ = new LevelMask_1$2.LevelMask(1);
    else {
        if ($ = new LevelMask_1$2.LevelMask(b.loadUint(8)),
        $.level < 1 || $.level > 3)
            throw new Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${$.level}/${$.value}"`);
        const nt = 8 + 8 + $.apply($.level - 1).hashCount * (256 + 16);
        if (d.length !== nt)
            throw new Error(`Pruned branch cell must have exactly ${nt} bits, got "${d.length}"`)
    }
    let et = []
      , tt = []
      , rt = [];
    for (let nt = 0; nt < $.level; nt++)
        tt.push(b.loadBuffer(32));
    for (let nt = 0; nt < $.level; nt++)
        rt.push(b.loadUint(16));
    for (let nt = 0; nt < $.level; nt++)
        et.push({
            depth: rt[nt],
            hash: tt[nt]
        });
    return {
        mask: $.value,
        pruned: et
    }
}
exoticPruned$1.exoticPruned = exoticPruned;
Object.defineProperty(resolveExotic$1, "__esModule", {
    value: !0
});
resolveExotic$1.resolveExotic = void 0;
const BitReader_1 = BitReader$1
  , CellType_1$2 = CellType
  , exoticLibrary_1$1 = exoticLibrary$1
  , exoticMerkleProof_1$1 = exoticMerkleProof$1
  , exoticMerkleUpdate_1$1 = exoticMerkleUpdate$1
  , exoticPruned_1$1 = exoticPruned$1
  , LevelMask_1$1 = LevelMask$1;
function resolvePruned(d, g) {
    let b = (0,
    exoticPruned_1$1.exoticPruned)(d, g)
      , _ = []
      , $ = []
      , et = new LevelMask_1$1.LevelMask(b.mask);
    for (let tt = 0; tt < b.pruned.length; tt++)
        _.push(b.pruned[tt].depth),
        $.push(b.pruned[tt].hash);
    return {
        type: CellType_1$2.CellType.PrunedBranch,
        depths: _,
        hashes: $,
        mask: et
    }
}
function resolveLibrary(d, g) {
    (0,
    exoticLibrary_1$1.exoticLibrary)(d, g);
    let b = []
      , _ = []
      , $ = new LevelMask_1$1.LevelMask;
    return {
        type: CellType_1$2.CellType.Library,
        depths: b,
        hashes: _,
        mask: $
    }
}
function resolveMerkleProof(d, g) {
    (0,
    exoticMerkleProof_1$1.exoticMerkleProof)(d, g);
    let b = []
      , _ = []
      , $ = new LevelMask_1$1.LevelMask(g[0].level() >> 1);
    return {
        type: CellType_1$2.CellType.MerkleProof,
        depths: b,
        hashes: _,
        mask: $
    }
}
function resolveMerkleUpdate(d, g) {
    (0,
    exoticMerkleUpdate_1$1.exoticMerkleUpdate)(d, g);
    let b = []
      , _ = []
      , $ = new LevelMask_1$1.LevelMask((g[0].level() | g[1].level()) >> 1);
    return {
        type: CellType_1$2.CellType.MerkleUpdate,
        depths: b,
        hashes: _,
        mask: $
    }
}
function resolveExotic(d, g) {
    let _ = new BitReader_1.BitReader(d).preloadUint(8);
    if (_ === 1)
        return resolvePruned(d, g);
    if (_ === 2)
        return resolveLibrary(d, g);
    if (_ === 3)
        return resolveMerkleProof(d, g);
    if (_ === 4)
        return resolveMerkleUpdate(d, g);
    throw Error("Invalid exotic cell type: " + _)
}
resolveExotic$1.resolveExotic = resolveExotic;
var wonderCalculator$1 = {}
  , descriptor$1 = {};
Object.defineProperty(descriptor$1, "__esModule", {
    value: !0
});
descriptor$1.getRepr = descriptor$1.getBitsDescriptor = descriptor$1.getRefsDescriptor = void 0;
const CellType_1$1 = CellType
  , paddedBits_1 = requirePaddedBits();
function getRefsDescriptor(d, g, b) {
    return d.length + (b !== CellType_1$1.CellType.Ordinary ? 1 : 0) * 8 + g * 32
}
descriptor$1.getRefsDescriptor = getRefsDescriptor;
function getBitsDescriptor(d) {
    let g = d.length;
    return Math.ceil(g / 8) + Math.floor(g / 8)
}
descriptor$1.getBitsDescriptor = getBitsDescriptor;
function getRepr(d, g, b, _, $) {
    const et = Math.ceil(g.length / 8)
      , tt = dist$3.Buffer.alloc(2 + et + (2 + 32) * b.length);
    let rt = 0;
    tt[rt++] = getRefsDescriptor(b, _, $),
    tt[rt++] = getBitsDescriptor(d),
    (0,
    paddedBits_1.bitsToPaddedBuffer)(g).copy(tt, rt),
    rt += et;
    for (const nt of b) {
        let it;
        $ == CellType_1$1.CellType.MerkleProof || $ == CellType_1$1.CellType.MerkleUpdate ? it = nt.depth(_ + 1) : it = nt.depth(_),
        tt[rt++] = Math.floor(it / 256),
        tt[rt++] = it % 256
    }
    for (const nt of b) {
        let it;
        $ == CellType_1$1.CellType.MerkleProof || $ == CellType_1$1.CellType.MerkleUpdate ? it = nt.hash(_ + 1) : it = nt.hash(_),
        it.copy(tt, rt),
        rt += 32
    }
    return tt
}
descriptor$1.getRepr = getRepr;
var dist$1 = {}
  , sha256$3 = {}
  , sha = {
    exports: {}
};
(function(d, g) {
    (function(b, _) {
        d.exports = _()
    }
    )(commonjsGlobal, function() {
        var b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        function _(er, Ut, Ct, yt) {
            var bt, At, Gt, Qt = Ut || [0], rr = (Ct = Ct || 0) >>> 3, Er = yt === -1 ? 3 : 0;
            for (bt = 0; bt < er.length; bt += 1)
                At = (Gt = bt + rr) >>> 2,
                Qt.length <= At && Qt.push(0),
                Qt[At] |= er[bt] << 8 * (Er + yt * (Gt % 4));
            return {
                value: Qt,
                binLen: 8 * er.length + Ct
            }
        }
        function $(er, Ut, Ct) {
            switch (Ut) {
            case "UTF8":
            case "UTF16BE":
            case "UTF16LE":
                break;
            default:
                throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")
            }
            switch (er) {
            case "HEX":
                return function(yt, bt, At) {
                    return function(Gt, Qt, rr, Er) {
                        var Ur, Mr, Lr, Kr;
                        if (Gt.length % 2 != 0)
                            throw new Error("String of HEX type must be in byte increments");
                        var Fr = Qt || [0]
                          , Mn = (rr = rr || 0) >>> 3
                          , Bn = Er === -1 ? 3 : 0;
                        for (Ur = 0; Ur < Gt.length; Ur += 2) {
                            if (Mr = parseInt(Gt.substr(Ur, 2), 16),
                            isNaN(Mr))
                                throw new Error("String of HEX type contains invalid characters");
                            for (Lr = (Kr = (Ur >>> 1) + Mn) >>> 2; Fr.length <= Lr; )
                                Fr.push(0);
                            Fr[Lr] |= Mr << 8 * (Bn + Er * (Kr % 4))
                        }
                        return {
                            value: Fr,
                            binLen: 4 * Gt.length + rr
                        }
                    }(yt, bt, At, Ct)
                }
                ;
            case "TEXT":
                return function(yt, bt, At) {
                    return function(Gt, Qt, rr, Er, Ur) {
                        var Mr, Lr, Kr, Fr, Mn, Bn, jn, Hn, eo = 0, Gn = rr || [0], Kn = (Er = Er || 0) >>> 3;
                        if (Qt === "UTF8")
                            for (jn = Ur === -1 ? 3 : 0,
                            Kr = 0; Kr < Gt.length; Kr += 1)
                                for (Lr = [],
                                128 > (Mr = Gt.charCodeAt(Kr)) ? Lr.push(Mr) : 2048 > Mr ? (Lr.push(192 | Mr >>> 6),
                                Lr.push(128 | 63 & Mr)) : 55296 > Mr || 57344 <= Mr ? Lr.push(224 | Mr >>> 12, 128 | Mr >>> 6 & 63, 128 | 63 & Mr) : (Kr += 1,
                                Mr = 65536 + ((1023 & Mr) << 10 | 1023 & Gt.charCodeAt(Kr)),
                                Lr.push(240 | Mr >>> 18, 128 | Mr >>> 12 & 63, 128 | Mr >>> 6 & 63, 128 | 63 & Mr)),
                                Fr = 0; Fr < Lr.length; Fr += 1) {
                                    for (Mn = (Bn = eo + Kn) >>> 2; Gn.length <= Mn; )
                                        Gn.push(0);
                                    Gn[Mn] |= Lr[Fr] << 8 * (jn + Ur * (Bn % 4)),
                                    eo += 1
                                }
                        else
                            for (jn = Ur === -1 ? 2 : 0,
                            Hn = Qt === "UTF16LE" && Ur !== 1 || Qt !== "UTF16LE" && Ur === 1,
                            Kr = 0; Kr < Gt.length; Kr += 1) {
                                for (Mr = Gt.charCodeAt(Kr),
                                Hn === !0 && (Mr = (Fr = 255 & Mr) << 8 | Mr >>> 8),
                                Mn = (Bn = eo + Kn) >>> 2; Gn.length <= Mn; )
                                    Gn.push(0);
                                Gn[Mn] |= Mr << 8 * (jn + Ur * (Bn % 4)),
                                eo += 2
                            }
                        return {
                            value: Gn,
                            binLen: 8 * eo + Er
                        }
                    }(yt, Ut, bt, At, Ct)
                }
                ;
            case "B64":
                return function(yt, bt, At) {
                    return function(Gt, Qt, rr, Er) {
                        var Ur, Mr, Lr, Kr, Fr, Mn, Bn = 0, jn = Qt || [0], Hn = (rr = rr || 0) >>> 3, eo = Er === -1 ? 3 : 0, Gn = Gt.indexOf("=");
                        if (Gt.search(/^[a-zA-Z0-9=+/]+$/) === -1)
                            throw new Error("Invalid character in base-64 string");
                        if (Gt = Gt.replace(/=/g, ""),
                        Gn !== -1 && Gn < Gt.length)
                            throw new Error("Invalid '=' found in base-64 string");
                        for (Ur = 0; Ur < Gt.length; Ur += 4) {
                            for (Kr = Gt.substr(Ur, 4),
                            Lr = 0,
                            Mr = 0; Mr < Kr.length; Mr += 1)
                                Lr |= b.indexOf(Kr.charAt(Mr)) << 18 - 6 * Mr;
                            for (Mr = 0; Mr < Kr.length - 1; Mr += 1) {
                                for (Fr = (Mn = Bn + Hn) >>> 2; jn.length <= Fr; )
                                    jn.push(0);
                                jn[Fr] |= (Lr >>> 16 - 8 * Mr & 255) << 8 * (eo + Er * (Mn % 4)),
                                Bn += 1
                            }
                        }
                        return {
                            value: jn,
                            binLen: 8 * Bn + rr
                        }
                    }(yt, bt, At, Ct)
                }
                ;
            case "BYTES":
                return function(yt, bt, At) {
                    return function(Gt, Qt, rr, Er) {
                        var Ur, Mr, Lr, Kr, Fr = Qt || [0], Mn = (rr = rr || 0) >>> 3, Bn = Er === -1 ? 3 : 0;
                        for (Mr = 0; Mr < Gt.length; Mr += 1)
                            Ur = Gt.charCodeAt(Mr),
                            Lr = (Kr = Mr + Mn) >>> 2,
                            Fr.length <= Lr && Fr.push(0),
                            Fr[Lr] |= Ur << 8 * (Bn + Er * (Kr % 4));
                        return {
                            value: Fr,
                            binLen: 8 * Gt.length + rr
                        }
                    }(yt, bt, At, Ct)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(yt, bt, At) {
                    return function(Gt, Qt, rr, Er) {
                        return _(new Uint8Array(Gt), Qt, rr, Er)
                    }(yt, bt, At, Ct)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(yt, bt, At) {
                    return _(yt, bt, At, Ct)
                }
                ;
            default:
                throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        function et(er, Ut, Ct, yt) {
            switch (er) {
            case "HEX":
                return function(bt) {
                    return function(At, Gt, Qt, rr) {
                        var Er, Ur, Mr = "", Lr = Gt / 8, Kr = Qt === -1 ? 3 : 0;
                        for (Er = 0; Er < Lr; Er += 1)
                            Ur = At[Er >>> 2] >>> 8 * (Kr + Qt * (Er % 4)),
                            Mr += "0123456789abcdef".charAt(Ur >>> 4 & 15) + "0123456789abcdef".charAt(15 & Ur);
                        return rr.outputUpper ? Mr.toUpperCase() : Mr
                    }(bt, Ut, Ct, yt)
                }
                ;
            case "B64":
                return function(bt) {
                    return function(At, Gt, Qt, rr) {
                        var Er, Ur, Mr, Lr, Kr, Fr = "", Mn = Gt / 8, Bn = Qt === -1 ? 3 : 0;
                        for (Er = 0; Er < Mn; Er += 3)
                            for (Lr = Er + 1 < Mn ? At[Er + 1 >>> 2] : 0,
                            Kr = Er + 2 < Mn ? At[Er + 2 >>> 2] : 0,
                            Mr = (At[Er >>> 2] >>> 8 * (Bn + Qt * (Er % 4)) & 255) << 16 | (Lr >>> 8 * (Bn + Qt * ((Er + 1) % 4)) & 255) << 8 | Kr >>> 8 * (Bn + Qt * ((Er + 2) % 4)) & 255,
                            Ur = 0; Ur < 4; Ur += 1)
                                Fr += 8 * Er + 6 * Ur <= Gt ? b.charAt(Mr >>> 6 * (3 - Ur) & 63) : rr.b64Pad;
                        return Fr
                    }(bt, Ut, Ct, yt)
                }
                ;
            case "BYTES":
                return function(bt) {
                    return function(At, Gt, Qt) {
                        var rr, Er, Ur = "", Mr = Gt / 8, Lr = Qt === -1 ? 3 : 0;
                        for (rr = 0; rr < Mr; rr += 1)
                            Er = At[rr >>> 2] >>> 8 * (Lr + Qt * (rr % 4)) & 255,
                            Ur += String.fromCharCode(Er);
                        return Ur
                    }(bt, Ut, Ct)
                }
                ;
            case "ARRAYBUFFER":
                try {
                    new ArrayBuffer(0)
                } catch {
                    throw new Error("ARRAYBUFFER not supported by this environment")
                }
                return function(bt) {
                    return function(At, Gt, Qt) {
                        var rr, Er = Gt / 8, Ur = new ArrayBuffer(Er), Mr = new Uint8Array(Ur), Lr = Qt === -1 ? 3 : 0;
                        for (rr = 0; rr < Er; rr += 1)
                            Mr[rr] = At[rr >>> 2] >>> 8 * (Lr + Qt * (rr % 4)) & 255;
                        return Ur
                    }(bt, Ut, Ct)
                }
                ;
            case "UINT8ARRAY":
                try {
                    new Uint8Array(0)
                } catch {
                    throw new Error("UINT8ARRAY not supported by this environment")
                }
                return function(bt) {
                    return function(At, Gt, Qt) {
                        var rr, Er = Gt / 8, Ur = Qt === -1 ? 3 : 0, Mr = new Uint8Array(Er);
                        for (rr = 0; rr < Er; rr += 1)
                            Mr[rr] = At[rr >>> 2] >>> 8 * (Ur + Qt * (rr % 4)) & 255;
                        return Mr
                    }(bt, Ut, Ct)
                }
                ;
            default:
                throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
        }
        var tt = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
          , rt = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
          , nt = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]
          , it = "Chosen SHA variant is not supported";
        function ot(er, Ut) {
            var Ct, yt, bt = er.binLen >>> 3, At = Ut.binLen >>> 3, Gt = bt << 3, Qt = 4 - bt << 3;
            if (bt % 4 != 0) {
                for (Ct = 0; Ct < At; Ct += 4)
                    yt = bt + Ct >>> 2,
                    er.value[yt] |= Ut.value[Ct >>> 2] << Gt,
                    er.value.push(0),
                    er.value[yt + 1] |= Ut.value[Ct >>> 2] >>> Qt;
                return (er.value.length << 2) - 4 >= At + bt && er.value.pop(),
                {
                    value: er.value,
                    binLen: er.binLen + Ut.binLen
                }
            }
            return {
                value: er.value.concat(Ut.value),
                binLen: er.binLen + Ut.binLen
            }
        }
        function at(er) {
            var Ut = {
                outputUpper: !1,
                b64Pad: "=",
                outputLen: -1
            }
              , Ct = er || {}
              , yt = "Output length must be a multiple of 8";
            if (Ut.outputUpper = Ct.outputUpper || !1,
            Ct.b64Pad && (Ut.b64Pad = Ct.b64Pad),
            Ct.outputLen) {
                if (Ct.outputLen % 8 != 0)
                    throw new Error(yt);
                Ut.outputLen = Ct.outputLen
            } else if (Ct.shakeLen) {
                if (Ct.shakeLen % 8 != 0)
                    throw new Error(yt);
                Ut.outputLen = Ct.shakeLen
            }
            if (typeof Ut.outputUpper != "boolean")
                throw new Error("Invalid outputUpper formatting option");
            if (typeof Ut.b64Pad != "string")
                throw new Error("Invalid b64Pad formatting option");
            return Ut
        }
        function st(er, Ut, Ct, yt) {
            var bt = er + " must include a value and format";
            if (!Ut) {
                if (!yt)
                    throw new Error(bt);
                return yt
            }
            if (Ut.value === void 0 || !Ut.format)
                throw new Error(bt);
            return $(Ut.format, Ut.encoding || "UTF8", Ct)(Ut.value)
        }
        var dt = function() {
            function er(Ut, Ct, yt) {
                var bt = yt || {};
                if (this.t = Ct,
                this.i = bt.encoding || "UTF8",
                this.numRounds = bt.numRounds || 1,
                isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds)
                    throw new Error("numRounds must a integer >= 1");
                this.o = Ut,
                this.u = [],
                this.s = 0,
                this.h = !1,
                this.v = 0,
                this.A = !1,
                this.l = [],
                this.H = []
            }
            return er.prototype.update = function(Ut) {
                var Ct, yt = 0, bt = this.S >>> 5, At = this.p(Ut, this.u, this.s), Gt = At.binLen, Qt = At.value, rr = Gt >>> 5;
                for (Ct = 0; Ct < rr; Ct += bt)
                    yt + this.S <= Gt && (this.m = this.R(Qt.slice(Ct, Ct + bt), this.m),
                    yt += this.S);
                this.v += yt,
                this.u = Qt.slice(yt >>> 5),
                this.s = Gt % this.S,
                this.h = !0
            }
            ,
            er.prototype.getHash = function(Ut, Ct) {
                var yt, bt, At = this.U, Gt = at(Ct);
                if (this.T) {
                    if (Gt.outputLen === -1)
                        throw new Error("Output length must be specified in options");
                    At = Gt.outputLen
                }
                var Qt = et(Ut, At, this.C, Gt);
                if (this.A && this.F)
                    return Qt(this.F(Gt));
                for (bt = this.K(this.u.slice(), this.s, this.v, this.B(this.m), At),
                yt = 1; yt < this.numRounds; yt += 1)
                    this.T && At % 32 != 0 && (bt[bt.length - 1] &= 16777215 >>> 24 - At % 32),
                    bt = this.K(bt, At, 0, this.L(this.o), At);
                return Qt(bt)
            }
            ,
            er.prototype.setHMACKey = function(Ut, Ct, yt) {
                if (!this.g)
                    throw new Error("Variant does not support HMAC");
                if (this.h)
                    throw new Error("Cannot set MAC key after calling update");
                var bt = $(Ct, (yt || {}).encoding || "UTF8", this.C);
                this.k(bt(Ut))
            }
            ,
            er.prototype.k = function(Ut) {
                var Ct, yt = this.S >>> 3, bt = yt / 4 - 1;
                if (this.numRounds !== 1)
                    throw new Error("Cannot set numRounds with MAC");
                if (this.A)
                    throw new Error("MAC key already set");
                for (yt < Ut.binLen / 8 && (Ut.value = this.K(Ut.value, Ut.binLen, 0, this.L(this.o), this.U)); Ut.value.length <= bt; )
                    Ut.value.push(0);
                for (Ct = 0; Ct <= bt; Ct += 1)
                    this.l[Ct] = 909522486 ^ Ut.value[Ct],
                    this.H[Ct] = 1549556828 ^ Ut.value[Ct];
                this.m = this.R(this.l, this.m),
                this.v = this.S,
                this.A = !0
            }
            ,
            er.prototype.getHMAC = function(Ut, Ct) {
                var yt = at(Ct);
                return et(Ut, this.U, this.C, yt)(this.Y())
            }
            ,
            er.prototype.Y = function() {
                var Ut;
                if (!this.A)
                    throw new Error("Cannot call getHMAC without first setting MAC key");
                var Ct = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
                return Ut = this.R(this.H, this.L(this.o)),
                Ut = this.K(Ct, this.U, this.S, Ut, this.U)
            }
            ,
            er
        }()
          , ft = function(er, Ut) {
            return (ft = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(Ct, yt) {
                Ct.__proto__ = yt
            }
            || function(Ct, yt) {
                for (var bt in yt)
                    Object.prototype.hasOwnProperty.call(yt, bt) && (Ct[bt] = yt[bt])
            }
            )(er, Ut)
        };
        function ht(er, Ut) {
            function Ct() {
                this.constructor = er
            }
            ft(er, Ut),
            er.prototype = Ut === null ? Object.create(Ut) : (Ct.prototype = Ut.prototype,
            new Ct)
        }
        function xt(er, Ut) {
            return er << Ut | er >>> 32 - Ut
        }
        function lt(er, Ut) {
            return er >>> Ut | er << 32 - Ut
        }
        function ct(er, Ut) {
            return er >>> Ut
        }
        function ut(er, Ut, Ct) {
            return er ^ Ut ^ Ct
        }
        function pt(er, Ut, Ct) {
            return er & Ut ^ ~er & Ct
        }
        function vt(er, Ut, Ct) {
            return er & Ut ^ er & Ct ^ Ut & Ct
        }
        function _t(er) {
            return lt(er, 2) ^ lt(er, 13) ^ lt(er, 22)
        }
        function Pt(er, Ut) {
            var Ct = (65535 & er) + (65535 & Ut);
            return (65535 & (er >>> 16) + (Ut >>> 16) + (Ct >>> 16)) << 16 | 65535 & Ct
        }
        function kt(er, Ut, Ct, yt) {
            var bt = (65535 & er) + (65535 & Ut) + (65535 & Ct) + (65535 & yt);
            return (65535 & (er >>> 16) + (Ut >>> 16) + (Ct >>> 16) + (yt >>> 16) + (bt >>> 16)) << 16 | 65535 & bt
        }
        function $t(er, Ut, Ct, yt, bt) {
            var At = (65535 & er) + (65535 & Ut) + (65535 & Ct) + (65535 & yt) + (65535 & bt);
            return (65535 & (er >>> 16) + (Ut >>> 16) + (Ct >>> 16) + (yt >>> 16) + (bt >>> 16) + (At >>> 16)) << 16 | 65535 & At
        }
        function Wt(er) {
            return lt(er, 7) ^ lt(er, 18) ^ ct(er, 3)
        }
        function Ht(er) {
            return lt(er, 6) ^ lt(er, 11) ^ lt(er, 25)
        }
        function Dt(er) {
            return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
        }
        function Vt(er, Ut) {
            var Ct, yt, bt, At, Gt, Qt, rr, Er = [];
            for (Ct = Ut[0],
            yt = Ut[1],
            bt = Ut[2],
            At = Ut[3],
            Gt = Ut[4],
            rr = 0; rr < 80; rr += 1)
                Er[rr] = rr < 16 ? er[rr] : xt(Er[rr - 3] ^ Er[rr - 8] ^ Er[rr - 14] ^ Er[rr - 16], 1),
                Qt = rr < 20 ? $t(xt(Ct, 5), pt(yt, bt, At), Gt, 1518500249, Er[rr]) : rr < 40 ? $t(xt(Ct, 5), ut(yt, bt, At), Gt, 1859775393, Er[rr]) : rr < 60 ? $t(xt(Ct, 5), vt(yt, bt, At), Gt, 2400959708, Er[rr]) : $t(xt(Ct, 5), ut(yt, bt, At), Gt, 3395469782, Er[rr]),
                Gt = At,
                At = bt,
                bt = xt(yt, 30),
                yt = Ct,
                Ct = Qt;
            return Ut[0] = Pt(Ct, Ut[0]),
            Ut[1] = Pt(yt, Ut[1]),
            Ut[2] = Pt(bt, Ut[2]),
            Ut[3] = Pt(At, Ut[3]),
            Ut[4] = Pt(Gt, Ut[4]),
            Ut
        }
        function Ft(er, Ut, Ct, yt) {
            for (var bt, At = 15 + (Ut + 65 >>> 9 << 4), Gt = Ut + Ct; er.length <= At; )
                er.push(0);
            for (er[Ut >>> 5] |= 128 << 24 - Ut % 32,
            er[At] = 4294967295 & Gt,
            er[At - 1] = Gt / 4294967296 | 0,
            bt = 0; bt < er.length; bt += 16)
                yt = Vt(er.slice(bt, bt + 16), yt);
            return yt
        }
        var Kt = function(er) {
            function Ut(Ct, yt, bt) {
                var At = this;
                if (Ct !== "SHA-1")
                    throw new Error(it);
                var Gt = bt || {};
                return (At = er.call(this, Ct, yt, bt) || this).g = !0,
                At.F = At.Y,
                At.C = -1,
                At.p = $(At.t, At.i, At.C),
                At.R = Vt,
                At.B = function(Qt) {
                    return Qt.slice()
                }
                ,
                At.L = Dt,
                At.K = Ft,
                At.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520],
                At.S = 512,
                At.U = 160,
                At.T = !1,
                Gt.hmacKey && At.k(st("hmacKey", Gt.hmacKey, At.C)),
                At
            }
            return ht(Ut, er),
            Ut
        }(dt);
        function Rt(er) {
            return er == "SHA-224" ? rt.slice() : nt.slice()
        }
        function qt(er, Ut) {
            var Ct, yt, bt, At, Gt, Qt, rr, Er, Ur, Mr, Lr, Kr, Fr = [];
            for (Ct = Ut[0],
            yt = Ut[1],
            bt = Ut[2],
            At = Ut[3],
            Gt = Ut[4],
            Qt = Ut[5],
            rr = Ut[6],
            Er = Ut[7],
            Lr = 0; Lr < 64; Lr += 1)
                Fr[Lr] = Lr < 16 ? er[Lr] : kt(lt(Kr = Fr[Lr - 2], 17) ^ lt(Kr, 19) ^ ct(Kr, 10), Fr[Lr - 7], Wt(Fr[Lr - 15]), Fr[Lr - 16]),
                Ur = $t(Er, Ht(Gt), pt(Gt, Qt, rr), tt[Lr], Fr[Lr]),
                Mr = Pt(_t(Ct), vt(Ct, yt, bt)),
                Er = rr,
                rr = Qt,
                Qt = Gt,
                Gt = Pt(At, Ur),
                At = bt,
                bt = yt,
                yt = Ct,
                Ct = Pt(Ur, Mr);
            return Ut[0] = Pt(Ct, Ut[0]),
            Ut[1] = Pt(yt, Ut[1]),
            Ut[2] = Pt(bt, Ut[2]),
            Ut[3] = Pt(At, Ut[3]),
            Ut[4] = Pt(Gt, Ut[4]),
            Ut[5] = Pt(Qt, Ut[5]),
            Ut[6] = Pt(rr, Ut[6]),
            Ut[7] = Pt(Er, Ut[7]),
            Ut
        }
        var Et = function(er) {
            function Ut(Ct, yt, bt) {
                var At = this;
                if (Ct !== "SHA-224" && Ct !== "SHA-256")
                    throw new Error(it);
                var Gt = bt || {};
                return (At = er.call(this, Ct, yt, bt) || this).F = At.Y,
                At.g = !0,
                At.C = -1,
                At.p = $(At.t, At.i, At.C),
                At.R = qt,
                At.B = function(Qt) {
                    return Qt.slice()
                }
                ,
                At.L = Rt,
                At.K = function(Qt, rr, Er, Ur) {
                    return function(Mr, Lr, Kr, Fr, Mn) {
                        for (var Bn, jn = 15 + (Lr + 65 >>> 9 << 4), Hn = Lr + Kr; Mr.length <= jn; )
                            Mr.push(0);
                        for (Mr[Lr >>> 5] |= 128 << 24 - Lr % 32,
                        Mr[jn] = 4294967295 & Hn,
                        Mr[jn - 1] = Hn / 4294967296 | 0,
                        Bn = 0; Bn < Mr.length; Bn += 16)
                            Fr = qt(Mr.slice(Bn, Bn + 16), Fr);
                        return Mn === "SHA-224" ? [Fr[0], Fr[1], Fr[2], Fr[3], Fr[4], Fr[5], Fr[6]] : Fr
                    }(Qt, rr, Er, Ur, Ct)
                }
                ,
                At.m = Rt(Ct),
                At.S = 512,
                At.U = Ct === "SHA-224" ? 224 : 256,
                At.T = !1,
                Gt.hmacKey && At.k(st("hmacKey", Gt.hmacKey, At.C)),
                At
            }
            return ht(Ut, er),
            Ut
        }(dt)
          , St = function(er, Ut) {
            this.N = er,
            this.I = Ut
        };
        function Lt(er, Ut) {
            var Ct;
            return Ut > 32 ? (Ct = 64 - Ut,
            new St(er.I << Ut | er.N >>> Ct,er.N << Ut | er.I >>> Ct)) : Ut !== 0 ? (Ct = 32 - Ut,
            new St(er.N << Ut | er.I >>> Ct,er.I << Ut | er.N >>> Ct)) : er
        }
        function Mt(er, Ut) {
            var Ct;
            return Ut < 32 ? (Ct = 32 - Ut,
            new St(er.N >>> Ut | er.I << Ct,er.I >>> Ut | er.N << Ct)) : (Ct = 64 - Ut,
            new St(er.I >>> Ut | er.N << Ct,er.N >>> Ut | er.I << Ct))
        }
        function ar(er, Ut) {
            return new St(er.N >>> Ut,er.I >>> Ut | er.N << 32 - Ut)
        }
        function wr(er, Ut, Ct) {
            return new St(er.N & Ut.N ^ ~er.N & Ct.N,er.I & Ut.I ^ ~er.I & Ct.I)
        }
        function Tr(er, Ut, Ct) {
            return new St(er.N & Ut.N ^ er.N & Ct.N ^ Ut.N & Ct.N,er.I & Ut.I ^ er.I & Ct.I ^ Ut.I & Ct.I)
        }
        function Pr(er) {
            var Ut = Mt(er, 28)
              , Ct = Mt(er, 34)
              , yt = Mt(er, 39);
            return new St(Ut.N ^ Ct.N ^ yt.N,Ut.I ^ Ct.I ^ yt.I)
        }
        function kr(er, Ut) {
            var Ct, yt;
            Ct = (65535 & er.I) + (65535 & Ut.I);
            var bt = (65535 & (yt = (er.I >>> 16) + (Ut.I >>> 16) + (Ct >>> 16))) << 16 | 65535 & Ct;
            return Ct = (65535 & er.N) + (65535 & Ut.N) + (yt >>> 16),
            yt = (er.N >>> 16) + (Ut.N >>> 16) + (Ct >>> 16),
            new St((65535 & yt) << 16 | 65535 & Ct,bt)
        }
        function jr(er, Ut, Ct, yt) {
            var bt, At;
            bt = (65535 & er.I) + (65535 & Ut.I) + (65535 & Ct.I) + (65535 & yt.I);
            var Gt = (65535 & (At = (er.I >>> 16) + (Ut.I >>> 16) + (Ct.I >>> 16) + (yt.I >>> 16) + (bt >>> 16))) << 16 | 65535 & bt;
            return bt = (65535 & er.N) + (65535 & Ut.N) + (65535 & Ct.N) + (65535 & yt.N) + (At >>> 16),
            At = (er.N >>> 16) + (Ut.N >>> 16) + (Ct.N >>> 16) + (yt.N >>> 16) + (bt >>> 16),
            new St((65535 & At) << 16 | 65535 & bt,Gt)
        }
        function cr(er, Ut, Ct, yt, bt) {
            var At, Gt;
            At = (65535 & er.I) + (65535 & Ut.I) + (65535 & Ct.I) + (65535 & yt.I) + (65535 & bt.I);
            var Qt = (65535 & (Gt = (er.I >>> 16) + (Ut.I >>> 16) + (Ct.I >>> 16) + (yt.I >>> 16) + (bt.I >>> 16) + (At >>> 16))) << 16 | 65535 & At;
            return At = (65535 & er.N) + (65535 & Ut.N) + (65535 & Ct.N) + (65535 & yt.N) + (65535 & bt.N) + (Gt >>> 16),
            Gt = (er.N >>> 16) + (Ut.N >>> 16) + (Ct.N >>> 16) + (yt.N >>> 16) + (bt.N >>> 16) + (At >>> 16),
            new St((65535 & Gt) << 16 | 65535 & At,Qt)
        }
        function dr(er, Ut) {
            return new St(er.N ^ Ut.N,er.I ^ Ut.I)
        }
        function lr(er) {
            var Ut = Mt(er, 1)
              , Ct = Mt(er, 8)
              , yt = ar(er, 7);
            return new St(Ut.N ^ Ct.N ^ yt.N,Ut.I ^ Ct.I ^ yt.I)
        }
        function ir(er) {
            var Ut = Mt(er, 14)
              , Ct = Mt(er, 18)
              , yt = Mt(er, 41);
            return new St(Ut.N ^ Ct.N ^ yt.N,Ut.I ^ Ct.I ^ yt.I)
        }
        var gr = [new St(tt[0],3609767458), new St(tt[1],602891725), new St(tt[2],3964484399), new St(tt[3],2173295548), new St(tt[4],4081628472), new St(tt[5],3053834265), new St(tt[6],2937671579), new St(tt[7],3664609560), new St(tt[8],2734883394), new St(tt[9],1164996542), new St(tt[10],1323610764), new St(tt[11],3590304994), new St(tt[12],4068182383), new St(tt[13],991336113), new St(tt[14],633803317), new St(tt[15],3479774868), new St(tt[16],2666613458), new St(tt[17],944711139), new St(tt[18],2341262773), new St(tt[19],2007800933), new St(tt[20],1495990901), new St(tt[21],1856431235), new St(tt[22],3175218132), new St(tt[23],2198950837), new St(tt[24],3999719339), new St(tt[25],766784016), new St(tt[26],2566594879), new St(tt[27],3203337956), new St(tt[28],1034457026), new St(tt[29],2466948901), new St(tt[30],3758326383), new St(tt[31],168717936), new St(tt[32],1188179964), new St(tt[33],1546045734), new St(tt[34],1522805485), new St(tt[35],2643833823), new St(tt[36],2343527390), new St(tt[37],1014477480), new St(tt[38],1206759142), new St(tt[39],344077627), new St(tt[40],1290863460), new St(tt[41],3158454273), new St(tt[42],3505952657), new St(tt[43],106217008), new St(tt[44],3606008344), new St(tt[45],1432725776), new St(tt[46],1467031594), new St(tt[47],851169720), new St(tt[48],3100823752), new St(tt[49],1363258195), new St(tt[50],3750685593), new St(tt[51],3785050280), new St(tt[52],3318307427), new St(tt[53],3812723403), new St(tt[54],2003034995), new St(tt[55],3602036899), new St(tt[56],1575990012), new St(tt[57],1125592928), new St(tt[58],2716904306), new St(tt[59],442776044), new St(tt[60],593698344), new St(tt[61],3733110249), new St(tt[62],2999351573), new St(tt[63],3815920427), new St(3391569614,3928383900), new St(3515267271,566280711), new St(3940187606,3454069534), new St(4118630271,4000239992), new St(116418474,1914138554), new St(174292421,2731055270), new St(289380356,3203993006), new St(460393269,320620315), new St(685471733,587496836), new St(852142971,1086792851), new St(1017036298,365543100), new St(1126000580,2618297676), new St(1288033470,3409855158), new St(1501505948,4234509866), new St(1607167915,987167468), new St(1816402316,1246189591)];
        function Cr(er) {
            return er === "SHA-384" ? [new St(3418070365,rt[0]), new St(1654270250,rt[1]), new St(2438529370,rt[2]), new St(355462360,rt[3]), new St(1731405415,rt[4]), new St(41048885895,rt[5]), new St(3675008525,rt[6]), new St(1203062813,rt[7])] : [new St(nt[0],4089235720), new St(nt[1],2227873595), new St(nt[2],4271175723), new St(nt[3],1595750129), new St(nt[4],2917565137), new St(nt[5],725511199), new St(nt[6],4215389547), new St(nt[7],327033209)]
        }
        function hr(er, Ut) {
            var Ct, yt, bt, At, Gt, Qt, rr, Er, Ur, Mr, Lr, Kr, Fr, Mn, Bn, jn, Hn = [];
            for (Ct = Ut[0],
            yt = Ut[1],
            bt = Ut[2],
            At = Ut[3],
            Gt = Ut[4],
            Qt = Ut[5],
            rr = Ut[6],
            Er = Ut[7],
            Lr = 0; Lr < 80; Lr += 1)
                Lr < 16 ? (Kr = 2 * Lr,
                Hn[Lr] = new St(er[Kr],er[Kr + 1])) : Hn[Lr] = jr((Fr = Hn[Lr - 2],
                Mn = void 0,
                Bn = void 0,
                jn = void 0,
                Mn = Mt(Fr, 19),
                Bn = Mt(Fr, 61),
                jn = ar(Fr, 6),
                new St(Mn.N ^ Bn.N ^ jn.N,Mn.I ^ Bn.I ^ jn.I)), Hn[Lr - 7], lr(Hn[Lr - 15]), Hn[Lr - 16]),
                Ur = cr(Er, ir(Gt), wr(Gt, Qt, rr), gr[Lr], Hn[Lr]),
                Mr = kr(Pr(Ct), Tr(Ct, yt, bt)),
                Er = rr,
                rr = Qt,
                Qt = Gt,
                Gt = kr(At, Ur),
                At = bt,
                bt = yt,
                yt = Ct,
                Ct = kr(Ur, Mr);
            return Ut[0] = kr(Ct, Ut[0]),
            Ut[1] = kr(yt, Ut[1]),
            Ut[2] = kr(bt, Ut[2]),
            Ut[3] = kr(At, Ut[3]),
            Ut[4] = kr(Gt, Ut[4]),
            Ut[5] = kr(Qt, Ut[5]),
            Ut[6] = kr(rr, Ut[6]),
            Ut[7] = kr(Er, Ut[7]),
            Ut
        }
        var zr = function(er) {
            function Ut(Ct, yt, bt) {
                var At = this;
                if (Ct !== "SHA-384" && Ct !== "SHA-512")
                    throw new Error(it);
                var Gt = bt || {};
                return (At = er.call(this, Ct, yt, bt) || this).F = At.Y,
                At.g = !0,
                At.C = -1,
                At.p = $(At.t, At.i, At.C),
                At.R = hr,
                At.B = function(Qt) {
                    return Qt.slice()
                }
                ,
                At.L = Cr,
                At.K = function(Qt, rr, Er, Ur) {
                    return function(Mr, Lr, Kr, Fr, Mn) {
                        for (var Bn, jn = 31 + (Lr + 129 >>> 10 << 5), Hn = Lr + Kr; Mr.length <= jn; )
                            Mr.push(0);
                        for (Mr[Lr >>> 5] |= 128 << 24 - Lr % 32,
                        Mr[jn] = 4294967295 & Hn,
                        Mr[jn - 1] = Hn / 4294967296 | 0,
                        Bn = 0; Bn < Mr.length; Bn += 32)
                            Fr = hr(Mr.slice(Bn, Bn + 32), Fr);
                        return Mn === "SHA-384" ? [(Fr = Fr)[0].N, Fr[0].I, Fr[1].N, Fr[1].I, Fr[2].N, Fr[2].I, Fr[3].N, Fr[3].I, Fr[4].N, Fr[4].I, Fr[5].N, Fr[5].I] : [Fr[0].N, Fr[0].I, Fr[1].N, Fr[1].I, Fr[2].N, Fr[2].I, Fr[3].N, Fr[3].I, Fr[4].N, Fr[4].I, Fr[5].N, Fr[5].I, Fr[6].N, Fr[6].I, Fr[7].N, Fr[7].I]
                    }(Qt, rr, Er, Ur, Ct)
                }
                ,
                At.m = Cr(Ct),
                At.S = 1024,
                At.U = Ct === "SHA-384" ? 384 : 512,
                At.T = !1,
                Gt.hmacKey && At.k(st("hmacKey", Gt.hmacKey, At.C)),
                At
            }
            return ht(Ut, er),
            Ut
        }(dt)
          , Zr = [new St(0,1), new St(0,32898), new St(2147483648,32906), new St(2147483648,2147516416), new St(0,32907), new St(0,2147483649), new St(2147483648,2147516545), new St(2147483648,32777), new St(0,138), new St(0,136), new St(0,2147516425), new St(0,2147483658), new St(0,2147516555), new St(2147483648,139), new St(2147483648,32905), new St(2147483648,32771), new St(2147483648,32770), new St(2147483648,128), new St(0,32778), new St(2147483648,2147483658), new St(2147483648,2147516545), new St(2147483648,32896), new St(0,2147483649), new St(2147483648,2147516424)]
          , ln = [[0, 36, 3, 41, 18], [1, 44, 10, 45, 2], [62, 6, 43, 15, 61], [28, 55, 25, 21, 56], [27, 20, 39, 8, 14]];
        function Gr(er) {
            var Ut, Ct = [];
            for (Ut = 0; Ut < 5; Ut += 1)
                Ct[Ut] = [new St(0,0), new St(0,0), new St(0,0), new St(0,0), new St(0,0)];
            return Ct
        }
        function vn(er) {
            var Ut, Ct = [];
            for (Ut = 0; Ut < 5; Ut += 1)
                Ct[Ut] = er[Ut].slice();
            return Ct
        }
        function fn(er, Ut) {
            var Ct, yt, bt, At, Gt, Qt, rr, Er, Ur, Mr = [], Lr = [];
            if (er !== null)
                for (yt = 0; yt < er.length; yt += 2)
                    Ut[(yt >>> 1) % 5][(yt >>> 1) / 5 | 0] = dr(Ut[(yt >>> 1) % 5][(yt >>> 1) / 5 | 0], new St(er[yt + 1],er[yt]));
            for (Ct = 0; Ct < 24; Ct += 1) {
                for (At = Gr(),
                yt = 0; yt < 5; yt += 1)
                    Mr[yt] = (Gt = Ut[yt][0],
                    Qt = Ut[yt][1],
                    rr = Ut[yt][2],
                    Er = Ut[yt][3],
                    Ur = Ut[yt][4],
                    new St(Gt.N ^ Qt.N ^ rr.N ^ Er.N ^ Ur.N,Gt.I ^ Qt.I ^ rr.I ^ Er.I ^ Ur.I));
                for (yt = 0; yt < 5; yt += 1)
                    Lr[yt] = dr(Mr[(yt + 4) % 5], Lt(Mr[(yt + 1) % 5], 1));
                for (yt = 0; yt < 5; yt += 1)
                    for (bt = 0; bt < 5; bt += 1)
                        Ut[yt][bt] = dr(Ut[yt][bt], Lr[yt]);
                for (yt = 0; yt < 5; yt += 1)
                    for (bt = 0; bt < 5; bt += 1)
                        At[bt][(2 * yt + 3 * bt) % 5] = Lt(Ut[yt][bt], ln[yt][bt]);
                for (yt = 0; yt < 5; yt += 1)
                    for (bt = 0; bt < 5; bt += 1)
                        Ut[yt][bt] = dr(At[yt][bt], new St(~At[(yt + 1) % 5][bt].N & At[(yt + 2) % 5][bt].N,~At[(yt + 1) % 5][bt].I & At[(yt + 2) % 5][bt].I));
                Ut[0][0] = dr(Ut[0][0], Zr[Ct])
            }
            return Ut
        }
        function Rn(er) {
            var Ut, Ct, yt = 0, bt = [0, 0], At = [4294967295 & er, er / 4294967296 & 2097151];
            for (Ut = 6; Ut >= 0; Ut--)
                (Ct = At[Ut >> 2] >>> 8 * Ut & 255) === 0 && yt === 0 || (bt[yt + 1 >> 2] |= Ct << 8 * (yt + 1),
                yt += 1);
            return yt = yt !== 0 ? yt : 1,
            bt[0] |= yt,
            {
                value: yt + 1 > 4 ? bt : [bt[0]],
                binLen: 8 + 8 * yt
            }
        }
        function bn(er) {
            return ot(Rn(er.binLen), er)
        }
        function Un(er, Ut) {
            var Ct, yt = Rn(Ut), bt = Ut >>> 2, At = (bt - (yt = ot(yt, er)).value.length % bt) % bt;
            for (Ct = 0; Ct < At; Ct++)
                yt.value.push(0);
            return yt.value
        }
        var zn = function(er) {
            function Ut(Ct, yt, bt) {
                var At = this
                  , Gt = 6
                  , Qt = 0
                  , rr = bt || {};
                if ((At = er.call(this, Ct, yt, bt) || this).numRounds !== 1) {
                    if (rr.kmacKey || rr.hmacKey)
                        throw new Error("Cannot set numRounds with MAC");
                    if (At.o === "CSHAKE128" || At.o === "CSHAKE256")
                        throw new Error("Cannot set numRounds for CSHAKE variants")
                }
                switch (At.C = 1,
                At.p = $(At.t, At.i, At.C),
                At.R = fn,
                At.B = vn,
                At.L = Gr,
                At.m = Gr(),
                At.T = !1,
                Ct) {
                case "SHA3-224":
                    At.S = Qt = 1152,
                    At.U = 224,
                    At.g = !0,
                    At.F = At.Y;
                    break;
                case "SHA3-256":
                    At.S = Qt = 1088,
                    At.U = 256,
                    At.g = !0,
                    At.F = At.Y;
                    break;
                case "SHA3-384":
                    At.S = Qt = 832,
                    At.U = 384,
                    At.g = !0,
                    At.F = At.Y;
                    break;
                case "SHA3-512":
                    At.S = Qt = 576,
                    At.U = 512,
                    At.g = !0,
                    At.F = At.Y;
                    break;
                case "SHAKE128":
                    Gt = 31,
                    At.S = Qt = 1344,
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = null;
                    break;
                case "SHAKE256":
                    Gt = 31,
                    At.S = Qt = 1088,
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = null;
                    break;
                case "KMAC128":
                    Gt = 4,
                    At.S = Qt = 1344,
                    At.M(bt),
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = At.X;
                    break;
                case "KMAC256":
                    Gt = 4,
                    At.S = Qt = 1088,
                    At.M(bt),
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = At.X;
                    break;
                case "CSHAKE128":
                    At.S = Qt = 1344,
                    Gt = At.O(bt),
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = null;
                    break;
                case "CSHAKE256":
                    At.S = Qt = 1088,
                    Gt = At.O(bt),
                    At.U = -1,
                    At.T = !0,
                    At.g = !1,
                    At.F = null;
                    break;
                default:
                    throw new Error(it)
                }
                return At.K = function(Er, Ur, Mr, Lr, Kr) {
                    return function(Fr, Mn, Bn, jn, Hn, eo, Gn) {
                        var Kn, ho, mo = 0, ao = [], lo = Hn >>> 5, no = Mn >>> 5;
                        for (Kn = 0; Kn < no && Mn >= Hn; Kn += lo)
                            jn = fn(Fr.slice(Kn, Kn + lo), jn),
                            Mn -= Hn;
                        for (Fr = Fr.slice(Kn),
                        Mn %= Hn; Fr.length < lo; )
                            Fr.push(0);
                        for (Fr[(Kn = Mn >>> 3) >> 2] ^= eo << Kn % 4 * 8,
                        Fr[lo - 1] ^= 2147483648,
                        jn = fn(Fr, jn); 32 * ao.length < Gn && (ho = jn[mo % 5][mo / 5 | 0],
                        ao.push(ho.I),
                        !(32 * ao.length >= Gn)); )
                            ao.push(ho.N),
                            64 * (mo += 1) % Hn == 0 && (fn(null, jn),
                            mo = 0);
                        return ao
                    }(Er, Ur, 0, Lr, Qt, Gt, Kr)
                }
                ,
                rr.hmacKey && At.k(st("hmacKey", rr.hmacKey, At.C)),
                At
            }
            return ht(Ut, er),
            Ut.prototype.O = function(Ct, yt) {
                var bt = function(rr) {
                    var Er = rr || {};
                    return {
                        funcName: st("funcName", Er.funcName, 1, {
                            value: [],
                            binLen: 0
                        }),
                        customization: st("Customization", Er.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Ct || {});
                yt && (bt.funcName = yt);
                var At = ot(bn(bt.funcName), bn(bt.customization));
                if (bt.customization.binLen !== 0 || bt.funcName.binLen !== 0) {
                    for (var Gt = Un(At, this.S >>> 3), Qt = 0; Qt < Gt.length; Qt += this.S >>> 5)
                        this.m = this.R(Gt.slice(Qt, Qt + (this.S >>> 5)), this.m),
                        this.v += this.S;
                    return 4
                }
                return 31
            }
            ,
            Ut.prototype.M = function(Ct) {
                var yt = function(Gt) {
                    var Qt = Gt || {};
                    return {
                        kmacKey: st("kmacKey", Qt.kmacKey, 1),
                        funcName: {
                            value: [1128353099],
                            binLen: 32
                        },
                        customization: st("Customization", Qt.customization, 1, {
                            value: [],
                            binLen: 0
                        })
                    }
                }(Ct || {});
                this.O(Ct, yt.funcName);
                for (var bt = Un(bn(yt.kmacKey), this.S >>> 3), At = 0; At < bt.length; At += this.S >>> 5)
                    this.m = this.R(bt.slice(At, At + (this.S >>> 5)), this.m),
                    this.v += this.S;
                this.A = !0
            }
            ,
            Ut.prototype.X = function(Ct) {
                var yt = ot({
                    value: this.u.slice(),
                    binLen: this.s
                }, function(bt) {
                    var At, Gt, Qt = 0, rr = [0, 0], Er = [4294967295 & bt, bt / 4294967296 & 2097151];
                    for (At = 6; At >= 0; At--)
                        (Gt = Er[At >> 2] >>> 8 * At & 255) == 0 && Qt === 0 || (rr[Qt >> 2] |= Gt << 8 * Qt,
                        Qt += 1);
                    return rr[(Qt = Qt !== 0 ? Qt : 1) >> 2] |= Qt << 8 * Qt,
                    {
                        value: Qt + 1 > 4 ? rr : [rr[0]],
                        binLen: 8 + 8 * Qt
                    }
                }(Ct.outputLen));
                return this.K(yt.value, yt.binLen, this.v, this.B(this.m), Ct.outputLen)
            }
            ,
            Ut
        }(dt);
        return function() {
            function er(Ut, Ct, yt) {
                if (Ut == "SHA-1")
                    this.j = new Kt(Ut,Ct,yt);
                else if (Ut == "SHA-224" || Ut == "SHA-256")
                    this.j = new Et(Ut,Ct,yt);
                else if (Ut == "SHA-384" || Ut == "SHA-512")
                    this.j = new zr(Ut,Ct,yt);
                else {
                    if (Ut != "SHA3-224" && Ut != "SHA3-256" && Ut != "SHA3-384" && Ut != "SHA3-512" && Ut != "SHAKE128" && Ut != "SHAKE256" && Ut != "CSHAKE128" && Ut != "CSHAKE256" && Ut != "KMAC128" && Ut != "KMAC256")
                        throw new Error(it);
                    this.j = new zn(Ut,Ct,yt)
                }
            }
            return er.prototype.update = function(Ut) {
                this.j.update(Ut)
            }
            ,
            er.prototype.getHash = function(Ut, Ct) {
                return this.j.getHash(Ut, Ct)
            }
            ,
            er.prototype.setHMACKey = function(Ut, Ct, yt) {
                this.j.setHMACKey(Ut, Ct, yt)
            }
            ,
            er.prototype.getHMAC = function(Ut, Ct) {
                return this.j.getHMAC(Ut, Ct)
            }
            ,
            er
        }()
    })
}
)(sha);
var shaExports = sha.exports
  , browser = {}
  , getSecureRandom$1 = {};
Object.defineProperty(getSecureRandom$1, "__esModule", {
    value: !0
});
getSecureRandom$1.getSecureRandomWords = getSecureRandom$1.getSecureRandomBytes = void 0;
function getSecureRandomBytes$1(d) {
    return dist$3.Buffer.from(window.crypto.getRandomValues(new Uint8Array(d)))
}
getSecureRandom$1.getSecureRandomBytes = getSecureRandomBytes$1;
function getSecureRandomWords$1(d) {
    return window.crypto.getRandomValues(new Uint16Array(d))
}
getSecureRandom$1.getSecureRandomWords = getSecureRandomWords$1;
var hmac_sha512$3 = {};
Object.defineProperty(hmac_sha512$3, "__esModule", {
    value: !0
});
hmac_sha512$3.hmac_sha512 = void 0;
async function hmac_sha512$2(d, g) {
    let b = typeof d == "string" ? dist$3.Buffer.from(d, "utf-8") : d
      , _ = typeof g == "string" ? dist$3.Buffer.from(g, "utf-8") : g;
    const $ = {
        name: "HMAC",
        hash: "SHA-512"
    }
      , et = await window.crypto.subtle.importKey("raw", b, $, !1, ["sign"]);
    return dist$3.Buffer.from(await crypto.subtle.sign($, et, _))
}
hmac_sha512$3.hmac_sha512 = hmac_sha512$2;
var pbkdf2_sha512$3 = {};
Object.defineProperty(pbkdf2_sha512$3, "__esModule", {
    value: !0
});
pbkdf2_sha512$3.pbkdf2_sha512 = void 0;
async function pbkdf2_sha512$2(d, g, b, _) {
    const $ = typeof d == "string" ? dist$3.Buffer.from(d, "utf-8") : d
      , et = typeof g == "string" ? dist$3.Buffer.from(g, "utf-8") : g
      , tt = await window.crypto.subtle.importKey("raw", $, {
        name: "PBKDF2"
    }, !1, ["deriveBits"])
      , rt = await window.crypto.subtle.deriveBits({
        name: "PBKDF2",
        hash: "SHA-512",
        salt: et,
        iterations: b
    }, tt, _ * 8);
    return dist$3.Buffer.from(rt)
}
pbkdf2_sha512$3.pbkdf2_sha512 = pbkdf2_sha512$2;
var sha256$2 = {};
Object.defineProperty(sha256$2, "__esModule", {
    value: !0
});
sha256$2.sha256 = void 0;
async function sha256$1(d) {
    return typeof d == "string" ? dist$3.Buffer.from(await crypto.subtle.digest("SHA-256", dist$3.Buffer.from(d, "utf-8"))) : dist$3.Buffer.from(await crypto.subtle.digest("SHA-256", d))
}
sha256$2.sha256 = sha256$1;
var sha512$3 = {};
Object.defineProperty(sha512$3, "__esModule", {
    value: !0
});
sha512$3.sha512 = void 0;
async function sha512$2(d) {
    return typeof d == "string" ? dist$3.Buffer.from(await crypto.subtle.digest("SHA-512", dist$3.Buffer.from(d, "utf-8"))) : dist$3.Buffer.from(await crypto.subtle.digest("SHA-512", d))
}
sha512$3.sha512 = sha512$2;
(function(d) {
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.sha512 = d.sha256 = d.pbkdf2_sha512 = d.hmac_sha512 = d.getSecureRandomWords = d.getSecureRandomBytes = void 0;
    var g = getSecureRandom$1;
    Object.defineProperty(d, "getSecureRandomBytes", {
        enumerable: !0,
        get: function() {
            return g.getSecureRandomBytes
        }
    }),
    Object.defineProperty(d, "getSecureRandomWords", {
        enumerable: !0,
        get: function() {
            return g.getSecureRandomWords
        }
    });
    var b = hmac_sha512$3;
    Object.defineProperty(d, "hmac_sha512", {
        enumerable: !0,
        get: function() {
            return b.hmac_sha512
        }
    });
    var _ = pbkdf2_sha512$3;
    Object.defineProperty(d, "pbkdf2_sha512", {
        enumerable: !0,
        get: function() {
            return _.pbkdf2_sha512
        }
    });
    var $ = sha256$2;
    Object.defineProperty(d, "sha256", {
        enumerable: !0,
        get: function() {
            return $.sha256
        }
    });
    var et = sha512$3;
    Object.defineProperty(d, "sha512", {
        enumerable: !0,
        get: function() {
            return et.sha512
        }
    })
}
)(browser);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
;
Object.defineProperty(sha256$3, "__esModule", {
    value: !0
});
sha256$3.sha256 = sha256$3.sha256_fallback = sha256$3.sha256_sync = void 0;
const jssha_1$2 = __importDefault$4(shaExports)
  , ton_crypto_primitives_1$4 = browser;
function sha256_sync(d) {
    let g;
    typeof d == "string" ? g = dist$3.Buffer.from(d, "utf-8").toString("hex") : g = d.toString("hex");
    let b = new jssha_1$2.default("SHA-256","HEX");
    b.update(g);
    let _ = b.getHash("HEX");
    return dist$3.Buffer.from(_, "hex")
}
sha256$3.sha256_sync = sha256_sync;
async function sha256_fallback(d) {
    return sha256_sync(d)
}
sha256$3.sha256_fallback = sha256_fallback;
function sha256(d) {
    return (0,
    ton_crypto_primitives_1$4.sha256)(d)
}
sha256$3.sha256 = sha256;
var sha512$1 = {}
  , __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
;
Object.defineProperty(sha512$1, "__esModule", {
    value: !0
});
sha512$1.sha512 = sha512$1.sha512_fallback = sha512$1.sha512_sync = void 0;
const jssha_1$1 = __importDefault$3(shaExports)
  , ton_crypto_primitives_1$3 = browser;
function sha512_sync(d) {
    let g;
    typeof d == "string" ? g = dist$3.Buffer.from(d, "utf-8").toString("hex") : g = d.toString("hex");
    let b = new jssha_1$1.default("SHA-512","HEX");
    b.update(g);
    let _ = b.getHash("HEX");
    return dist$3.Buffer.from(_, "hex")
}
sha512$1.sha512_sync = sha512_sync;
async function sha512_fallback(d) {
    return sha512_sync(d)
}
sha512$1.sha512_fallback = sha512_fallback;
async function sha512(d) {
    return (0,
    ton_crypto_primitives_1$3.sha512)(d)
}
sha512$1.sha512 = sha512;
var pbkdf2_sha512$1 = {};
Object.defineProperty(pbkdf2_sha512$1, "__esModule", {
    value: !0
});
pbkdf2_sha512$1.pbkdf2_sha512 = void 0;
const ton_crypto_primitives_1$2 = browser;
function pbkdf2_sha512(d, g, b, _) {
    return (0,
    ton_crypto_primitives_1$2.pbkdf2_sha512)(d, g, b, _)
}
pbkdf2_sha512$1.pbkdf2_sha512 = pbkdf2_sha512;
var hmac_sha512$1 = {}
  , __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
;
Object.defineProperty(hmac_sha512$1, "__esModule", {
    value: !0
});
hmac_sha512$1.hmac_sha512 = hmac_sha512$1.hmac_sha512_fallback = void 0;
const jssha_1 = __importDefault$2(shaExports)
  , ton_crypto_primitives_1$1 = browser;
async function hmac_sha512_fallback(d, g) {
    let b = typeof d == "string" ? dist$3.Buffer.from(d, "utf-8") : d
      , _ = typeof g == "string" ? dist$3.Buffer.from(g, "utf-8") : g;
    const $ = new jssha_1.default("SHA-512","HEX",{
        hmacKey: {
            value: b.toString("hex"),
            format: "HEX"
        }
    });
    $.update(_.toString("hex"));
    const et = $.getHash("HEX");
    return dist$3.Buffer.from(et, "hex")
}
hmac_sha512$1.hmac_sha512_fallback = hmac_sha512_fallback;
function hmac_sha512(d, g) {
    return (0,
    ton_crypto_primitives_1$1.hmac_sha512)(d, g)
}
hmac_sha512$1.hmac_sha512 = hmac_sha512;
var getSecureRandom = {};
Object.defineProperty(getSecureRandom, "__esModule", {
    value: !0
});
getSecureRandom.getSecureRandomNumber = getSecureRandom.getSecureRandomWords = getSecureRandom.getSecureRandomBytes = void 0;
const ton_crypto_primitives_1 = browser;
async function getSecureRandomBytes(d) {
    return (0,
    ton_crypto_primitives_1.getSecureRandomBytes)(d)
}
getSecureRandom.getSecureRandomBytes = getSecureRandomBytes;
async function getSecureRandomWords(d) {
    return getSecureRandomWords()
}
getSecureRandom.getSecureRandomWords = getSecureRandomWords;
async function getSecureRandomNumber(d, g) {
    let b = g - d;
    var _ = Math.ceil(Math.log2(b));
    if (_ > 53)
        throw new Error("Range is too large");
    for (var $ = Math.ceil(_ / 8), et = Math.pow(2, _) - 1; ; ) {
        let rt = await getSecureRandomBytes(_)
          , nt = ($ - 1) * 8
          , it = 0;
        for (var tt = 0; tt < $; tt++)
            it += rt[tt] * Math.pow(2, nt),
            nt -= 8;
        if (it = it & et,
        !(it >= b))
            return d + it
    }
}
getSecureRandom.getSecureRandomNumber = getSecureRandomNumber;
var newSecureWords$1 = {}
  , wordlist$1 = {};
Object.defineProperty(wordlist$1, "__esModule", {
    value: !0
});
wordlist$1.wordlist = void 0;
wordlist$1.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"];
Object.defineProperty(newSecureWords$1, "__esModule", {
    value: !0
});
newSecureWords$1.newSecureWords = void 0;
const getSecureRandom_1$1 = getSecureRandom
  , wordlist_1$1 = wordlist$1;
async function newSecureWords(d=6) {
    let g = [];
    for (let b = 0; b < d; b++)
        g.push(wordlist_1$1.wordlist[await (0,
        getSecureRandom_1$1.getSecureRandomNumber)(0, wordlist_1$1.wordlist.length)]);
    return g
}
newSecureWords$1.newSecureWords = newSecureWords;
var newSecurePassphrase = {}, hasRequiredNewSecurePassphrase;
function requireNewSecurePassphrase() {
    if (hasRequiredNewSecurePassphrase)
        return newSecurePassphrase;
    hasRequiredNewSecurePassphrase = 1,
    Object.defineProperty(newSecurePassphrase, "__esModule", {
        value: !0
    }),
    newSecurePassphrase.newSecurePassphrase = void 0;
    const d = requireDist();
    async function g(b=6) {
        return (await (0,
        d.newSecureWords)(b)).join("-")
    }
    return newSecurePassphrase.newSecurePassphrase = g,
    newSecurePassphrase
}
var mnemonic = {}
  , binary = {};
Object.defineProperty(binary, "__esModule", {
    value: !0
});
binary.bitsToBytes = binary.bytesToBits = binary.lpad = void 0;
function lpad(d, g, b) {
    for (; d.length < b; )
        d = g + d;
    return d
}
binary.lpad = lpad;
function bytesToBits(d) {
    let g = "";
    for (let b = 0; b < d.length; b++) {
        let _ = d.at(b);
        g += lpad(_.toString(2), "0", 8)
    }
    return g
}
binary.bytesToBits = bytesToBits;
function bitsToBytes(d) {
    if (d.length % 8 !== 0)
        throw Error("Uneven bits");
    let g = [];
    for (; d.length > 0; )
        g.push(parseInt(d.slice(0, 8), 2)),
        d = d.slice(8);
    return dist$3.Buffer.from(g)
}
binary.bitsToBytes = bitsToBytes;
var wordlist = {};
Object.defineProperty(wordlist, "__esModule", {
    value: !0
});
wordlist.wordlist = void 0;
const EN = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
wordlist.wordlist = EN;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
;
Object.defineProperty(mnemonic, "__esModule", {
    value: !0
});
mnemonic.mnemonicFromRandomSeed = mnemonic.mnemonicIndexesToBytes = mnemonic.bytesToMnemonics = mnemonic.bytesToMnemonicIndexes = mnemonic.mnemonicNew = mnemonic.mnemonicValidate = mnemonic.mnemonicToHDSeed = mnemonic.mnemonicToWalletKey = mnemonic.mnemonicToPrivateKey = mnemonic.mnemonicToSeed = mnemonic.mnemonicToEntropy = void 0;
const tweetnacl_1$1 = __importDefault$1(naclFastExports)
  , getSecureRandom_1 = getSecureRandom
  , hmac_sha512_1$3 = hmac_sha512$1
  , pbkdf2_sha512_1 = pbkdf2_sha512$1
  , binary_1 = binary
  , wordlist_1 = wordlist
  , PBKDF_ITERATIONS = 1e5;
async function isPasswordNeeded(d) {
    const g = await mnemonicToEntropy(d);
    return await isPasswordSeed(g) && !await isBasicSeed(g)
}
function normalizeMnemonic(d) {
    return d.map(g=>g.toLowerCase().trim())
}
async function isBasicSeed(d) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(d, "TON seed version", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), 64))[0] == 0
}
async function isPasswordSeed(d) {
    return (await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(d, "TON fast seed version", 1, 64))[0] == 1
}
async function mnemonicToEntropy(d, g) {
    return await (0,
    hmac_sha512_1$3.hmac_sha512)(d.join(" "), g && g.length > 0 ? g : "")
}
mnemonic.mnemonicToEntropy = mnemonicToEntropy;
async function mnemonicToSeed(d, g, b) {
    const _ = await mnemonicToEntropy(d, b);
    return await (0,
    pbkdf2_sha512_1.pbkdf2_sha512)(_, g, PBKDF_ITERATIONS, 64)
}
mnemonic.mnemonicToSeed = mnemonicToSeed;
async function mnemonicToPrivateKey(d, g) {
    d = normalizeMnemonic(d);
    const b = await mnemonicToSeed(d, "TON default seed", g);
    let _ = tweetnacl_1$1.default.sign.keyPair.fromSeed(b.slice(0, 32));
    return {
        publicKey: dist$3.Buffer.from(_.publicKey),
        secretKey: dist$3.Buffer.from(_.secretKey)
    }
}
mnemonic.mnemonicToPrivateKey = mnemonicToPrivateKey;
async function mnemonicToWalletKey(d, g) {
    let _ = (await mnemonicToPrivateKey(d, g)).secretKey.slice(0, 32);
    const $ = tweetnacl_1$1.default.sign.keyPair.fromSeed(_);
    return {
        publicKey: dist$3.Buffer.from($.publicKey),
        secretKey: dist$3.Buffer.from($.secretKey)
    }
}
mnemonic.mnemonicToWalletKey = mnemonicToWalletKey;
async function mnemonicToHDSeed(d, g) {
    return d = normalizeMnemonic(d),
    await mnemonicToSeed(d, "TON HD Keys seed", g)
}
mnemonic.mnemonicToHDSeed = mnemonicToHDSeed;
async function mnemonicValidate(d, g) {
    d = normalizeMnemonic(d);
    for (let b of d)
        if (wordlist_1.wordlist.indexOf(b) < 0)
            return !1;
    return g && g.length > 0 && !await isPasswordNeeded(d) ? !1 : await isBasicSeed(await mnemonicToEntropy(d, g))
}
mnemonic.mnemonicValidate = mnemonicValidate;
async function mnemonicNew(d=24, g) {
    let b = [];
    for (; ; ) {
        b = [];
        for (let _ = 0; _ < d; _++) {
            let $ = await (0,
            getSecureRandom_1.getSecureRandomNumber)(0, wordlist_1.wordlist.length);
            b.push(wordlist_1.wordlist[$])
        }
        if (!(g && g.length > 0 && !await isPasswordNeeded(b)) && await isBasicSeed(await mnemonicToEntropy(b, g)))
            break
    }
    return b
}
mnemonic.mnemonicNew = mnemonicNew;
function bytesToMnemonicIndexes(d, g) {
    let b = (0,
    binary_1.bytesToBits)(d)
      , _ = [];
    for (let $ = 0; $ < g; $++) {
        let et = b.slice($ * 11, $ * 11 + 11);
        _.push(parseInt(et, 2))
    }
    return _
}
mnemonic.bytesToMnemonicIndexes = bytesToMnemonicIndexes;
function bytesToMnemonics(d, g) {
    let b = bytesToMnemonicIndexes(d, g)
      , _ = [];
    for (let $ of b)
        _.push(wordlist_1.wordlist[$]);
    return _
}
mnemonic.bytesToMnemonics = bytesToMnemonics;
function mnemonicIndexesToBytes(d) {
    let g = "";
    for (let b of d) {
        if (!Number.isSafeInteger(b) || b < 0 || b >= 2028)
            throw Error("Invalid input");
        g += (0,
        binary_1.lpad)(b.toString(2), "0", 11)
    }
    for (; g.length % 8 !== 0; )
        g = g + "0";
    return (0,
    binary_1.bitsToBytes)(g)
}
mnemonic.mnemonicIndexesToBytes = mnemonicIndexesToBytes;
async function mnemonicFromRandomSeed(d, g=24, b) {
    const _ = Math.ceil(g * 11 / 8);
    let $ = d;
    for (; ; ) {
        let et = await (0,
        pbkdf2_sha512_1.pbkdf2_sha512)($, "TON mnemonic seed", Math.max(1, Math.floor(PBKDF_ITERATIONS / 256)), _)
          , tt = bytesToMnemonics(et, g);
        if (await mnemonicValidate(tt, b))
            return tt;
        $ = et
    }
}
mnemonic.mnemonicFromRandomSeed = mnemonicFromRandomSeed;
var nacl = {}
  , __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
;
Object.defineProperty(nacl, "__esModule", {
    value: !0
});
nacl.openBox = nacl.sealBox = nacl.signVerify = nacl.sign = nacl.keyPairFromSeed = nacl.keyPairFromSecretKey = void 0;
const tweetnacl_1 = __importDefault(naclFastExports);
function keyPairFromSecretKey(d) {
    let g = tweetnacl_1.default.sign.keyPair.fromSecretKey(new Uint8Array(d));
    return {
        publicKey: dist$3.Buffer.from(g.publicKey),
        secretKey: dist$3.Buffer.from(g.secretKey)
    }
}
nacl.keyPairFromSecretKey = keyPairFromSecretKey;
function keyPairFromSeed(d) {
    let g = tweetnacl_1.default.sign.keyPair.fromSeed(new Uint8Array(d));
    return {
        publicKey: dist$3.Buffer.from(g.publicKey),
        secretKey: dist$3.Buffer.from(g.secretKey)
    }
}
nacl.keyPairFromSeed = keyPairFromSeed;
function sign(d, g) {
    return dist$3.Buffer.from(tweetnacl_1.default.sign.detached(new Uint8Array(d), new Uint8Array(g)))
}
nacl.sign = sign;
function signVerify(d, g, b) {
    return tweetnacl_1.default.sign.detached.verify(new Uint8Array(d), new Uint8Array(g), new Uint8Array(b))
}
nacl.signVerify = signVerify;
function sealBox(d, g, b) {
    return dist$3.Buffer.from(tweetnacl_1.default.secretbox(d, g, b))
}
nacl.sealBox = sealBox;
function openBox(d, g, b) {
    let _ = tweetnacl_1.default.secretbox.open(d, g, b);
    return _ ? dist$3.Buffer.from(_) : null
}
nacl.openBox = openBox;
var ed25519 = {};
Object.defineProperty(ed25519, "__esModule", {
    value: !0
});
ed25519.deriveEd25519Path = ed25519.deriveED25519HardenedKey = ed25519.getED25519MasterKeyFromSeed = void 0;
const hmac_sha512_1$2 = hmac_sha512$1
  , ED25519_CURVE = "ed25519 seed"
  , HARDENED_OFFSET$1 = 2147483648;
async function getED25519MasterKeyFromSeed(d) {
    const g = await (0,
    hmac_sha512_1$2.hmac_sha512)(ED25519_CURVE, d)
      , b = g.slice(0, 32)
      , _ = g.slice(32);
    return {
        key: b,
        chainCode: _
    }
}
ed25519.getED25519MasterKeyFromSeed = getED25519MasterKeyFromSeed;
async function deriveED25519HardenedKey(d, g) {
    if (g >= HARDENED_OFFSET$1)
        throw Error("Key index must be less than offset");
    const b = dist$3.Buffer.alloc(4);
    b.writeUInt32BE(g + HARDENED_OFFSET$1, 0);
    const _ = dist$3.Buffer.concat([dist$3.Buffer.alloc(1, 0), d.key, b])
      , $ = await (0,
    hmac_sha512_1$2.hmac_sha512)(d.chainCode, _)
      , et = $.slice(0, 32)
      , tt = $.slice(32);
    return {
        key: et,
        chainCode: tt
    }
}
ed25519.deriveED25519HardenedKey = deriveED25519HardenedKey;
async function deriveEd25519Path(d, g) {
    let b = await getED25519MasterKeyFromSeed(d)
      , _ = [...g];
    for (; _.length > 0; ) {
        let $ = _[0];
        _ = _.slice(1),
        b = await deriveED25519HardenedKey(b, $)
    }
    return b.key
}
ed25519.deriveEd25519Path = deriveEd25519Path;
var symmetric = {};
Object.defineProperty(symmetric, "__esModule", {
    value: !0
});
symmetric.deriveSymmetricPath = symmetric.deriveSymmetricHardenedKey = symmetric.getSymmetricMasterKeyFromSeed = void 0;
const hmac_sha512_1$1 = hmac_sha512$1
  , SYMMETRIC_SEED = "Symmetric key seed";
async function getSymmetricMasterKeyFromSeed(d) {
    const g = await (0,
    hmac_sha512_1$1.hmac_sha512)(SYMMETRIC_SEED, d)
      , b = g.slice(32)
      , _ = g.slice(0, 32);
    return {
        key: b,
        chainCode: _
    }
}
symmetric.getSymmetricMasterKeyFromSeed = getSymmetricMasterKeyFromSeed;
async function deriveSymmetricHardenedKey(d, g) {
    const b = dist$3.Buffer.concat([dist$3.Buffer.alloc(1, 0), dist$3.Buffer.from(g)])
      , _ = await (0,
    hmac_sha512_1$1.hmac_sha512)(d.chainCode, b)
      , $ = _.slice(32)
      , et = _.slice(0, 32);
    return {
        key: $,
        chainCode: et
    }
}
symmetric.deriveSymmetricHardenedKey = deriveSymmetricHardenedKey;
async function deriveSymmetricPath(d, g) {
    let b = await getSymmetricMasterKeyFromSeed(d)
      , _ = [...g];
    for (; _.length > 0; ) {
        let $ = _[0];
        _ = _.slice(1),
        b = await deriveSymmetricHardenedKey(b, $)
    }
    return b.key
}
symmetric.deriveSymmetricPath = deriveSymmetricPath;
var mnemonics = {};
Object.defineProperty(mnemonics, "__esModule", {
    value: !0
});
mnemonics.deriveMnemonicsPath = mnemonics.deriveMnemonicHardenedKey = mnemonics.getMnemonicsMasterKeyFromSeed = void 0;
const mnemonic_1 = mnemonic
  , hmac_sha512_1 = hmac_sha512$1
  , HARDENED_OFFSET = 2147483648
  , MNEMONICS_SEED = "TON Mnemonics HD seed";
async function getMnemonicsMasterKeyFromSeed(d) {
    const g = await (0,
    hmac_sha512_1.hmac_sha512)(MNEMONICS_SEED, d)
      , b = g.slice(0, 32)
      , _ = g.slice(32);
    return {
        key: b,
        chainCode: _
    }
}
mnemonics.getMnemonicsMasterKeyFromSeed = getMnemonicsMasterKeyFromSeed;
async function deriveMnemonicHardenedKey(d, g) {
    if (g >= HARDENED_OFFSET)
        throw Error("Key index must be less than offset");
    const b = dist$3.Buffer.alloc(4);
    b.writeUInt32BE(g + HARDENED_OFFSET, 0);
    const _ = dist$3.Buffer.concat([dist$3.Buffer.alloc(1, 0), d.key, b])
      , $ = await (0,
    hmac_sha512_1.hmac_sha512)(d.chainCode, _)
      , et = $.slice(0, 32)
      , tt = $.slice(32);
    return {
        key: et,
        chainCode: tt
    }
}
mnemonics.deriveMnemonicHardenedKey = deriveMnemonicHardenedKey;
async function deriveMnemonicsPath(d, g, b=24, _) {
    let $ = await getMnemonicsMasterKeyFromSeed(d)
      , et = [...g];
    for (; et.length > 0; ) {
        let tt = et[0];
        et = et.slice(1),
        $ = await deriveMnemonicHardenedKey($, tt)
    }
    return await (0,
    mnemonic_1.mnemonicFromRandomSeed)($.key, b, _)
}
mnemonics.deriveMnemonicsPath = deriveMnemonicsPath;
var hasRequiredDist;
function requireDist() {
    return hasRequiredDist || (hasRequiredDist = 1,
    function(d) {
        Object.defineProperty(d, "__esModule", {
            value: !0
        }),
        d.getMnemonicsMasterKeyFromSeed = d.deriveMnemonicHardenedKey = d.deriveMnemonicsPath = d.deriveSymmetricPath = d.deriveSymmetricHardenedKey = d.getSymmetricMasterKeyFromSeed = d.deriveEd25519Path = d.deriveED25519HardenedKey = d.getED25519MasterKeyFromSeed = d.signVerify = d.sign = d.keyPairFromSecretKey = d.keyPairFromSeed = d.openBox = d.sealBox = d.mnemonicWordList = d.mnemonicToHDSeed = d.mnemonicToSeed = d.mnemonicToWalletKey = d.mnemonicToPrivateKey = d.mnemonicValidate = d.mnemonicNew = d.newSecurePassphrase = d.newSecureWords = d.getSecureRandomNumber = d.getSecureRandomWords = d.getSecureRandomBytes = d.hmac_sha512 = d.pbkdf2_sha512 = d.sha512_sync = d.sha512 = d.sha256_sync = d.sha256 = void 0;
        var g = sha256$3;
        Object.defineProperty(d, "sha256", {
            enumerable: !0,
            get: function() {
                return g.sha256
            }
        }),
        Object.defineProperty(d, "sha256_sync", {
            enumerable: !0,
            get: function() {
                return g.sha256_sync
            }
        });
        var b = sha512$1;
        Object.defineProperty(d, "sha512", {
            enumerable: !0,
            get: function() {
                return b.sha512
            }
        }),
        Object.defineProperty(d, "sha512_sync", {
            enumerable: !0,
            get: function() {
                return b.sha512_sync
            }
        });
        var _ = pbkdf2_sha512$1;
        Object.defineProperty(d, "pbkdf2_sha512", {
            enumerable: !0,
            get: function() {
                return _.pbkdf2_sha512
            }
        });
        var $ = hmac_sha512$1;
        Object.defineProperty(d, "hmac_sha512", {
            enumerable: !0,
            get: function() {
                return $.hmac_sha512
            }
        });
        var et = getSecureRandom;
        Object.defineProperty(d, "getSecureRandomBytes", {
            enumerable: !0,
            get: function() {
                return et.getSecureRandomBytes
            }
        }),
        Object.defineProperty(d, "getSecureRandomWords", {
            enumerable: !0,
            get: function() {
                return et.getSecureRandomWords
            }
        }),
        Object.defineProperty(d, "getSecureRandomNumber", {
            enumerable: !0,
            get: function() {
                return et.getSecureRandomNumber
            }
        });
        var tt = newSecureWords$1;
        Object.defineProperty(d, "newSecureWords", {
            enumerable: !0,
            get: function() {
                return tt.newSecureWords
            }
        });
        var rt = requireNewSecurePassphrase();
        Object.defineProperty(d, "newSecurePassphrase", {
            enumerable: !0,
            get: function() {
                return rt.newSecurePassphrase
            }
        });
        var nt = mnemonic;
        Object.defineProperty(d, "mnemonicNew", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicNew
            }
        }),
        Object.defineProperty(d, "mnemonicValidate", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicValidate
            }
        }),
        Object.defineProperty(d, "mnemonicToPrivateKey", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicToPrivateKey
            }
        }),
        Object.defineProperty(d, "mnemonicToWalletKey", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicToWalletKey
            }
        }),
        Object.defineProperty(d, "mnemonicToSeed", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicToSeed
            }
        }),
        Object.defineProperty(d, "mnemonicToHDSeed", {
            enumerable: !0,
            get: function() {
                return nt.mnemonicToHDSeed
            }
        });
        var it = wordlist;
        Object.defineProperty(d, "mnemonicWordList", {
            enumerable: !0,
            get: function() {
                return it.wordlist
            }
        });
        var ot = nacl;
        Object.defineProperty(d, "sealBox", {
            enumerable: !0,
            get: function() {
                return ot.sealBox
            }
        }),
        Object.defineProperty(d, "openBox", {
            enumerable: !0,
            get: function() {
                return ot.openBox
            }
        });
        var at = nacl;
        Object.defineProperty(d, "keyPairFromSeed", {
            enumerable: !0,
            get: function() {
                return at.keyPairFromSeed
            }
        }),
        Object.defineProperty(d, "keyPairFromSecretKey", {
            enumerable: !0,
            get: function() {
                return at.keyPairFromSecretKey
            }
        }),
        Object.defineProperty(d, "sign", {
            enumerable: !0,
            get: function() {
                return at.sign
            }
        }),
        Object.defineProperty(d, "signVerify", {
            enumerable: !0,
            get: function() {
                return at.signVerify
            }
        });
        var st = ed25519;
        Object.defineProperty(d, "getED25519MasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return st.getED25519MasterKeyFromSeed
            }
        }),
        Object.defineProperty(d, "deriveED25519HardenedKey", {
            enumerable: !0,
            get: function() {
                return st.deriveED25519HardenedKey
            }
        }),
        Object.defineProperty(d, "deriveEd25519Path", {
            enumerable: !0,
            get: function() {
                return st.deriveEd25519Path
            }
        });
        var dt = symmetric;
        Object.defineProperty(d, "getSymmetricMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return dt.getSymmetricMasterKeyFromSeed
            }
        }),
        Object.defineProperty(d, "deriveSymmetricHardenedKey", {
            enumerable: !0,
            get: function() {
                return dt.deriveSymmetricHardenedKey
            }
        }),
        Object.defineProperty(d, "deriveSymmetricPath", {
            enumerable: !0,
            get: function() {
                return dt.deriveSymmetricPath
            }
        });
        var ft = mnemonics;
        Object.defineProperty(d, "deriveMnemonicsPath", {
            enumerable: !0,
            get: function() {
                return ft.deriveMnemonicsPath
            }
        }),
        Object.defineProperty(d, "deriveMnemonicHardenedKey", {
            enumerable: !0,
            get: function() {
                return ft.deriveMnemonicHardenedKey
            }
        }),
        Object.defineProperty(d, "getMnemonicsMasterKeyFromSeed", {
            enumerable: !0,
            get: function() {
                return ft.getMnemonicsMasterKeyFromSeed
            }
        })
    }(dist$1)),
    dist$1
}
Object.defineProperty(wonderCalculator$1, "__esModule", {
    value: !0
});
wonderCalculator$1.wonderCalculator = void 0;
const BitString_1 = requireBitString()
  , CellType_1 = CellType
  , LevelMask_1 = LevelMask$1
  , exoticPruned_1 = exoticPruned$1
  , exoticMerkleProof_1 = exoticMerkleProof$1
  , descriptor_1 = descriptor$1
  , ton_crypto_1$1 = requireDist()
  , exoticMerkleUpdate_1 = exoticMerkleUpdate$1
  , exoticLibrary_1 = exoticLibrary$1;
function wonderCalculator(d, g, b) {
    let _, $ = null;
    if (d === CellType_1.CellType.Ordinary) {
        let st = 0;
        for (let dt of b)
            st = st | dt.mask.value;
        _ = new LevelMask_1.LevelMask(st)
    } else if (d === CellType_1.CellType.PrunedBranch)
        $ = (0,
        exoticPruned_1.exoticPruned)(g, b),
        _ = new LevelMask_1.LevelMask($.mask);
    else if (d === CellType_1.CellType.MerkleProof)
        (0,
        exoticMerkleProof_1.exoticMerkleProof)(g, b),
        _ = new LevelMask_1.LevelMask(b[0].mask.value >> 1);
    else if (d === CellType_1.CellType.MerkleUpdate)
        (0,
        exoticMerkleUpdate_1.exoticMerkleUpdate)(g, b),
        _ = new LevelMask_1.LevelMask((b[0].mask.value | b[1].mask.value) >> 1);
    else if (d === CellType_1.CellType.Library)
        (0,
        exoticLibrary_1.exoticLibrary)(g, b),
        _ = new LevelMask_1.LevelMask;
    else
        throw new Error("Unsupported exotic type");
    let et = []
      , tt = []
      , rt = d === CellType_1.CellType.PrunedBranch ? 1 : _.hashCount
      , it = _.hashCount - rt;
    for (let st = 0, dt = 0; st <= _.level; st++) {
        if (!_.isSignificant(st))
            continue;
        if (dt < it) {
            dt++;
            continue
        }
        let ft;
        if (dt === it) {
            if (!(st === 0 || d === CellType_1.CellType.PrunedBranch))
                throw Error("Invalid");
            ft = g
        } else {
            if (!(st !== 0 && d !== CellType_1.CellType.PrunedBranch))
                throw Error("Invalid: " + st + ", " + d);
            ft = new BitString_1.BitString(tt[dt - it - 1],0,256)
        }
        let ht = 0;
        for (let ut of b) {
            let pt;
            d == CellType_1.CellType.MerkleProof || d == CellType_1.CellType.MerkleUpdate ? pt = ut.depth(st + 1) : pt = ut.depth(st),
            ht = Math.max(ht, pt)
        }
        b.length > 0 && ht++;
        let xt = (0,
        descriptor_1.getRepr)(g, ft, b, st, d)
          , lt = (0,
        ton_crypto_1$1.sha256_sync)(xt)
          , ct = dt - it;
        et[ct] = ht,
        tt[ct] = lt,
        dt++
    }
    let ot = []
      , at = [];
    if ($)
        for (let st = 0; st < 4; st++) {
            const {hashIndex: dt} = _.apply(st)
              , {hashIndex: ft} = _;
            dt !== ft ? (ot.push($.pruned[dt].hash),
            at.push($.pruned[dt].depth)) : (ot.push(tt[0]),
            at.push(et[0]))
        }
    else
        for (let st = 0; st < 4; st++)
            ot.push(tt[_.apply(st).hashIndex]),
            at.push(et[_.apply(st).hashIndex]);
    return {
        mask: _,
        hashes: ot,
        depths: at
    }
}
wonderCalculator$1.wonderCalculator = wonderCalculator;
var serialization = {}
  , topologicalSort$1 = {};
Object.defineProperty(topologicalSort$1, "__esModule", {
    value: !0
});
topologicalSort$1.topologicalSort = void 0;
function topologicalSort(d) {
    let g = [d]
      , b = new Map
      , _ = new Set
      , $ = [];
    for (; g.length > 0; ) {
        const it = [...g];
        g = [];
        for (let ot of it) {
            const at = ot.hash().toString("hex");
            if (!b.has(at)) {
                _.add(at),
                b.set(at, {
                    cell: ot,
                    refs: ot.refs.map(st=>st.hash().toString("hex"))
                });
                for (let st of ot.refs)
                    g.push(st)
            }
        }
    }
    let et = new Set;
    function tt(it) {
        if (_.has(it)) {
            if (et.has(it))
                throw Error("Not a DAG");
            et.add(it);
            for (let ot of b.get(it).refs)
                tt(ot);
            $.unshift(it),
            et.delete(it),
            _.delete(it)
        }
    }
    for (; _.size > 0; ) {
        const it = Array.from(_)[0];
        tt(it)
    }
    let rt = new Map;
    for (let it = 0; it < $.length; it++)
        rt.set($[it], it);
    let nt = [];
    for (let it of $) {
        const ot = b.get(it);
        nt.push({
            cell: ot.cell,
            refs: ot.refs.map(at=>rt.get(at))
        })
    }
    return nt
}
topologicalSort$1.topologicalSort = topologicalSort;
var bitsForNumber$1 = {};
Object.defineProperty(bitsForNumber$1, "__esModule", {
    value: !0
});
bitsForNumber$1.bitsForNumber = void 0;
function bitsForNumber(d, g) {
    let b = BigInt(d);
    if (g === "int")
        return b === 0n || b === -1n ? 1 : (b > 0 ? b : -b).toString(2).length + 1;
    if (g === "uint") {
        if (b < 0)
            throw Error(`value is negative. Got ${d}`);
        return b.toString(2).length
    } else
        throw Error(`invalid mode. Got ${g}`)
}
bitsForNumber$1.bitsForNumber = bitsForNumber;
var crc32c$1 = {};
Object.defineProperty(crc32c$1, "__esModule", {
    value: !0
});
crc32c$1.crc32c = void 0;
const POLY = 2197175160;
function crc32c(d) {
    let g = -1;
    for (let _ = 0; _ < d.length; _++)
        g ^= d[_],
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1,
        g = g & 1 ? g >>> 1 ^ POLY : g >>> 1;
    g = g ^ 4294967295;
    let b = dist$3.Buffer.alloc(4);
    return b.writeInt32LE(g),
    b
}
crc32c$1.crc32c = crc32c;
var hasRequiredSerialization;
function requireSerialization() {
    if (hasRequiredSerialization)
        return serialization;
    hasRequiredSerialization = 1,
    Object.defineProperty(serialization, "__esModule", {
        value: !0
    }),
    serialization.serializeBoc = serialization.deserializeBoc = serialization.parseBoc = void 0;
    const d = BitReader$1
      , g = requireBitString()
      , b = requireCell()
      , _ = topologicalSort$1
      , $ = bitsForNumber$1
      , et = requireBitBuilder()
      , tt = descriptor$1
      , rt = requirePaddedBits()
      , nt = crc32c$1;
    function it(lt) {
        return ot(lt & 7)
    }
    function ot(lt) {
        let ct = 0;
        for (let ut = 0; ut < 3; ut++)
            ct += lt & 1,
            lt = lt >> 1;
        return ct + 1
    }
    function at(lt, ct) {
        const ut = lt.loadUint(8)
          , pt = ut % 8
          , vt = !!(ut & 8)
          , _t = lt.loadUint(8)
          , Pt = Math.ceil(_t / 2)
          , kt = !!(_t % 2)
          , $t = ut >> 5
          , Wt = (ut & 16) != 0
          , Ht = 32
          , Dt = Wt ? it($t) * Ht : 0
          , Vt = Wt ? it($t) * 2 : 0;
        lt.skip(Dt * 8),
        lt.skip(Vt * 8);
        let Ft = g.BitString.EMPTY;
        Pt > 0 && (kt ? Ft = lt.loadPaddedBits(Pt * 8) : Ft = lt.loadBits(Pt * 8));
        let Kt = [];
        for (let Rt = 0; Rt < pt; Rt++)
            Kt.push(lt.loadUint(ct * 8));
        return {
            bits: Ft,
            refs: Kt,
            exotic: vt
        }
    }
    function st(lt, ct) {
        return 2 + Math.ceil(lt.bits.length / 8) + lt.refs.length * ct
    }
    function dt(lt) {
        let ct = new d.BitReader(new g.BitString(lt,0,lt.length * 8))
          , ut = ct.loadUint(32);
        if (ut === 1761568243) {
            let pt = ct.loadUint(8)
              , vt = ct.loadUint(8)
              , _t = ct.loadUint(pt * 8)
              , Pt = ct.loadUint(pt * 8)
              , kt = ct.loadUint(pt * 8)
              , $t = ct.loadUint(vt * 8)
              , Wt = ct.loadBuffer(_t * vt)
              , Ht = ct.loadBuffer($t);
            return {
                size: pt,
                offBytes: vt,
                cells: _t,
                roots: Pt,
                absent: kt,
                totalCellSize: $t,
                index: Wt,
                cellData: Ht,
                root: [0]
            }
        } else if (ut === 2898503464) {
            let pt = ct.loadUint(8)
              , vt = ct.loadUint(8)
              , _t = ct.loadUint(pt * 8)
              , Pt = ct.loadUint(pt * 8)
              , kt = ct.loadUint(pt * 8)
              , $t = ct.loadUint(vt * 8)
              , Wt = ct.loadBuffer(_t * vt)
              , Ht = ct.loadBuffer($t)
              , Dt = ct.loadBuffer(4);
            if (!(0,
            nt.crc32c)(lt.subarray(0, lt.length - 4)).equals(Dt))
                throw Error("Invalid CRC32C");
            return {
                size: pt,
                offBytes: vt,
                cells: _t,
                roots: Pt,
                absent: kt,
                totalCellSize: $t,
                index: Wt,
                cellData: Ht,
                root: [0]
            }
        } else if (ut === 3052313714) {
            let pt = ct.loadUint(1)
              , vt = ct.loadUint(1);
            ct.loadUint(1),
            ct.loadUint(2);
            let _t = ct.loadUint(3)
              , Pt = ct.loadUint(8)
              , kt = ct.loadUint(_t * 8)
              , $t = ct.loadUint(_t * 8)
              , Wt = ct.loadUint(_t * 8)
              , Ht = ct.loadUint(Pt * 8)
              , Dt = [];
            for (let Kt = 0; Kt < $t; Kt++)
                Dt.push(ct.loadUint(_t * 8));
            let Vt = null;
            pt && (Vt = ct.loadBuffer(kt * Pt));
            let Ft = ct.loadBuffer(Ht);
            if (vt) {
                let Kt = ct.loadBuffer(4);
                if (!(0,
                nt.crc32c)(lt.subarray(0, lt.length - 4)).equals(Kt))
                    throw Error("Invalid CRC32C")
            }
            return {
                size: _t,
                offBytes: Pt,
                cells: kt,
                roots: $t,
                absent: Wt,
                totalCellSize: Ht,
                index: Vt,
                cellData: Ft,
                root: Dt
            }
        } else
            throw Error("Invalid magic")
    }
    serialization.parseBoc = dt;
    function ft(lt) {
        let ct = dt(lt)
          , ut = new d.BitReader(new g.BitString(ct.cellData,0,ct.cellData.length * 8))
          , pt = [];
        for (let _t = 0; _t < ct.cells; _t++) {
            let Pt = at(ut, ct.size);
            pt.push({
                ...Pt,
                result: null
            })
        }
        for (let _t = pt.length - 1; _t >= 0; _t--) {
            if (pt[_t].result)
                throw Error("Impossible");
            let Pt = [];
            for (let kt of pt[_t].refs) {
                if (!pt[kt].result)
                    throw Error("Invalid BOC file");
                Pt.push(pt[kt].result)
            }
            pt[_t].result = new b.Cell({
                bits: pt[_t].bits,
                refs: Pt,
                exotic: pt[_t].exotic
            })
        }
        let vt = [];
        for (let _t = 0; _t < ct.root.length; _t++)
            vt.push(pt[ct.root[_t]].result);
        return vt
    }
    serialization.deserializeBoc = ft;
    function ht(lt, ct, ut, pt) {
        let vt = (0,
        tt.getRefsDescriptor)(lt.refs, lt.level(), lt.type)
          , _t = (0,
        tt.getBitsDescriptor)(lt.bits);
        pt.writeUint(vt, 8),
        pt.writeUint(_t, 8),
        pt.writeBuffer((0,
        rt.bitsToPaddedBuffer)(lt.bits));
        for (let Pt of ct)
            pt.writeUint(Pt, ut * 8)
    }
    function xt(lt, ct) {
        let ut = (0,
        _.topologicalSort)(lt)
          , pt = ut.length
          , vt = ct.idx
          , _t = ct.crc32
          , Pt = !1
          , kt = 0
          , $t = Math.max(Math.ceil((0,
        $.bitsForNumber)(pt, "uint") / 8), 1)
          , Wt = 0
          , Ht = [];
        for (let Rt of ut) {
            let qt = st(Rt.cell, $t);
            Ht.push(Wt),
            Wt += qt
        }
        let Dt = Math.max(Math.ceil((0,
        $.bitsForNumber)(Wt, "uint") / 8), 1)
          , Vt = (4 + 1 + 1 + 3 * $t + Dt + 1 * $t + (vt ? pt * Dt : 0) + Wt + (_t ? 4 : 0)) * 8
          , Ft = new et.BitBuilder(Vt);
        if (Ft.writeUint(3052313714, 32),
        Ft.writeBit(vt),
        Ft.writeBit(_t),
        Ft.writeBit(Pt),
        Ft.writeUint(kt, 2),
        Ft.writeUint($t, 3),
        Ft.writeUint(Dt, 8),
        Ft.writeUint(pt, $t * 8),
        Ft.writeUint(1, $t * 8),
        Ft.writeUint(0, $t * 8),
        Ft.writeUint(Wt, Dt * 8),
        Ft.writeUint(0, $t * 8),
        vt)
            for (let Rt = 0; Rt < pt; Rt++)
                Ft.writeUint(Ht[Rt], Dt * 8);
        for (let Rt = 0; Rt < pt; Rt++)
            ht(ut[Rt].cell, ut[Rt].refs, $t, Ft);
        if (_t) {
            let Rt = (0,
            nt.crc32c)(Ft.buffer());
            Ft.writeBuffer(Rt)
        }
        let Kt = Ft.buffer();
        if (Kt.length !== Vt / 8)
            throw Error("Internal error");
        return Kt
    }
    return serialization.serializeBoc = xt,
    serialization
}
var hasRequiredCell;
function requireCell() {
    if (hasRequiredCell)
        return Cell;
    hasRequiredCell = 1;
    var d = commonjsGlobal && commonjsGlobal.__importDefault || function(st) {
        return st && st.__esModule ? st : {
            default: st
        }
    }
    , g;
    Object.defineProperty(Cell, "__esModule", {
        value: !0
    }),
    Cell.Cell = void 0;
    const b = d(symbol_inspect)
      , _ = requireBitString()
      , $ = CellType
      , et = requireSlice()
      , tt = resolveExotic$1
      , rt = wonderCalculator$1
      , nt = requireSerialization()
      , it = BitReader$1
      , ot = requireBuilder();
    let at = class Au {
        static fromBoc(dt) {
            return (0,
            nt.deserializeBoc)(dt)
        }
        static fromBase64(dt) {
            let ft = Au.fromBoc(dist$3.Buffer.from(dt, "base64"));
            if (ft.length !== 1)
                throw new Error("Deserialized more than one cell");
            return ft[0]
        }
        constructor(dt) {
            this._hashes = [],
            this._depths = [],
            this.beginParse = (pt=!1)=>{
                if (this.isExotic && !pt)
                    throw new Error("Exotic cells cannot be parsed");
                return new et.Slice(new it.BitReader(this.bits),this.refs)
            }
            ,
            this.hash = (pt=3)=>this._hashes[Math.min(this._hashes.length - 1, pt)],
            this.depth = (pt=3)=>this._depths[Math.min(this._depths.length - 1, pt)],
            this.level = ()=>this.mask.level,
            this.equals = pt=>this.hash().equals(pt.hash()),
            this[g] = ()=>this.toString();
            let ft = _.BitString.EMPTY;
            dt && dt.bits && (ft = dt.bits);
            let ht = [];
            dt && dt.refs && (ht = [...dt.refs]);
            let xt, lt, ct, ut = $.CellType.Ordinary;
            if (dt && dt.exotic) {
                let pt = (0,
                tt.resolveExotic)(ft, ht)
                  , vt = (0,
                rt.wonderCalculator)(pt.type, ft, ht);
                ct = vt.mask,
                lt = vt.depths,
                xt = vt.hashes,
                ut = pt.type
            } else {
                if (ht.length > 4)
                    throw new Error("Invalid number of references");
                if (ft.length > 1023)
                    throw new Error(`Bits overflow: ${ft.length} > 1023`);
                let pt = (0,
                rt.wonderCalculator)($.CellType.Ordinary, ft, ht);
                ct = pt.mask,
                lt = pt.depths,
                xt = pt.hashes,
                ut = $.CellType.Ordinary
            }
            this.type = ut,
            this.bits = ft,
            this.refs = ht,
            this.mask = ct,
            this._depths = lt,
            this._hashes = xt,
            Object.freeze(this),
            Object.freeze(this.refs),
            Object.freeze(this.bits),
            Object.freeze(this.mask),
            Object.freeze(this._depths),
            Object.freeze(this._hashes)
        }
        get isExotic() {
            return this.type !== $.CellType.Ordinary
        }
        toBoc(dt) {
            let ft = dt && dt.idx !== null && dt.idx !== void 0 ? dt.idx : !1
              , ht = dt && dt.crc32 !== null && dt.crc32 !== void 0 ? dt.crc32 : !0;
            return (0,
            nt.serializeBoc)(this, {
                idx: ft,
                crc32: ht
            })
        }
        toString(dt) {
            let ft = dt || ""
              , ht = "x";
            this.isExotic && (this.type === $.CellType.MerkleProof ? ht = "p" : this.type === $.CellType.MerkleUpdate ? ht = "u" : this.type === $.CellType.PrunedBranch && (ht = "p"));
            let xt = ft + (this.isExotic ? ht : "x") + "{" + this.bits.toString() + "}";
            for (let lt in this.refs) {
                const ct = this.refs[lt];
                xt += `
` + ct.toString(ft + " ")
            }
            return xt
        }
        asSlice() {
            return this.beginParse()
        }
        asBuilder() {
            return (0,
            ot.beginCell)().storeSlice(this.asSlice())
        }
    }
    ;
    return Cell.Cell = at,
    g = b.default,
    at.EMPTY = new at,
    Cell
}
var hasRequiredBuilder;
function requireBuilder() {
    if (hasRequiredBuilder)
        return Builder;
    hasRequiredBuilder = 1,
    Object.defineProperty(Builder, "__esModule", {
        value: !0
    }),
    Builder.Builder = Builder.beginCell = void 0;
    const d = requireBitBuilder()
      , g = requireCell()
      , b = requireStrings();
    function _() {
        return new $
    }
    Builder.beginCell = _;
    let $ = class Mu {
        constructor() {
            this._bits = new d.BitBuilder,
            this._refs = []
        }
        get bits() {
            return this._bits.length
        }
        get refs() {
            return this._refs.length
        }
        get availableBits() {
            return 1023 - this.bits
        }
        get availableRefs() {
            return 4 - this.refs
        }
        storeBit(tt) {
            return this._bits.writeBit(tt),
            this
        }
        storeBits(tt) {
            return this._bits.writeBits(tt),
            this
        }
        storeBuffer(tt, rt) {
            if (rt != null && tt.length !== rt)
                throw Error(`Buffer length ${tt.length} is not equal to ${rt}`);
            return this._bits.writeBuffer(tt),
            this
        }
        storeMaybeBuffer(tt, rt) {
            return tt !== null ? (this.storeBit(1),
            this.storeBuffer(tt, rt)) : this.storeBit(0),
            this
        }
        storeUint(tt, rt) {
            return this._bits.writeUint(tt, rt),
            this
        }
        storeMaybeUint(tt, rt) {
            return tt != null ? (this.storeBit(1),
            this.storeUint(tt, rt)) : this.storeBit(0),
            this
        }
        storeInt(tt, rt) {
            return this._bits.writeInt(tt, rt),
            this
        }
        storeMaybeInt(tt, rt) {
            return tt != null ? (this.storeBit(1),
            this.storeInt(tt, rt)) : this.storeBit(0),
            this
        }
        storeVarUint(tt, rt) {
            return this._bits.writeVarUint(tt, rt),
            this
        }
        storeMaybeVarUint(tt, rt) {
            return tt != null ? (this.storeBit(1),
            this.storeVarUint(tt, rt)) : this.storeBit(0),
            this
        }
        storeVarInt(tt, rt) {
            return this._bits.writeVarInt(tt, rt),
            this
        }
        storeMaybeVarInt(tt, rt) {
            return tt != null ? (this.storeBit(1),
            this.storeVarInt(tt, rt)) : this.storeBit(0),
            this
        }
        storeCoins(tt) {
            return this._bits.writeCoins(tt),
            this
        }
        storeMaybeCoins(tt) {
            return tt != null ? (this.storeBit(1),
            this.storeCoins(tt)) : this.storeBit(0),
            this
        }
        storeAddress(tt) {
            return this._bits.writeAddress(tt),
            this
        }
        storeRef(tt) {
            if (this._refs.length >= 4)
                throw new Error("Too many references");
            if (tt instanceof g.Cell)
                this._refs.push(tt);
            else if (tt instanceof Mu)
                this._refs.push(tt.endCell());
            else
                throw new Error("Invalid argument");
            return this
        }
        storeMaybeRef(tt) {
            return tt ? (this.storeBit(1),
            this.storeRef(tt)) : this.storeBit(0),
            this
        }
        storeSlice(tt) {
            let rt = tt.clone();
            for (rt.remainingBits > 0 && this.storeBits(rt.loadBits(rt.remainingBits)); rt.remainingRefs > 0; )
                this.storeRef(rt.loadRef());
            return this
        }
        storeMaybeSlice(tt) {
            return tt ? (this.storeBit(1),
            this.storeSlice(tt)) : this.storeBit(0),
            this
        }
        storeBuilder(tt) {
            return this.storeSlice(tt.endCell().beginParse())
        }
        storeMaybeBuilder(tt) {
            return tt ? (this.storeBit(1),
            this.storeBuilder(tt)) : this.storeBit(0),
            this
        }
        storeWritable(tt) {
            return typeof tt == "object" ? tt.writeTo(this) : tt(this),
            this
        }
        storeMaybeWritable(tt) {
            return tt ? (this.storeBit(1),
            this.storeWritable(tt)) : this.storeBit(0),
            this
        }
        store(tt) {
            return this.storeWritable(tt),
            this
        }
        storeStringTail(tt) {
            return (0,
            b.writeString)(tt, this),
            this
        }
        storeMaybeStringTail(tt) {
            return tt != null ? (this.storeBit(1),
            (0,
            b.writeString)(tt, this)) : this.storeBit(0),
            this
        }
        storeStringRefTail(tt) {
            return this.storeRef(_().storeStringTail(tt)),
            this
        }
        storeMaybeStringRefTail(tt) {
            return tt != null ? (this.storeBit(1),
            this.storeStringRefTail(tt)) : this.storeBit(0),
            this
        }
        storeDict(tt, rt, nt) {
            return tt ? tt.store(this, rt, nt) : this.storeBit(0),
            this
        }
        storeDictDirect(tt, rt, nt) {
            return tt.storeDirect(this, rt, nt),
            this
        }
        endCell() {
            return new g.Cell({
                bits: this._bits.build(),
                refs: this._refs
            })
        }
        asCell() {
            return this.endCell()
        }
        asSlice() {
            return this.endCell().beginParse()
        }
    }
    ;
    return Builder.Builder = $,
    Builder
}
var StateInit = {}
  , SimpleLibrary = {};
Object.defineProperty(SimpleLibrary, "__esModule", {
    value: !0
});
SimpleLibrary.SimpleLibraryValue = SimpleLibrary.storeSimpleLibrary = SimpleLibrary.loadSimpleLibrary = void 0;
function loadSimpleLibrary(d) {
    return {
        public: d.loadBit(),
        root: d.loadRef()
    }
}
SimpleLibrary.loadSimpleLibrary = loadSimpleLibrary;
function storeSimpleLibrary(d) {
    return g=>{
        g.storeBit(d.public),
        g.storeRef(d.root)
    }
}
SimpleLibrary.storeSimpleLibrary = storeSimpleLibrary;
SimpleLibrary.SimpleLibraryValue = {
    serialize(d, g) {
        storeSimpleLibrary(d)(g)
    },
    parse(d) {
        return loadSimpleLibrary(d)
    }
};
var TickTock = {};
Object.defineProperty(TickTock, "__esModule", {
    value: !0
});
TickTock.storeTickTock = TickTock.loadTickTock = void 0;
function loadTickTock(d) {
    return {
        tick: d.loadBit(),
        tock: d.loadBit()
    }
}
TickTock.loadTickTock = loadTickTock;
function storeTickTock(d) {
    return g=>{
        g.storeBit(d.tick),
        g.storeBit(d.tock)
    }
}
TickTock.storeTickTock = storeTickTock;
Object.defineProperty(StateInit, "__esModule", {
    value: !0
});
StateInit.storeStateInit = StateInit.loadStateInit = void 0;
const Dictionary_1$2 = requireDictionary()
  , SimpleLibrary_1 = SimpleLibrary
  , TickTock_1 = TickTock;
function loadStateInit(d) {
    let g;
    d.loadBit() && (g = d.loadUint(5));
    let b;
    d.loadBit() && (b = (0,
    TickTock_1.loadTickTock)(d));
    let _ = d.loadMaybeRef()
      , $ = d.loadMaybeRef()
      , et = d.loadDict(Dictionary_1$2.Dictionary.Keys.BigUint(256), SimpleLibrary_1.SimpleLibraryValue);
    return et.size === 0 && (et = void 0),
    {
        splitDepth: g,
        special: b,
        code: _,
        data: $,
        libraries: et
    }
}
StateInit.loadStateInit = loadStateInit;
function storeStateInit(d) {
    return g=>{
        d.splitDepth !== null && d.splitDepth !== void 0 ? (g.storeBit(!0),
        g.storeUint(d.splitDepth, 5)) : g.storeBit(!1),
        d.special !== null && d.special !== void 0 ? (g.storeBit(!0),
        g.store((0,
        TickTock_1.storeTickTock)(d.special))) : g.storeBit(!1),
        g.storeMaybeRef(d.code),
        g.storeMaybeRef(d.data),
        g.storeDict(d.libraries)
    }
}
StateInit.storeStateInit = storeStateInit;
Object.defineProperty(contractAddress$1, "__esModule", {
    value: !0
});
contractAddress$1.contractAddress = void 0;
const Builder_1$8 = requireBuilder()
  , StateInit_1$3 = StateInit
  , Address_1$2 = Address$1;
function contractAddress(d, g) {
    let b = (0,
    Builder_1$8.beginCell)().store((0,
    StateInit_1$3.storeStateInit)(g)).endCell().hash();
    return new Address_1$2.Address(d,b)
}
contractAddress$1.contractAddress = contractAddress;
var tuple = {};
Object.defineProperty(tuple, "__esModule", {
    value: !0
});
tuple.parseTuple = tuple.serializeTuple = void 0;
const Builder_1$7 = requireBuilder()
  , INT64_MIN = BigInt("-9223372036854775808")
  , INT64_MAX = BigInt("9223372036854775807");
function serializeTupleItem(d, g) {
    if (d.type === "null")
        g.storeUint(0, 8);
    else if (d.type === "int")
        d.value <= INT64_MAX && d.value >= INT64_MIN ? (g.storeUint(1, 8),
        g.storeInt(d.value, 64)) : (g.storeUint(256, 15),
        g.storeInt(d.value, 257));
    else if (d.type === "nan")
        g.storeInt(767, 16);
    else if (d.type === "cell")
        g.storeUint(3, 8),
        g.storeRef(d.cell);
    else if (d.type === "slice")
        g.storeUint(4, 8),
        g.storeUint(0, 10),
        g.storeUint(d.cell.bits.length, 10),
        g.storeUint(0, 3),
        g.storeUint(d.cell.refs.length, 3),
        g.storeRef(d.cell);
    else if (d.type === "builder")
        g.storeUint(5, 8),
        g.storeRef(d.cell);
    else if (d.type === "tuple") {
        let b = null
          , _ = null;
        for (let $ = 0; $ < d.items.length; $++) {
            let et = b;
            b = _,
            _ = et,
            $ > 1 && (b = (0,
            Builder_1$7.beginCell)().storeRef(_).storeRef(b).endCell());
            let tt = (0,
            Builder_1$7.beginCell)();
            serializeTupleItem(d.items[$], tt),
            _ = tt.endCell()
        }
        g.storeUint(7, 8),
        g.storeUint(d.items.length, 16),
        b && g.storeRef(b),
        _ && g.storeRef(_)
    } else
        throw Error("Invalid value")
}
function parseStackItem(d) {
    let g = d.loadUint(8);
    if (g === 0)
        return {
            type: "null"
        };
    if (g === 1)
        return {
            type: "int",
            value: d.loadIntBig(64)
        };
    if (g === 2)
        return d.loadUint(7) === 0 ? {
            type: "int",
            value: d.loadIntBig(257)
        } : (d.loadBit(),
        {
            type: "nan"
        });
    if (g === 3)
        return {
            type: "cell",
            cell: d.loadRef()
        };
    if (g === 4) {
        let b = d.loadUint(10)
          , _ = d.loadUint(10)
          , $ = d.loadUint(3)
          , et = d.loadUint(3)
          , tt = d.loadRef().beginParse();
        tt.skip(b);
        let rt = tt.loadBits(_ - b)
          , nt = (0,
        Builder_1$7.beginCell)().storeBits(rt);
        if ($ < et) {
            for (let it = 0; it < $; it++)
                tt.loadRef();
            for (let it = 0; it < et - $; it++)
                nt.storeRef(tt.loadRef())
        }
        return {
            type: "slice",
            cell: nt.endCell()
        }
    } else {
        if (g === 5)
            return {
                type: "builder",
                cell: d.loadRef()
            };
        if (g === 7) {
            let b = d.loadUint(16)
              , _ = [];
            if (b > 1) {
                let $ = d.loadRef().beginParse()
                  , et = d.loadRef().beginParse();
                _.unshift(parseStackItem(et));
                for (let tt = 0; tt < b - 2; tt++) {
                    let rt = $;
                    $ = rt.loadRef().beginParse(),
                    et = rt.loadRef().beginParse(),
                    _.unshift(parseStackItem(et))
                }
                _.unshift(parseStackItem($))
            } else
                b === 1 && _.push(parseStackItem(d.loadRef().beginParse()));
            return {
                type: "tuple",
                items: _
            }
        } else
            throw Error("Unsupported stack item")
    }
}
function serializeTupleTail(d, g) {
    if (d.length > 0) {
        let b = (0,
        Builder_1$7.beginCell)();
        serializeTupleTail(d.slice(0, d.length - 1), b),
        g.storeRef(b.endCell()),
        serializeTupleItem(d[d.length - 1], g)
    }
}
function serializeTuple(d) {
    let g = (0,
    Builder_1$7.beginCell)();
    g.storeUint(d.length, 24);
    let b = [...d];
    return serializeTupleTail(b, g),
    g.endCell()
}
tuple.serializeTuple = serializeTuple;
function parseTuple(d) {
    let g = []
      , b = d.beginParse()
      , _ = b.loadUint(24);
    for (let $ = 0; $ < _; $++) {
        let et = b.loadRef();
        g.unshift(parseStackItem(b)),
        b = et.beginParse()
    }
    return g
}
tuple.parseTuple = parseTuple;
var reader = {};
Object.defineProperty(reader, "__esModule", {
    value: !0
});
reader.TupleReader = void 0;
class TupleReader {
    constructor(g) {
        this.items = [...g]
    }
    get remaining() {
        return this.items.length
    }
    peek() {
        if (this.items.length === 0)
            throw Error("EOF");
        return this.items[0]
    }
    pop() {
        if (this.items.length === 0)
            throw Error("EOF");
        let g = this.items[0];
        return this.items.splice(0, 1),
        g
    }
    skip(g=1) {
        for (let b = 0; b < g; b++)
            this.pop();
        return this
    }
    readBigNumber() {
        let g = this.pop();
        if (g.type !== "int")
            throw Error("Not a number");
        return g.value
    }
    readBigNumberOpt() {
        let g = this.pop();
        if (g.type === "null")
            return null;
        if (g.type !== "int")
            throw Error("Not a number");
        return g.value
    }
    readNumber() {
        return Number(this.readBigNumber())
    }
    readNumberOpt() {
        let g = this.readBigNumberOpt();
        return g !== null ? Number(g) : null
    }
    readBoolean() {
        return this.readNumber() !== 0
    }
    readBooleanOpt() {
        let g = this.readNumberOpt();
        return g !== null ? g !== 0 : null
    }
    readAddress() {
        let g = this.readCell().beginParse().loadAddress();
        if (g !== null)
            return g;
        throw Error("Not an address")
    }
    readAddressOpt() {
        let g = this.readCellOpt();
        return g !== null ? g.beginParse().loadMaybeAddress() : null
    }
    readCell() {
        let g = this.pop();
        if (g.type !== "cell" && g.type !== "slice" && g.type !== "builder")
            throw Error("Not a cell: " + g.type);
        return g.cell
    }
    readCellOpt() {
        let g = this.pop();
        if (g.type === "null")
            return null;
        if (g.type !== "cell" && g.type !== "slice" && g.type !== "builder")
            throw Error("Not a cell");
        return g.cell
    }
    readTuple() {
        let g = this.pop();
        if (g.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(g.items)
    }
    readTupleOpt() {
        let g = this.pop();
        if (g.type === "null")
            return null;
        if (g.type !== "tuple")
            throw Error("Not a tuple");
        return new TupleReader(g.items)
    }
    static readLispList(g) {
        const b = [];
        let _ = g;
        for (; _ !== null; ) {
            var $ = _.pop();
            if (_.items.length === 0 || _.items[0].type !== "tuple" && _.items[0].type !== "null")
                throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
            _ = _.readTupleOpt(),
            b.push($)
        }
        return b
    }
    readLispListDirect() {
        return this.items.length === 1 && this.items[0].type === "null" ? [] : TupleReader.readLispList(this)
    }
    readLispList() {
        return TupleReader.readLispList(this.readTupleOpt())
    }
    readBuffer() {
        let g = this.readCell().beginParse();
        if (g.remainingRefs !== 0 || g.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return g.loadBuffer(g.remainingBits / 8)
    }
    readBufferOpt() {
        if (this.peek().type === "null")
            return null;
        let b = this.readCell().beginParse();
        if (b.remainingRefs !== 0 || b.remainingBits % 8 !== 0)
            throw Error("Not a buffer");
        return b.loadBuffer(b.remainingBits / 8)
    }
    readString() {
        return this.readCell().beginParse().loadStringTail()
    }
    readStringOpt() {
        return this.peek().type === "null" ? null : this.readCell().beginParse().loadStringTail()
    }
}
reader.TupleReader = TupleReader;
var builder = {};
Object.defineProperty(builder, "__esModule", {
    value: !0
});
builder.TupleBuilder = void 0;
const Builder_1$6 = requireBuilder()
  , Cell_1$2 = requireCell()
  , Slice_1 = requireSlice();
class TupleBuilder {
    constructor() {
        this._tuple = []
    }
    writeNumber(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: BigInt(g)
        })
    }
    writeBoolean(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "int",
            value: g ? -1n : 0n
        })
    }
    writeBuffer(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeBuffer(g).endCell()
        })
    }
    writeString(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeStringTail(g).endCell()
        })
    }
    writeCell(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : g instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "cell",
            cell: g
        }) : g instanceof Slice_1.Slice && this._tuple.push({
            type: "cell",
            cell: g.asCell()
        })
    }
    writeSlice(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : g instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "slice",
            cell: g
        }) : g instanceof Slice_1.Slice && this._tuple.push({
            type: "slice",
            cell: g.asCell()
        })
    }
    writeBuilder(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : g instanceof Cell_1$2.Cell ? this._tuple.push({
            type: "builder",
            cell: g
        }) : g instanceof Slice_1.Slice && this._tuple.push({
            type: "builder",
            cell: g.asCell()
        })
    }
    writeTuple(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "tuple",
            items: g
        })
    }
    writeAddress(g) {
        g == null ? this._tuple.push({
            type: "null"
        }) : this._tuple.push({
            type: "slice",
            cell: (0,
            Builder_1$6.beginCell)().storeAddress(g).endCell()
        })
    }
    build() {
        return [...this._tuple]
    }
}
builder.TupleBuilder = TupleBuilder;
var _export$1 = {}
  , _helpers = {}
  , convert = {};
Object.defineProperty(convert, "__esModule", {
    value: !0
});
convert.fromNano = convert.toNano = void 0;
function toNano(d) {
    if (typeof d == "bigint")
        return d * 1000000000n;
    {
        if (typeof d == "number") {
            if (!Number.isFinite(d))
                throw Error("Invalid number");
            if (Math.log10(d) <= 6)
                d = d.toLocaleString("en", {
                    minimumFractionDigits: 9,
                    useGrouping: !1
                });
            else if (d - Math.trunc(d) === 0)
                d = d.toLocaleString("en", {
                    maximumFractionDigits: 0,
                    useGrouping: !1
                });
            else
                throw Error("Not enough precision for a number value. Use string value instead")
        }
        let g = !1;
        for (; d.startsWith("-"); )
            g = !g,
            d = d.slice(1);
        if (d === ".")
            throw Error("Invalid number");
        let b = d.split(".");
        if (b.length > 2)
            throw Error("Invalid number");
        let _ = b[0]
          , $ = b[1];
        if (_ || (_ = "0"),
        $ || ($ = "0"),
        $.length > 9)
            throw Error("Invalid number");
        for (; $.length < 9; )
            $ += "0";
        let et = BigInt(_) * 1000000000n + BigInt($);
        return g && (et = -et),
        et
    }
}
convert.toNano = toNano;
function fromNano(d) {
    let g = BigInt(d)
      , b = !1;
    g < 0 && (b = !0,
    g = -g);
    let $ = (g % 1000000000n).toString();
    for (; $.length < 9; )
        $ = "0" + $;
    $ = $.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    let rt = `${(g / 1000000000n).toString()}${$ === "0" ? "" : `.${$}`}`;
    return b && (rt = "-" + rt),
    rt
}
convert.fromNano = fromNano;
Object.defineProperty(_helpers, "__esModule", {
    value: !0
});
_helpers.comment = _helpers.external = _helpers.internal = void 0;
const Address_1$1 = Address$1
  , Cell_1$1 = requireCell()
  , Builder_1$5 = requireBuilder()
  , convert_1 = convert;
function internal(d) {
    let g = !0;
    d.bounce !== null && d.bounce !== void 0 && (g = d.bounce);
    let b;
    if (typeof d.to == "string")
        b = Address_1$1.Address.parse(d.to);
    else if (Address_1$1.Address.isAddress(d.to))
        b = d.to;
    else
        throw new Error(`Invalid address ${d.to}`);
    let _;
    typeof d.value == "string" ? _ = (0,
    convert_1.toNano)(d.value) : _ = d.value;
    let $ = Cell_1$1.Cell.EMPTY;
    return typeof d.body == "string" ? $ = (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(d.body).endCell() : d.body && ($ = d.body),
    {
        info: {
            type: "internal",
            dest: b,
            value: {
                coins: _
            },
            bounce: g,
            ihrDisabled: !0,
            bounced: !1,
            ihrFee: 0n,
            forwardFee: 0n,
            createdAt: 0,
            createdLt: 0n
        },
        init: d.init ? {
            code: d.init.code,
            data: d.init.data
        } : void 0,
        body: $
    }
}
_helpers.internal = internal;
function external(d) {
    let g;
    if (typeof d.to == "string")
        g = Address_1$1.Address.parse(d.to);
    else if (Address_1$1.Address.isAddress(d.to))
        g = d.to;
    else
        throw new Error(`Invalid address ${d.to}`);
    return {
        info: {
            type: "external-in",
            dest: g,
            importFee: 0n
        },
        init: d.init ? {
            code: d.init.code,
            data: d.init.data
        } : void 0,
        body: d.body || Cell_1$1.Cell.EMPTY
    }
}
_helpers.external = external;
function comment(d) {
    return (0,
    Builder_1$5.beginCell)().storeUint(0, 32).storeStringTail(d).endCell()
}
_helpers.comment = comment;
var Account = {}
  , AccountStorage = {}
  , AccountState = {};
Object.defineProperty(AccountState, "__esModule", {
    value: !0
});
AccountState.storeAccountState = AccountState.loadAccountState = void 0;
const StateInit_1$2 = StateInit;
function loadAccountState(d) {
    return d.loadBit() ? {
        type: "active",
        state: (0,
        StateInit_1$2.loadStateInit)(d)
    } : d.loadBit() ? {
        type: "frozen",
        stateHash: d.loadUintBig(256)
    } : {
        type: "uninit"
    }
}
AccountState.loadAccountState = loadAccountState;
function storeAccountState(d) {
    return g=>{
        d.type === "active" ? (g.storeBit(!0),
        g.store((0,
        StateInit_1$2.storeStateInit)(d.state))) : d.type === "frozen" ? (g.storeBit(!1),
        g.storeBit(!0),
        g.storeUint(d.stateHash, 256)) : d.type === "uninit" && (g.storeBit(!1),
        g.storeBit(!1))
    }
}
AccountState.storeAccountState = storeAccountState;
var CurrencyCollection = {};
Object.defineProperty(CurrencyCollection, "__esModule", {
    value: !0
});
CurrencyCollection.storeCurrencyCollection = CurrencyCollection.loadCurrencyCollection = void 0;
const Dictionary_1$1 = requireDictionary();
function loadCurrencyCollection(d) {
    const g = d.loadCoins()
      , b = d.loadDict(Dictionary_1$1.Dictionary.Keys.Uint(32), Dictionary_1$1.Dictionary.Values.BigVarUint(5));
    return b.size === 0 ? {
        coins: g
    } : {
        other: b,
        coins: g
    }
}
CurrencyCollection.loadCurrencyCollection = loadCurrencyCollection;
function storeCurrencyCollection(d) {
    return g=>{
        g.storeCoins(d.coins),
        d.other ? g.storeDict(d.other) : g.storeBit(0)
    }
}
CurrencyCollection.storeCurrencyCollection = storeCurrencyCollection;
Object.defineProperty(AccountStorage, "__esModule", {
    value: !0
});
AccountStorage.storeAccountStorage = AccountStorage.loadAccountStorage = void 0;
const AccountState_1 = AccountState
  , CurrencyCollection_1$5 = CurrencyCollection;
function loadAccountStorage(d) {
    return {
        lastTransLt: d.loadUintBig(64),
        balance: (0,
        CurrencyCollection_1$5.loadCurrencyCollection)(d),
        state: (0,
        AccountState_1.loadAccountState)(d)
    }
}
AccountStorage.loadAccountStorage = loadAccountStorage;
function storeAccountStorage(d) {
    return g=>{
        g.storeUint(d.lastTransLt, 64),
        g.store((0,
        CurrencyCollection_1$5.storeCurrencyCollection)(d.balance)),
        g.store((0,
        AccountState_1.storeAccountState)(d.state))
    }
}
AccountStorage.storeAccountStorage = storeAccountStorage;
var StorageInto = {}
  , StorageUsed = {};
Object.defineProperty(StorageUsed, "__esModule", {
    value: !0
});
StorageUsed.storeStorageUsed = StorageUsed.loadStorageUsed = void 0;
function loadStorageUsed(d) {
    return {
        cells: d.loadVarUintBig(3),
        bits: d.loadVarUintBig(3),
        publicCells: d.loadVarUintBig(3)
    }
}
StorageUsed.loadStorageUsed = loadStorageUsed;
function storeStorageUsed(d) {
    return g=>{
        g.storeVarUint(d.cells, 3),
        g.storeVarUint(d.bits, 3),
        g.storeVarUint(d.publicCells, 3)
    }
}
StorageUsed.storeStorageUsed = storeStorageUsed;
Object.defineProperty(StorageInto, "__esModule", {
    value: !0
});
StorageInto.storeStorageInfo = StorageInto.loadStorageInfo = void 0;
const StorageUsed_1 = StorageUsed;
function loadStorageInfo(d) {
    return {
        used: (0,
        StorageUsed_1.loadStorageUsed)(d),
        lastPaid: d.loadUint(32),
        duePayment: d.loadMaybeCoins()
    }
}
StorageInto.loadStorageInfo = loadStorageInfo;
function storeStorageInfo(d) {
    return g=>{
        g.store((0,
        StorageUsed_1.storeStorageUsed)(d.used)),
        g.storeUint(d.lastPaid, 32),
        g.storeMaybeCoins(d.duePayment)
    }
}
StorageInto.storeStorageInfo = storeStorageInfo;
Object.defineProperty(Account, "__esModule", {
    value: !0
});
Account.storeAccount = Account.loadAccount = void 0;
const AccountStorage_1 = AccountStorage
  , StorageInto_1 = StorageInto;
function loadAccount(d) {
    return {
        addr: d.loadAddress(),
        storageStats: (0,
        StorageInto_1.loadStorageInfo)(d),
        storage: (0,
        AccountStorage_1.loadAccountStorage)(d)
    }
}
Account.loadAccount = loadAccount;
function storeAccount(d) {
    return g=>{
        g.storeAddress(d.addr),
        g.store((0,
        StorageInto_1.storeStorageInfo)(d.storageStats)),
        g.store((0,
        AccountStorage_1.storeAccountStorage)(d.storage))
    }
}
Account.storeAccount = storeAccount;
var AccountStatus = {};
Object.defineProperty(AccountStatus, "__esModule", {
    value: !0
});
AccountStatus.storeAccountStatus = AccountStatus.loadAccountStatus = void 0;
function loadAccountStatus(d) {
    const g = d.loadUint(2);
    if (g === 0)
        return "uninitialized";
    if (g === 1)
        return "frozen";
    if (g === 2)
        return "active";
    if (g === 3)
        return "non-existing";
    throw Error("Invalid data")
}
AccountStatus.loadAccountStatus = loadAccountStatus;
function storeAccountStatus(d) {
    return g=>{
        if (d === "uninitialized")
            g.storeUint(0, 2);
        else if (d === "frozen")
            g.storeUint(1, 2);
        else if (d === "active")
            g.storeUint(2, 2);
        else if (d === "non-existing")
            g.storeUint(3, 2);
        else
            throw Error("Invalid data");
        return g
    }
}
AccountStatus.storeAccountStatus = storeAccountStatus;
var AccountStatusChange = {};
Object.defineProperty(AccountStatusChange, "__esModule", {
    value: !0
});
AccountStatusChange.storeAccountStatusChange = AccountStatusChange.loadAccountStatusChange = void 0;
function loadAccountStatusChange(d) {
    return d.loadBit() ? d.loadBit() ? "frozen" : "deleted" : "unchanged"
}
AccountStatusChange.loadAccountStatusChange = loadAccountStatusChange;
function storeAccountStatusChange(d) {
    return g=>{
        if (d == "unchanged")
            g.storeBit(0);
        else if (d === "frozen")
            g.storeBit(1),
            g.storeBit(0);
        else if (d === "deleted")
            g.storeBit(1),
            g.storeBit(1);
        else
            throw Error("Invalid account status change")
    }
}
AccountStatusChange.storeAccountStatusChange = storeAccountStatusChange;
var OutList = {}
  , MessageRelaxed = {}
  , CommonMessageInfoRelaxed = {};
Object.defineProperty(CommonMessageInfoRelaxed, "__esModule", {
    value: !0
});
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = void 0;
const CurrencyCollection_1$4 = CurrencyCollection;
function loadCommonMessageInfoRelaxed(d) {
    if (!d.loadBit()) {
        const et = d.loadBit()
          , tt = d.loadBit()
          , rt = d.loadBit()
          , nt = d.loadMaybeAddress()
          , it = d.loadAddress()
          , ot = (0,
        CurrencyCollection_1$4.loadCurrencyCollection)(d)
          , at = d.loadCoins()
          , st = d.loadCoins()
          , dt = d.loadUintBig(64)
          , ft = d.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: et,
            bounce: tt,
            bounced: rt,
            src: nt,
            dest: it,
            value: ot,
            ihrFee: at,
            forwardFee: st,
            createdLt: dt,
            createdAt: ft
        }
    }
    if (!d.loadBit())
        throw Error("External In message is not possible for CommonMessageInfoRelaxed");
    const g = d.loadMaybeAddress()
      , b = d.loadMaybeExternalAddress()
      , _ = d.loadUintBig(64)
      , $ = d.loadUint(32);
    return {
        type: "external-out",
        src: g,
        dest: b,
        createdLt: _,
        createdAt: $
    }
}
CommonMessageInfoRelaxed.loadCommonMessageInfoRelaxed = loadCommonMessageInfoRelaxed;
function storeCommonMessageInfoRelaxed(d) {
    return g=>{
        if (d.type === "internal")
            g.storeBit(0),
            g.storeBit(d.ihrDisabled),
            g.storeBit(d.bounce),
            g.storeBit(d.bounced),
            g.storeAddress(d.src),
            g.storeAddress(d.dest),
            g.store((0,
            CurrencyCollection_1$4.storeCurrencyCollection)(d.value)),
            g.storeCoins(d.ihrFee),
            g.storeCoins(d.forwardFee),
            g.storeUint(d.createdLt, 64),
            g.storeUint(d.createdAt, 32);
        else if (d.type === "external-out")
            g.storeBit(1),
            g.storeBit(1),
            g.storeAddress(d.src),
            g.storeAddress(d.dest),
            g.storeUint(d.createdLt, 64),
            g.storeUint(d.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfoRelaxed.storeCommonMessageInfoRelaxed = storeCommonMessageInfoRelaxed;
Object.defineProperty(MessageRelaxed, "__esModule", {
    value: !0
});
MessageRelaxed.storeMessageRelaxed = MessageRelaxed.loadMessageRelaxed = void 0;
const Builder_1$4 = requireBuilder()
  , CommonMessageInfoRelaxed_1 = CommonMessageInfoRelaxed
  , StateInit_1$1 = StateInit;
function loadMessageRelaxed(d) {
    const g = (0,
    CommonMessageInfoRelaxed_1.loadCommonMessageInfoRelaxed)(d);
    let b = null;
    d.loadBit() && (d.loadBit() ? b = (0,
    StateInit_1$1.loadStateInit)(d.loadRef().beginParse()) : b = (0,
    StateInit_1$1.loadStateInit)(d));
    const _ = d.loadBit() ? d.loadRef() : d.asCell();
    return {
        info: g,
        init: b,
        body: _
    }
}
MessageRelaxed.loadMessageRelaxed = loadMessageRelaxed;
function storeMessageRelaxed(d, g) {
    return b=>{
        if (b.store((0,
        CommonMessageInfoRelaxed_1.storeCommonMessageInfoRelaxed)(d.info)),
        d.init) {
            b.storeBit(!0);
            let $ = (0,
            Builder_1$4.beginCell)().store((0,
            StateInit_1$1.storeStateInit)(d.init))
              , et = !1;
            g && g.forceRef ? et = !0 : b.availableBits - 2 >= $.bits ? et = !1 : et = !0,
            et ? (b.storeBit(!0),
            b.storeRef($)) : (b.storeBit(!1),
            b.storeBuilder($))
        } else
            b.storeBit(!1);
        let _ = !1;
        g && g.forceRef ? _ = !0 : b.availableBits - 1 >= d.body.bits.length && b.refs + d.body.refs.length <= 4 ? _ = !1 : _ = !0,
        _ ? (b.storeBit(!0),
        b.storeRef(d.body)) : (b.storeBit(!1),
        b.storeBuilder(d.body.asBuilder()))
    }
}
MessageRelaxed.storeMessageRelaxed = storeMessageRelaxed;
Object.defineProperty(OutList, "__esModule", {
    value: !0
});
OutList.loadOutList = OutList.storeOutList = OutList.loadOutAction = OutList.storeOutAction = void 0;
const MessageRelaxed_1 = MessageRelaxed
  , Builder_1$3 = requireBuilder();
function storeOutAction(d) {
    switch (d.type) {
    case "sendMsg":
        return storeOutActionSendMsg(d);
    case "setCode":
        return storeOutActionSetCode(d);
    default:
        throw new Error(`Unknown action type ${d.type}`)
    }
}
OutList.storeOutAction = storeOutAction;
const outActionSendMsgTag = 247711853;
function storeOutActionSendMsg(d) {
    return g=>{
        g.storeUint(outActionSendMsgTag, 32).storeUint(d.mode, 8).storeRef((0,
        Builder_1$3.beginCell)().store((0,
        MessageRelaxed_1.storeMessageRelaxed)(d.outMsg)).endCell())
    }
}
const outActionSetCodeTag = 2907562126;
function storeOutActionSetCode(d) {
    return g=>{
        g.storeUint(outActionSetCodeTag, 32).storeRef(d.newCode)
    }
}
function loadOutAction(d) {
    const g = d.loadUint(32);
    if (g === outActionSendMsgTag) {
        const b = d.loadUint(8)
          , _ = (0,
        MessageRelaxed_1.loadMessageRelaxed)(d.loadRef().beginParse());
        return {
            type: "sendMsg",
            mode: b,
            outMsg: _
        }
    }
    if (g === outActionSetCodeTag)
        return {
            type: "setCode",
            newCode: d.loadRef()
        };
    throw new Error(`Unknown out action tag 0x${g.toString(16)}`)
}
OutList.loadOutAction = loadOutAction;
function storeOutList(d) {
    const g = d.reduce((b,_)=>(0,
    Builder_1$3.beginCell)().storeRef(b).store(storeOutAction(_)).endCell(), (0,
    Builder_1$3.beginCell)().endCell());
    return b=>{
        b.storeSlice(g.beginParse())
    }
}
OutList.storeOutList = storeOutList;
function loadOutList(d) {
    const g = [];
    for (; d.remainingRefs; ) {
        const b = d.loadRef();
        g.push(loadOutAction(d)),
        d = b.beginParse()
    }
    return g.reverse()
}
OutList.loadOutList = loadOutList;
var CommonMessageInfo = {};
Object.defineProperty(CommonMessageInfo, "__esModule", {
    value: !0
});
CommonMessageInfo.storeCommonMessageInfo = CommonMessageInfo.loadCommonMessageInfo = void 0;
const CurrencyCollection_1$3 = CurrencyCollection;
function loadCommonMessageInfo(d) {
    if (!d.loadBit()) {
        const et = d.loadBit()
          , tt = d.loadBit()
          , rt = d.loadBit()
          , nt = d.loadAddress()
          , it = d.loadAddress()
          , ot = (0,
        CurrencyCollection_1$3.loadCurrencyCollection)(d)
          , at = d.loadCoins()
          , st = d.loadCoins()
          , dt = d.loadUintBig(64)
          , ft = d.loadUint(32);
        return {
            type: "internal",
            ihrDisabled: et,
            bounce: tt,
            bounced: rt,
            src: nt,
            dest: it,
            value: ot,
            ihrFee: at,
            forwardFee: st,
            createdLt: dt,
            createdAt: ft
        }
    }
    if (!d.loadBit()) {
        const et = d.loadMaybeExternalAddress()
          , tt = d.loadAddress()
          , rt = d.loadCoins();
        return {
            type: "external-in",
            src: et,
            dest: tt,
            importFee: rt
        }
    }
    const g = d.loadAddress()
      , b = d.loadMaybeExternalAddress()
      , _ = d.loadUintBig(64)
      , $ = d.loadUint(32);
    return {
        type: "external-out",
        src: g,
        dest: b,
        createdLt: _,
        createdAt: $
    }
}
CommonMessageInfo.loadCommonMessageInfo = loadCommonMessageInfo;
function storeCommonMessageInfo(d) {
    return g=>{
        if (d.type === "internal")
            g.storeBit(0),
            g.storeBit(d.ihrDisabled),
            g.storeBit(d.bounce),
            g.storeBit(d.bounced),
            g.storeAddress(d.src),
            g.storeAddress(d.dest),
            g.store((0,
            CurrencyCollection_1$3.storeCurrencyCollection)(d.value)),
            g.storeCoins(d.ihrFee),
            g.storeCoins(d.forwardFee),
            g.storeUint(d.createdLt, 64),
            g.storeUint(d.createdAt, 32);
        else if (d.type === "external-in")
            g.storeBit(1),
            g.storeBit(0),
            g.storeAddress(d.src),
            g.storeAddress(d.dest),
            g.storeCoins(d.importFee);
        else if (d.type === "external-out")
            g.storeBit(1),
            g.storeBit(1),
            g.storeAddress(d.src),
            g.storeAddress(d.dest),
            g.storeUint(d.createdLt, 64),
            g.storeUint(d.createdAt, 32);
        else
            throw new Error("Unknown CommonMessageInfo type")
    }
}
CommonMessageInfo.storeCommonMessageInfo = storeCommonMessageInfo;
var ComputeSkipReason = {};
Object.defineProperty(ComputeSkipReason, "__esModule", {
    value: !0
});
ComputeSkipReason.storeComputeSkipReason = ComputeSkipReason.loadComputeSkipReason = void 0;
function loadComputeSkipReason(d) {
    let g = d.loadUint(2);
    if (g === 0)
        return "no-state";
    if (g === 1)
        return "bad-state";
    if (g === 2)
        return "no-gas";
    throw new Error(`Unknown ComputeSkipReason: ${g}`)
}
ComputeSkipReason.loadComputeSkipReason = loadComputeSkipReason;
function storeComputeSkipReason(d) {
    return g=>{
        if (d === "no-state")
            g.storeUint(0, 2);
        else if (d === "bad-state")
            g.storeUint(1, 2);
        else if (d === "no-gas")
            g.storeUint(2, 2);
        else
            throw new Error(`Unknown ComputeSkipReason: ${d}`)
    }
}
ComputeSkipReason.storeComputeSkipReason = storeComputeSkipReason;
var DepthBalanceInfo = {};
Object.defineProperty(DepthBalanceInfo, "__esModule", {
    value: !0
});
DepthBalanceInfo.storeDepthBalanceInfo = DepthBalanceInfo.loadDepthBalanceInfo = void 0;
const CurrencyCollection_1$2 = CurrencyCollection;
function loadDepthBalanceInfo(d) {
    return {
        splitDepth: d.loadUint(5),
        balance: (0,
        CurrencyCollection_1$2.loadCurrencyCollection)(d)
    }
}
DepthBalanceInfo.loadDepthBalanceInfo = loadDepthBalanceInfo;
function storeDepthBalanceInfo(d) {
    return g=>{
        g.storeUint(d.splitDepth, 5),
        g.store((0,
        CurrencyCollection_1$2.storeCurrencyCollection)(d.balance))
    }
}
DepthBalanceInfo.storeDepthBalanceInfo = storeDepthBalanceInfo;
var HashUpdate = {};
Object.defineProperty(HashUpdate, "__esModule", {
    value: !0
});
HashUpdate.storeHashUpdate = HashUpdate.loadHashUpdate = void 0;
function loadHashUpdate(d) {
    if (d.loadUint(8) !== 114)
        throw Error("Invalid data");
    const g = d.loadBuffer(32)
      , b = d.loadBuffer(32);
    return {
        oldHash: g,
        newHash: b
    }
}
HashUpdate.loadHashUpdate = loadHashUpdate;
function storeHashUpdate(d) {
    return g=>{
        g.storeUint(114, 8),
        g.storeBuffer(d.oldHash),
        g.storeBuffer(d.newHash)
    }
}
HashUpdate.storeHashUpdate = storeHashUpdate;
var MasterchainStateExtra = {};
Object.defineProperty(MasterchainStateExtra, "__esModule", {
    value: !0
});
MasterchainStateExtra.loadMasterchainStateExtra = void 0;
const Dictionary_1 = requireDictionary()
  , CurrencyCollection_1$1 = CurrencyCollection;
function loadMasterchainStateExtra(d) {
    if (d.loadUint(16) !== 52262)
        throw Error("Invalid data");
    d.loadBit() && d.loadRef();
    let g = d.loadUintBig(256)
      , b = Dictionary_1.Dictionary.load(Dictionary_1.Dictionary.Keys.Int(32), Dictionary_1.Dictionary.Values.Cell(), d);
    const _ = (0,
    CurrencyCollection_1$1.loadCurrencyCollection)(d);
    return {
        config: b,
        configAddress: g,
        globalBalance: _
    }
}
MasterchainStateExtra.loadMasterchainStateExtra = loadMasterchainStateExtra;
var Message = {};
Object.defineProperty(Message, "__esModule", {
    value: !0
});
Message.MessageValue = Message.storeMessage = Message.loadMessage = void 0;
const Builder_1$2 = requireBuilder()
  , CommonMessageInfo_1 = CommonMessageInfo
  , StateInit_1 = StateInit;
function loadMessage(d) {
    const g = (0,
    CommonMessageInfo_1.loadCommonMessageInfo)(d);
    let b = null;
    d.loadBit() && (d.loadBit() ? b = (0,
    StateInit_1.loadStateInit)(d.loadRef().beginParse()) : b = (0,
    StateInit_1.loadStateInit)(d));
    const _ = d.loadBit() ? d.loadRef() : d.asCell();
    return {
        info: g,
        init: b,
        body: _
    }
}
Message.loadMessage = loadMessage;
function storeMessage(d, g) {
    return b=>{
        if (b.store((0,
        CommonMessageInfo_1.storeCommonMessageInfo)(d.info)),
        d.init) {
            b.storeBit(!0);
            let $ = (0,
            Builder_1$2.beginCell)().store((0,
            StateInit_1.storeStateInit)(d.init))
              , et = !1;
            g && g.forceRef ? et = !0 : b.availableBits - 2 >= $.bits ? et = !1 : et = !0,
            et ? (b.storeBit(!0),
            b.storeRef($)) : (b.storeBit(!1),
            b.storeBuilder($))
        } else
            b.storeBit(!1);
        let _ = !1;
        g && g.forceRef ? _ = !0 : b.availableBits - 1 >= d.body.bits.length && b.refs + d.body.refs.length <= 4 ? _ = !1 : _ = !0,
        _ ? (b.storeBit(!0),
        b.storeRef(d.body)) : (b.storeBit(!1),
        b.storeBuilder(d.body.asBuilder()))
    }
}
Message.storeMessage = storeMessage;
Message.MessageValue = {
    serialize(d, g) {
        g.storeRef((0,
        Builder_1$2.beginCell)().store(storeMessage(d)))
    },
    parse(d) {
        return loadMessage(d.loadRef().beginParse())
    }
};
var SendMode = {};
(function(d) {
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.SendMode = void 0,
    function(g) {
        g[g.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE",
        g[g.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE",
        g[g.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO",
        g[g.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY",
        g[g.IGNORE_ERRORS = 2] = "IGNORE_ERRORS",
        g[g.NONE = 0] = "NONE"
    }(d.SendMode || (d.SendMode = {}))
}
)(SendMode);
var ShardAccount = {};
Object.defineProperty(ShardAccount, "__esModule", {
    value: !0
});
ShardAccount.storeShardAccount = ShardAccount.loadShardAccount = void 0;
const Builder_1$1 = requireBuilder()
  , Account_1 = Account;
function loadShardAccount(d) {
    let g = d.loadRef(), b;
    if (!g.isExotic) {
        let _ = g.beginParse();
        _.loadBit() && (b = (0,
        Account_1.loadAccount)(_))
    }
    return {
        account: b,
        lastTransactionHash: d.loadUintBig(256),
        lastTransactionLt: d.loadUintBig(64)
    }
}
ShardAccount.loadShardAccount = loadShardAccount;
function storeShardAccount(d) {
    return g=>{
        d.account ? g.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!0).store((0,
        Account_1.storeAccount)(d.account))) : g.storeRef((0,
        Builder_1$1.beginCell)().storeBit(!1)),
        g.storeUint(d.lastTransactionHash, 256),
        g.storeUint(d.lastTransactionLt, 64)
    }
}
ShardAccount.storeShardAccount = storeShardAccount;
var ShardAccounts = {};
(function(d) {
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.storeShardAccounts = d.loadShardAccounts = d.ShardAccountRefValue = void 0;
    const g = requireDictionary()
      , b = DepthBalanceInfo
      , _ = ShardAccount;
    d.ShardAccountRefValue = {
        parse: tt=>{
            let rt = (0,
            b.loadDepthBalanceInfo)(tt)
              , nt = (0,
            _.loadShardAccount)(tt);
            return {
                depthBalanceInfo: rt,
                shardAccount: nt
            }
        }
        ,
        serialize(tt, rt) {
            rt.store((0,
            b.storeDepthBalanceInfo)(tt.depthBalanceInfo)),
            rt.store((0,
            _.storeShardAccount)(tt.shardAccount))
        }
    };
    function $(tt) {
        return g.Dictionary.load(g.Dictionary.Keys.BigUint(256), d.ShardAccountRefValue, tt)
    }
    d.loadShardAccounts = $;
    function et(tt) {
        return rt=>{
            rt.storeDict(tt)
        }
    }
    d.storeShardAccounts = et
}
)(ShardAccounts);
var ShardIdent = {};
Object.defineProperty(ShardIdent, "__esModule", {
    value: !0
});
ShardIdent.storeShardIdent = ShardIdent.loadShardIdent = void 0;
function loadShardIdent(d) {
    if (d.loadUint(2) !== 0)
        throw Error("Invalid data");
    return {
        shardPrefixBits: d.loadUint(6),
        workchainId: d.loadInt(32),
        shardPrefix: d.loadUintBig(64)
    }
}
ShardIdent.loadShardIdent = loadShardIdent;
function storeShardIdent(d) {
    return g=>{
        g.storeUint(0, 2),
        g.storeUint(d.shardPrefixBits, 6),
        g.storeInt(d.workchainId, 32),
        g.storeUint(d.shardPrefix, 64)
    }
}
ShardIdent.storeShardIdent = storeShardIdent;
var ShardStateUnsplit = {};
Object.defineProperty(ShardStateUnsplit, "__esModule", {
    value: !0
});
ShardStateUnsplit.loadShardStateUnsplit = void 0;
const MasterchainStateExtra_1 = MasterchainStateExtra
  , ShardAccounts_1 = ShardAccounts
  , ShardIdent_1 = ShardIdent;
function loadShardStateUnsplit(d) {
    if (d.loadUint(32) !== 2418257890)
        throw Error("Invalid data");
    let g = d.loadInt(32)
      , b = (0,
    ShardIdent_1.loadShardIdent)(d)
      , _ = d.loadUint(32)
      , $ = d.loadUint(32)
      , et = d.loadUint(32)
      , tt = d.loadUintBig(64)
      , rt = d.loadUint(32);
    d.loadRef();
    let nt = d.loadBit(), it = d.loadRef(), ot;
    it.isExotic || (ot = (0,
    ShardAccounts_1.loadShardAccounts)(it.beginParse())),
    d.loadRef();
    let at = d.loadBit()
      , st = null;
    if (at) {
        let dt = d.loadRef();
        dt.isExotic || (st = (0,
        MasterchainStateExtra_1.loadMasterchainStateExtra)(dt.beginParse()))
    }
    return {
        globalId: g,
        shardId: b,
        seqno: _,
        vertSeqNo: $,
        genUtime: et,
        genLt: tt,
        minRefMcSeqno: rt,
        beforeSplit: nt,
        accounts: ot,
        extras: st
    }
}
ShardStateUnsplit.loadShardStateUnsplit = loadShardStateUnsplit;
var SplitMergeInfo = {};
Object.defineProperty(SplitMergeInfo, "__esModule", {
    value: !0
});
SplitMergeInfo.storeSplitMergeInfo = SplitMergeInfo.loadSplitMergeInfo = void 0;
function loadSplitMergeInfo(d) {
    let g = d.loadUint(6)
      , b = d.loadUint(6)
      , _ = d.loadUintBig(256)
      , $ = d.loadUintBig(256);
    return {
        currentShardPrefixLength: g,
        accountSplitDepth: b,
        thisAddress: _,
        siblingAddress: $
    }
}
SplitMergeInfo.loadSplitMergeInfo = loadSplitMergeInfo;
function storeSplitMergeInfo(d) {
    return g=>{
        g.storeUint(d.currentShardPrefixLength, 6),
        g.storeUint(d.accountSplitDepth, 6),
        g.storeUint(d.thisAddress, 256),
        g.storeUint(d.siblingAddress, 256)
    }
}
SplitMergeInfo.storeSplitMergeInfo = storeSplitMergeInfo;
var StorageUsedShort = {};
Object.defineProperty(StorageUsedShort, "__esModule", {
    value: !0
});
StorageUsedShort.storeStorageUsedShort = StorageUsedShort.loadStorageUsedShort = void 0;
function loadStorageUsedShort(d) {
    let g = d.loadVarUintBig(3)
      , b = d.loadVarUintBig(3);
    return {
        cells: g,
        bits: b
    }
}
StorageUsedShort.loadStorageUsedShort = loadStorageUsedShort;
function storeStorageUsedShort(d) {
    return g=>{
        g.storeVarUint(d.cells, 3),
        g.storeVarUint(d.bits, 3)
    }
}
StorageUsedShort.storeStorageUsedShort = storeStorageUsedShort;
var Transaction = {}
  , TransactionDescription = {}
  , TransactionActionPhase = {};
Object.defineProperty(TransactionActionPhase, "__esModule", {
    value: !0
});
TransactionActionPhase.storeTransactionActionPhase = TransactionActionPhase.loadTransactionActionPhase = void 0;
const AccountStatusChange_1$1 = AccountStatusChange
  , StorageUsedShort_1$1 = StorageUsedShort;
function loadTransactionActionPhase(d) {
    let g = d.loadBit()
      , b = d.loadBit()
      , _ = d.loadBit()
      , $ = (0,
    AccountStatusChange_1$1.loadAccountStatusChange)(d)
      , et = d.loadBit() ? d.loadCoins() : void 0
      , tt = d.loadBit() ? d.loadCoins() : void 0
      , rt = d.loadInt(32)
      , nt = d.loadBit() ? d.loadInt(32) : void 0
      , it = d.loadUint(16)
      , ot = d.loadUint(16)
      , at = d.loadUint(16)
      , st = d.loadUint(16)
      , dt = d.loadUintBig(256)
      , ft = (0,
    StorageUsedShort_1$1.loadStorageUsedShort)(d);
    return {
        success: g,
        valid: b,
        noFunds: _,
        statusChange: $,
        totalFwdFees: et,
        totalActionFees: tt,
        resultCode: rt,
        resultArg: nt,
        totalActions: it,
        specActions: ot,
        skippedActions: at,
        messagesCreated: st,
        actionListHash: dt,
        totalMessageSize: ft
    }
}
TransactionActionPhase.loadTransactionActionPhase = loadTransactionActionPhase;
function storeTransactionActionPhase(d) {
    return g=>{
        g.storeBit(d.success),
        g.storeBit(d.valid),
        g.storeBit(d.noFunds),
        g.store((0,
        AccountStatusChange_1$1.storeAccountStatusChange)(d.statusChange)),
        g.storeMaybeCoins(d.totalFwdFees),
        g.storeMaybeCoins(d.totalActionFees),
        g.storeInt(d.resultCode, 32),
        g.storeMaybeInt(d.resultArg, 32),
        g.storeUint(d.totalActions, 16),
        g.storeUint(d.specActions, 16),
        g.storeUint(d.skippedActions, 16),
        g.storeUint(d.messagesCreated, 16),
        g.storeUint(d.actionListHash, 256),
        g.store((0,
        StorageUsedShort_1$1.storeStorageUsedShort)(d.totalMessageSize))
    }
}
TransactionActionPhase.storeTransactionActionPhase = storeTransactionActionPhase;
var TransactionBouncePhase = {};
Object.defineProperty(TransactionBouncePhase, "__esModule", {
    value: !0
});
TransactionBouncePhase.storeTransactionBouncePhase = TransactionBouncePhase.loadTransactionBouncePhase = void 0;
const StorageUsedShort_1 = StorageUsedShort;
function loadTransactionBouncePhase(d) {
    if (d.loadBit()) {
        let g = (0,
        StorageUsedShort_1.loadStorageUsedShort)(d)
          , b = d.loadCoins()
          , _ = d.loadCoins();
        return {
            type: "ok",
            messageSize: g,
            messageFees: b,
            forwardFees: _
        }
    }
    if (d.loadBit()) {
        let g = (0,
        StorageUsedShort_1.loadStorageUsedShort)(d)
          , b = d.loadCoins();
        return {
            type: "no-funds",
            messageSize: g,
            requiredForwardFees: b
        }
    }
    return {
        type: "negative-funds"
    }
}
TransactionBouncePhase.loadTransactionBouncePhase = loadTransactionBouncePhase;
function storeTransactionBouncePhase(d) {
    return g=>{
        if (d.type === "ok")
            g.storeBit(!0),
            g.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(d.messageSize)),
            g.storeCoins(d.messageFees),
            g.storeCoins(d.forwardFees);
        else if (d.type === "negative-funds")
            g.storeBit(!1),
            g.storeBit(!1);
        else if (d.type === "no-funds")
            g.storeBit(!1),
            g.storeBit(!0),
            g.store((0,
            StorageUsedShort_1.storeStorageUsedShort)(d.messageSize)),
            g.storeCoins(d.requiredForwardFees);
        else
            throw new Error("Invalid TransactionBouncePhase type")
    }
}
TransactionBouncePhase.storeTransactionBouncePhase = storeTransactionBouncePhase;
var TransactionComputePhase = {};
Object.defineProperty(TransactionComputePhase, "__esModule", {
    value: !0
});
TransactionComputePhase.storeTransactionComputePhase = TransactionComputePhase.loadTransactionComputePhase = void 0;
const Builder_1 = requireBuilder()
  , ComputeSkipReason_1 = ComputeSkipReason;
function loadTransactionComputePhase(d) {
    if (!d.loadBit())
        return {
            type: "skipped",
            reason: (0,
            ComputeSkipReason_1.loadComputeSkipReason)(d)
        };
    let g = d.loadBit()
      , b = d.loadBit()
      , _ = d.loadBit()
      , $ = d.loadCoins();
    const et = d.loadRef().beginParse();
    let tt = et.loadVarUintBig(3)
      , rt = et.loadVarUintBig(3)
      , nt = et.loadBit() ? et.loadVarUintBig(2) : void 0
      , it = et.loadUint(8)
      , ot = et.loadInt(32)
      , at = et.loadBit() ? et.loadInt(32) : void 0
      , st = et.loadUint(32)
      , dt = et.loadUintBig(256)
      , ft = et.loadUintBig(256);
    return {
        type: "vm",
        success: g,
        messageStateUsed: b,
        accountActivated: _,
        gasFees: $,
        gasUsed: tt,
        gasLimit: rt,
        gasCredit: nt,
        mode: it,
        exitCode: ot,
        exitArg: at,
        vmSteps: st,
        vmInitStateHash: dt,
        vmFinalStateHash: ft
    }
}
TransactionComputePhase.loadTransactionComputePhase = loadTransactionComputePhase;
function storeTransactionComputePhase(d) {
    return g=>{
        if (d.type === "skipped") {
            g.storeBit(0),
            g.store((0,
            ComputeSkipReason_1.storeComputeSkipReason)(d.reason));
            return
        }
        g.storeBit(1),
        g.storeBit(d.success),
        g.storeBit(d.messageStateUsed),
        g.storeBit(d.accountActivated),
        g.storeCoins(d.gasFees),
        g.storeRef((0,
        Builder_1.beginCell)().storeVarUint(d.gasUsed, 3).storeVarUint(d.gasLimit, 3).store(b=>d.gasCredit !== void 0 && d.gasCredit !== null ? b.storeBit(1).storeVarUint(d.gasCredit, 2) : b.storeBit(0)).storeUint(d.mode, 8).storeInt(d.exitCode, 32).store(b=>d.exitArg !== void 0 && d.exitArg !== null ? b.storeBit(1).storeInt(d.exitArg, 32) : b.storeBit(0)).storeUint(d.vmSteps, 32).storeUint(d.vmInitStateHash, 256).storeUint(d.vmFinalStateHash, 256).endCell())
    }
}
TransactionComputePhase.storeTransactionComputePhase = storeTransactionComputePhase;
var TransactionCreditPhase = {};
Object.defineProperty(TransactionCreditPhase, "__esModule", {
    value: !0
});
TransactionCreditPhase.storeTransactionCreditPhase = TransactionCreditPhase.loadTransactionCreditPhase = void 0;
const CurrencyCollection_1 = CurrencyCollection;
function loadTransactionCreditPhase(d) {
    const g = d.loadBit() ? d.loadCoins() : void 0
      , b = (0,
    CurrencyCollection_1.loadCurrencyCollection)(d);
    return {
        dueFeesColelcted: g,
        credit: b
    }
}
TransactionCreditPhase.loadTransactionCreditPhase = loadTransactionCreditPhase;
function storeTransactionCreditPhase(d) {
    return g=>{
        d.dueFeesColelcted === null || d.dueFeesColelcted === void 0 ? g.storeBit(!1) : (g.storeBit(!0),
        g.storeCoins(d.dueFeesColelcted)),
        g.store((0,
        CurrencyCollection_1.storeCurrencyCollection)(d.credit))
    }
}
TransactionCreditPhase.storeTransactionCreditPhase = storeTransactionCreditPhase;
var TransactionStoragePhase = {};
Object.defineProperty(TransactionStoragePhase, "__esModule", {
    value: !0
});
TransactionStoragePhase.storeTransactionsStoragePhase = TransactionStoragePhase.loadTransactionStoragePhase = void 0;
const AccountStatusChange_1 = AccountStatusChange;
function loadTransactionStoragePhase(d) {
    const g = d.loadCoins();
    let b;
    d.loadBit() && (b = d.loadCoins());
    const _ = (0,
    AccountStatusChange_1.loadAccountStatusChange)(d);
    return {
        storageFeesCollected: g,
        storageFeesDue: b,
        statusChange: _
    }
}
TransactionStoragePhase.loadTransactionStoragePhase = loadTransactionStoragePhase;
function storeTransactionsStoragePhase(d) {
    return g=>{
        g.storeCoins(d.storageFeesCollected),
        d.storageFeesDue === null || d.storageFeesDue === void 0 ? g.storeBit(!1) : (g.storeBit(!0),
        g.storeCoins(d.storageFeesDue)),
        g.store((0,
        AccountStatusChange_1.storeAccountStatusChange)(d.statusChange))
    }
}
TransactionStoragePhase.storeTransactionsStoragePhase = storeTransactionsStoragePhase;
var hasRequiredTransactionDescription;
function requireTransactionDescription() {
    if (hasRequiredTransactionDescription)
        return TransactionDescription;
    hasRequiredTransactionDescription = 1,
    Object.defineProperty(TransactionDescription, "__esModule", {
        value: !0
    }),
    TransactionDescription.storeTransactionDescription = TransactionDescription.loadTransactionDescription = void 0;
    const d = requireBuilder()
      , g = SplitMergeInfo
      , b = requireTransaction()
      , _ = TransactionActionPhase
      , $ = TransactionBouncePhase
      , et = TransactionComputePhase
      , tt = TransactionCreditPhase
      , rt = TransactionStoragePhase;
    function nt(ot) {
        let at = ot.loadUint(4);
        if (at === 0) {
            const st = ot.loadBit();
            let dt;
            ot.loadBit() && (dt = (0,
            rt.loadTransactionStoragePhase)(ot));
            let ft;
            ot.loadBit() && (ft = (0,
            tt.loadTransactionCreditPhase)(ot));
            let ht = (0,
            et.loadTransactionComputePhase)(ot), xt;
            ot.loadBit() && (xt = (0,
            _.loadTransactionActionPhase)(ot.loadRef().beginParse()));
            let lt = ot.loadBit(), ct;
            ot.loadBit() && (ct = (0,
            $.loadTransactionBouncePhase)(ot));
            const ut = ot.loadBit();
            return {
                type: "generic",
                creditFirst: st,
                storagePhase: dt,
                creditPhase: ft,
                computePhase: ht,
                actionPhase: xt,
                bouncePhase: ct,
                aborted: lt,
                destroyed: ut
            }
        }
        if (at === 1)
            return {
                type: "storage",
                storagePhase: (0,
                rt.loadTransactionStoragePhase)(ot)
            };
        if (at === 2 || at === 3) {
            const st = at === 3;
            let dt = (0,
            rt.loadTransactionStoragePhase)(ot), ft = (0,
            et.loadTransactionComputePhase)(ot), ht;
            ot.loadBit() && (ht = (0,
            _.loadTransactionActionPhase)(ot.loadRef().beginParse()));
            const xt = ot.loadBit()
              , lt = ot.loadBit();
            return {
                type: "tick-tock",
                isTock: st,
                storagePhase: dt,
                computePhase: ft,
                actionPhase: ht,
                aborted: xt,
                destroyed: lt
            }
        }
        if (at === 4) {
            let st = (0,
            g.loadSplitMergeInfo)(ot), dt;
            ot.loadBit() && (dt = (0,
            rt.loadTransactionStoragePhase)(ot));
            let ft = (0,
            et.loadTransactionComputePhase)(ot), ht;
            ot.loadBit() && (ht = (0,
            _.loadTransactionActionPhase)(ot.loadRef().beginParse()));
            const xt = ot.loadBit()
              , lt = ot.loadBit();
            return {
                type: "split-prepare",
                splitInfo: st,
                storagePhase: dt,
                computePhase: ft,
                actionPhase: ht,
                aborted: xt,
                destroyed: lt
            }
        }
        if (at === 5) {
            let st = (0,
            g.loadSplitMergeInfo)(ot)
              , dt = (0,
            b.loadTransaction)(ot.loadRef().beginParse());
            const ft = ot.loadBit();
            return {
                type: "split-install",
                splitInfo: st,
                prepareTransaction: dt,
                installed: ft
            }
        }
        throw Error(`Unsupported transaction description type ${at}`)
    }
    TransactionDescription.loadTransactionDescription = nt;
    function it(ot) {
        return at=>{
            if (ot.type === "generic")
                at.storeUint(0, 4),
                at.storeBit(ot.creditFirst),
                ot.storagePhase ? (at.storeBit(!0),
                at.store((0,
                rt.storeTransactionsStoragePhase)(ot.storagePhase))) : at.storeBit(!1),
                ot.creditPhase ? (at.storeBit(!0),
                at.store((0,
                tt.storeTransactionCreditPhase)(ot.creditPhase))) : at.storeBit(!1),
                at.store((0,
                et.storeTransactionComputePhase)(ot.computePhase)),
                ot.actionPhase ? (at.storeBit(!0),
                at.storeRef((0,
                d.beginCell)().store((0,
                _.storeTransactionActionPhase)(ot.actionPhase)))) : at.storeBit(!1),
                at.storeBit(ot.aborted),
                ot.bouncePhase ? (at.storeBit(!0),
                at.store((0,
                $.storeTransactionBouncePhase)(ot.bouncePhase))) : at.storeBit(!1),
                at.storeBit(ot.destroyed);
            else if (ot.type === "storage")
                at.storeUint(1, 4),
                at.store((0,
                rt.storeTransactionsStoragePhase)(ot.storagePhase));
            else if (ot.type === "tick-tock")
                at.storeUint(ot.isTock ? 3 : 2, 4),
                at.store((0,
                rt.storeTransactionsStoragePhase)(ot.storagePhase)),
                at.store((0,
                et.storeTransactionComputePhase)(ot.computePhase)),
                ot.actionPhase ? (at.storeBit(!0),
                at.storeRef((0,
                d.beginCell)().store((0,
                _.storeTransactionActionPhase)(ot.actionPhase)))) : at.storeBit(!1),
                at.storeBit(ot.aborted),
                at.storeBit(ot.destroyed);
            else if (ot.type === "split-prepare")
                at.storeUint(4, 4),
                at.store((0,
                g.storeSplitMergeInfo)(ot.splitInfo)),
                ot.storagePhase ? (at.storeBit(!0),
                at.store((0,
                rt.storeTransactionsStoragePhase)(ot.storagePhase))) : at.storeBit(!1),
                at.store((0,
                et.storeTransactionComputePhase)(ot.computePhase)),
                ot.actionPhase ? (at.storeBit(!0),
                at.store((0,
                _.storeTransactionActionPhase)(ot.actionPhase))) : at.storeBit(!1),
                at.storeBit(ot.aborted),
                at.storeBit(ot.destroyed);
            else if (ot.type === "split-install")
                at.storeUint(5, 4),
                at.store((0,
                g.storeSplitMergeInfo)(ot.splitInfo)),
                at.storeRef((0,
                d.beginCell)().store((0,
                b.storeTransaction)(ot.prepareTransaction))),
                at.storeBit(ot.installed);
            else
                throw Error(`Unsupported transaction description type ${ot.type}`)
        }
    }
    return TransactionDescription.storeTransactionDescription = it,
    TransactionDescription
}
var hasRequiredTransaction;
function requireTransaction() {
    if (hasRequiredTransaction)
        return Transaction;
    hasRequiredTransaction = 1,
    Object.defineProperty(Transaction, "__esModule", {
        value: !0
    }),
    Transaction.storeTransaction = Transaction.loadTransaction = void 0;
    const d = requireBuilder()
      , g = requireDictionary()
      , b = AccountStatus
      , _ = CurrencyCollection
      , $ = HashUpdate
      , et = Message
      , tt = requireTransactionDescription();
    function rt(it) {
        let ot = it.asCell();
        if (it.loadUint(4) !== 7)
            throw Error("Invalid data");
        let at = it.loadUintBig(256)
          , st = it.loadUintBig(64)
          , dt = it.loadUintBig(256)
          , ft = it.loadUintBig(64)
          , ht = it.loadUint(32)
          , xt = it.loadUint(15)
          , lt = (0,
        b.loadAccountStatus)(it)
          , ct = (0,
        b.loadAccountStatus)(it)
          , pt = it.loadRef().beginParse()
          , vt = pt.loadBit() ? (0,
        et.loadMessage)(pt.loadRef().beginParse()) : void 0
          , _t = pt.loadDict(g.Dictionary.Keys.Uint(15), et.MessageValue);
        pt.endParse();
        let Pt = (0,
        _.loadCurrencyCollection)(it)
          , kt = (0,
        $.loadHashUpdate)(it.loadRef().beginParse())
          , $t = (0,
        tt.loadTransactionDescription)(it.loadRef().beginParse());
        return {
            address: at,
            lt: st,
            prevTransactionHash: dt,
            prevTransactionLt: ft,
            now: ht,
            outMessagesCount: xt,
            oldStatus: lt,
            endStatus: ct,
            inMessage: vt,
            outMessages: _t,
            totalFees: Pt,
            stateUpdate: kt,
            description: $t,
            raw: ot,
            hash: ()=>ot.hash()
        }
    }
    Transaction.loadTransaction = rt;
    function nt(it) {
        return ot=>{
            ot.storeUint(7, 4),
            ot.storeUint(it.address, 256),
            ot.storeUint(it.lt, 64),
            ot.storeUint(it.prevTransactionHash, 256),
            ot.storeUint(it.prevTransactionLt, 64),
            ot.storeUint(it.now, 32),
            ot.storeUint(it.outMessagesCount, 15),
            ot.store((0,
            b.storeAccountStatus)(it.oldStatus)),
            ot.store((0,
            b.storeAccountStatus)(it.endStatus));
            let at = (0,
            d.beginCell)();
            it.inMessage ? (at.storeBit(!0),
            at.storeRef((0,
            d.beginCell)().store((0,
            et.storeMessage)(it.inMessage)))) : at.storeBit(!1),
            at.storeDict(it.outMessages),
            ot.storeRef(at),
            ot.store((0,
            _.storeCurrencyCollection)(it.totalFees)),
            ot.storeRef((0,
            d.beginCell)().store((0,
            $.storeHashUpdate)(it.stateUpdate))),
            ot.storeRef((0,
            d.beginCell)().store((0,
            tt.storeTransactionDescription)(it.description)))
        }
    }
    return Transaction.storeTransaction = nt,
    Transaction
}
(function(d) {
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.loadStorageInfo = d.storeStateInit = d.loadStateInit = d.storeSplitMergeInfo = d.loadSplitMergeInfo = d.storeSimpleLibrary = d.loadSimpleLibrary = d.loadShardStateUnsplit = d.storeShardIdent = d.loadShardIdent = d.storeShardAccounts = d.loadShardAccounts = d.ShardAccountRefValue = d.storeShardAccount = d.loadShardAccount = d.SendMode = d.storeMessageRelaxed = d.loadMessageRelaxed = d.storeMessage = d.loadMessage = d.loadMasterchainStateExtra = d.storeHashUpdate = d.loadHashUpdate = d.storeDepthBalanceInfo = d.loadDepthBalanceInfo = d.storeCurrencyCollection = d.loadCurrencyCollection = d.storeComputeSkipReason = d.loadComputeSkipReason = d.storeCommonMessageInfoRelaxed = d.loadCommonMessageInfoRelaxed = d.storeCommonMessageInfo = d.loadCommonMessageInfo = d.storeOutList = d.loadOutList = d.storeOutAction = d.loadOutAction = d.storeAccountStorage = d.loadAccountStorage = d.storeAccountStatusChange = d.loadAccountStatusChange = d.storeAccountStatus = d.loadAccountStatus = d.storeAccountState = d.loadAccountState = d.storeAccount = d.loadAccount = d.comment = d.external = d.internal = void 0,
    d.storeTransactionsStoragePhase = d.loadTransactionStoragePhase = d.storeTransactionDescription = d.loadTransactionDescription = d.storeTransactionCreditPhase = d.loadTransactionCreditPhase = d.storeTransactionComputePhase = d.loadTransactionComputePhase = d.storeTransactionBouncePhase = d.loadTransactionBouncePhase = d.storeTransactionActionPhase = d.loadTransactionActionPhase = d.storeTransaction = d.loadTransaction = d.storeTickTock = d.loadTickTock = d.storeStorageUsedShort = d.loadStorageUsedShort = d.storeStorageUsed = d.loadStorageUsed = d.storeStorageInfo = void 0;
    var g = _helpers;
    Object.defineProperty(d, "internal", {
        enumerable: !0,
        get: function() {
            return g.internal
        }
    }),
    Object.defineProperty(d, "external", {
        enumerable: !0,
        get: function() {
            return g.external
        }
    }),
    Object.defineProperty(d, "comment", {
        enumerable: !0,
        get: function() {
            return g.comment
        }
    });
    var b = Account;
    Object.defineProperty(d, "loadAccount", {
        enumerable: !0,
        get: function() {
            return b.loadAccount
        }
    }),
    Object.defineProperty(d, "storeAccount", {
        enumerable: !0,
        get: function() {
            return b.storeAccount
        }
    });
    var _ = AccountState;
    Object.defineProperty(d, "loadAccountState", {
        enumerable: !0,
        get: function() {
            return _.loadAccountState
        }
    }),
    Object.defineProperty(d, "storeAccountState", {
        enumerable: !0,
        get: function() {
            return _.storeAccountState
        }
    });
    var $ = AccountStatus;
    Object.defineProperty(d, "loadAccountStatus", {
        enumerable: !0,
        get: function() {
            return $.loadAccountStatus
        }
    }),
    Object.defineProperty(d, "storeAccountStatus", {
        enumerable: !0,
        get: function() {
            return $.storeAccountStatus
        }
    });
    var et = AccountStatusChange;
    Object.defineProperty(d, "loadAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return et.loadAccountStatusChange
        }
    }),
    Object.defineProperty(d, "storeAccountStatusChange", {
        enumerable: !0,
        get: function() {
            return et.storeAccountStatusChange
        }
    });
    var tt = AccountStorage;
    Object.defineProperty(d, "loadAccountStorage", {
        enumerable: !0,
        get: function() {
            return tt.loadAccountStorage
        }
    }),
    Object.defineProperty(d, "storeAccountStorage", {
        enumerable: !0,
        get: function() {
            return tt.storeAccountStorage
        }
    });
    var rt = OutList;
    Object.defineProperty(d, "loadOutAction", {
        enumerable: !0,
        get: function() {
            return rt.loadOutAction
        }
    }),
    Object.defineProperty(d, "storeOutAction", {
        enumerable: !0,
        get: function() {
            return rt.storeOutAction
        }
    }),
    Object.defineProperty(d, "loadOutList", {
        enumerable: !0,
        get: function() {
            return rt.loadOutList
        }
    }),
    Object.defineProperty(d, "storeOutList", {
        enumerable: !0,
        get: function() {
            return rt.storeOutList
        }
    });
    var nt = CommonMessageInfo;
    Object.defineProperty(d, "loadCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return nt.loadCommonMessageInfo
        }
    }),
    Object.defineProperty(d, "storeCommonMessageInfo", {
        enumerable: !0,
        get: function() {
            return nt.storeCommonMessageInfo
        }
    });
    var it = CommonMessageInfoRelaxed;
    Object.defineProperty(d, "loadCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return it.loadCommonMessageInfoRelaxed
        }
    }),
    Object.defineProperty(d, "storeCommonMessageInfoRelaxed", {
        enumerable: !0,
        get: function() {
            return it.storeCommonMessageInfoRelaxed
        }
    });
    var ot = ComputeSkipReason;
    Object.defineProperty(d, "loadComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return ot.loadComputeSkipReason
        }
    }),
    Object.defineProperty(d, "storeComputeSkipReason", {
        enumerable: !0,
        get: function() {
            return ot.storeComputeSkipReason
        }
    });
    var at = CurrencyCollection;
    Object.defineProperty(d, "loadCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return at.loadCurrencyCollection
        }
    }),
    Object.defineProperty(d, "storeCurrencyCollection", {
        enumerable: !0,
        get: function() {
            return at.storeCurrencyCollection
        }
    });
    var st = DepthBalanceInfo;
    Object.defineProperty(d, "loadDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return st.loadDepthBalanceInfo
        }
    }),
    Object.defineProperty(d, "storeDepthBalanceInfo", {
        enumerable: !0,
        get: function() {
            return st.storeDepthBalanceInfo
        }
    });
    var dt = HashUpdate;
    Object.defineProperty(d, "loadHashUpdate", {
        enumerable: !0,
        get: function() {
            return dt.loadHashUpdate
        }
    }),
    Object.defineProperty(d, "storeHashUpdate", {
        enumerable: !0,
        get: function() {
            return dt.storeHashUpdate
        }
    });
    var ft = MasterchainStateExtra;
    Object.defineProperty(d, "loadMasterchainStateExtra", {
        enumerable: !0,
        get: function() {
            return ft.loadMasterchainStateExtra
        }
    });
    var ht = Message;
    Object.defineProperty(d, "loadMessage", {
        enumerable: !0,
        get: function() {
            return ht.loadMessage
        }
    }),
    Object.defineProperty(d, "storeMessage", {
        enumerable: !0,
        get: function() {
            return ht.storeMessage
        }
    });
    var xt = MessageRelaxed;
    Object.defineProperty(d, "loadMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return xt.loadMessageRelaxed
        }
    }),
    Object.defineProperty(d, "storeMessageRelaxed", {
        enumerable: !0,
        get: function() {
            return xt.storeMessageRelaxed
        }
    });
    var lt = SendMode;
    Object.defineProperty(d, "SendMode", {
        enumerable: !0,
        get: function() {
            return lt.SendMode
        }
    });
    var ct = ShardAccount;
    Object.defineProperty(d, "loadShardAccount", {
        enumerable: !0,
        get: function() {
            return ct.loadShardAccount
        }
    }),
    Object.defineProperty(d, "storeShardAccount", {
        enumerable: !0,
        get: function() {
            return ct.storeShardAccount
        }
    });
    var ut = ShardAccounts;
    Object.defineProperty(d, "ShardAccountRefValue", {
        enumerable: !0,
        get: function() {
            return ut.ShardAccountRefValue
        }
    }),
    Object.defineProperty(d, "loadShardAccounts", {
        enumerable: !0,
        get: function() {
            return ut.loadShardAccounts
        }
    }),
    Object.defineProperty(d, "storeShardAccounts", {
        enumerable: !0,
        get: function() {
            return ut.storeShardAccounts
        }
    });
    var pt = ShardIdent;
    Object.defineProperty(d, "loadShardIdent", {
        enumerable: !0,
        get: function() {
            return pt.loadShardIdent
        }
    }),
    Object.defineProperty(d, "storeShardIdent", {
        enumerable: !0,
        get: function() {
            return pt.storeShardIdent
        }
    });
    var vt = ShardStateUnsplit;
    Object.defineProperty(d, "loadShardStateUnsplit", {
        enumerable: !0,
        get: function() {
            return vt.loadShardStateUnsplit
        }
    });
    var _t = SimpleLibrary;
    Object.defineProperty(d, "loadSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return _t.loadSimpleLibrary
        }
    }),
    Object.defineProperty(d, "storeSimpleLibrary", {
        enumerable: !0,
        get: function() {
            return _t.storeSimpleLibrary
        }
    });
    var Pt = SplitMergeInfo;
    Object.defineProperty(d, "loadSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return Pt.loadSplitMergeInfo
        }
    }),
    Object.defineProperty(d, "storeSplitMergeInfo", {
        enumerable: !0,
        get: function() {
            return Pt.storeSplitMergeInfo
        }
    });
    var kt = StateInit;
    Object.defineProperty(d, "loadStateInit", {
        enumerable: !0,
        get: function() {
            return kt.loadStateInit
        }
    }),
    Object.defineProperty(d, "storeStateInit", {
        enumerable: !0,
        get: function() {
            return kt.storeStateInit
        }
    });
    var $t = StorageInto;
    Object.defineProperty(d, "loadStorageInfo", {
        enumerable: !0,
        get: function() {
            return $t.loadStorageInfo
        }
    }),
    Object.defineProperty(d, "storeStorageInfo", {
        enumerable: !0,
        get: function() {
            return $t.storeStorageInfo
        }
    });
    var Wt = StorageUsed;
    Object.defineProperty(d, "loadStorageUsed", {
        enumerable: !0,
        get: function() {
            return Wt.loadStorageUsed
        }
    }),
    Object.defineProperty(d, "storeStorageUsed", {
        enumerable: !0,
        get: function() {
            return Wt.storeStorageUsed
        }
    });
    var Ht = StorageUsedShort;
    Object.defineProperty(d, "loadStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Ht.loadStorageUsedShort
        }
    }),
    Object.defineProperty(d, "storeStorageUsedShort", {
        enumerable: !0,
        get: function() {
            return Ht.storeStorageUsedShort
        }
    });
    var Dt = TickTock;
    Object.defineProperty(d, "loadTickTock", {
        enumerable: !0,
        get: function() {
            return Dt.loadTickTock
        }
    }),
    Object.defineProperty(d, "storeTickTock", {
        enumerable: !0,
        get: function() {
            return Dt.storeTickTock
        }
    });
    var Vt = requireTransaction();
    Object.defineProperty(d, "loadTransaction", {
        enumerable: !0,
        get: function() {
            return Vt.loadTransaction
        }
    }),
    Object.defineProperty(d, "storeTransaction", {
        enumerable: !0,
        get: function() {
            return Vt.storeTransaction
        }
    });
    var Ft = TransactionActionPhase;
    Object.defineProperty(d, "loadTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return Ft.loadTransactionActionPhase
        }
    }),
    Object.defineProperty(d, "storeTransactionActionPhase", {
        enumerable: !0,
        get: function() {
            return Ft.storeTransactionActionPhase
        }
    });
    var Kt = TransactionBouncePhase;
    Object.defineProperty(d, "loadTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return Kt.loadTransactionBouncePhase
        }
    }),
    Object.defineProperty(d, "storeTransactionBouncePhase", {
        enumerable: !0,
        get: function() {
            return Kt.storeTransactionBouncePhase
        }
    });
    var Rt = TransactionComputePhase;
    Object.defineProperty(d, "loadTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return Rt.loadTransactionComputePhase
        }
    }),
    Object.defineProperty(d, "storeTransactionComputePhase", {
        enumerable: !0,
        get: function() {
            return Rt.storeTransactionComputePhase
        }
    });
    var qt = TransactionCreditPhase;
    Object.defineProperty(d, "loadTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return qt.loadTransactionCreditPhase
        }
    }),
    Object.defineProperty(d, "storeTransactionCreditPhase", {
        enumerable: !0,
        get: function() {
            return qt.storeTransactionCreditPhase
        }
    });
    var Et = requireTransactionDescription();
    Object.defineProperty(d, "loadTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Et.loadTransactionDescription
        }
    }),
    Object.defineProperty(d, "storeTransactionDescription", {
        enumerable: !0,
        get: function() {
            return Et.storeTransactionDescription
        }
    });
    var St = TransactionStoragePhase;
    Object.defineProperty(d, "loadTransactionStoragePhase", {
        enumerable: !0,
        get: function() {
            return St.loadTransactionStoragePhase
        }
    }),
    Object.defineProperty(d, "storeTransactionsStoragePhase", {
        enumerable: !0,
        get: function() {
            return St.storeTransactionsStoragePhase
        }
    })
}
)(_export$1);
var openContract$1 = {};
Object.defineProperty(openContract$1, "__esModule", {
    value: !0
});
openContract$1.openContract = void 0;
const Address_1 = Address$1
  , Cell_1 = requireCell();
function openContract(d, g) {
    let b, _ = null;
    if (!Address_1.Address.isAddress(d.address))
        throw Error("Invalid address");
    if (b = d.address,
    d.init) {
        if (!(d.init.code instanceof Cell_1.Cell))
            throw Error("Invalid init.code");
        if (!(d.init.data instanceof Cell_1.Cell))
            throw Error("Invalid init.data");
        _ = d.init
    }
    let $ = g({
        address: b,
        init: _
    });
    return new Proxy(d,{
        get(et, tt) {
            const rt = et[tt];
            return typeof tt == "string" && (tt.startsWith("get") || tt.startsWith("send")) && typeof rt == "function" ? (...nt)=>rt.apply(et, [$, ...nt]) : rt
        }
    })
}
openContract$1.openContract = openContract;
var ComputeError$1 = {};
Object.defineProperty(ComputeError$1, "__esModule", {
    value: !0
});
ComputeError$1.ComputeError = void 0;
class ComputeError extends Error {
    constructor(g, b, _) {
        super(g),
        this.exitCode = b,
        this.debugLogs = _ && _.debugLogs ? _.debugLogs : null,
        this.logs = _ && _.logs ? _.logs : null,
        Object.setPrototypeOf(this, ComputeError.prototype)
    }
}
ComputeError$1.ComputeError = ComputeError;
var getMethodId$1 = {};
Object.defineProperty(getMethodId$1, "__esModule", {
    value: !0
});
getMethodId$1.getMethodId = void 0;
const TABLE = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);
function crc16(d) {
    d instanceof dist$3.Buffer || (d = dist$3.Buffer.from(d));
    let g = 0;
    for (let b = 0; b < d.length; b++) {
        const _ = d[b];
        g = (TABLE[(g >> 8 ^ _) & 255] ^ g << 8) & 65535
    }
    return g
}
function getMethodId(d) {
    return crc16(d) & 65535 | 65536
}
getMethodId$1.getMethodId = getMethodId;
var safeSign$1 = {};
Object.defineProperty(safeSign$1, "__esModule", {
    value: !0
});
safeSign$1.safeSignVerify = safeSign$1.safeSign = void 0;
const ton_crypto_1 = requireDist()
  , MIN_SEED_LENGTH = 8
  , MAX_SEED_LENGTH = 64;
function createSafeSignHash(d, g) {
    let b = dist$3.Buffer.from(g);
    if (b.length > MAX_SEED_LENGTH)
        throw Error("Seed can	 be longer than 64 bytes");
    if (b.length < MIN_SEED_LENGTH)
        throw Error("Seed must be at least 8 bytes");
    return (0,
    ton_crypto_1.sha256_sync)(dist$3.Buffer.concat([dist$3.Buffer.from([255, 255]), b, d.hash()]))
}
function safeSign(d, g, b="ton-safe-sign-magic") {
    return (0,
    ton_crypto_1.sign)(createSafeSignHash(d, b), g)
}
safeSign$1.safeSign = safeSign;
function safeSignVerify(d, g, b, _="ton-safe-sign-magic") {
    return (0,
    ton_crypto_1.signVerify)(createSafeSignHash(d, _), g, b)
}
safeSign$1.safeSignVerify = safeSignVerify;
(function(d) {
    var g = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(Kt, Rt, qt, Et) {
        Et === void 0 && (Et = qt);
        var St = Object.getOwnPropertyDescriptor(Rt, qt);
        (!St || ("get"in St ? !Rt.__esModule : St.writable || St.configurable)) && (St = {
            enumerable: !0,
            get: function() {
                return Rt[qt]
            }
        }),
        Object.defineProperty(Kt, Et, St)
    }
    : function(Kt, Rt, qt, Et) {
        Et === void 0 && (Et = qt),
        Kt[Et] = Rt[qt]
    }
    )
      , b = commonjsGlobal && commonjsGlobal.__exportStar || function(Kt, Rt) {
        for (var qt in Kt)
            qt !== "default" && !Object.prototype.hasOwnProperty.call(Rt, qt) && g(Rt, Kt, qt)
    }
    ;
    Object.defineProperty(d, "__esModule", {
        value: !0
    }),
    d.safeSignVerify = d.safeSign = d.getMethodId = d.base32Encode = d.base32Decode = d.crc32c = d.crc16 = d.fromNano = d.toNano = d.ComputeError = d.openContract = d.TupleBuilder = d.TupleReader = d.serializeTuple = d.parseTuple = d.generateMerkleUpdate = d.generateMerkleProof = d.exoticPruned = d.exoticMerkleUpdate = d.exoticMerkleProof = d.Dictionary = d.Cell = d.CellType = d.Slice = d.beginCell = d.Builder = d.BitBuilder = d.BitReader = d.BitString = d.contractAddress = d.ADNLAddress = d.ExternalAddress = d.address = d.Address = void 0;
    var _ = Address$1;
    Object.defineProperty(d, "Address", {
        enumerable: !0,
        get: function() {
            return _.Address
        }
    }),
    Object.defineProperty(d, "address", {
        enumerable: !0,
        get: function() {
            return _.address
        }
    });
    var $ = ExternalAddress$1;
    Object.defineProperty(d, "ExternalAddress", {
        enumerable: !0,
        get: function() {
            return $.ExternalAddress
        }
    });
    var et = ADNLAddress$1;
    Object.defineProperty(d, "ADNLAddress", {
        enumerable: !0,
        get: function() {
            return et.ADNLAddress
        }
    });
    var tt = contractAddress$1;
    Object.defineProperty(d, "contractAddress", {
        enumerable: !0,
        get: function() {
            return tt.contractAddress
        }
    });
    var rt = requireBitString();
    Object.defineProperty(d, "BitString", {
        enumerable: !0,
        get: function() {
            return rt.BitString
        }
    });
    var nt = BitReader$1;
    Object.defineProperty(d, "BitReader", {
        enumerable: !0,
        get: function() {
            return nt.BitReader
        }
    });
    var it = requireBitBuilder();
    Object.defineProperty(d, "BitBuilder", {
        enumerable: !0,
        get: function() {
            return it.BitBuilder
        }
    });
    var ot = requireBuilder();
    Object.defineProperty(d, "Builder", {
        enumerable: !0,
        get: function() {
            return ot.Builder
        }
    }),
    Object.defineProperty(d, "beginCell", {
        enumerable: !0,
        get: function() {
            return ot.beginCell
        }
    });
    var at = requireSlice();
    Object.defineProperty(d, "Slice", {
        enumerable: !0,
        get: function() {
            return at.Slice
        }
    });
    var st = CellType;
    Object.defineProperty(d, "CellType", {
        enumerable: !0,
        get: function() {
            return st.CellType
        }
    });
    var dt = requireCell();
    Object.defineProperty(d, "Cell", {
        enumerable: !0,
        get: function() {
            return dt.Cell
        }
    });
    var ft = requireDictionary();
    Object.defineProperty(d, "Dictionary", {
        enumerable: !0,
        get: function() {
            return ft.Dictionary
        }
    });
    var ht = exoticMerkleProof$1;
    Object.defineProperty(d, "exoticMerkleProof", {
        enumerable: !0,
        get: function() {
            return ht.exoticMerkleProof
        }
    });
    var xt = exoticMerkleUpdate$1;
    Object.defineProperty(d, "exoticMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return xt.exoticMerkleUpdate
        }
    });
    var lt = exoticPruned$1;
    Object.defineProperty(d, "exoticPruned", {
        enumerable: !0,
        get: function() {
            return lt.exoticPruned
        }
    });
    var ct = requireGenerateMerkleProof();
    Object.defineProperty(d, "generateMerkleProof", {
        enumerable: !0,
        get: function() {
            return ct.generateMerkleProof
        }
    });
    var ut = requireGenerateMerkleUpdate();
    Object.defineProperty(d, "generateMerkleUpdate", {
        enumerable: !0,
        get: function() {
            return ut.generateMerkleUpdate
        }
    });
    var pt = tuple;
    Object.defineProperty(d, "parseTuple", {
        enumerable: !0,
        get: function() {
            return pt.parseTuple
        }
    }),
    Object.defineProperty(d, "serializeTuple", {
        enumerable: !0,
        get: function() {
            return pt.serializeTuple
        }
    });
    var vt = reader;
    Object.defineProperty(d, "TupleReader", {
        enumerable: !0,
        get: function() {
            return vt.TupleReader
        }
    });
    var _t = builder;
    Object.defineProperty(d, "TupleBuilder", {
        enumerable: !0,
        get: function() {
            return _t.TupleBuilder
        }
    }),
    b(_export$1, d);
    var Pt = openContract$1;
    Object.defineProperty(d, "openContract", {
        enumerable: !0,
        get: function() {
            return Pt.openContract
        }
    });
    var kt = ComputeError$1;
    Object.defineProperty(d, "ComputeError", {
        enumerable: !0,
        get: function() {
            return kt.ComputeError
        }
    });
    var $t = convert;
    Object.defineProperty(d, "toNano", {
        enumerable: !0,
        get: function() {
            return $t.toNano
        }
    }),
    Object.defineProperty(d, "fromNano", {
        enumerable: !0,
        get: function() {
            return $t.fromNano
        }
    });
    var Wt = crc16$2;
    Object.defineProperty(d, "crc16", {
        enumerable: !0,
        get: function() {
            return Wt.crc16
        }
    });
    var Ht = crc32c$1;
    Object.defineProperty(d, "crc32c", {
        enumerable: !0,
        get: function() {
            return Ht.crc32c
        }
    });
    var Dt = base32;
    Object.defineProperty(d, "base32Decode", {
        enumerable: !0,
        get: function() {
            return Dt.base32Decode
        }
    }),
    Object.defineProperty(d, "base32Encode", {
        enumerable: !0,
        get: function() {
            return Dt.base32Encode
        }
    });
    var Vt = getMethodId$1;
    Object.defineProperty(d, "getMethodId", {
        enumerable: !0,
        get: function() {
            return Vt.getMethodId
        }
    });
    var Ft = safeSign$1;
    Object.defineProperty(d, "safeSign", {
        enumerable: !0,
        get: function() {
            return Ft.safeSign
        }
    }),
    Object.defineProperty(d, "safeSignVerify", {
        enumerable: !0,
        get: function() {
            return Ft.safeSignVerify
        }
    })
}
)(dist$2);
var module = {};
(function d(g, b, _, $) {
    var et = !!(g.Worker && g.Blob && g.Promise && g.OffscreenCanvas && g.OffscreenCanvasRenderingContext2D && g.HTMLCanvasElement && g.HTMLCanvasElement.prototype.transferControlToOffscreen && g.URL && g.URL.createObjectURL)
      , tt = typeof Path2D == "function" && typeof DOMMatrix == "function"
      , rt = function() {
        if (!g.OffscreenCanvas)
            return !1;
        var Lt = new OffscreenCanvas(1,1)
          , Mt = Lt.getContext("2d");
        Mt.fillRect(0, 0, 1, 1);
        var ar = Lt.transferToImageBitmap();
        try {
            Mt.createPattern(ar, "no-repeat")
        } catch {
            return !1
        }
        return !0
    }();
    function nt() {}
    function it(Lt) {
        var Mt = b.exports.Promise
          , ar = Mt !== void 0 ? Mt : g.Promise;
        return typeof ar == "function" ? new ar(Lt) : (Lt(nt, nt),
        null)
    }
    var ot = function(Lt, Mt) {
        return {
            transform: function(ar) {
                if (Lt)
                    return ar;
                if (Mt.has(ar))
                    return Mt.get(ar);
                var wr = new OffscreenCanvas(ar.width,ar.height)
                  , Tr = wr.getContext("2d");
                return Tr.drawImage(ar, 0, 0),
                Mt.set(ar, wr),
                wr
            },
            clear: function() {
                Mt.clear()
            }
        }
    }(rt, new Map)
      , at = function() {
        var Lt = Math.floor(16.666666666666668), Mt, ar, wr = {}, Tr = 0;
        return typeof requestAnimationFrame == "function" && typeof cancelAnimationFrame == "function" ? (Mt = function(Pr) {
            var kr = Math.random();
            return wr[kr] = requestAnimationFrame(function jr(cr) {
                Tr === cr || Tr + Lt - 1 < cr ? (Tr = cr,
                delete wr[kr],
                Pr()) : wr[kr] = requestAnimationFrame(jr)
            }),
            kr
        }
        ,
        ar = function(Pr) {
            wr[Pr] && cancelAnimationFrame(wr[Pr])
        }
        ) : (Mt = function(Pr) {
            return setTimeout(Pr, Lt)
        }
        ,
        ar = function(Pr) {
            return clearTimeout(Pr)
        }
        ),
        {
            frame: Mt,
            cancel: ar
        }
    }()
      , st = function() {
        var Lt, Mt, ar = {};
        function wr(Tr) {
            function Pr(kr, jr) {
                Tr.postMessage({
                    options: kr || {},
                    callback: jr
                })
            }
            Tr.init = function(jr) {
                var cr = jr.transferControlToOffscreen();
                Tr.postMessage({
                    canvas: cr
                }, [cr])
            }
            ,
            Tr.fire = function(jr, cr, dr) {
                if (Mt)
                    return Pr(jr, null),
                    Mt;
                var lr = Math.random().toString(36).slice(2);
                return Mt = it(function(ir) {
                    function gr(Cr) {
                        Cr.data.callback === lr && (delete ar[lr],
                        Tr.removeEventListener("message", gr),
                        Mt = null,
                        ot.clear(),
                        dr(),
                        ir())
                    }
                    Tr.addEventListener("message", gr),
                    Pr(jr, lr),
                    ar[lr] = gr.bind(null, {
                        data: {
                            callback: lr
                        }
                    })
                }),
                Mt
            }
            ,
            Tr.reset = function() {
                Tr.postMessage({
                    reset: !0
                });
                for (var jr in ar)
                    ar[jr](),
                    delete ar[jr]
            }
        }
        return function() {
            if (Lt)
                return Lt;
            if (!_ && et) {
                var Tr = ["var CONFETTI, SIZE = {}, module = {};", "(" + d.toString() + ")(this, module, true, SIZE);", "onmessage = function(msg) {", "  if (msg.data.options) {", "    CONFETTI(msg.data.options).then(function () {", "      if (msg.data.callback) {", "        postMessage({ callback: msg.data.callback });", "      }", "    });", "  } else if (msg.data.reset) {", "    CONFETTI && CONFETTI.reset();", "  } else if (msg.data.resize) {", "    SIZE.width = msg.data.resize.width;", "    SIZE.height = msg.data.resize.height;", "  } else if (msg.data.canvas) {", "    SIZE.width = msg.data.canvas.width;", "    SIZE.height = msg.data.canvas.height;", "    CONFETTI = module.exports.create(msg.data.canvas);", "  }", "}"].join(`
`);
                try {
                    Lt = new Worker(URL.createObjectURL(new Blob([Tr])))
                } catch (Pr) {
                    return typeof console !== void 0 && typeof console.warn == "function" && console.warn("🎊 Could not load worker", Pr),
                    null
                }
                wr(Lt)
            }
            return Lt
        }
    }()
      , dt = {
        particleCount: 50,
        angle: 90,
        spread: 45,
        startVelocity: 45,
        decay: .9,
        gravity: 1,
        drift: 0,
        ticks: 200,
        x: .5,
        y: .5,
        shapes: ["square", "circle"],
        zIndex: 100,
        colors: ["#26ccff", "#a25afd", "#ff5e7e", "#88ff5a", "#fcff42", "#ffa62d", "#ff36ff"],
        disableForReducedMotion: !1,
        scalar: 1
    };
    function ft(Lt, Mt) {
        return Mt ? Mt(Lt) : Lt
    }
    function ht(Lt) {
        return Lt != null
    }
    function xt(Lt, Mt, ar) {
        return ft(Lt && ht(Lt[Mt]) ? Lt[Mt] : dt[Mt], ar)
    }
    function lt(Lt) {
        return Lt < 0 ? 0 : Math.floor(Lt)
    }
    function ct(Lt, Mt) {
        return Math.floor(Math.random() * (Mt - Lt)) + Lt
    }
    function ut(Lt) {
        return parseInt(Lt, 16)
    }
    function pt(Lt) {
        return Lt.map(vt)
    }
    function vt(Lt) {
        var Mt = String(Lt).replace(/[^0-9a-f]/gi, "");
        return Mt.length < 6 && (Mt = Mt[0] + Mt[0] + Mt[1] + Mt[1] + Mt[2] + Mt[2]),
        {
            r: ut(Mt.substring(0, 2)),
            g: ut(Mt.substring(2, 4)),
            b: ut(Mt.substring(4, 6))
        }
    }
    function _t(Lt) {
        var Mt = xt(Lt, "origin", Object);
        return Mt.x = xt(Mt, "x", Number),
        Mt.y = xt(Mt, "y", Number),
        Mt
    }
    function Pt(Lt) {
        Lt.width = document.documentElement.clientWidth,
        Lt.height = document.documentElement.clientHeight
    }
    function kt(Lt) {
        var Mt = Lt.getBoundingClientRect();
        Lt.width = Mt.width,
        Lt.height = Mt.height
    }
    function $t(Lt) {
        var Mt = document.createElement("canvas");
        return Mt.style.position = "fixed",
        Mt.style.top = "0px",
        Mt.style.left = "0px",
        Mt.style.pointerEvents = "none",
        Mt.style.zIndex = Lt,
        Mt
    }
    function Wt(Lt, Mt, ar, wr, Tr, Pr, kr, jr, cr) {
        Lt.save(),
        Lt.translate(Mt, ar),
        Lt.rotate(Pr),
        Lt.scale(wr, Tr),
        Lt.arc(0, 0, 1, kr, jr, cr),
        Lt.restore()
    }
    function Ht(Lt) {
        var Mt = Lt.angle * (Math.PI / 180)
          , ar = Lt.spread * (Math.PI / 180);
        return {
            x: Lt.x,
            y: Lt.y,
            wobble: Math.random() * 10,
            wobbleSpeed: Math.min(.11, Math.random() * .1 + .05),
            velocity: Lt.startVelocity * .5 + Math.random() * Lt.startVelocity,
            angle2D: -Mt + (.5 * ar - Math.random() * ar),
            tiltAngle: (Math.random() * (.75 - .25) + .25) * Math.PI,
            color: Lt.color,
            shape: Lt.shape,
            tick: 0,
            totalTicks: Lt.ticks,
            decay: Lt.decay,
            drift: Lt.drift,
            random: Math.random() + 2,
            tiltSin: 0,
            tiltCos: 0,
            wobbleX: 0,
            wobbleY: 0,
            gravity: Lt.gravity * 3,
            ovalScalar: .6,
            scalar: Lt.scalar,
            flat: Lt.flat
        }
    }
    function Dt(Lt, Mt) {
        Mt.x += Math.cos(Mt.angle2D) * Mt.velocity + Mt.drift,
        Mt.y += Math.sin(Mt.angle2D) * Mt.velocity + Mt.gravity,
        Mt.velocity *= Mt.decay,
        Mt.flat ? (Mt.wobble = 0,
        Mt.wobbleX = Mt.x + 10 * Mt.scalar,
        Mt.wobbleY = Mt.y + 10 * Mt.scalar,
        Mt.tiltSin = 0,
        Mt.tiltCos = 0,
        Mt.random = 1) : (Mt.wobble += Mt.wobbleSpeed,
        Mt.wobbleX = Mt.x + 10 * Mt.scalar * Math.cos(Mt.wobble),
        Mt.wobbleY = Mt.y + 10 * Mt.scalar * Math.sin(Mt.wobble),
        Mt.tiltAngle += .1,
        Mt.tiltSin = Math.sin(Mt.tiltAngle),
        Mt.tiltCos = Math.cos(Mt.tiltAngle),
        Mt.random = Math.random() + 2);
        var ar = Mt.tick++ / Mt.totalTicks
          , wr = Mt.x + Mt.random * Mt.tiltCos
          , Tr = Mt.y + Mt.random * Mt.tiltSin
          , Pr = Mt.wobbleX + Mt.random * Mt.tiltCos
          , kr = Mt.wobbleY + Mt.random * Mt.tiltSin;
        if (Lt.fillStyle = "rgba(" + Mt.color.r + ", " + Mt.color.g + ", " + Mt.color.b + ", " + (1 - ar) + ")",
        Lt.beginPath(),
        tt && Mt.shape.type === "path" && typeof Mt.shape.path == "string" && Array.isArray(Mt.shape.matrix))
            Lt.fill(qt(Mt.shape.path, Mt.shape.matrix, Mt.x, Mt.y, Math.abs(Pr - wr) * .1, Math.abs(kr - Tr) * .1, Math.PI / 10 * Mt.wobble));
        else if (Mt.shape.type === "bitmap") {
            var jr = Math.PI / 10 * Mt.wobble
              , cr = Math.abs(Pr - wr) * .1
              , dr = Math.abs(kr - Tr) * .1
              , lr = Mt.shape.bitmap.width * Mt.scalar
              , ir = Mt.shape.bitmap.height * Mt.scalar
              , gr = new DOMMatrix([Math.cos(jr) * cr, Math.sin(jr) * cr, -Math.sin(jr) * dr, Math.cos(jr) * dr, Mt.x, Mt.y]);
            gr.multiplySelf(new DOMMatrix(Mt.shape.matrix));
            var Cr = Lt.createPattern(ot.transform(Mt.shape.bitmap), "no-repeat");
            Cr.setTransform(gr),
            Lt.globalAlpha = 1 - ar,
            Lt.fillStyle = Cr,
            Lt.fillRect(Mt.x - lr / 2, Mt.y - ir / 2, lr, ir),
            Lt.globalAlpha = 1
        } else if (Mt.shape === "circle")
            Lt.ellipse ? Lt.ellipse(Mt.x, Mt.y, Math.abs(Pr - wr) * Mt.ovalScalar, Math.abs(kr - Tr) * Mt.ovalScalar, Math.PI / 10 * Mt.wobble, 0, 2 * Math.PI) : Wt(Lt, Mt.x, Mt.y, Math.abs(Pr - wr) * Mt.ovalScalar, Math.abs(kr - Tr) * Mt.ovalScalar, Math.PI / 10 * Mt.wobble, 0, 2 * Math.PI);
        else if (Mt.shape === "star")
            for (var hr = Math.PI / 2 * 3, zr = 4 * Mt.scalar, Zr = 8 * Mt.scalar, ln = Mt.x, Gr = Mt.y, vn = 5, fn = Math.PI / vn; vn--; )
                ln = Mt.x + Math.cos(hr) * Zr,
                Gr = Mt.y + Math.sin(hr) * Zr,
                Lt.lineTo(ln, Gr),
                hr += fn,
                ln = Mt.x + Math.cos(hr) * zr,
                Gr = Mt.y + Math.sin(hr) * zr,
                Lt.lineTo(ln, Gr),
                hr += fn;
        else
            Lt.moveTo(Math.floor(Mt.x), Math.floor(Mt.y)),
            Lt.lineTo(Math.floor(Mt.wobbleX), Math.floor(Tr)),
            Lt.lineTo(Math.floor(Pr), Math.floor(kr)),
            Lt.lineTo(Math.floor(wr), Math.floor(Mt.wobbleY));
        return Lt.closePath(),
        Lt.fill(),
        Mt.tick < Mt.totalTicks
    }
    function Vt(Lt, Mt, ar, wr, Tr) {
        var Pr = Mt.slice(), kr = Lt.getContext("2d"), jr, cr, dr = it(function(lr) {
            function ir() {
                jr = cr = null,
                kr.clearRect(0, 0, wr.width, wr.height),
                ot.clear(),
                Tr(),
                lr()
            }
            function gr() {
                _ && !(wr.width === $.width && wr.height === $.height) && (wr.width = Lt.width = $.width,
                wr.height = Lt.height = $.height),
                !wr.width && !wr.height && (ar(Lt),
                wr.width = Lt.width,
                wr.height = Lt.height),
                kr.clearRect(0, 0, wr.width, wr.height),
                Pr = Pr.filter(function(Cr) {
                    return Dt(kr, Cr)
                }),
                Pr.length ? jr = at.frame(gr) : ir()
            }
            jr = at.frame(gr),
            cr = ir
        });
        return {
            addFettis: function(lr) {
                return Pr = Pr.concat(lr),
                dr
            },
            canvas: Lt,
            promise: dr,
            reset: function() {
                jr && at.cancel(jr),
                cr && cr()
            }
        }
    }
    function Ft(Lt, Mt) {
        var ar = !Lt, wr = !!xt(Mt || {}, "resize"), Tr = !1, Pr = xt(Mt, "disableForReducedMotion", Boolean), kr = et && !!xt(Mt || {}, "useWorker"), jr = kr ? st() : null, cr = ar ? Pt : kt, dr = Lt && jr ? !!Lt.__confetti_initialized : !1, lr = typeof matchMedia == "function" && matchMedia("(prefers-reduced-motion)").matches, ir;
        function gr(hr, zr, Zr) {
            for (var ln = xt(hr, "particleCount", lt), Gr = xt(hr, "angle", Number), vn = xt(hr, "spread", Number), fn = xt(hr, "startVelocity", Number), Rn = xt(hr, "decay", Number), bn = xt(hr, "gravity", Number), Un = xt(hr, "drift", Number), zn = xt(hr, "colors", pt), er = xt(hr, "ticks", Number), Ut = xt(hr, "shapes"), Ct = xt(hr, "scalar"), yt = !!xt(hr, "flat"), bt = _t(hr), At = ln, Gt = [], Qt = Lt.width * bt.x, rr = Lt.height * bt.y; At--; )
                Gt.push(Ht({
                    x: Qt,
                    y: rr,
                    angle: Gr,
                    spread: vn,
                    startVelocity: fn,
                    color: zn[At % zn.length],
                    shape: Ut[ct(0, Ut.length)],
                    ticks: er,
                    decay: Rn,
                    gravity: bn,
                    drift: Un,
                    scalar: Ct,
                    flat: yt
                }));
            return ir ? ir.addFettis(Gt) : (ir = Vt(Lt, Gt, cr, zr, Zr),
            ir.promise)
        }
        function Cr(hr) {
            var zr = Pr || xt(hr, "disableForReducedMotion", Boolean)
              , Zr = xt(hr, "zIndex", Number);
            if (zr && lr)
                return it(function(fn) {
                    fn()
                });
            ar && ir ? Lt = ir.canvas : ar && !Lt && (Lt = $t(Zr),
            document.body.appendChild(Lt)),
            wr && !dr && cr(Lt);
            var ln = {
                width: Lt.width,
                height: Lt.height
            };
            jr && !dr && jr.init(Lt),
            dr = !0,
            jr && (Lt.__confetti_initialized = !0);
            function Gr() {
                if (jr) {
                    var fn = {
                        getBoundingClientRect: function() {
                            if (!ar)
                                return Lt.getBoundingClientRect()
                        }
                    };
                    cr(fn),
                    jr.postMessage({
                        resize: {
                            width: fn.width,
                            height: fn.height
                        }
                    });
                    return
                }
                ln.width = ln.height = null
            }
            function vn() {
                ir = null,
                wr && (Tr = !1,
                g.removeEventListener("resize", Gr)),
                ar && Lt && (document.body.contains(Lt) && document.body.removeChild(Lt),
                Lt = null,
                dr = !1)
            }
            return wr && !Tr && (Tr = !0,
            g.addEventListener("resize", Gr, !1)),
            jr ? jr.fire(hr, ln, vn) : gr(hr, ln, vn)
        }
        return Cr.reset = function() {
            jr && jr.reset(),
            ir && ir.reset()
        }
        ,
        Cr
    }
    var Kt;
    function Rt() {
        return Kt || (Kt = Ft(null, {
            useWorker: !0,
            resize: !0
        })),
        Kt
    }
    function qt(Lt, Mt, ar, wr, Tr, Pr, kr) {
        var jr = new Path2D(Lt)
          , cr = new Path2D;
        cr.addPath(jr, new DOMMatrix(Mt));
        var dr = new Path2D;
        return dr.addPath(cr, new DOMMatrix([Math.cos(kr) * Tr, Math.sin(kr) * Tr, -Math.sin(kr) * Pr, Math.cos(kr) * Pr, ar, wr])),
        dr
    }
    function Et(Lt) {
        if (!tt)
            throw new Error("path confetti are not supported in this browser");
        var Mt, ar;
        typeof Lt == "string" ? Mt = Lt : (Mt = Lt.path,
        ar = Lt.matrix);
        var wr = new Path2D(Mt)
          , Tr = document.createElement("canvas")
          , Pr = Tr.getContext("2d");
        if (!ar) {
            for (var kr = 1e3, jr = kr, cr = kr, dr = 0, lr = 0, ir, gr, Cr = 0; Cr < kr; Cr += 2)
                for (var hr = 0; hr < kr; hr += 2)
                    Pr.isPointInPath(wr, Cr, hr, "nonzero") && (jr = Math.min(jr, Cr),
                    cr = Math.min(cr, hr),
                    dr = Math.max(dr, Cr),
                    lr = Math.max(lr, hr));
            ir = dr - jr,
            gr = lr - cr;
            var zr = 10
              , Zr = Math.min(zr / ir, zr / gr);
            ar = [Zr, 0, 0, Zr, -Math.round(ir / 2 + jr) * Zr, -Math.round(gr / 2 + cr) * Zr]
        }
        return {
            type: "path",
            path: Mt,
            matrix: ar
        }
    }
    function St(Lt) {
        var Mt, ar = 1, wr = "#000000", Tr = '"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "Twemoji Mozilla", "system emoji", sans-serif';
        typeof Lt == "string" ? Mt = Lt : (Mt = Lt.text,
        ar = "scalar"in Lt ? Lt.scalar : ar,
        Tr = "fontFamily"in Lt ? Lt.fontFamily : Tr,
        wr = "color"in Lt ? Lt.color : wr);
        var Pr = 10 * ar
          , kr = "" + Pr + "px " + Tr
          , jr = new OffscreenCanvas(Pr,Pr)
          , cr = jr.getContext("2d");
        cr.font = kr;
        var dr = cr.measureText(Mt)
          , lr = Math.ceil(dr.actualBoundingBoxRight + dr.actualBoundingBoxLeft)
          , ir = Math.ceil(dr.actualBoundingBoxAscent + dr.actualBoundingBoxDescent)
          , gr = 2
          , Cr = dr.actualBoundingBoxLeft + gr
          , hr = dr.actualBoundingBoxAscent + gr;
        lr += gr + gr,
        ir += gr + gr,
        jr = new OffscreenCanvas(lr,ir),
        cr = jr.getContext("2d"),
        cr.font = kr,
        cr.fillStyle = wr,
        cr.fillText(Mt, Cr, hr);
        var zr = 1 / ar;
        return {
            type: "bitmap",
            bitmap: jr.transferToImageBitmap(),
            matrix: [zr, 0, 0, zr, -lr * zr / 2, -ir * zr / 2]
        }
    }
    b.exports = function() {
        return Rt().apply(this, arguments)
    }
    ,
    b.exports.reset = function() {
        Rt().reset()
    }
    ,
    b.exports.create = Ft,
    b.exports.shapeFromPath = Et,
    b.exports.shapeFromText = St
}
)(function() {
    return typeof window < "u" ? window : typeof self < "u" ? self : this || {}
}(), module, !1);
const confetti = module.exports;
module.exports.create;
var dist = {}
  , _extends = {}
  , _global = {
    exports: {}
}
  , global$5 = _global.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
typeof __g == "number" && (__g = global$5);
var _globalExports = _global.exports
  , _core = {
    exports: {}
}
  , core$4 = _core.exports = {
    version: "2.6.12"
};
typeof __e == "number" && (__e = core$4);
var _coreExports = _core.exports, _aFunction = function(d) {
    if (typeof d != "function")
        throw TypeError(d + " is not a function!");
    return d
}, aFunction = _aFunction, _ctx = function(d, g, b) {
    if (aFunction(d),
    g === void 0)
        return d;
    switch (b) {
    case 1:
        return function(_) {
            return d.call(g, _)
        }
        ;
    case 2:
        return function(_, $) {
            return d.call(g, _, $)
        }
        ;
    case 3:
        return function(_, $, et) {
            return d.call(g, _, $, et)
        }
    }
    return function() {
        return d.apply(g, arguments)
    }
}, _objectDp = {}, _isObject = function(d) {
    return typeof d == "object" ? d !== null : typeof d == "function"
}, isObject$3 = _isObject, _anObject = function(d) {
    if (!isObject$3(d))
        throw TypeError(d + " is not an object!");
    return d
}, _fails = function(d) {
    try {
        return !!d()
    } catch {
        return !0
    }
}, _descriptors = !_fails(function() {
    return Object.defineProperty({}, "a", {
        get: function() {
            return 7
        }
    }).a != 7
}), _domCreate, hasRequired_domCreate;
function require_domCreate() {
    if (hasRequired_domCreate)
        return _domCreate;
    hasRequired_domCreate = 1;
    var d = _isObject
      , g = _globalExports.document
      , b = d(g) && d(g.createElement);
    return _domCreate = function(_) {
        return b ? g.createElement(_) : {}
    }
    ,
    _domCreate
}
var _ie8DomDefine = !_descriptors && !_fails(function() {
    return Object.defineProperty(require_domCreate()("div"), "a", {
        get: function() {
            return 7
        }
    }).a != 7
})
  , isObject$2 = _isObject
  , _toPrimitive = function(d, g) {
    if (!isObject$2(d))
        return d;
    var b, _;
    if (g && typeof (b = d.toString) == "function" && !isObject$2(_ = b.call(d)) || typeof (b = d.valueOf) == "function" && !isObject$2(_ = b.call(d)) || !g && typeof (b = d.toString) == "function" && !isObject$2(_ = b.call(d)))
        return _;
    throw TypeError("Can't convert object to primitive value")
}
  , anObject$3 = _anObject
  , IE8_DOM_DEFINE$1 = _ie8DomDefine
  , toPrimitive$2 = _toPrimitive
  , dP$3 = Object.defineProperty;
_objectDp.f = _descriptors ? Object.defineProperty : function(g, b, _) {
    if (anObject$3(g),
    b = toPrimitive$2(b, !0),
    anObject$3(_),
    IE8_DOM_DEFINE$1)
        try {
            return dP$3(g, b, _)
        } catch {}
    if ("get"in _ || "set"in _)
        throw TypeError("Accessors not supported!");
    return "value"in _ && (g[b] = _.value),
    g
}
;
var _propertyDesc = function(d, g) {
    return {
        enumerable: !(d & 1),
        configurable: !(d & 2),
        writable: !(d & 4),
        value: g
    }
}
  , dP$2 = _objectDp
  , createDesc$2 = _propertyDesc
  , _hide = _descriptors ? function(d, g, b) {
    return dP$2.f(d, g, createDesc$2(1, b))
}
: function(d, g, b) {
    return d[g] = b,
    d
}
  , hasOwnProperty = {}.hasOwnProperty
  , _has = function(d, g) {
    return hasOwnProperty.call(d, g)
}
  , global$4 = _globalExports
  , core$3 = _coreExports
  , ctx = _ctx
  , hide$2 = _hide
  , has$6 = _has
  , PROTOTYPE$2 = "prototype"
  , $export$7 = function(d, g, b) {
    var _ = d & $export$7.F, $ = d & $export$7.G, et = d & $export$7.S, tt = d & $export$7.P, rt = d & $export$7.B, nt = d & $export$7.W, it = $ ? core$3 : core$3[g] || (core$3[g] = {}), ot = it[PROTOTYPE$2], at = $ ? global$4 : et ? global$4[g] : (global$4[g] || {})[PROTOTYPE$2], st, dt, ft;
    $ && (b = g);
    for (st in b)
        dt = !_ && at && at[st] !== void 0,
        !(dt && has$6(it, st)) && (ft = dt ? at[st] : b[st],
        it[st] = $ && typeof at[st] != "function" ? b[st] : rt && dt ? ctx(ft, global$4) : nt && at[st] == ft ? function(ht) {
            var xt = function(lt, ct, ut) {
                if (this instanceof ht) {
                    switch (arguments.length) {
                    case 0:
                        return new ht;
                    case 1:
                        return new ht(lt);
                    case 2:
                        return new ht(lt,ct)
                    }
                    return new ht(lt,ct,ut)
                }
                return ht.apply(this, arguments)
            };
            return xt[PROTOTYPE$2] = ht[PROTOTYPE$2],
            xt
        }(ft) : tt && typeof ft == "function" ? ctx(Function.call, ft) : ft,
        tt && ((it.virtual || (it.virtual = {}))[st] = ft,
        d & $export$7.R && ot && !ot[st] && hide$2(ot, st, ft)))
};
$export$7.F = 1;
$export$7.G = 2;
$export$7.S = 4;
$export$7.P = 8;
$export$7.B = 16;
$export$7.W = 32;
$export$7.U = 64;
$export$7.R = 128;
var _export = $export$7, toString$1 = {}.toString, _cof = function(d) {
    return toString$1.call(d).slice(8, -1)
}, _iobject, hasRequired_iobject;
function require_iobject() {
    if (hasRequired_iobject)
        return _iobject;
    hasRequired_iobject = 1;
    var d = _cof;
    return _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(g) {
        return d(g) == "String" ? g.split("") : Object(g)
    }
    ,
    _iobject
}
var _defined = function(d) {
    if (d == null)
        throw TypeError("Can't call method on  " + d);
    return d
}
  , IObject = require_iobject()
  , defined$2 = _defined
  , _toIobject = function(d) {
    return IObject(defined$2(d))
}
  , ceil = Math.ceil
  , floor = Math.floor
  , _toInteger = function(d) {
    return isNaN(d = +d) ? 0 : (d > 0 ? floor : ceil)(d)
}
  , toInteger$2 = _toInteger
  , min$1 = Math.min
  , _toLength = function(d) {
    return d > 0 ? min$1(toInteger$2(d), 9007199254740991) : 0
}
  , toInteger$1 = _toInteger
  , max = Math.max
  , min = Math.min
  , _toAbsoluteIndex = function(d, g) {
    return d = toInteger$1(d),
    d < 0 ? max(d + g, 0) : min(d, g)
}
  , toIObject$5 = _toIobject
  , toLength = _toLength
  , toAbsoluteIndex = _toAbsoluteIndex
  , _arrayIncludes = function(d) {
    return function(g, b, _) {
        var $ = toIObject$5(g), et = toLength($.length), tt = toAbsoluteIndex(_, et), rt;
        if (d && b != b) {
            for (; et > tt; )
                if (rt = $[tt++],
                rt != rt)
                    return !0
        } else
            for (; et > tt; tt++)
                if ((d || tt in $) && $[tt] === b)
                    return d || tt || 0;
        return !d && -1
    }
}
  , _shared = {
    exports: {}
}
  , _library = !0
  , core$2 = _coreExports
  , global$3 = _globalExports
  , SHARED = "__core-js_shared__"
  , store$1 = global$3[SHARED] || (global$3[SHARED] = {});
(_shared.exports = function(d, g) {
    return store$1[d] || (store$1[d] = g !== void 0 ? g : {})
}
)("versions", []).push({
    version: core$2.version,
    mode: "pure",
    copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
});
var _sharedExports = _shared.exports
  , id$1 = 0
  , px = Math.random()
  , _uid = function(d) {
    return "Symbol(".concat(d === void 0 ? "" : d, ")_", (++id$1 + px).toString(36))
}
  , shared$1 = _sharedExports("keys")
  , uid$2 = _uid
  , _sharedKey = function(d) {
    return shared$1[d] || (shared$1[d] = uid$2(d))
}
  , has$5 = _has
  , toIObject$4 = _toIobject
  , arrayIndexOf = _arrayIncludes(!1)
  , IE_PROTO$2 = _sharedKey("IE_PROTO")
  , _objectKeysInternal = function(d, g) {
    var b = toIObject$4(d), _ = 0, $ = [], et;
    for (et in b)
        et != IE_PROTO$2 && has$5(b, et) && $.push(et);
    for (; g.length > _; )
        has$5(b, et = g[_++]) && (~arrayIndexOf($, et) || $.push(et));
    return $
}
  , _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
  , $keys$2 = _objectKeysInternal
  , enumBugKeys$1 = _enumBugKeys
  , _objectKeys = Object.keys || function(g) {
    return $keys$2(g, enumBugKeys$1)
}
  , _objectGops = {};
_objectGops.f = Object.getOwnPropertySymbols;
var _objectPie = {}, hasRequired_objectPie;
function require_objectPie() {
    return hasRequired_objectPie || (hasRequired_objectPie = 1,
    _objectPie.f = {}.propertyIsEnumerable),
    _objectPie
}
var defined$1 = _defined, _toObject = function(d) {
    return Object(defined$1(d))
}, _objectAssign, hasRequired_objectAssign;
function require_objectAssign() {
    if (hasRequired_objectAssign)
        return _objectAssign;
    hasRequired_objectAssign = 1;
    var d = _descriptors
      , g = _objectKeys
      , b = _objectGops
      , _ = require_objectPie()
      , $ = _toObject
      , et = require_iobject()
      , tt = Object.assign;
    return _objectAssign = !tt || _fails(function() {
        var rt = {}
          , nt = {}
          , it = Symbol()
          , ot = "abcdefghijklmnopqrst";
        return rt[it] = 7,
        ot.split("").forEach(function(at) {
            nt[at] = at
        }),
        tt({}, rt)[it] != 7 || Object.keys(tt({}, nt)).join("") != ot
    }) ? function(nt, it) {
        for (var ot = $(nt), at = arguments.length, st = 1, dt = b.f, ft = _.f; at > st; )
            for (var ht = et(arguments[st++]), xt = dt ? g(ht).concat(dt(ht)) : g(ht), lt = xt.length, ct = 0, ut; lt > ct; )
                ut = xt[ct++],
                (!d || ft.call(ht, ut)) && (ot[ut] = ht[ut]);
        return ot
    }
    : tt,
    _objectAssign
}
var $export$6 = _export;
$export$6($export$6.S + $export$6.F, "Object", {
    assign: require_objectAssign()
});
var assign$1 = _coreExports.Object.assign
  , assign = {
    default: assign$1,
    __esModule: !0
};
_extends.__esModule = !0;
var _assign = assign
  , _assign2 = _interopRequireDefault$5(_assign);
function _interopRequireDefault$5(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
_extends.default = _assign2.default || function(d) {
    for (var g = 1; g < arguments.length; g++) {
        var b = arguments[g];
        for (var _ in b)
            Object.prototype.hasOwnProperty.call(b, _) && (d[_] = b[_])
    }
    return d
}
;
var has$4 = _has
  , toObject$2 = _toObject
  , IE_PROTO$1 = _sharedKey("IE_PROTO")
  , ObjectProto$1 = Object.prototype
  , _objectGpo = Object.getPrototypeOf || function(d) {
    return d = toObject$2(d),
    has$4(d, IE_PROTO$1) ? d[IE_PROTO$1] : typeof d.constructor == "function" && d instanceof d.constructor ? d.constructor.prototype : d instanceof Object ? ObjectProto$1 : null
}
  , $export$5 = _export
  , core$1 = _coreExports
  , fails = _fails
  , _objectSap = function(d, g) {
    var b = (core$1.Object || {})[d] || Object[d]
      , _ = {};
    _[d] = g(b),
    $export$5($export$5.S + $export$5.F * fails(function() {
        b(1)
    }), "Object", _)
}
  , toObject$1 = _toObject
  , $getPrototypeOf = _objectGpo;
_objectSap("getPrototypeOf", function() {
    return function(g) {
        return $getPrototypeOf(toObject$1(g))
    }
});
var getPrototypeOf$2 = _coreExports.Object.getPrototypeOf
  , getPrototypeOf$1 = {
    default: getPrototypeOf$2,
    __esModule: !0
}
  , classCallCheck = {};
classCallCheck.__esModule = !0;
classCallCheck.default = function(d, g) {
    if (!(d instanceof g))
        throw new TypeError("Cannot call a class as a function")
}
;
var createClass = {}
  , $export$4 = _export;
$export$4($export$4.S + $export$4.F * !_descriptors, "Object", {
    defineProperty: _objectDp.f
});
var $Object$1 = _coreExports.Object
  , defineProperty$2 = function(g, b, _) {
    return $Object$1.defineProperty(g, b, _)
}
  , defineProperty$1 = {
    default: defineProperty$2,
    __esModule: !0
};
createClass.__esModule = !0;
var _defineProperty = defineProperty$1
  , _defineProperty2 = _interopRequireDefault$4(_defineProperty);
function _interopRequireDefault$4(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
createClass.default = function() {
    function d(g, b) {
        for (var _ = 0; _ < b.length; _++) {
            var $ = b[_];
            $.enumerable = $.enumerable || !1,
            $.configurable = !0,
            "value"in $ && ($.writable = !0),
            (0,
            _defineProperty2.default)(g, $.key, $)
        }
    }
    return function(g, b, _) {
        return b && d(g.prototype, b),
        _ && d(g, _),
        g
    }
}();
var possibleConstructorReturn = {}, _typeof$1 = {}, toInteger = _toInteger, defined = _defined, _stringAt = function(d) {
    return function(g, b) {
        var _ = String(defined(g)), $ = toInteger(b), et = _.length, tt, rt;
        return $ < 0 || $ >= et ? d ? "" : void 0 : (tt = _.charCodeAt($),
        tt < 55296 || tt > 56319 || $ + 1 === et || (rt = _.charCodeAt($ + 1)) < 56320 || rt > 57343 ? d ? _.charAt($) : tt : d ? _.slice($, $ + 2) : (tt - 55296 << 10) + (rt - 56320) + 65536)
    }
}, _redefine = _hide, _iterators = {}, dP$1 = _objectDp, anObject$2 = _anObject, getKeys$1 = _objectKeys, _objectDps = _descriptors ? Object.defineProperties : function(g, b) {
    anObject$2(g);
    for (var _ = getKeys$1(b), $ = _.length, et = 0, tt; $ > et; )
        dP$1.f(g, tt = _[et++], b[tt]);
    return g
}
, _html, hasRequired_html;
function require_html() {
    if (hasRequired_html)
        return _html;
    hasRequired_html = 1;
    var d = _globalExports.document;
    return _html = d && d.documentElement,
    _html
}
var anObject$1 = _anObject
  , dPs = _objectDps
  , enumBugKeys = _enumBugKeys
  , IE_PROTO = _sharedKey("IE_PROTO")
  , Empty = function() {}
  , PROTOTYPE$1 = "prototype"
  , createDict = function() {
    var d = require_domCreate()("iframe"), g = enumBugKeys.length, b = "<", _ = ">", $;
    for (d.style.display = "none",
    require_html().appendChild(d),
    d.src = "javascript:",
    $ = d.contentWindow.document,
    $.open(),
    $.write(b + "script" + _ + "document.F=Object" + b + "/script" + _),
    $.close(),
    createDict = $.F; g--; )
        delete createDict[PROTOTYPE$1][enumBugKeys[g]];
    return createDict()
}
  , _objectCreate = Object.create || function(g, b) {
    var _;
    return g !== null ? (Empty[PROTOTYPE$1] = anObject$1(g),
    _ = new Empty,
    Empty[PROTOTYPE$1] = null,
    _[IE_PROTO] = g) : _ = createDict(),
    b === void 0 ? _ : dPs(_, b)
}
  , _wks = {
    exports: {}
}
  , store = _sharedExports("wks")
  , uid$1 = _uid
  , Symbol$1 = _globalExports.Symbol
  , USE_SYMBOL = typeof Symbol$1 == "function"
  , $exports = _wks.exports = function(d) {
    return store[d] || (store[d] = USE_SYMBOL && Symbol$1[d] || (USE_SYMBOL ? Symbol$1 : uid$1)("Symbol." + d))
}
;
$exports.store = store;
var _wksExports = _wks.exports
  , def = _objectDp.f
  , has$3 = _has
  , TAG = _wksExports("toStringTag")
  , _setToStringTag = function(d, g, b) {
    d && !has$3(d = b ? d : d.prototype, TAG) && def(d, TAG, {
        configurable: !0,
        value: g
    })
}
  , create$2 = _objectCreate
  , descriptor = _propertyDesc
  , setToStringTag$2 = _setToStringTag
  , IteratorPrototype = {};
_hide(IteratorPrototype, _wksExports("iterator"), function() {
    return this
});
var _iterCreate = function(d, g, b) {
    d.prototype = create$2(IteratorPrototype, {
        next: descriptor(1, b)
    }),
    setToStringTag$2(d, g + " Iterator")
}
  , $export$3 = _export
  , redefine$1 = _redefine
  , hide$1 = _hide
  , Iterators$2 = _iterators
  , $iterCreate = _iterCreate
  , setToStringTag$1 = _setToStringTag
  , getPrototypeOf = _objectGpo
  , ITERATOR = _wksExports("iterator")
  , BUGGY = !([].keys && "next"in [].keys())
  , FF_ITERATOR = "@@iterator"
  , KEYS = "keys"
  , VALUES = "values"
  , returnThis = function() {
    return this
}
  , _iterDefine = function(d, g, b, _, $, et, tt) {
    $iterCreate(b, g, _);
    var rt = function(ut) {
        if (!BUGGY && ut in at)
            return at[ut];
        switch (ut) {
        case KEYS:
            return function() {
                return new b(this,ut)
            }
            ;
        case VALUES:
            return function() {
                return new b(this,ut)
            }
        }
        return function() {
            return new b(this,ut)
        }
    }, nt = g + " Iterator", it = $ == VALUES, ot = !1, at = d.prototype, st = at[ITERATOR] || at[FF_ITERATOR] || $ && at[$], dt = st || rt($), ft = $ ? it ? rt("entries") : dt : void 0, ht = g == "Array" && at.entries || st, xt, lt, ct;
    if (ht && (ct = getPrototypeOf(ht.call(new d)),
    ct !== Object.prototype && ct.next && setToStringTag$1(ct, nt, !0)),
    it && st && st.name !== VALUES && (ot = !0,
    dt = function() {
        return st.call(this)
    }
    ),
    tt && (BUGGY || ot || !at[ITERATOR]) && hide$1(at, ITERATOR, dt),
    Iterators$2[g] = dt,
    Iterators$2[nt] = returnThis,
    $)
        if (xt = {
            values: it ? dt : rt(VALUES),
            keys: et ? dt : rt(KEYS),
            entries: ft
        },
        tt)
            for (lt in xt)
                lt in at || redefine$1(at, lt, xt[lt]);
        else
            $export$3($export$3.P + $export$3.F * (BUGGY || ot), g, xt);
    return xt
}
  , $at = _stringAt(!0);
_iterDefine(String, "String", function(d) {
    this._t = String(d),
    this._i = 0
}, function() {
    var d = this._t, g = this._i, b;
    return g >= d.length ? {
        value: void 0,
        done: !0
    } : (b = $at(d, g),
    this._i += b.length,
    {
        value: b,
        done: !1
    })
});
var _iterStep = function(d, g) {
    return {
        value: g,
        done: !!d
    }
}
  , step = _iterStep
  , Iterators$1 = _iterators
  , toIObject$3 = _toIobject;
_iterDefine(Array, "Array", function(d, g) {
    this._t = toIObject$3(d),
    this._i = 0,
    this._k = g
}, function() {
    var d = this._t
      , g = this._k
      , b = this._i++;
    return !d || b >= d.length ? (this._t = void 0,
    step(1)) : g == "keys" ? step(0, b) : g == "values" ? step(0, d[b]) : step(0, [b, d[b]])
}, "values");
Iterators$1.Arguments = Iterators$1.Array;
var global$2 = _globalExports
  , hide = _hide
  , Iterators = _iterators
  , TO_STRING_TAG = _wksExports("toStringTag")
  , DOMIterables = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(",");
for (var i = 0; i < DOMIterables.length; i++) {
    var NAME = DOMIterables[i]
      , Collection = global$2[NAME]
      , proto = Collection && Collection.prototype;
    proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME),
    Iterators[NAME] = Iterators.Array
}
var _wksExt = {};
_wksExt.f = _wksExports;
var iterator$1 = _wksExt.f("iterator")
  , iterator = {
    default: iterator$1,
    __esModule: !0
}
  , _meta = {
    exports: {}
}
  , META$1 = _uid("meta")
  , isObject$1 = _isObject
  , has$2 = _has
  , setDesc = _objectDp.f
  , id = 0
  , isExtensible = Object.isExtensible || function() {
    return !0
}
  , FREEZE = !_fails(function() {
    return isExtensible(Object.preventExtensions({}))
})
  , setMeta = function(d) {
    setDesc(d, META$1, {
        value: {
            i: "O" + ++id,
            w: {}
        }
    })
}
  , fastKey = function(d, g) {
    if (!isObject$1(d))
        return typeof d == "symbol" ? d : (typeof d == "string" ? "S" : "P") + d;
    if (!has$2(d, META$1)) {
        if (!isExtensible(d))
            return "F";
        if (!g)
            return "E";
        setMeta(d)
    }
    return d[META$1].i
}
  , getWeak = function(d, g) {
    if (!has$2(d, META$1)) {
        if (!isExtensible(d))
            return !0;
        if (!g)
            return !1;
        setMeta(d)
    }
    return d[META$1].w
}
  , onFreeze = function(d) {
    return FREEZE && meta.NEED && isExtensible(d) && !has$2(d, META$1) && setMeta(d),
    d
}
  , meta = _meta.exports = {
    KEY: META$1,
    NEED: !1,
    fastKey,
    getWeak,
    onFreeze
}
  , _metaExports = _meta.exports
  , core = _coreExports
  , wksExt$1 = _wksExt
  , defineProperty = _objectDp.f
  , _wksDefine = function(d) {
    var g = core.Symbol || (core.Symbol = {});
    d.charAt(0) != "_" && !(d in g) && defineProperty(g, d, {
        value: wksExt$1.f(d)
    })
}
  , getKeys = _objectKeys
  , gOPS = _objectGops
  , pIE$1 = require_objectPie()
  , _enumKeys = function(d) {
    var g = getKeys(d)
      , b = gOPS.f;
    if (b)
        for (var _ = b(d), $ = pIE$1.f, et = 0, tt; _.length > et; )
            $.call(d, tt = _[et++]) && g.push(tt);
    return g
}
  , cof = _cof
  , _isArray = Array.isArray || function(g) {
    return cof(g) == "Array"
}
  , _objectGopnExt = {}
  , _objectGopn = {}
  , $keys$1 = _objectKeysInternal
  , hiddenKeys = _enumBugKeys.concat("length", "prototype");
_objectGopn.f = Object.getOwnPropertyNames || function(g) {
    return $keys$1(g, hiddenKeys)
}
;
var toIObject$2 = _toIobject
  , gOPN$1 = _objectGopn.f
  , toString = {}.toString
  , windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , getWindowNames = function(d) {
    try {
        return gOPN$1(d)
    } catch {
        return windowNames.slice()
    }
};
_objectGopnExt.f = function(g) {
    return windowNames && toString.call(g) == "[object Window]" ? getWindowNames(g) : gOPN$1(toIObject$2(g))
}
;
var _objectGopd = {}
  , pIE = require_objectPie()
  , createDesc$1 = _propertyDesc
  , toIObject$1 = _toIobject
  , toPrimitive$1 = _toPrimitive
  , has$1 = _has
  , IE8_DOM_DEFINE = _ie8DomDefine
  , gOPD$1 = Object.getOwnPropertyDescriptor;
_objectGopd.f = _descriptors ? gOPD$1 : function(g, b) {
    if (g = toIObject$1(g),
    b = toPrimitive$1(b, !0),
    IE8_DOM_DEFINE)
        try {
            return gOPD$1(g, b)
        } catch {}
    if (has$1(g, b))
        return createDesc$1(!pIE.f.call(g, b), g[b])
}
;
var global$1 = _globalExports
  , has = _has
  , DESCRIPTORS = _descriptors
  , $export$2 = _export
  , redefine = _redefine
  , META = _metaExports.KEY
  , $fails = _fails
  , shared = _sharedExports
  , setToStringTag = _setToStringTag
  , uid = _uid
  , wks = _wksExports
  , wksExt = _wksExt
  , wksDefine = _wksDefine
  , enumKeys = _enumKeys
  , isArray = _isArray
  , anObject = _anObject
  , isObject = _isObject
  , toObject = _toObject
  , toIObject = _toIobject
  , toPrimitive = _toPrimitive
  , createDesc = _propertyDesc
  , _create$1 = _objectCreate
  , gOPNExt = _objectGopnExt
  , $GOPD = _objectGopd
  , $GOPS = _objectGops
  , $DP = _objectDp
  , $keys = _objectKeys
  , gOPD = $GOPD.f
  , dP = $DP.f
  , gOPN = gOPNExt.f
  , $Symbol = global$1.Symbol
  , $JSON = global$1.JSON
  , _stringify = $JSON && $JSON.stringify
  , PROTOTYPE = "prototype"
  , HIDDEN = wks("_hidden")
  , TO_PRIMITIVE = wks("toPrimitive")
  , isEnum = {}.propertyIsEnumerable
  , SymbolRegistry = shared("symbol-registry")
  , AllSymbols = shared("symbols")
  , OPSymbols = shared("op-symbols")
  , ObjectProto = Object[PROTOTYPE]
  , USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f
  , QObject = global$1.QObject
  , setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild
  , setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create$1(dP({}, "a", {
        get: function() {
            return dP(this, "a", {
                value: 7
            }).a
        }
    })).a != 7
}) ? function(d, g, b) {
    var _ = gOPD(ObjectProto, g);
    _ && delete ObjectProto[g],
    dP(d, g, b),
    _ && d !== ObjectProto && dP(ObjectProto, g, _)
}
: dP
  , wrap = function(d) {
    var g = AllSymbols[d] = _create$1($Symbol[PROTOTYPE]);
    return g._k = d,
    g
}
  , isSymbol = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(d) {
    return typeof d == "symbol"
}
: function(d) {
    return d instanceof $Symbol
}
  , $defineProperty = function(g, b, _) {
    return g === ObjectProto && $defineProperty(OPSymbols, b, _),
    anObject(g),
    b = toPrimitive(b, !0),
    anObject(_),
    has(AllSymbols, b) ? (_.enumerable ? (has(g, HIDDEN) && g[HIDDEN][b] && (g[HIDDEN][b] = !1),
    _ = _create$1(_, {
        enumerable: createDesc(0, !1)
    })) : (has(g, HIDDEN) || dP(g, HIDDEN, createDesc(1, {})),
    g[HIDDEN][b] = !0),
    setSymbolDesc(g, b, _)) : dP(g, b, _)
}
  , $defineProperties = function(g, b) {
    anObject(g);
    for (var _ = enumKeys(b = toIObject(b)), $ = 0, et = _.length, tt; et > $; )
        $defineProperty(g, tt = _[$++], b[tt]);
    return g
}
  , $create = function(g, b) {
    return b === void 0 ? _create$1(g) : $defineProperties(_create$1(g), b)
}
  , $propertyIsEnumerable = function(g) {
    var b = isEnum.call(this, g = toPrimitive(g, !0));
    return this === ObjectProto && has(AllSymbols, g) && !has(OPSymbols, g) ? !1 : b || !has(this, g) || !has(AllSymbols, g) || has(this, HIDDEN) && this[HIDDEN][g] ? b : !0
}
  , $getOwnPropertyDescriptor = function(g, b) {
    if (g = toIObject(g),
    b = toPrimitive(b, !0),
    !(g === ObjectProto && has(AllSymbols, b) && !has(OPSymbols, b))) {
        var _ = gOPD(g, b);
        return _ && has(AllSymbols, b) && !(has(g, HIDDEN) && g[HIDDEN][b]) && (_.enumerable = !0),
        _
    }
}
  , $getOwnPropertyNames = function(g) {
    for (var b = gOPN(toIObject(g)), _ = [], $ = 0, et; b.length > $; )
        !has(AllSymbols, et = b[$++]) && et != HIDDEN && et != META && _.push(et);
    return _
}
  , $getOwnPropertySymbols = function(g) {
    for (var b = g === ObjectProto, _ = gOPN(b ? OPSymbols : toIObject(g)), $ = [], et = 0, tt; _.length > et; )
        has(AllSymbols, tt = _[et++]) && (!b || has(ObjectProto, tt)) && $.push(AllSymbols[tt]);
    return $
};
USE_NATIVE || ($Symbol = function() {
    if (this instanceof $Symbol)
        throw TypeError("Symbol is not a constructor!");
    var g = uid(arguments.length > 0 ? arguments[0] : void 0)
      , b = function(_) {
        this === ObjectProto && b.call(OPSymbols, _),
        has(this, HIDDEN) && has(this[HIDDEN], g) && (this[HIDDEN][g] = !1),
        setSymbolDesc(this, g, createDesc(1, _))
    };
    return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, g, {
        configurable: !0,
        set: b
    }),
    wrap(g)
}
,
redefine($Symbol[PROTOTYPE], "toString", function() {
    return this._k
}),
$GOPD.f = $getOwnPropertyDescriptor,
$DP.f = $defineProperty,
_objectGopn.f = gOPNExt.f = $getOwnPropertyNames,
require_objectPie().f = $propertyIsEnumerable,
$GOPS.f = $getOwnPropertySymbols,
DESCRIPTORS && !_library && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable),
wksExt.f = function(d) {
    return wrap(wks(d))
}
);
$export$2($export$2.G + $export$2.W + $export$2.F * !USE_NATIVE, {
    Symbol: $Symbol
});
for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
    wks(es6Symbols[j++]);
for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; )
    wksDefine(wellKnownSymbols[k++]);
$export$2($export$2.S + $export$2.F * !USE_NATIVE, "Symbol", {
    for: function(d) {
        return has(SymbolRegistry, d += "") ? SymbolRegistry[d] : SymbolRegistry[d] = $Symbol(d)
    },
    keyFor: function(g) {
        if (!isSymbol(g))
            throw TypeError(g + " is not a symbol!");
        for (var b in SymbolRegistry)
            if (SymbolRegistry[b] === g)
                return b
    },
    useSetter: function() {
        setter = !0
    },
    useSimple: function() {
        setter = !1
    }
});
$export$2($export$2.S + $export$2.F * !USE_NATIVE, "Object", {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
});
var FAILS_ON_PRIMITIVES = $fails(function() {
    $GOPS.f(1)
});
$export$2($export$2.S + $export$2.F * FAILS_ON_PRIMITIVES, "Object", {
    getOwnPropertySymbols: function(g) {
        return $GOPS.f(toObject(g))
    }
});
$JSON && $export$2($export$2.S + $export$2.F * (!USE_NATIVE || $fails(function() {
    var d = $Symbol();
    return _stringify([d]) != "[null]" || _stringify({
        a: d
    }) != "{}" || _stringify(Object(d)) != "{}"
})), "JSON", {
    stringify: function(g) {
        for (var b = [g], _ = 1, $, et; arguments.length > _; )
            b.push(arguments[_++]);
        if (et = $ = b[1],
        !(!isObject($) && g === void 0 || isSymbol(g)))
            return isArray($) || ($ = function(tt, rt) {
                if (typeof et == "function" && (rt = et.call(this, tt, rt)),
                !isSymbol(rt))
                    return rt
            }
            ),
            b[1] = $,
            _stringify.apply($JSON, b)
    }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, "Symbol");
setToStringTag(Math, "Math", !0);
setToStringTag(global$1.JSON, "JSON", !0);
_wksDefine("asyncIterator");
_wksDefine("observable");
var symbol$1 = _coreExports.Symbol
  , symbol = {
    default: symbol$1,
    __esModule: !0
};
_typeof$1.__esModule = !0;
var _iterator = iterator
  , _iterator2 = _interopRequireDefault$3(_iterator)
  , _symbol = symbol
  , _symbol2 = _interopRequireDefault$3(_symbol)
  , _typeof = typeof _symbol2.default == "function" && typeof _iterator2.default == "symbol" ? function(d) {
    return typeof d
}
: function(d) {
    return d && typeof _symbol2.default == "function" && d.constructor === _symbol2.default && d !== _symbol2.default.prototype ? "symbol" : typeof d
}
;
function _interopRequireDefault$3(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
_typeof$1.default = typeof _symbol2.default == "function" && _typeof(_iterator2.default) === "symbol" ? function(d) {
    return typeof d > "u" ? "undefined" : _typeof(d)
}
: function(d) {
    return d && typeof _symbol2.default == "function" && d.constructor === _symbol2.default && d !== _symbol2.default.prototype ? "symbol" : typeof d > "u" ? "undefined" : _typeof(d)
}
;
possibleConstructorReturn.__esModule = !0;
var _typeof2$1 = _typeof$1
  , _typeof3$1 = _interopRequireDefault$2(_typeof2$1);
function _interopRequireDefault$2(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
possibleConstructorReturn.default = function(d, g) {
    if (!d)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return g && ((typeof g > "u" ? "undefined" : (0,
    _typeof3$1.default)(g)) === "object" || typeof g == "function") ? g : d
}
;
var inherits = {}, _setProto, hasRequired_setProto;
function require_setProto() {
    if (hasRequired_setProto)
        return _setProto;
    hasRequired_setProto = 1;
    var d = _isObject
      , g = _anObject
      , b = function(_, $) {
        if (g(_),
        !d($) && $ !== null)
            throw TypeError($ + ": can't set as prototype!")
    };
    return _setProto = {
        set: Object.setPrototypeOf || ("__proto__"in {} ? function(_, $, et) {
            try {
                et = _ctx(Function.call, _objectGopd.f(Object.prototype, "__proto__").set, 2),
                et(_, []),
                $ = !(_ instanceof Array)
            } catch {
                $ = !0
            }
            return function(rt, nt) {
                return b(rt, nt),
                $ ? rt.__proto__ = nt : et(rt, nt),
                rt
            }
        }({}, !1) : void 0),
        check: b
    },
    _setProto
}
var $export$1 = _export;
$export$1($export$1.S, "Object", {
    setPrototypeOf: require_setProto().set
});
var setPrototypeOf$1 = _coreExports.Object.setPrototypeOf
  , setPrototypeOf = {
    default: setPrototypeOf$1,
    __esModule: !0
}
  , $export = _export;
$export($export.S, "Object", {
    create: _objectCreate
});
var $Object = _coreExports.Object
  , create$1 = function(g, b) {
    return $Object.create(g, b)
}
  , create = {
    default: create$1,
    __esModule: !0
};
inherits.__esModule = !0;
var _setPrototypeOf = setPrototypeOf
  , _setPrototypeOf2 = _interopRequireDefault$1(_setPrototypeOf)
  , _create = create
  , _create2 = _interopRequireDefault$1(_create)
  , _typeof2 = _typeof$1
  , _typeof3 = _interopRequireDefault$1(_typeof2);
function _interopRequireDefault$1(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
inherits.default = function(d, g) {
    if (typeof g != "function" && g !== null)
        throw new TypeError("Super expression must either be null or a function, not " + (typeof g > "u" ? "undefined" : (0,
        _typeof3.default)(g)));
    d.prototype = (0,
    _create2.default)(g && g.prototype, {
        constructor: {
            value: d,
            enumerable: !1,
            writable: !0,
            configurable: !0
        }
    }),
    g && (_setPrototypeOf2.default ? (0,
    _setPrototypeOf2.default)(d, g) : d.__proto__ = g)
}
;
var propTypes = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function d(_, $, et, tt, rt, nt) {
        if (nt !== ReactPropTypesSecret) {
            var it = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw it.name = "Invariant Violation",
            it
        }
    }
    d.isRequired = d;
    function g() {
        return d
    }
    var b = {
        array: d,
        bigint: d,
        bool: d,
        func: d,
        number: d,
        object: d,
        string: d,
        symbol: d,
        any: d,
        arrayOf: g,
        element: d,
        elementType: d,
        instanceOf: g,
        node: d,
        objectOf: g,
        oneOf: g,
        oneOfType: g,
        shape: g,
        exact: g,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return b.PropTypes = b,
    b
};
propTypes.exports = factoryWithThrowingShims();
var propTypesExports = propTypes.exports
  , lottie = {
    exports: {}
};
(function(module, exports) {
    typeof navigator < "u" && function(d, g) {
        module.exports = g()
    }(commonjsGlobal, function() {
        var svgNS = "http://www.w3.org/2000/svg"
          , locationHref = ""
          , _useWebWorker = !1
          , initialDefaultFrame = -999999
          , setWebWorker = function(g) {
            _useWebWorker = !!g
        }
          , getWebWorker = function() {
            return _useWebWorker
        }
          , setLocationHref = function(g) {
            locationHref = g
        }
          , getLocationHref = function() {
            return locationHref
        };
        function createTag(d) {
            return document.createElement(d)
        }
        function extendPrototype(d, g) {
            var b, _ = d.length, $;
            for (b = 0; b < _; b += 1) {
                $ = d[b].prototype;
                for (var et in $)
                    Object.prototype.hasOwnProperty.call($, et) && (g.prototype[et] = $[et])
            }
        }
        function getDescriptor(d, g) {
            return Object.getOwnPropertyDescriptor(d, g)
        }
        function createProxyFunction(d) {
            function g() {}
            return g.prototype = d,
            g
        }
        var audioControllerFactory = function() {
            function d(g) {
                this.audios = [],
                this.audioFactory = g,
                this._volume = 1,
                this._isMuted = !1
            }
            return d.prototype = {
                addAudio: function(b) {
                    this.audios.push(b)
                },
                pause: function() {
                    var b, _ = this.audios.length;
                    for (b = 0; b < _; b += 1)
                        this.audios[b].pause()
                },
                resume: function() {
                    var b, _ = this.audios.length;
                    for (b = 0; b < _; b += 1)
                        this.audios[b].resume()
                },
                setRate: function(b) {
                    var _, $ = this.audios.length;
                    for (_ = 0; _ < $; _ += 1)
                        this.audios[_].setRate(b)
                },
                createAudio: function(b) {
                    return this.audioFactory ? this.audioFactory(b) : window.Howl ? new window.Howl({
                        src: [b]
                    }) : {
                        isPlaying: !1,
                        play: function() {
                            this.isPlaying = !0
                        },
                        seek: function() {
                            this.isPlaying = !1
                        },
                        playing: function() {},
                        rate: function() {},
                        setVolume: function() {}
                    }
                },
                setAudioFactory: function(b) {
                    this.audioFactory = b
                },
                setVolume: function(b) {
                    this._volume = b,
                    this._updateVolume()
                },
                mute: function() {
                    this._isMuted = !0,
                    this._updateVolume()
                },
                unmute: function() {
                    this._isMuted = !1,
                    this._updateVolume()
                },
                getVolume: function() {
                    return this._volume
                },
                _updateVolume: function() {
                    var b, _ = this.audios.length;
                    for (b = 0; b < _; b += 1)
                        this.audios[b].volume(this._volume * (this._isMuted ? 0 : 1))
                }
            },
            function() {
                return new d
            }
        }()
          , createTypedArray = function() {
            function d(b, _) {
                var $ = 0, et = [], tt;
                switch (b) {
                case "int16":
                case "uint8c":
                    tt = 1;
                    break;
                default:
                    tt = 1.1;
                    break
                }
                for ($ = 0; $ < _; $ += 1)
                    et.push(tt);
                return et
            }
            function g(b, _) {
                return b === "float32" ? new Float32Array(_) : b === "int16" ? new Int16Array(_) : b === "uint8c" ? new Uint8ClampedArray(_) : d(b, _)
            }
            return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? g : d
        }();
        function createSizedArray(d) {
            return Array.apply(null, {
                length: d
            })
        }
        function _typeof$6(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(b) {
                return typeof b
            }
            : _typeof$6 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$6(d)
        }
        var subframeEnabled = !0
          , expressionsPlugin = null
          , expressionsInterfaces = null
          , idPrefix$1 = ""
          , isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          , bmPow = Math.pow
          , bmSqrt = Math.sqrt
          , bmFloor = Math.floor
          , bmMax = Math.max
          , bmMin = Math.min
          , BMMath = {};
        (function() {
            var d = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], g, b = d.length;
            for (g = 0; g < b; g += 1)
                BMMath[d[g]] = Math[d[g]]
        }
        )(),
        BMMath.random = Math.random,
        BMMath.abs = function(d) {
            var g = _typeof$6(d);
            if (g === "object" && d.length) {
                var b = createSizedArray(d.length), _, $ = d.length;
                for (_ = 0; _ < $; _ += 1)
                    b[_] = Math.abs(d[_]);
                return b
            }
            return Math.abs(d)
        }
        ;
        var defaultCurveSegments = 150
          , degToRads = Math.PI / 180
          , roundCorner = .5519;
        function styleDiv(d) {
            d.style.position = "absolute",
            d.style.top = 0,
            d.style.left = 0,
            d.style.display = "block",
            d.style.transformOrigin = "0 0",
            d.style.webkitTransformOrigin = "0 0",
            d.style.backfaceVisibility = "visible",
            d.style.webkitBackfaceVisibility = "visible",
            d.style.transformStyle = "preserve-3d",
            d.style.webkitTransformStyle = "preserve-3d",
            d.style.mozTransformStyle = "preserve-3d"
        }
        function BMEnterFrameEvent(d, g, b, _) {
            this.type = d,
            this.currentTime = g,
            this.totalTime = b,
            this.direction = _ < 0 ? -1 : 1
        }
        function BMCompleteEvent(d, g) {
            this.type = d,
            this.direction = g < 0 ? -1 : 1
        }
        function BMCompleteLoopEvent(d, g, b, _) {
            this.type = d,
            this.currentLoop = b,
            this.totalLoops = g,
            this.direction = _ < 0 ? -1 : 1
        }
        function BMSegmentStartEvent(d, g, b) {
            this.type = d,
            this.firstFrame = g,
            this.totalFrames = b
        }
        function BMDestroyEvent(d, g) {
            this.type = d,
            this.target = g
        }
        function BMRenderFrameErrorEvent(d, g) {
            this.type = "renderFrameError",
            this.nativeError = d,
            this.currentTime = g
        }
        function BMConfigErrorEvent(d) {
            this.type = "configError",
            this.nativeError = d
        }
        var createElementID = function() {
            var d = 0;
            return function() {
                return d += 1,
                idPrefix$1 + "__lottie_element_" + d
            }
        }();
        function HSVtoRGB(d, g, b) {
            var _, $, et, tt, rt, nt, it, ot;
            switch (tt = Math.floor(d * 6),
            rt = d * 6 - tt,
            nt = b * (1 - g),
            it = b * (1 - rt * g),
            ot = b * (1 - (1 - rt) * g),
            tt % 6) {
            case 0:
                _ = b,
                $ = ot,
                et = nt;
                break;
            case 1:
                _ = it,
                $ = b,
                et = nt;
                break;
            case 2:
                _ = nt,
                $ = b,
                et = ot;
                break;
            case 3:
                _ = nt,
                $ = it,
                et = b;
                break;
            case 4:
                _ = ot,
                $ = nt,
                et = b;
                break;
            case 5:
                _ = b,
                $ = nt,
                et = it;
                break
            }
            return [_, $, et]
        }
        function RGBtoHSV(d, g, b) {
            var _ = Math.max(d, g, b), $ = Math.min(d, g, b), et = _ - $, tt, rt = _ === 0 ? 0 : et / _, nt = _ / 255;
            switch (_) {
            case $:
                tt = 0;
                break;
            case d:
                tt = g - b + et * (g < b ? 6 : 0),
                tt /= 6 * et;
                break;
            case g:
                tt = b - d + et * 2,
                tt /= 6 * et;
                break;
            case b:
                tt = d - g + et * 4,
                tt /= 6 * et;
                break
            }
            return [tt, rt, nt]
        }
        function addSaturationToRGB(d, g) {
            var b = RGBtoHSV(d[0] * 255, d[1] * 255, d[2] * 255);
            return b[1] += g,
            b[1] > 1 ? b[1] = 1 : b[1] <= 0 && (b[1] = 0),
            HSVtoRGB(b[0], b[1], b[2])
        }
        function addBrightnessToRGB(d, g) {
            var b = RGBtoHSV(d[0] * 255, d[1] * 255, d[2] * 255);
            return b[2] += g,
            b[2] > 1 ? b[2] = 1 : b[2] < 0 && (b[2] = 0),
            HSVtoRGB(b[0], b[1], b[2])
        }
        function addHueToRGB(d, g) {
            var b = RGBtoHSV(d[0] * 255, d[1] * 255, d[2] * 255);
            return b[0] += g / 360,
            b[0] > 1 ? b[0] -= 1 : b[0] < 0 && (b[0] += 1),
            HSVtoRGB(b[0], b[1], b[2])
        }
        var rgbToHex = function() {
            var d = [], g, b;
            for (g = 0; g < 256; g += 1)
                b = g.toString(16),
                d[g] = b.length === 1 ? "0" + b : b;
            return function(_, $, et) {
                return _ < 0 && (_ = 0),
                $ < 0 && ($ = 0),
                et < 0 && (et = 0),
                "#" + d[_] + d[$] + d[et]
            }
        }()
          , setSubframeEnabled = function(g) {
            subframeEnabled = !!g
        }
          , getSubframeEnabled = function() {
            return subframeEnabled
        }
          , setExpressionsPlugin = function(g) {
            expressionsPlugin = g
        }
          , getExpressionsPlugin = function() {
            return expressionsPlugin
        }
          , setExpressionInterfaces = function(g) {
            expressionsInterfaces = g
        }
          , getExpressionInterfaces = function() {
            return expressionsInterfaces
        }
          , setDefaultCurveSegments = function(g) {
            defaultCurveSegments = g
        }
          , getDefaultCurveSegments = function() {
            return defaultCurveSegments
        }
          , setIdPrefix = function(g) {
            idPrefix$1 = g
        };
        function createNS(d) {
            return document.createElementNS(svgNS, d)
        }
        function _typeof$5(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(b) {
                return typeof b
            }
            : _typeof$5 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$5(d)
        }
        var dataManager = function() {
            var d = 1, g = [], b, _, $ = {
                onmessage: function() {},
                postMessage: function(dt) {
                    b({
                        data: dt
                    })
                }
            }, et = {
                postMessage: function(dt) {
                    $.onmessage({
                        data: dt
                    })
                }
            };
            function tt(st) {
                if (window.Worker && window.Blob && getWebWorker()) {
                    var dt = new Blob(["var _workerSelf = self; self.onmessage = ", st.toString()],{
                        type: "text/javascript"
                    })
                      , ft = URL.createObjectURL(dt);
                    return new Worker(ft)
                }
                return b = st,
                $
            }
            function rt() {
                _ || (_ = tt(function(dt) {
                    function ft() {
                        function xt(Kt, Rt) {
                            var qt, Et, St = Kt.length, Lt, Mt, ar, wr;
                            for (Et = 0; Et < St; Et += 1)
                                if (qt = Kt[Et],
                                "ks"in qt && !qt.completed) {
                                    if (qt.completed = !0,
                                    qt.hasMask) {
                                        var Tr = qt.masksProperties;
                                        for (Mt = Tr.length,
                                        Lt = 0; Lt < Mt; Lt += 1)
                                            if (Tr[Lt].pt.k.i)
                                                vt(Tr[Lt].pt.k);
                                            else
                                                for (wr = Tr[Lt].pt.k.length,
                                                ar = 0; ar < wr; ar += 1)
                                                    Tr[Lt].pt.k[ar].s && vt(Tr[Lt].pt.k[ar].s[0]),
                                                    Tr[Lt].pt.k[ar].e && vt(Tr[Lt].pt.k[ar].e[0])
                                    }
                                    qt.ty === 0 ? (qt.layers = ut(qt.refId, Rt),
                                    xt(qt.layers, Rt)) : qt.ty === 4 ? pt(qt.shapes) : qt.ty === 5 && Vt(qt)
                                }
                        }
                        function lt(Kt, Rt) {
                            if (Kt) {
                                var qt = 0
                                  , Et = Kt.length;
                                for (qt = 0; qt < Et; qt += 1)
                                    Kt[qt].t === 1 && (Kt[qt].data.layers = ut(Kt[qt].data.refId, Rt),
                                    xt(Kt[qt].data.layers, Rt))
                            }
                        }
                        function ct(Kt, Rt) {
                            for (var qt = 0, Et = Rt.length; qt < Et; ) {
                                if (Rt[qt].id === Kt)
                                    return Rt[qt];
                                qt += 1
                            }
                            return null
                        }
                        function ut(Kt, Rt) {
                            var qt = ct(Kt, Rt);
                            return qt ? qt.layers.__used ? JSON.parse(JSON.stringify(qt.layers)) : (qt.layers.__used = !0,
                            qt.layers) : null
                        }
                        function pt(Kt) {
                            var Rt, qt = Kt.length, Et, St;
                            for (Rt = qt - 1; Rt >= 0; Rt -= 1)
                                if (Kt[Rt].ty === "sh")
                                    if (Kt[Rt].ks.k.i)
                                        vt(Kt[Rt].ks.k);
                                    else
                                        for (St = Kt[Rt].ks.k.length,
                                        Et = 0; Et < St; Et += 1)
                                            Kt[Rt].ks.k[Et].s && vt(Kt[Rt].ks.k[Et].s[0]),
                                            Kt[Rt].ks.k[Et].e && vt(Kt[Rt].ks.k[Et].e[0]);
                                else
                                    Kt[Rt].ty === "gr" && pt(Kt[Rt].it)
                        }
                        function vt(Kt) {
                            var Rt, qt = Kt.i.length;
                            for (Rt = 0; Rt < qt; Rt += 1)
                                Kt.i[Rt][0] += Kt.v[Rt][0],
                                Kt.i[Rt][1] += Kt.v[Rt][1],
                                Kt.o[Rt][0] += Kt.v[Rt][0],
                                Kt.o[Rt][1] += Kt.v[Rt][1]
                        }
                        function _t(Kt, Rt) {
                            var qt = Rt ? Rt.split(".") : [100, 100, 100];
                            return Kt[0] > qt[0] ? !0 : qt[0] > Kt[0] ? !1 : Kt[1] > qt[1] ? !0 : qt[1] > Kt[1] ? !1 : Kt[2] > qt[2] ? !0 : qt[2] > Kt[2] ? !1 : null
                        }
                        var Pt = function() {
                            var Kt = [4, 4, 14];
                            function Rt(Et) {
                                var St = Et.t.d;
                                Et.t.d = {
                                    k: [{
                                        s: St,
                                        t: 0
                                    }]
                                }
                            }
                            function qt(Et) {
                                var St, Lt = Et.length;
                                for (St = 0; St < Lt; St += 1)
                                    Et[St].ty === 5 && Rt(Et[St])
                            }
                            return function(Et) {
                                if (_t(Kt, Et.v) && (qt(Et.layers),
                                Et.assets)) {
                                    var St, Lt = Et.assets.length;
                                    for (St = 0; St < Lt; St += 1)
                                        Et.assets[St].layers && qt(Et.assets[St].layers)
                                }
                            }
                        }()
                          , kt = function() {
                            var Kt = [4, 7, 99];
                            return function(Rt) {
                                if (Rt.chars && !_t(Kt, Rt.v)) {
                                    var qt, Et = Rt.chars.length;
                                    for (qt = 0; qt < Et; qt += 1) {
                                        var St = Rt.chars[qt];
                                        St.data && St.data.shapes && (pt(St.data.shapes),
                                        St.data.ip = 0,
                                        St.data.op = 99999,
                                        St.data.st = 0,
                                        St.data.sr = 1,
                                        St.data.ks = {
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            }
                                        },
                                        Rt.chars[qt].t || (St.data.shapes.push({
                                            ty: "no"
                                        }),
                                        St.data.shapes[0].it.push({
                                            p: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            s: {
                                                k: [100, 100],
                                                a: 0
                                            },
                                            a: {
                                                k: [0, 0],
                                                a: 0
                                            },
                                            r: {
                                                k: 0,
                                                a: 0
                                            },
                                            o: {
                                                k: 100,
                                                a: 0
                                            },
                                            sk: {
                                                k: 0,
                                                a: 0
                                            },
                                            sa: {
                                                k: 0,
                                                a: 0
                                            },
                                            ty: "tr"
                                        })))
                                    }
                                }
                            }
                        }()
                          , $t = function() {
                            var Kt = [5, 7, 15];
                            function Rt(Et) {
                                var St = Et.t.p;
                                typeof St.a == "number" && (St.a = {
                                    a: 0,
                                    k: St.a
                                }),
                                typeof St.p == "number" && (St.p = {
                                    a: 0,
                                    k: St.p
                                }),
                                typeof St.r == "number" && (St.r = {
                                    a: 0,
                                    k: St.r
                                })
                            }
                            function qt(Et) {
                                var St, Lt = Et.length;
                                for (St = 0; St < Lt; St += 1)
                                    Et[St].ty === 5 && Rt(Et[St])
                            }
                            return function(Et) {
                                if (_t(Kt, Et.v) && (qt(Et.layers),
                                Et.assets)) {
                                    var St, Lt = Et.assets.length;
                                    for (St = 0; St < Lt; St += 1)
                                        Et.assets[St].layers && qt(Et.assets[St].layers)
                                }
                            }
                        }()
                          , Wt = function() {
                            var Kt = [4, 1, 9];
                            function Rt(Et) {
                                var St, Lt = Et.length, Mt, ar;
                                for (St = 0; St < Lt; St += 1)
                                    if (Et[St].ty === "gr")
                                        Rt(Et[St].it);
                                    else if (Et[St].ty === "fl" || Et[St].ty === "st")
                                        if (Et[St].c.k && Et[St].c.k[0].i)
                                            for (ar = Et[St].c.k.length,
                                            Mt = 0; Mt < ar; Mt += 1)
                                                Et[St].c.k[Mt].s && (Et[St].c.k[Mt].s[0] /= 255,
                                                Et[St].c.k[Mt].s[1] /= 255,
                                                Et[St].c.k[Mt].s[2] /= 255,
                                                Et[St].c.k[Mt].s[3] /= 255),
                                                Et[St].c.k[Mt].e && (Et[St].c.k[Mt].e[0] /= 255,
                                                Et[St].c.k[Mt].e[1] /= 255,
                                                Et[St].c.k[Mt].e[2] /= 255,
                                                Et[St].c.k[Mt].e[3] /= 255);
                                        else
                                            Et[St].c.k[0] /= 255,
                                            Et[St].c.k[1] /= 255,
                                            Et[St].c.k[2] /= 255,
                                            Et[St].c.k[3] /= 255
                            }
                            function qt(Et) {
                                var St, Lt = Et.length;
                                for (St = 0; St < Lt; St += 1)
                                    Et[St].ty === 4 && Rt(Et[St].shapes)
                            }
                            return function(Et) {
                                if (_t(Kt, Et.v) && (qt(Et.layers),
                                Et.assets)) {
                                    var St, Lt = Et.assets.length;
                                    for (St = 0; St < Lt; St += 1)
                                        Et.assets[St].layers && qt(Et.assets[St].layers)
                                }
                            }
                        }()
                          , Ht = function() {
                            var Kt = [4, 4, 18];
                            function Rt(Et) {
                                var St, Lt = Et.length, Mt, ar;
                                for (St = Lt - 1; St >= 0; St -= 1)
                                    if (Et[St].ty === "sh")
                                        if (Et[St].ks.k.i)
                                            Et[St].ks.k.c = Et[St].closed;
                                        else
                                            for (ar = Et[St].ks.k.length,
                                            Mt = 0; Mt < ar; Mt += 1)
                                                Et[St].ks.k[Mt].s && (Et[St].ks.k[Mt].s[0].c = Et[St].closed),
                                                Et[St].ks.k[Mt].e && (Et[St].ks.k[Mt].e[0].c = Et[St].closed);
                                    else
                                        Et[St].ty === "gr" && Rt(Et[St].it)
                            }
                            function qt(Et) {
                                var St, Lt, Mt = Et.length, ar, wr, Tr, Pr;
                                for (Lt = 0; Lt < Mt; Lt += 1) {
                                    if (St = Et[Lt],
                                    St.hasMask) {
                                        var kr = St.masksProperties;
                                        for (wr = kr.length,
                                        ar = 0; ar < wr; ar += 1)
                                            if (kr[ar].pt.k.i)
                                                kr[ar].pt.k.c = kr[ar].cl;
                                            else
                                                for (Pr = kr[ar].pt.k.length,
                                                Tr = 0; Tr < Pr; Tr += 1)
                                                    kr[ar].pt.k[Tr].s && (kr[ar].pt.k[Tr].s[0].c = kr[ar].cl),
                                                    kr[ar].pt.k[Tr].e && (kr[ar].pt.k[Tr].e[0].c = kr[ar].cl)
                                    }
                                    St.ty === 4 && Rt(St.shapes)
                                }
                            }
                            return function(Et) {
                                if (_t(Kt, Et.v) && (qt(Et.layers),
                                Et.assets)) {
                                    var St, Lt = Et.assets.length;
                                    for (St = 0; St < Lt; St += 1)
                                        Et.assets[St].layers && qt(Et.assets[St].layers)
                                }
                            }
                        }();
                        function Dt(Kt) {
                            Kt.__complete || (Wt(Kt),
                            Pt(Kt),
                            kt(Kt),
                            $t(Kt),
                            Ht(Kt),
                            xt(Kt.layers, Kt.assets),
                            lt(Kt.chars, Kt.assets),
                            Kt.__complete = !0)
                        }
                        function Vt(Kt) {
                            Kt.t.a.length === 0 && "m"in Kt.t.p
                        }
                        var Ft = {};
                        return Ft.completeData = Dt,
                        Ft.checkColors = Wt,
                        Ft.checkChars = kt,
                        Ft.checkPathProperties = $t,
                        Ft.checkShapes = Ht,
                        Ft.completeLayers = xt,
                        Ft
                    }
                    if (et.dataManager || (et.dataManager = ft()),
                    et.assetLoader || (et.assetLoader = function() {
                        function xt(ct) {
                            var ut = ct.getResponseHeader("content-type");
                            return ut && ct.responseType === "json" && ut.indexOf("json") !== -1 || ct.response && _typeof$5(ct.response) === "object" ? ct.response : ct.response && typeof ct.response == "string" ? JSON.parse(ct.response) : ct.responseText ? JSON.parse(ct.responseText) : null
                        }
                        function lt(ct, ut, pt, vt) {
                            var _t, Pt = new XMLHttpRequest;
                            try {
                                Pt.responseType = "json"
                            } catch {}
                            Pt.onreadystatechange = function() {
                                if (Pt.readyState === 4)
                                    if (Pt.status === 200)
                                        _t = xt(Pt),
                                        pt(_t);
                                    else
                                        try {
                                            _t = xt(Pt),
                                            pt(_t)
                                        } catch (kt) {
                                            vt && vt(kt)
                                        }
                            }
                            ;
                            try {
                                Pt.open(["G", "E", "T"].join(""), ct, !0)
                            } catch {
                                Pt.open(["G", "E", "T"].join(""), ut + "/" + ct, !0)
                            }
                            Pt.send()
                        }
                        return {
                            load: lt
                        }
                    }()),
                    dt.data.type === "loadAnimation")
                        et.assetLoader.load(dt.data.path, dt.data.fullPath, function(xt) {
                            et.dataManager.completeData(xt),
                            et.postMessage({
                                id: dt.data.id,
                                payload: xt,
                                status: "success"
                            })
                        }, function() {
                            et.postMessage({
                                id: dt.data.id,
                                status: "error"
                            })
                        });
                    else if (dt.data.type === "complete") {
                        var ht = dt.data.animation;
                        et.dataManager.completeData(ht),
                        et.postMessage({
                            id: dt.data.id,
                            payload: ht,
                            status: "success"
                        })
                    } else
                        dt.data.type === "loadData" && et.assetLoader.load(dt.data.path, dt.data.fullPath, function(xt) {
                            et.postMessage({
                                id: dt.data.id,
                                payload: xt,
                                status: "success"
                            })
                        }, function() {
                            et.postMessage({
                                id: dt.data.id,
                                status: "error"
                            })
                        })
                }),
                _.onmessage = function(st) {
                    var dt = st.data
                      , ft = dt.id
                      , ht = g[ft];
                    g[ft] = null,
                    dt.status === "success" ? ht.onComplete(dt.payload) : ht.onError && ht.onError()
                }
                )
            }
            function nt(st, dt) {
                d += 1;
                var ft = "processId_" + d;
                return g[ft] = {
                    onComplete: st,
                    onError: dt
                },
                ft
            }
            function it(st, dt, ft) {
                rt();
                var ht = nt(dt, ft);
                _.postMessage({
                    type: "loadAnimation",
                    path: st,
                    fullPath: window.location.origin + window.location.pathname,
                    id: ht
                })
            }
            function ot(st, dt, ft) {
                rt();
                var ht = nt(dt, ft);
                _.postMessage({
                    type: "loadData",
                    path: st,
                    fullPath: window.location.origin + window.location.pathname,
                    id: ht
                })
            }
            function at(st, dt, ft) {
                rt();
                var ht = nt(dt, ft);
                _.postMessage({
                    type: "complete",
                    animation: st,
                    id: ht
                })
            }
            return {
                loadAnimation: it,
                loadData: ot,
                completeAnimation: at
            }
        }()
          , ImagePreloader = function() {
            var d = function() {
                var lt = createTag("canvas");
                lt.width = 1,
                lt.height = 1;
                var ct = lt.getContext("2d");
                return ct.fillStyle = "rgba(0,0,0,0)",
                ct.fillRect(0, 0, 1, 1),
                lt
            }();
            function g() {
                this.loadedAssets += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function b() {
                this.loadedFootagesCount += 1,
                this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null)
            }
            function _(lt, ct, ut) {
                var pt = "";
                if (lt.e)
                    pt = lt.p;
                else if (ct) {
                    var vt = lt.p;
                    vt.indexOf("images/") !== -1 && (vt = vt.split("/")[1]),
                    pt = ct + vt
                } else
                    pt = ut,
                    pt += lt.u ? lt.u : "",
                    pt += lt.p;
                return pt
            }
            function $(lt) {
                var ct = 0
                  , ut = setInterval((function() {
                    var pt = lt.getBBox();
                    (pt.width || ct > 500) && (this._imageLoaded(),
                    clearInterval(ut)),
                    ct += 1
                }
                ).bind(this), 50)
            }
            function et(lt) {
                var ct = _(lt, this.assetsPath, this.path)
                  , ut = createNS("image");
                isSafari ? this.testImageLoaded(ut) : ut.addEventListener("load", this._imageLoaded, !1),
                ut.addEventListener("error", (function() {
                    pt.img = d,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                ut.setAttributeNS("http://www.w3.org/1999/xlink", "href", ct),
                this._elementHelper.append ? this._elementHelper.append(ut) : this._elementHelper.appendChild(ut);
                var pt = {
                    img: ut,
                    assetData: lt
                };
                return pt
            }
            function tt(lt) {
                var ct = _(lt, this.assetsPath, this.path)
                  , ut = createTag("img");
                ut.crossOrigin = "anonymous",
                ut.addEventListener("load", this._imageLoaded, !1),
                ut.addEventListener("error", (function() {
                    pt.img = d,
                    this._imageLoaded()
                }
                ).bind(this), !1),
                ut.src = ct;
                var pt = {
                    img: ut,
                    assetData: lt
                };
                return pt
            }
            function rt(lt) {
                var ct = {
                    assetData: lt
                }
                  , ut = _(lt, this.assetsPath, this.path);
                return dataManager.loadData(ut, (function(pt) {
                    ct.img = pt,
                    this._footageLoaded()
                }
                ).bind(this), (function() {
                    ct.img = {},
                    this._footageLoaded()
                }
                ).bind(this)),
                ct
            }
            function nt(lt, ct) {
                this.imagesLoadedCb = ct;
                var ut, pt = lt.length;
                for (ut = 0; ut < pt; ut += 1)
                    lt[ut].layers || (!lt[ut].t || lt[ut].t === "seq" ? (this.totalImages += 1,
                    this.images.push(this._createImageData(lt[ut]))) : lt[ut].t === 3 && (this.totalFootages += 1,
                    this.images.push(this.createFootageData(lt[ut]))))
            }
            function it(lt) {
                this.path = lt || ""
            }
            function ot(lt) {
                this.assetsPath = lt || ""
            }
            function at(lt) {
                for (var ct = 0, ut = this.images.length; ct < ut; ) {
                    if (this.images[ct].assetData === lt)
                        return this.images[ct].img;
                    ct += 1
                }
                return null
            }
            function st() {
                this.imagesLoadedCb = null,
                this.images.length = 0
            }
            function dt() {
                return this.totalImages === this.loadedAssets
            }
            function ft() {
                return this.totalFootages === this.loadedFootagesCount
            }
            function ht(lt, ct) {
                lt === "svg" ? (this._elementHelper = ct,
                this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this)
            }
            function xt() {
                this._imageLoaded = g.bind(this),
                this._footageLoaded = b.bind(this),
                this.testImageLoaded = $.bind(this),
                this.createFootageData = rt.bind(this),
                this.assetsPath = "",
                this.path = "",
                this.totalImages = 0,
                this.totalFootages = 0,
                this.loadedAssets = 0,
                this.loadedFootagesCount = 0,
                this.imagesLoadedCb = null,
                this.images = []
            }
            return xt.prototype = {
                loadAssets: nt,
                setAssetsPath: ot,
                setPath: it,
                loadedImages: dt,
                loadedFootages: ft,
                destroy: st,
                getAsset: at,
                createImgData: tt,
                createImageData: et,
                imageLoaded: g,
                footageLoaded: b,
                setCacheType: ht
            },
            xt
        }();
        function BaseEvent() {}
        BaseEvent.prototype = {
            triggerEvent: function(g, b) {
                if (this._cbs[g])
                    for (var _ = this._cbs[g], $ = 0; $ < _.length; $ += 1)
                        _[$](b)
            },
            addEventListener: function(g, b) {
                return this._cbs[g] || (this._cbs[g] = []),
                this._cbs[g].push(b),
                (function() {
                    this.removeEventListener(g, b)
                }
                ).bind(this)
            },
            removeEventListener: function(g, b) {
                if (!b)
                    this._cbs[g] = null;
                else if (this._cbs[g]) {
                    for (var _ = 0, $ = this._cbs[g].length; _ < $; )
                        this._cbs[g][_] === b && (this._cbs[g].splice(_, 1),
                        _ -= 1,
                        $ -= 1),
                        _ += 1;
                    this._cbs[g].length || (this._cbs[g] = null)
                }
            }
        };
        var markerParser = function() {
            function d(g) {
                for (var b = g.split(`\r
`), _ = {}, $, et = 0, tt = 0; tt < b.length; tt += 1)
                    $ = b[tt].split(":"),
                    $.length === 2 && (_[$[0]] = $[1].trim(),
                    et += 1);
                if (et === 0)
                    throw new Error;
                return _
            }
            return function(g) {
                for (var b = [], _ = 0; _ < g.length; _ += 1) {
                    var $ = g[_]
                      , et = {
                        time: $.tm,
                        duration: $.dr
                    };
                    try {
                        et.payload = JSON.parse(g[_].cm)
                    } catch {
                        try {
                            et.payload = d(g[_].cm)
                        } catch {
                            et.payload = {
                                name: g[_].cm
                            }
                        }
                    }
                    b.push(et)
                }
                return b
            }
        }()
          , ProjectInterface = function() {
            function d(g) {
                this.compositions.push(g)
            }
            return function() {
                function g(b) {
                    for (var _ = 0, $ = this.compositions.length; _ < $; ) {
                        if (this.compositions[_].data && this.compositions[_].data.nm === b)
                            return this.compositions[_].prepareFrame && this.compositions[_].data.xt && this.compositions[_].prepareFrame(this.currentFrame),
                            this.compositions[_].compInterface;
                        _ += 1
                    }
                    return null
                }
                return g.compositions = [],
                g.currentFrame = 0,
                g.registerComposition = d,
                g
            }
        }()
          , renderers = {}
          , registerRenderer = function(g, b) {
            renderers[g] = b
        };
        function getRenderer(d) {
            return renderers[d]
        }
        function getRegisteredRenderer() {
            if (renderers.canvas)
                return "canvas";
            for (var d in renderers)
                if (renderers[d])
                    return d;
            return ""
        }
        function _typeof$4(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(b) {
                return typeof b
            }
            : _typeof$4 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$4(d)
        }
        var AnimationItem = function() {
            this._cbs = [],
            this.name = "",
            this.path = "",
            this.isLoaded = !1,
            this.currentFrame = 0,
            this.currentRawFrame = 0,
            this.firstFrame = 0,
            this.totalFrames = 0,
            this.frameRate = 0,
            this.frameMult = 0,
            this.playSpeed = 1,
            this.playDirection = 1,
            this.playCount = 0,
            this.animationData = {},
            this.assets = [],
            this.isPaused = !0,
            this.autoplay = !1,
            this.loop = !0,
            this.renderer = null,
            this.animationID = createElementID(),
            this.assetsPath = "",
            this.timeCompleted = 0,
            this.segmentPos = 0,
            this.isSubframeEnabled = getSubframeEnabled(),
            this.segments = [],
            this._idle = !0,
            this._completedLoop = !1,
            this.projectInterface = ProjectInterface(),
            this.imagePreloader = new ImagePreloader,
            this.audioController = audioControllerFactory(),
            this.markers = [],
            this.configAnimation = this.configAnimation.bind(this),
            this.onSetupError = this.onSetupError.bind(this),
            this.onSegmentComplete = this.onSegmentComplete.bind(this),
            this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame",0,0,0),
            this.expressionsPlugin = getExpressionsPlugin()
        };
        extendPrototype([BaseEvent], AnimationItem),
        AnimationItem.prototype.setParams = function(d) {
            (d.wrapper || d.container) && (this.wrapper = d.wrapper || d.container);
            var g = "svg";
            d.animType ? g = d.animType : d.renderer && (g = d.renderer);
            var b = getRenderer(g);
            this.renderer = new b(this,d.rendererSettings),
            this.imagePreloader.setCacheType(g, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            this.animType = g,
            d.loop === "" || d.loop === null || d.loop === void 0 || d.loop === !0 ? this.loop = !0 : d.loop === !1 ? this.loop = !1 : this.loop = parseInt(d.loop, 10),
            this.autoplay = "autoplay"in d ? d.autoplay : !0,
            this.name = d.name ? d.name : "",
            this.autoloadSegments = Object.prototype.hasOwnProperty.call(d, "autoloadSegments") ? d.autoloadSegments : !0,
            this.assetsPath = d.assetsPath,
            this.initialSegment = d.initialSegment,
            d.audioFactory && this.audioController.setAudioFactory(d.audioFactory),
            d.animationData ? this.setupAnimation(d.animationData) : d.path && (d.path.lastIndexOf("\\") !== -1 ? this.path = d.path.substr(0, d.path.lastIndexOf("\\") + 1) : this.path = d.path.substr(0, d.path.lastIndexOf("/") + 1),
            this.fileName = d.path.substr(d.path.lastIndexOf("/") + 1),
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")),
            dataManager.loadAnimation(d.path, this.configAnimation, this.onSetupError))
        }
        ,
        AnimationItem.prototype.onSetupError = function() {
            this.trigger("data_failed")
        }
        ,
        AnimationItem.prototype.setupAnimation = function(d) {
            dataManager.completeAnimation(d, this.configAnimation)
        }
        ,
        AnimationItem.prototype.setData = function(d, g) {
            g && _typeof$4(g) !== "object" && (g = JSON.parse(g));
            var b = {
                wrapper: d,
                animationData: g
            }
              , _ = d.attributes;
            b.path = _.getNamedItem("data-animation-path") ? _.getNamedItem("data-animation-path").value : _.getNamedItem("data-bm-path") ? _.getNamedItem("data-bm-path").value : _.getNamedItem("bm-path") ? _.getNamedItem("bm-path").value : "",
            b.animType = _.getNamedItem("data-anim-type") ? _.getNamedItem("data-anim-type").value : _.getNamedItem("data-bm-type") ? _.getNamedItem("data-bm-type").value : _.getNamedItem("bm-type") ? _.getNamedItem("bm-type").value : _.getNamedItem("data-bm-renderer") ? _.getNamedItem("data-bm-renderer").value : _.getNamedItem("bm-renderer") ? _.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
            var $ = _.getNamedItem("data-anim-loop") ? _.getNamedItem("data-anim-loop").value : _.getNamedItem("data-bm-loop") ? _.getNamedItem("data-bm-loop").value : _.getNamedItem("bm-loop") ? _.getNamedItem("bm-loop").value : "";
            $ === "false" ? b.loop = !1 : $ === "true" ? b.loop = !0 : $ !== "" && (b.loop = parseInt($, 10));
            var et = _.getNamedItem("data-anim-autoplay") ? _.getNamedItem("data-anim-autoplay").value : _.getNamedItem("data-bm-autoplay") ? _.getNamedItem("data-bm-autoplay").value : _.getNamedItem("bm-autoplay") ? _.getNamedItem("bm-autoplay").value : !0;
            b.autoplay = et !== "false",
            b.name = _.getNamedItem("data-name") ? _.getNamedItem("data-name").value : _.getNamedItem("data-bm-name") ? _.getNamedItem("data-bm-name").value : _.getNamedItem("bm-name") ? _.getNamedItem("bm-name").value : "";
            var tt = _.getNamedItem("data-anim-prerender") ? _.getNamedItem("data-anim-prerender").value : _.getNamedItem("data-bm-prerender") ? _.getNamedItem("data-bm-prerender").value : _.getNamedItem("bm-prerender") ? _.getNamedItem("bm-prerender").value : "";
            tt === "false" && (b.prerender = !1),
            b.path ? this.setParams(b) : this.trigger("destroy")
        }
        ,
        AnimationItem.prototype.includeLayers = function(d) {
            d.op > this.animationData.op && (this.animationData.op = d.op,
            this.totalFrames = Math.floor(d.op - this.animationData.ip));
            var g = this.animationData.layers, b, _ = g.length, $ = d.layers, et, tt = $.length;
            for (et = 0; et < tt; et += 1)
                for (b = 0; b < _; ) {
                    if (g[b].id === $[et].id) {
                        g[b] = $[et];
                        break
                    }
                    b += 1
                }
            if ((d.chars || d.fonts) && (this.renderer.globalData.fontManager.addChars(d.chars),
            this.renderer.globalData.fontManager.addFonts(d.fonts, this.renderer.globalData.defs)),
            d.assets)
                for (_ = d.assets.length,
                b = 0; b < _; b += 1)
                    this.animationData.assets.push(d.assets[b]);
            this.animationData.__complete = !1,
            dataManager.completeAnimation(this.animationData, this.onSegmentComplete)
        }
        ,
        AnimationItem.prototype.onSegmentComplete = function(d) {
            this.animationData = d;
            var g = getExpressionsPlugin();
            g && g.initExpressions(this),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.loadNextSegment = function() {
            var d = this.animationData.segments;
            if (!d || d.length === 0 || !this.autoloadSegments) {
                this.trigger("data_ready"),
                this.timeCompleted = this.totalFrames;
                return
            }
            var g = d.shift();
            this.timeCompleted = g.time * this.frameRate;
            var b = this.path + this.fileName + "_" + this.segmentPos + ".json";
            this.segmentPos += 1,
            dataManager.loadData(b, this.includeLayers.bind(this), (function() {
                this.trigger("data_failed")
            }
            ).bind(this))
        }
        ,
        AnimationItem.prototype.loadSegments = function() {
            var d = this.animationData.segments;
            d || (this.timeCompleted = this.totalFrames),
            this.loadNextSegment()
        }
        ,
        AnimationItem.prototype.imagesLoaded = function() {
            this.trigger("loaded_images"),
            this.checkLoaded()
        }
        ,
        AnimationItem.prototype.preloadImages = function() {
            this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this))
        }
        ,
        AnimationItem.prototype.configAnimation = function(d) {
            if (this.renderer)
                try {
                    this.animationData = d,
                    this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]),
                    this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip),
                    this.firstFrame = Math.round(this.animationData.ip)),
                    this.renderer.configAnimation(d),
                    d.assets || (d.assets = []),
                    this.assets = this.animationData.assets,
                    this.frameRate = this.animationData.fr,
                    this.frameMult = this.animationData.fr / 1e3,
                    this.renderer.searchExtraCompositions(d.assets),
                    this.markers = markerParser(d.markers || []),
                    this.trigger("config_ready"),
                    this.preloadImages(),
                    this.loadSegments(),
                    this.updaFrameModifier(),
                    this.waitForFontsLoaded(),
                    this.isPaused && this.audioController.pause()
                } catch (g) {
                    this.triggerConfigError(g)
                }
        }
        ,
        AnimationItem.prototype.waitForFontsLoaded = function() {
            this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }
        ,
        AnimationItem.prototype.checkLoaded = function() {
            if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
                this.isLoaded = !0;
                var d = getExpressionsPlugin();
                d && d.initExpressions(this),
                this.renderer.initItems(),
                setTimeout((function() {
                    this.trigger("DOMLoaded")
                }
                ).bind(this), 0),
                this.gotoFrame(),
                this.autoplay && this.play()
            }
        }
        ,
        AnimationItem.prototype.resize = function(d, g) {
            var b = typeof d == "number" ? d : void 0
              , _ = typeof g == "number" ? g : void 0;
            this.renderer.updateContainerSize(b, _)
        }
        ,
        AnimationItem.prototype.setSubframe = function(d) {
            this.isSubframeEnabled = !!d
        }
        ,
        AnimationItem.prototype.gotoFrame = function() {
            this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame,
            this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame")
        }
        ,
        AnimationItem.prototype.renderFrame = function() {
            if (!(this.isLoaded === !1 || !this.renderer))
                try {
                    this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                    this.renderer.renderFrame(this.currentFrame + this.firstFrame)
                } catch (d) {
                    this.triggerRenderFrameError(d)
                }
        }
        ,
        AnimationItem.prototype.play = function(d) {
            d && this.name !== d || this.isPaused === !0 && (this.isPaused = !1,
            this.trigger("_play"),
            this.audioController.resume(),
            this._idle && (this._idle = !1,
            this.trigger("_active")))
        }
        ,
        AnimationItem.prototype.pause = function(d) {
            d && this.name !== d || this.isPaused === !1 && (this.isPaused = !0,
            this.trigger("_pause"),
            this._idle = !0,
            this.trigger("_idle"),
            this.audioController.pause())
        }
        ,
        AnimationItem.prototype.togglePause = function(d) {
            d && this.name !== d || (this.isPaused === !0 ? this.play() : this.pause())
        }
        ,
        AnimationItem.prototype.stop = function(d) {
            d && this.name !== d || (this.pause(),
            this.playCount = 0,
            this._completedLoop = !1,
            this.setCurrentRawFrameValue(0))
        }
        ,
        AnimationItem.prototype.getMarkerData = function(d) {
            for (var g, b = 0; b < this.markers.length; b += 1)
                if (g = this.markers[b],
                g.payload && g.payload.name === d)
                    return g;
            return null
        }
        ,
        AnimationItem.prototype.goToAndStop = function(d, g, b) {
            if (!(b && this.name !== b)) {
                var _ = Number(d);
                if (isNaN(_)) {
                    var $ = this.getMarkerData(d);
                    $ && this.goToAndStop($.time, !0)
                } else
                    g ? this.setCurrentRawFrameValue(d) : this.setCurrentRawFrameValue(d * this.frameModifier);
                this.pause()
            }
        }
        ,
        AnimationItem.prototype.goToAndPlay = function(d, g, b) {
            if (!(b && this.name !== b)) {
                var _ = Number(d);
                if (isNaN(_)) {
                    var $ = this.getMarkerData(d);
                    $ && ($.duration ? this.playSegments([$.time, $.time + $.duration], !0) : this.goToAndStop($.time, !0))
                } else
                    this.goToAndStop(_, g, b);
                this.play()
            }
        }
        ,
        AnimationItem.prototype.advanceTime = function(d) {
            if (!(this.isPaused === !0 || this.isLoaded === !1)) {
                var g = this.currentRawFrame + d * this.frameModifier
                  , b = !1;
                g >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(g > this.totalFrames ? g % this.totalFrames : 0) || (b = !0,
                g = this.totalFrames - 1) : g >= this.totalFrames ? (this.playCount += 1,
                this.checkSegments(g % this.totalFrames) || (this.setCurrentRawFrameValue(g % this.totalFrames),
                this._completedLoop = !0,
                this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(g) : g < 0 ? this.checkSegments(g % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + g % this.totalFrames),
                this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (b = !0,
                g = 0)) : this.setCurrentRawFrameValue(g),
                b && (this.setCurrentRawFrameValue(g),
                this.pause(),
                this.trigger("complete"))
            }
        }
        ,
        AnimationItem.prototype.adjustSegment = function(d, g) {
            this.playCount = 0,
            d[1] < d[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
            this.totalFrames = d[0] - d[1],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = d[1],
            this.setCurrentRawFrameValue(this.totalFrames - .001 - g)) : d[1] > d[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
            this.totalFrames = d[1] - d[0],
            this.timeCompleted = this.totalFrames,
            this.firstFrame = d[0],
            this.setCurrentRawFrameValue(.001 + g)),
            this.trigger("segmentStart")
        }
        ,
        AnimationItem.prototype.setSegment = function(d, g) {
            var b = -1;
            this.isPaused && (this.currentRawFrame + this.firstFrame < d ? b = d : this.currentRawFrame + this.firstFrame > g && (b = g - d)),
            this.firstFrame = d,
            this.totalFrames = g - d,
            this.timeCompleted = this.totalFrames,
            b !== -1 && this.goToAndStop(b, !0)
        }
        ,
        AnimationItem.prototype.playSegments = function(d, g) {
            if (g && (this.segments.length = 0),
            _typeof$4(d[0]) === "object") {
                var b, _ = d.length;
                for (b = 0; b < _; b += 1)
                    this.segments.push(d[b])
            } else
                this.segments.push(d);
            this.segments.length && g && this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play()
        }
        ,
        AnimationItem.prototype.resetSegments = function(d) {
            this.segments.length = 0,
            this.segments.push([this.animationData.ip, this.animationData.op]),
            d && this.checkSegments(0)
        }
        ,
        AnimationItem.prototype.checkSegments = function(d) {
            return this.segments.length ? (this.adjustSegment(this.segments.shift(), d),
            !0) : !1
        }
        ,
        AnimationItem.prototype.destroy = function(d) {
            d && this.name !== d || !this.renderer || (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            this._cbs = null,
            this.onEnterFrame = null,
            this.onLoopComplete = null,
            this.onComplete = null,
            this.onSegmentStart = null,
            this.onDestroy = null,
            this.renderer = null,
            this.expressionsPlugin = null,
            this.imagePreloader = null,
            this.projectInterface = null)
        }
        ,
        AnimationItem.prototype.setCurrentRawFrameValue = function(d) {
            this.currentRawFrame = d,
            this.gotoFrame()
        }
        ,
        AnimationItem.prototype.setSpeed = function(d) {
            this.playSpeed = d,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setDirection = function(d) {
            this.playDirection = d < 0 ? -1 : 1,
            this.updaFrameModifier()
        }
        ,
        AnimationItem.prototype.setLoop = function(d) {
            this.loop = d
        }
        ,
        AnimationItem.prototype.setVolume = function(d, g) {
            g && this.name !== g || this.audioController.setVolume(d)
        }
        ,
        AnimationItem.prototype.getVolume = function() {
            return this.audioController.getVolume()
        }
        ,
        AnimationItem.prototype.mute = function(d) {
            d && this.name !== d || this.audioController.mute()
        }
        ,
        AnimationItem.prototype.unmute = function(d) {
            d && this.name !== d || this.audioController.unmute()
        }
        ,
        AnimationItem.prototype.updaFrameModifier = function() {
            this.frameModifier = this.frameMult * this.playSpeed * this.playDirection,
            this.audioController.setRate(this.playSpeed * this.playDirection)
        }
        ,
        AnimationItem.prototype.getPath = function() {
            return this.path
        }
        ,
        AnimationItem.prototype.getAssetsPath = function(d) {
            var g = "";
            if (d.e)
                g = d.p;
            else if (this.assetsPath) {
                var b = d.p;
                b.indexOf("images/") !== -1 && (b = b.split("/")[1]),
                g = this.assetsPath + b
            } else
                g = this.path,
                g += d.u ? d.u : "",
                g += d.p;
            return g
        }
        ,
        AnimationItem.prototype.getAssetData = function(d) {
            for (var g = 0, b = this.assets.length; g < b; ) {
                if (d === this.assets[g].id)
                    return this.assets[g];
                g += 1
            }
            return null
        }
        ,
        AnimationItem.prototype.hide = function() {
            this.renderer.hide()
        }
        ,
        AnimationItem.prototype.show = function() {
            this.renderer.show()
        }
        ,
        AnimationItem.prototype.getDuration = function(d) {
            return d ? this.totalFrames : this.totalFrames / this.frameRate
        }
        ,
        AnimationItem.prototype.updateDocumentData = function(d, g, b) {
            try {
                var _ = this.renderer.getElementByPath(d);
                _.updateDocumentData(g, b)
            } catch {}
        }
        ,
        AnimationItem.prototype.trigger = function(d) {
            if (this._cbs && this._cbs[d])
                switch (d) {
                case "enterFrame":
                    this.triggerEvent(d, new BMEnterFrameEvent(d,this.currentFrame,this.totalFrames,this.frameModifier));
                    break;
                case "drawnFrame":
                    this.drawnFrameEvent.currentTime = this.currentFrame,
                    this.drawnFrameEvent.totalTime = this.totalFrames,
                    this.drawnFrameEvent.direction = this.frameModifier,
                    this.triggerEvent(d, this.drawnFrameEvent);
                    break;
                case "loopComplete":
                    this.triggerEvent(d, new BMCompleteLoopEvent(d,this.loop,this.playCount,this.frameMult));
                    break;
                case "complete":
                    this.triggerEvent(d, new BMCompleteEvent(d,this.frameMult));
                    break;
                case "segmentStart":
                    this.triggerEvent(d, new BMSegmentStartEvent(d,this.firstFrame,this.totalFrames));
                    break;
                case "destroy":
                    this.triggerEvent(d, new BMDestroyEvent(d,this));
                    break;
                default:
                    this.triggerEvent(d)
                }
            d === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(d,this.currentFrame,this.totalFrames,this.frameMult)),
            d === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(d,this.loop,this.playCount,this.frameMult)),
            d === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(d,this.frameMult)),
            d === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(d,this.firstFrame,this.totalFrames)),
            d === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(d,this))
        }
        ,
        AnimationItem.prototype.triggerRenderFrameError = function(d) {
            var g = new BMRenderFrameErrorEvent(d,this.currentFrame);
            this.triggerEvent("error", g),
            this.onError && this.onError.call(this, g)
        }
        ,
        AnimationItem.prototype.triggerConfigError = function(d) {
            var g = new BMConfigErrorEvent(d,this.currentFrame);
            this.triggerEvent("error", g),
            this.onError && this.onError.call(this, g)
        }
        ;
        var animationManager = function() {
            var d = {}
              , g = []
              , b = 0
              , _ = 0
              , $ = 0
              , et = !0
              , tt = !1;
            function rt(Rt) {
                for (var qt = 0, Et = Rt.target; qt < _; )
                    g[qt].animation === Et && (g.splice(qt, 1),
                    qt -= 1,
                    _ -= 1,
                    Et.isPaused || at()),
                    qt += 1
            }
            function nt(Rt, qt) {
                if (!Rt)
                    return null;
                for (var Et = 0; Et < _; ) {
                    if (g[Et].elem === Rt && g[Et].elem !== null)
                        return g[Et].animation;
                    Et += 1
                }
                var St = new AnimationItem;
                return st(St, Rt),
                St.setData(Rt, qt),
                St
            }
            function it() {
                var Rt, qt = g.length, Et = [];
                for (Rt = 0; Rt < qt; Rt += 1)
                    Et.push(g[Rt].animation);
                return Et
            }
            function ot() {
                $ += 1,
                Wt()
            }
            function at() {
                $ -= 1
            }
            function st(Rt, qt) {
                Rt.addEventListener("destroy", rt),
                Rt.addEventListener("_active", ot),
                Rt.addEventListener("_idle", at),
                g.push({
                    elem: qt,
                    animation: Rt
                }),
                _ += 1
            }
            function dt(Rt) {
                var qt = new AnimationItem;
                return st(qt, null),
                qt.setParams(Rt),
                qt
            }
            function ft(Rt, qt) {
                var Et;
                for (Et = 0; Et < _; Et += 1)
                    g[Et].animation.setSpeed(Rt, qt)
            }
            function ht(Rt, qt) {
                var Et;
                for (Et = 0; Et < _; Et += 1)
                    g[Et].animation.setDirection(Rt, qt)
            }
            function xt(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.play(Rt)
            }
            function lt(Rt) {
                var qt = Rt - b, Et;
                for (Et = 0; Et < _; Et += 1)
                    g[Et].animation.advanceTime(qt);
                b = Rt,
                $ && !tt ? window.requestAnimationFrame(lt) : et = !0
            }
            function ct(Rt) {
                b = Rt,
                window.requestAnimationFrame(lt)
            }
            function ut(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.pause(Rt)
            }
            function pt(Rt, qt, Et) {
                var St;
                for (St = 0; St < _; St += 1)
                    g[St].animation.goToAndStop(Rt, qt, Et)
            }
            function vt(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.stop(Rt)
            }
            function _t(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.togglePause(Rt)
            }
            function Pt(Rt) {
                var qt;
                for (qt = _ - 1; qt >= 0; qt -= 1)
                    g[qt].animation.destroy(Rt)
            }
            function kt(Rt, qt, Et) {
                var St = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Lt, Mt = St.length;
                for (Lt = 0; Lt < Mt; Lt += 1)
                    Et && St[Lt].setAttribute("data-bm-type", Et),
                    nt(St[Lt], Rt);
                if (qt && Mt === 0) {
                    Et || (Et = "svg");
                    var ar = document.getElementsByTagName("body")[0];
                    ar.innerText = "";
                    var wr = createTag("div");
                    wr.style.width = "100%",
                    wr.style.height = "100%",
                    wr.setAttribute("data-bm-type", Et),
                    ar.appendChild(wr),
                    nt(wr, Rt)
                }
            }
            function $t() {
                var Rt;
                for (Rt = 0; Rt < _; Rt += 1)
                    g[Rt].animation.resize()
            }
            function Wt() {
                !tt && $ && et && (window.requestAnimationFrame(ct),
                et = !1)
            }
            function Ht() {
                tt = !0
            }
            function Dt() {
                tt = !1,
                Wt()
            }
            function Vt(Rt, qt) {
                var Et;
                for (Et = 0; Et < _; Et += 1)
                    g[Et].animation.setVolume(Rt, qt)
            }
            function Ft(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.mute(Rt)
            }
            function Kt(Rt) {
                var qt;
                for (qt = 0; qt < _; qt += 1)
                    g[qt].animation.unmute(Rt)
            }
            return d.registerAnimation = nt,
            d.loadAnimation = dt,
            d.setSpeed = ft,
            d.setDirection = ht,
            d.play = xt,
            d.pause = ut,
            d.stop = vt,
            d.togglePause = _t,
            d.searchAnimations = kt,
            d.resize = $t,
            d.goToAndStop = pt,
            d.destroy = Pt,
            d.freeze = Ht,
            d.unfreeze = Dt,
            d.setVolume = Vt,
            d.mute = Ft,
            d.unmute = Kt,
            d.getRegisteredAnimations = it,
            d
        }()
          , BezierFactory = function() {
            var d = {};
            d.getBezierEasing = b;
            var g = {};
            function b(ct, ut, pt, vt, _t) {
                var Pt = _t || ("bez_" + ct + "_" + ut + "_" + pt + "_" + vt).replace(/\./g, "p");
                if (g[Pt])
                    return g[Pt];
                var kt = new lt([ct, ut, pt, vt]);
                return g[Pt] = kt,
                kt
            }
            var _ = 4
              , $ = .001
              , et = 1e-7
              , tt = 10
              , rt = 11
              , nt = 1 / (rt - 1)
              , it = typeof Float32Array == "function";
            function ot(ct, ut) {
                return 1 - 3 * ut + 3 * ct
            }
            function at(ct, ut) {
                return 3 * ut - 6 * ct
            }
            function st(ct) {
                return 3 * ct
            }
            function dt(ct, ut, pt) {
                return ((ot(ut, pt) * ct + at(ut, pt)) * ct + st(ut)) * ct
            }
            function ft(ct, ut, pt) {
                return 3 * ot(ut, pt) * ct * ct + 2 * at(ut, pt) * ct + st(ut)
            }
            function ht(ct, ut, pt, vt, _t) {
                var Pt, kt, $t = 0;
                do
                    kt = ut + (pt - ut) / 2,
                    Pt = dt(kt, vt, _t) - ct,
                    Pt > 0 ? pt = kt : ut = kt;
                while (Math.abs(Pt) > et && ++$t < tt);
                return kt
            }
            function xt(ct, ut, pt, vt) {
                for (var _t = 0; _t < _; ++_t) {
                    var Pt = ft(ut, pt, vt);
                    if (Pt === 0)
                        return ut;
                    var kt = dt(ut, pt, vt) - ct;
                    ut -= kt / Pt
                }
                return ut
            }
            function lt(ct) {
                this._p = ct,
                this._mSampleValues = it ? new Float32Array(rt) : new Array(rt),
                this._precomputed = !1,
                this.get = this.get.bind(this)
            }
            return lt.prototype = {
                get: function(ut) {
                    var pt = this._p[0]
                      , vt = this._p[1]
                      , _t = this._p[2]
                      , Pt = this._p[3];
                    return this._precomputed || this._precompute(),
                    pt === vt && _t === Pt ? ut : ut === 0 ? 0 : ut === 1 ? 1 : dt(this._getTForX(ut), vt, Pt)
                },
                _precompute: function() {
                    var ut = this._p[0]
                      , pt = this._p[1]
                      , vt = this._p[2]
                      , _t = this._p[3];
                    this._precomputed = !0,
                    (ut !== pt || vt !== _t) && this._calcSampleValues()
                },
                _calcSampleValues: function() {
                    for (var ut = this._p[0], pt = this._p[2], vt = 0; vt < rt; ++vt)
                        this._mSampleValues[vt] = dt(vt * nt, ut, pt)
                },
                _getTForX: function(ut) {
                    for (var pt = this._p[0], vt = this._p[2], _t = this._mSampleValues, Pt = 0, kt = 1, $t = rt - 1; kt !== $t && _t[kt] <= ut; ++kt)
                        Pt += nt;
                    --kt;
                    var Wt = (ut - _t[kt]) / (_t[kt + 1] - _t[kt])
                      , Ht = Pt + Wt * nt
                      , Dt = ft(Ht, pt, vt);
                    return Dt >= $ ? xt(ut, Ht, pt, vt) : Dt === 0 ? Ht : ht(ut, Pt, Pt + nt, pt, vt)
                }
            },
            d
        }()
          , pooling = function() {
            function d(g) {
                return g.concat(createSizedArray(g.length))
            }
            return {
                double: d
            }
        }()
          , poolFactory = function() {
            return function(d, g, b) {
                var _ = 0
                  , $ = d
                  , et = createSizedArray($)
                  , tt = {
                    newElement: rt,
                    release: nt
                };
                function rt() {
                    var it;
                    return _ ? (_ -= 1,
                    it = et[_]) : it = g(),
                    it
                }
                function nt(it) {
                    _ === $ && (et = pooling.double(et),
                    $ *= 2),
                    b && b(it),
                    et[_] = it,
                    _ += 1
                }
                return tt
            }
        }()
          , bezierLengthPool = function() {
            function d() {
                return {
                    addedLength: 0,
                    percents: createTypedArray("float32", getDefaultCurveSegments()),
                    lengths: createTypedArray("float32", getDefaultCurveSegments())
                }
            }
            return poolFactory(8, d)
        }()
          , segmentsLengthPool = function() {
            function d() {
                return {
                    lengths: [],
                    totalLength: 0
                }
            }
            function g(b) {
                var _, $ = b.lengths.length;
                for (_ = 0; _ < $; _ += 1)
                    bezierLengthPool.release(b.lengths[_]);
                b.lengths.length = 0
            }
            return poolFactory(8, d, g)
        }();
        function bezFunction() {
            var d = Math;
            function g(st, dt, ft, ht, xt, lt) {
                var ct = st * ht + dt * xt + ft * lt - xt * ht - lt * st - ft * dt;
                return ct > -.001 && ct < .001
            }
            function b(st, dt, ft, ht, xt, lt, ct, ut, pt) {
                if (ft === 0 && lt === 0 && pt === 0)
                    return g(st, dt, ht, xt, ct, ut);
                var vt = d.sqrt(d.pow(ht - st, 2) + d.pow(xt - dt, 2) + d.pow(lt - ft, 2)), _t = d.sqrt(d.pow(ct - st, 2) + d.pow(ut - dt, 2) + d.pow(pt - ft, 2)), Pt = d.sqrt(d.pow(ct - ht, 2) + d.pow(ut - xt, 2) + d.pow(pt - lt, 2)), kt;
                return vt > _t ? vt > Pt ? kt = vt - _t - Pt : kt = Pt - _t - vt : Pt > _t ? kt = Pt - _t - vt : kt = _t - vt - Pt,
                kt > -1e-4 && kt < 1e-4
            }
            var _ = function() {
                return function(st, dt, ft, ht) {
                    var xt = getDefaultCurveSegments(), lt, ct, ut, pt, vt, _t = 0, Pt, kt = [], $t = [], Wt = bezierLengthPool.newElement();
                    for (ut = ft.length,
                    lt = 0; lt < xt; lt += 1) {
                        for (vt = lt / (xt - 1),
                        Pt = 0,
                        ct = 0; ct < ut; ct += 1)
                            pt = bmPow(1 - vt, 3) * st[ct] + 3 * bmPow(1 - vt, 2) * vt * ft[ct] + 3 * (1 - vt) * bmPow(vt, 2) * ht[ct] + bmPow(vt, 3) * dt[ct],
                            kt[ct] = pt,
                            $t[ct] !== null && (Pt += bmPow(kt[ct] - $t[ct], 2)),
                            $t[ct] = kt[ct];
                        Pt && (Pt = bmSqrt(Pt),
                        _t += Pt),
                        Wt.percents[lt] = vt,
                        Wt.lengths[lt] = _t
                    }
                    return Wt.addedLength = _t,
                    Wt
                }
            }();
            function $(st) {
                var dt = segmentsLengthPool.newElement(), ft = st.c, ht = st.v, xt = st.o, lt = st.i, ct, ut = st._length, pt = dt.lengths, vt = 0;
                for (ct = 0; ct < ut - 1; ct += 1)
                    pt[ct] = _(ht[ct], ht[ct + 1], xt[ct], lt[ct + 1]),
                    vt += pt[ct].addedLength;
                return ft && ut && (pt[ct] = _(ht[ct], ht[0], xt[ct], lt[0]),
                vt += pt[ct].addedLength),
                dt.totalLength = vt,
                dt
            }
            function et(st) {
                this.segmentLength = 0,
                this.points = new Array(st)
            }
            function tt(st, dt) {
                this.partialLength = st,
                this.point = dt
            }
            var rt = function() {
                var st = {};
                return function(dt, ft, ht, xt) {
                    var lt = (dt[0] + "_" + dt[1] + "_" + ft[0] + "_" + ft[1] + "_" + ht[0] + "_" + ht[1] + "_" + xt[0] + "_" + xt[1]).replace(/\./g, "p");
                    if (!st[lt]) {
                        var ct = getDefaultCurveSegments(), ut, pt, vt, _t, Pt, kt = 0, $t, Wt, Ht = null;
                        dt.length === 2 && (dt[0] !== ft[0] || dt[1] !== ft[1]) && g(dt[0], dt[1], ft[0], ft[1], dt[0] + ht[0], dt[1] + ht[1]) && g(dt[0], dt[1], ft[0], ft[1], ft[0] + xt[0], ft[1] + xt[1]) && (ct = 2);
                        var Dt = new et(ct);
                        for (vt = ht.length,
                        ut = 0; ut < ct; ut += 1) {
                            for (Wt = createSizedArray(vt),
                            Pt = ut / (ct - 1),
                            $t = 0,
                            pt = 0; pt < vt; pt += 1)
                                _t = bmPow(1 - Pt, 3) * dt[pt] + 3 * bmPow(1 - Pt, 2) * Pt * (dt[pt] + ht[pt]) + 3 * (1 - Pt) * bmPow(Pt, 2) * (ft[pt] + xt[pt]) + bmPow(Pt, 3) * ft[pt],
                                Wt[pt] = _t,
                                Ht !== null && ($t += bmPow(Wt[pt] - Ht[pt], 2));
                            $t = bmSqrt($t),
                            kt += $t,
                            Dt.points[ut] = new tt($t,Wt),
                            Ht = Wt
                        }
                        Dt.segmentLength = kt,
                        st[lt] = Dt
                    }
                    return st[lt]
                }
            }();
            function nt(st, dt) {
                var ft = dt.percents
                  , ht = dt.lengths
                  , xt = ft.length
                  , lt = bmFloor((xt - 1) * st)
                  , ct = st * dt.addedLength
                  , ut = 0;
                if (lt === xt - 1 || lt === 0 || ct === ht[lt])
                    return ft[lt];
                for (var pt = ht[lt] > ct ? -1 : 1, vt = !0; vt; )
                    if (ht[lt] <= ct && ht[lt + 1] > ct ? (ut = (ct - ht[lt]) / (ht[lt + 1] - ht[lt]),
                    vt = !1) : lt += pt,
                    lt < 0 || lt >= xt - 1) {
                        if (lt === xt - 1)
                            return ft[lt];
                        vt = !1
                    }
                return ft[lt] + (ft[lt + 1] - ft[lt]) * ut
            }
            function it(st, dt, ft, ht, xt, lt) {
                var ct = nt(xt, lt)
                  , ut = 1 - ct
                  , pt = d.round((ut * ut * ut * st[0] + (ct * ut * ut + ut * ct * ut + ut * ut * ct) * ft[0] + (ct * ct * ut + ut * ct * ct + ct * ut * ct) * ht[0] + ct * ct * ct * dt[0]) * 1e3) / 1e3
                  , vt = d.round((ut * ut * ut * st[1] + (ct * ut * ut + ut * ct * ut + ut * ut * ct) * ft[1] + (ct * ct * ut + ut * ct * ct + ct * ut * ct) * ht[1] + ct * ct * ct * dt[1]) * 1e3) / 1e3;
                return [pt, vt]
            }
            var ot = createTypedArray("float32", 8);
            function at(st, dt, ft, ht, xt, lt, ct) {
                xt < 0 ? xt = 0 : xt > 1 && (xt = 1);
                var ut = nt(xt, ct);
                lt = lt > 1 ? 1 : lt;
                var pt = nt(lt, ct), vt, _t = st.length, Pt = 1 - ut, kt = 1 - pt, $t = Pt * Pt * Pt, Wt = ut * Pt * Pt * 3, Ht = ut * ut * Pt * 3, Dt = ut * ut * ut, Vt = Pt * Pt * kt, Ft = ut * Pt * kt + Pt * ut * kt + Pt * Pt * pt, Kt = ut * ut * kt + Pt * ut * pt + ut * Pt * pt, Rt = ut * ut * pt, qt = Pt * kt * kt, Et = ut * kt * kt + Pt * pt * kt + Pt * kt * pt, St = ut * pt * kt + Pt * pt * pt + ut * kt * pt, Lt = ut * pt * pt, Mt = kt * kt * kt, ar = pt * kt * kt + kt * pt * kt + kt * kt * pt, wr = pt * pt * kt + kt * pt * pt + pt * kt * pt, Tr = pt * pt * pt;
                for (vt = 0; vt < _t; vt += 1)
                    ot[vt * 4] = d.round(($t * st[vt] + Wt * ft[vt] + Ht * ht[vt] + Dt * dt[vt]) * 1e3) / 1e3,
                    ot[vt * 4 + 1] = d.round((Vt * st[vt] + Ft * ft[vt] + Kt * ht[vt] + Rt * dt[vt]) * 1e3) / 1e3,
                    ot[vt * 4 + 2] = d.round((qt * st[vt] + Et * ft[vt] + St * ht[vt] + Lt * dt[vt]) * 1e3) / 1e3,
                    ot[vt * 4 + 3] = d.round((Mt * st[vt] + ar * ft[vt] + wr * ht[vt] + Tr * dt[vt]) * 1e3) / 1e3;
                return ot
            }
            return {
                getSegmentsLength: $,
                getNewSegment: at,
                getPointInSegment: it,
                buildBezierData: rt,
                pointOnLine2D: g,
                pointOnLine3D: b
            }
        }
        var bez = bezFunction()
          , initFrame = initialDefaultFrame
          , mathAbs = Math.abs;
        function interpolateValue(d, g) {
            var b = this.offsetTime, _;
            this.propType === "multidimensional" && (_ = createTypedArray("float32", this.pv.length));
            for (var $ = g.lastIndex, et = $, tt = this.keyframes.length - 1, rt = !0, nt, it, ot; rt; ) {
                if (nt = this.keyframes[et],
                it = this.keyframes[et + 1],
                et === tt - 1 && d >= it.t - b) {
                    nt.h && (nt = it),
                    $ = 0;
                    break
                }
                if (it.t - b > d) {
                    $ = et;
                    break
                }
                et < tt - 1 ? et += 1 : ($ = 0,
                rt = !1)
            }
            ot = this.keyframesMetadata[et] || {};
            var at, st, dt, ft, ht, xt, lt = it.t - b, ct = nt.t - b, ut;
            if (nt.to) {
                ot.bezierData || (ot.bezierData = bez.buildBezierData(nt.s, it.s || nt.e, nt.to, nt.ti));
                var pt = ot.bezierData;
                if (d >= lt || d < ct) {
                    var vt = d >= lt ? pt.points.length - 1 : 0;
                    for (st = pt.points[vt].point.length,
                    at = 0; at < st; at += 1)
                        _[at] = pt.points[vt].point[at]
                } else {
                    ot.__fnct ? xt = ot.__fnct : (xt = BezierFactory.getBezierEasing(nt.o.x, nt.o.y, nt.i.x, nt.i.y, nt.n).get,
                    ot.__fnct = xt),
                    dt = xt((d - ct) / (lt - ct));
                    var _t = pt.segmentLength * dt, Pt, kt = g.lastFrame < d && g._lastKeyframeIndex === et ? g._lastAddedLength : 0;
                    for (ht = g.lastFrame < d && g._lastKeyframeIndex === et ? g._lastPoint : 0,
                    rt = !0,
                    ft = pt.points.length; rt; ) {
                        if (kt += pt.points[ht].partialLength,
                        _t === 0 || dt === 0 || ht === pt.points.length - 1) {
                            for (st = pt.points[ht].point.length,
                            at = 0; at < st; at += 1)
                                _[at] = pt.points[ht].point[at];
                            break
                        } else if (_t >= kt && _t < kt + pt.points[ht + 1].partialLength) {
                            for (Pt = (_t - kt) / pt.points[ht + 1].partialLength,
                            st = pt.points[ht].point.length,
                            at = 0; at < st; at += 1)
                                _[at] = pt.points[ht].point[at] + (pt.points[ht + 1].point[at] - pt.points[ht].point[at]) * Pt;
                            break
                        }
                        ht < ft - 1 ? ht += 1 : rt = !1
                    }
                    g._lastPoint = ht,
                    g._lastAddedLength = kt - pt.points[ht].partialLength,
                    g._lastKeyframeIndex = et
                }
            } else {
                var $t, Wt, Ht, Dt, Vt;
                if (tt = nt.s.length,
                ut = it.s || nt.e,
                this.sh && nt.h !== 1)
                    if (d >= lt)
                        _[0] = ut[0],
                        _[1] = ut[1],
                        _[2] = ut[2];
                    else if (d <= ct)
                        _[0] = nt.s[0],
                        _[1] = nt.s[1],
                        _[2] = nt.s[2];
                    else {
                        var Ft = createQuaternion(nt.s)
                          , Kt = createQuaternion(ut)
                          , Rt = (d - ct) / (lt - ct);
                        quaternionToEuler(_, slerp(Ft, Kt, Rt))
                    }
                else
                    for (et = 0; et < tt; et += 1)
                        nt.h !== 1 && (d >= lt ? dt = 1 : d < ct ? dt = 0 : (nt.o.x.constructor === Array ? (ot.__fnct || (ot.__fnct = []),
                        ot.__fnct[et] ? xt = ot.__fnct[et] : ($t = nt.o.x[et] === void 0 ? nt.o.x[0] : nt.o.x[et],
                        Wt = nt.o.y[et] === void 0 ? nt.o.y[0] : nt.o.y[et],
                        Ht = nt.i.x[et] === void 0 ? nt.i.x[0] : nt.i.x[et],
                        Dt = nt.i.y[et] === void 0 ? nt.i.y[0] : nt.i.y[et],
                        xt = BezierFactory.getBezierEasing($t, Wt, Ht, Dt).get,
                        ot.__fnct[et] = xt)) : ot.__fnct ? xt = ot.__fnct : ($t = nt.o.x,
                        Wt = nt.o.y,
                        Ht = nt.i.x,
                        Dt = nt.i.y,
                        xt = BezierFactory.getBezierEasing($t, Wt, Ht, Dt).get,
                        nt.keyframeMetadata = xt),
                        dt = xt((d - ct) / (lt - ct)))),
                        ut = it.s || nt.e,
                        Vt = nt.h === 1 ? nt.s[et] : nt.s[et] + (ut[et] - nt.s[et]) * dt,
                        this.propType === "multidimensional" ? _[et] = Vt : _ = Vt
            }
            return g.lastIndex = $,
            _
        }
        function slerp(d, g, b) {
            var _ = [], $ = d[0], et = d[1], tt = d[2], rt = d[3], nt = g[0], it = g[1], ot = g[2], at = g[3], st, dt, ft, ht, xt;
            return dt = $ * nt + et * it + tt * ot + rt * at,
            dt < 0 && (dt = -dt,
            nt = -nt,
            it = -it,
            ot = -ot,
            at = -at),
            1 - dt > 1e-6 ? (st = Math.acos(dt),
            ft = Math.sin(st),
            ht = Math.sin((1 - b) * st) / ft,
            xt = Math.sin(b * st) / ft) : (ht = 1 - b,
            xt = b),
            _[0] = ht * $ + xt * nt,
            _[1] = ht * et + xt * it,
            _[2] = ht * tt + xt * ot,
            _[3] = ht * rt + xt * at,
            _
        }
        function quaternionToEuler(d, g) {
            var b = g[0]
              , _ = g[1]
              , $ = g[2]
              , et = g[3]
              , tt = Math.atan2(2 * _ * et - 2 * b * $, 1 - 2 * _ * _ - 2 * $ * $)
              , rt = Math.asin(2 * b * _ + 2 * $ * et)
              , nt = Math.atan2(2 * b * et - 2 * _ * $, 1 - 2 * b * b - 2 * $ * $);
            d[0] = tt / degToRads,
            d[1] = rt / degToRads,
            d[2] = nt / degToRads
        }
        function createQuaternion(d) {
            var g = d[0] * degToRads
              , b = d[1] * degToRads
              , _ = d[2] * degToRads
              , $ = Math.cos(g / 2)
              , et = Math.cos(b / 2)
              , tt = Math.cos(_ / 2)
              , rt = Math.sin(g / 2)
              , nt = Math.sin(b / 2)
              , it = Math.sin(_ / 2)
              , ot = $ * et * tt - rt * nt * it
              , at = rt * nt * tt + $ * et * it
              , st = rt * et * tt + $ * nt * it
              , dt = $ * nt * tt - rt * et * it;
            return [at, st, dt, ot]
        }
        function getValueAtCurrentTime() {
            var d = this.comp.renderedFrame - this.offsetTime
              , g = this.keyframes[0].t - this.offsetTime
              , b = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(d === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= b && d >= b || this._caching.lastFrame < g && d < g))) {
                this._caching.lastFrame >= d && (this._caching._lastKeyframeIndex = -1,
                this._caching.lastIndex = 0);
                var _ = this.interpolateValue(d, this._caching);
                this.pv = _
            }
            return this._caching.lastFrame = d,
            this.pv
        }
        function setVValue(d) {
            var g;
            if (this.propType === "unidimensional")
                g = d * this.mult,
                mathAbs(this.v - g) > 1e-5 && (this.v = g,
                this._mdf = !0);
            else
                for (var b = 0, _ = this.v.length; b < _; )
                    g = d[b] * this.mult,
                    mathAbs(this.v[b] - g) > 1e-5 && (this.v[b] = g,
                    this._mdf = !0),
                    b += 1
        }
        function processEffectsSequence() {
            if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
                if (this.lock) {
                    this.setVValue(this.pv);
                    return
                }
                this.lock = !0,
                this._mdf = this._isFirstFrame;
                var d, g = this.effectsSequence.length, b = this.kf ? this.pv : this.data.k;
                for (d = 0; d < g; d += 1)
                    b = this.effectsSequence[d](b);
                this.setVValue(b),
                this._isFirstFrame = !1,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        function addEffect(d) {
            this.effectsSequence.push(d),
            this.container.addDynamicProperty(this)
        }
        function ValueProperty(d, g, b, _) {
            this.propType = "unidimensional",
            this.mult = b || 1,
            this.data = g,
            this.v = b ? g.k * b : g.k,
            this.pv = g.k,
            this._mdf = !1,
            this.elem = d,
            this.container = _,
            this.comp = d.comp,
            this.k = !1,
            this.kf = !1,
            this.vel = 0,
            this.effectsSequence = [],
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function MultiDimensionalProperty(d, g, b, _) {
            this.propType = "multidimensional",
            this.mult = b || 1,
            this.data = g,
            this._mdf = !1,
            this.elem = d,
            this.container = _,
            this.comp = d.comp,
            this.k = !1,
            this.kf = !1,
            this.frameId = -1;
            var $, et = g.k.length;
            for (this.v = createTypedArray("float32", et),
            this.pv = createTypedArray("float32", et),
            this.vel = createTypedArray("float32", et),
            $ = 0; $ < et; $ += 1)
                this.v[$] = g.k[$] * this.mult,
                this.pv[$] = g.k[$];
            this._isFirstFrame = !0,
            this.effectsSequence = [],
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.addEffect = addEffect
        }
        function KeyframedValueProperty(d, g, b, _) {
            this.propType = "unidimensional",
            this.keyframes = g.k,
            this.keyframesMetadata = [],
            this.offsetTime = d.data.st,
            this.frameId = -1,
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: 0,
                _lastKeyframeIndex: -1
            },
            this.k = !0,
            this.kf = !0,
            this.data = g,
            this.mult = b || 1,
            this.elem = d,
            this.container = _,
            this.comp = d.comp,
            this.v = initFrame,
            this.pv = initFrame,
            this._isFirstFrame = !0,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.addEffect = addEffect
        }
        function KeyframedMultidimensionalProperty(d, g, b, _) {
            this.propType = "multidimensional";
            var $, et = g.k.length, tt, rt, nt, it;
            for ($ = 0; $ < et - 1; $ += 1)
                g.k[$].to && g.k[$].s && g.k[$ + 1] && g.k[$ + 1].s && (tt = g.k[$].s,
                rt = g.k[$ + 1].s,
                nt = g.k[$].to,
                it = g.k[$].ti,
                (tt.length === 2 && !(tt[0] === rt[0] && tt[1] === rt[1]) && bez.pointOnLine2D(tt[0], tt[1], rt[0], rt[1], tt[0] + nt[0], tt[1] + nt[1]) && bez.pointOnLine2D(tt[0], tt[1], rt[0], rt[1], rt[0] + it[0], rt[1] + it[1]) || tt.length === 3 && !(tt[0] === rt[0] && tt[1] === rt[1] && tt[2] === rt[2]) && bez.pointOnLine3D(tt[0], tt[1], tt[2], rt[0], rt[1], rt[2], tt[0] + nt[0], tt[1] + nt[1], tt[2] + nt[2]) && bez.pointOnLine3D(tt[0], tt[1], tt[2], rt[0], rt[1], rt[2], rt[0] + it[0], rt[1] + it[1], rt[2] + it[2])) && (g.k[$].to = null,
                g.k[$].ti = null),
                tt[0] === rt[0] && tt[1] === rt[1] && nt[0] === 0 && nt[1] === 0 && it[0] === 0 && it[1] === 0 && (tt.length === 2 || tt[2] === rt[2] && nt[2] === 0 && it[2] === 0) && (g.k[$].to = null,
                g.k[$].ti = null));
            this.effectsSequence = [getValueAtCurrentTime.bind(this)],
            this.data = g,
            this.keyframes = g.k,
            this.keyframesMetadata = [],
            this.offsetTime = d.data.st,
            this.k = !0,
            this.kf = !0,
            this._isFirstFrame = !0,
            this.mult = b || 1,
            this.elem = d,
            this.container = _,
            this.comp = d.comp,
            this.getValue = processEffectsSequence,
            this.setVValue = setVValue,
            this.interpolateValue = interpolateValue,
            this.frameId = -1;
            var ot = g.k[0].s.length;
            for (this.v = createTypedArray("float32", ot),
            this.pv = createTypedArray("float32", ot),
            $ = 0; $ < ot; $ += 1)
                this.v[$] = initFrame,
                this.pv[$] = initFrame;
            this._caching = {
                lastFrame: initFrame,
                lastIndex: 0,
                value: createTypedArray("float32", ot)
            },
            this.addEffect = addEffect
        }
        var PropertyFactory = function() {
            function d(b, _, $, et, tt) {
                _.sid && (_ = b.globalData.slotManager.getProp(_));
                var rt;
                if (!_.k.length)
                    rt = new ValueProperty(b,_,et,tt);
                else if (typeof _.k[0] == "number")
                    rt = new MultiDimensionalProperty(b,_,et,tt);
                else
                    switch ($) {
                    case 0:
                        rt = new KeyframedValueProperty(b,_,et,tt);
                        break;
                    case 1:
                        rt = new KeyframedMultidimensionalProperty(b,_,et,tt);
                        break
                    }
                return rt.effectsSequence.length && tt.addDynamicProperty(rt),
                rt
            }
            var g = {
                getProp: d
            };
            return g
        }();
        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
            addDynamicProperty: function(g) {
                this.dynamicProperties.indexOf(g) === -1 && (this.dynamicProperties.push(g),
                this.container.addDynamicProperty(this),
                this._isAnimated = !0)
            },
            iterateDynamicProperties: function() {
                this._mdf = !1;
                var g, b = this.dynamicProperties.length;
                for (g = 0; g < b; g += 1)
                    this.dynamicProperties[g].getValue(),
                    this.dynamicProperties[g]._mdf && (this._mdf = !0)
            },
            initDynamicPropertyContainer: function(g) {
                this.container = g,
                this.dynamicProperties = [],
                this._mdf = !1,
                this._isAnimated = !1
            }
        };
        var pointPool = function() {
            function d() {
                return createTypedArray("float32", 2)
            }
            return poolFactory(8, d)
        }();
        function ShapePath() {
            this.c = !1,
            this._length = 0,
            this._maxLength = 8,
            this.v = createSizedArray(this._maxLength),
            this.o = createSizedArray(this._maxLength),
            this.i = createSizedArray(this._maxLength)
        }
        ShapePath.prototype.setPathData = function(d, g) {
            this.c = d,
            this.setLength(g);
            for (var b = 0; b < g; )
                this.v[b] = pointPool.newElement(),
                this.o[b] = pointPool.newElement(),
                this.i[b] = pointPool.newElement(),
                b += 1
        }
        ,
        ShapePath.prototype.setLength = function(d) {
            for (; this._maxLength < d; )
                this.doubleArrayLength();
            this._length = d
        }
        ,
        ShapePath.prototype.doubleArrayLength = function() {
            this.v = this.v.concat(createSizedArray(this._maxLength)),
            this.i = this.i.concat(createSizedArray(this._maxLength)),
            this.o = this.o.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2
        }
        ,
        ShapePath.prototype.setXYAt = function(d, g, b, _, $) {
            var et;
            switch (this._length = Math.max(this._length, _ + 1),
            this._length >= this._maxLength && this.doubleArrayLength(),
            b) {
            case "v":
                et = this.v;
                break;
            case "i":
                et = this.i;
                break;
            case "o":
                et = this.o;
                break;
            default:
                et = [];
                break
            }
            (!et[_] || et[_] && !$) && (et[_] = pointPool.newElement()),
            et[_][0] = d,
            et[_][1] = g
        }
        ,
        ShapePath.prototype.setTripleAt = function(d, g, b, _, $, et, tt, rt) {
            this.setXYAt(d, g, "v", tt, rt),
            this.setXYAt(b, _, "o", tt, rt),
            this.setXYAt($, et, "i", tt, rt)
        }
        ,
        ShapePath.prototype.reverse = function() {
            var d = new ShapePath;
            d.setPathData(this.c, this._length);
            var g = this.v
              , b = this.o
              , _ = this.i
              , $ = 0;
            this.c && (d.setTripleAt(g[0][0], g[0][1], _[0][0], _[0][1], b[0][0], b[0][1], 0, !1),
            $ = 1);
            var et = this._length - 1, tt = this._length, rt;
            for (rt = $; rt < tt; rt += 1)
                d.setTripleAt(g[et][0], g[et][1], _[et][0], _[et][1], b[et][0], b[et][1], rt, !1),
                et -= 1;
            return d
        }
        ,
        ShapePath.prototype.length = function() {
            return this._length
        }
        ;
        var shapePool = function() {
            function d() {
                return new ShapePath
            }
            function g($) {
                var et = $._length, tt;
                for (tt = 0; tt < et; tt += 1)
                    pointPool.release($.v[tt]),
                    pointPool.release($.i[tt]),
                    pointPool.release($.o[tt]),
                    $.v[tt] = null,
                    $.i[tt] = null,
                    $.o[tt] = null;
                $._length = 0,
                $.c = !1
            }
            function b($) {
                var et = _.newElement(), tt, rt = $._length === void 0 ? $.v.length : $._length;
                for (et.setLength(rt),
                et.c = $.c,
                tt = 0; tt < rt; tt += 1)
                    et.setTripleAt($.v[tt][0], $.v[tt][1], $.o[tt][0], $.o[tt][1], $.i[tt][0], $.i[tt][1], tt);
                return et
            }
            var _ = poolFactory(4, d, g);
            return _.clone = b,
            _
        }();
        function ShapeCollection() {
            this._length = 0,
            this._maxLength = 4,
            this.shapes = createSizedArray(this._maxLength)
        }
        ShapeCollection.prototype.addShape = function(d) {
            this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)),
            this._maxLength *= 2),
            this.shapes[this._length] = d,
            this._length += 1
        }
        ,
        ShapeCollection.prototype.releaseShapes = function() {
            var d;
            for (d = 0; d < this._length; d += 1)
                shapePool.release(this.shapes[d]);
            this._length = 0
        }
        ;
        var shapeCollectionPool = function() {
            var d = {
                newShapeCollection: $,
                release: et
            }
              , g = 0
              , b = 4
              , _ = createSizedArray(b);
            function $() {
                var tt;
                return g ? (g -= 1,
                tt = _[g]) : tt = new ShapeCollection,
                tt
            }
            function et(tt) {
                var rt, nt = tt._length;
                for (rt = 0; rt < nt; rt += 1)
                    shapePool.release(tt.shapes[rt]);
                tt._length = 0,
                g === b && (_ = pooling.double(_),
                b *= 2),
                _[g] = tt,
                g += 1
            }
            return d
        }()
          , ShapePropertyFactory = function() {
            var d = -999999;
            function g(lt, ct, ut) {
                var pt = ut.lastIndex, vt, _t, Pt, kt, $t, Wt, Ht, Dt, Vt, Ft = this.keyframes;
                if (lt < Ft[0].t - this.offsetTime)
                    vt = Ft[0].s[0],
                    Pt = !0,
                    pt = 0;
                else if (lt >= Ft[Ft.length - 1].t - this.offsetTime)
                    vt = Ft[Ft.length - 1].s ? Ft[Ft.length - 1].s[0] : Ft[Ft.length - 2].e[0],
                    Pt = !0;
                else {
                    for (var Kt = pt, Rt = Ft.length - 1, qt = !0, Et, St, Lt; qt && (Et = Ft[Kt],
                    St = Ft[Kt + 1],
                    !(St.t - this.offsetTime > lt)); )
                        Kt < Rt - 1 ? Kt += 1 : qt = !1;
                    if (Lt = this.keyframesMetadata[Kt] || {},
                    Pt = Et.h === 1,
                    pt = Kt,
                    !Pt) {
                        if (lt >= St.t - this.offsetTime)
                            Dt = 1;
                        else if (lt < Et.t - this.offsetTime)
                            Dt = 0;
                        else {
                            var Mt;
                            Lt.__fnct ? Mt = Lt.__fnct : (Mt = BezierFactory.getBezierEasing(Et.o.x, Et.o.y, Et.i.x, Et.i.y).get,
                            Lt.__fnct = Mt),
                            Dt = Mt((lt - (Et.t - this.offsetTime)) / (St.t - this.offsetTime - (Et.t - this.offsetTime)))
                        }
                        _t = St.s ? St.s[0] : Et.e[0]
                    }
                    vt = Et.s[0]
                }
                for (Wt = ct._length,
                Ht = vt.i[0].length,
                ut.lastIndex = pt,
                kt = 0; kt < Wt; kt += 1)
                    for ($t = 0; $t < Ht; $t += 1)
                        Vt = Pt ? vt.i[kt][$t] : vt.i[kt][$t] + (_t.i[kt][$t] - vt.i[kt][$t]) * Dt,
                        ct.i[kt][$t] = Vt,
                        Vt = Pt ? vt.o[kt][$t] : vt.o[kt][$t] + (_t.o[kt][$t] - vt.o[kt][$t]) * Dt,
                        ct.o[kt][$t] = Vt,
                        Vt = Pt ? vt.v[kt][$t] : vt.v[kt][$t] + (_t.v[kt][$t] - vt.v[kt][$t]) * Dt,
                        ct.v[kt][$t] = Vt
            }
            function b() {
                var lt = this.comp.renderedFrame - this.offsetTime
                  , ct = this.keyframes[0].t - this.offsetTime
                  , ut = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
                  , pt = this._caching.lastFrame;
                return pt !== d && (pt < ct && lt < ct || pt > ut && lt > ut) || (this._caching.lastIndex = pt < lt ? this._caching.lastIndex : 0,
                this.interpolateShape(lt, this.pv, this._caching)),
                this._caching.lastFrame = lt,
                this.pv
            }
            function _() {
                this.paths = this.localShapeCollection
            }
            function $(lt, ct) {
                if (lt._length !== ct._length || lt.c !== ct.c)
                    return !1;
                var ut, pt = lt._length;
                for (ut = 0; ut < pt; ut += 1)
                    if (lt.v[ut][0] !== ct.v[ut][0] || lt.v[ut][1] !== ct.v[ut][1] || lt.o[ut][0] !== ct.o[ut][0] || lt.o[ut][1] !== ct.o[ut][1] || lt.i[ut][0] !== ct.i[ut][0] || lt.i[ut][1] !== ct.i[ut][1])
                        return !1;
                return !0
            }
            function et(lt) {
                $(this.v, lt) || (this.v = shapePool.clone(lt),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                this._mdf = !0,
                this.paths = this.localShapeCollection)
            }
            function tt() {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (!this.effectsSequence.length) {
                        this._mdf = !1;
                        return
                    }
                    if (this.lock) {
                        this.setVValue(this.pv);
                        return
                    }
                    this.lock = !0,
                    this._mdf = !1;
                    var lt;
                    this.kf ? lt = this.pv : this.data.ks ? lt = this.data.ks.k : lt = this.data.pt.k;
                    var ct, ut = this.effectsSequence.length;
                    for (ct = 0; ct < ut; ct += 1)
                        lt = this.effectsSequence[ct](lt);
                    this.setVValue(lt),
                    this.lock = !1,
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function rt(lt, ct, ut) {
                this.propType = "shape",
                this.comp = lt.comp,
                this.container = lt,
                this.elem = lt,
                this.data = ct,
                this.k = !1,
                this.kf = !1,
                this._mdf = !1;
                var pt = ut === 3 ? ct.pt.k : ct.ks.k;
                this.v = shapePool.clone(pt),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.reset = _,
                this.effectsSequence = []
            }
            function nt(lt) {
                this.effectsSequence.push(lt),
                this.container.addDynamicProperty(this)
            }
            rt.prototype.interpolateShape = g,
            rt.prototype.getValue = tt,
            rt.prototype.setVValue = et,
            rt.prototype.addEffect = nt;
            function it(lt, ct, ut) {
                this.propType = "shape",
                this.comp = lt.comp,
                this.elem = lt,
                this.container = lt,
                this.offsetTime = lt.data.st,
                this.keyframes = ut === 3 ? ct.pt.k : ct.ks.k,
                this.keyframesMetadata = [],
                this.k = !0,
                this.kf = !0;
                var pt = this.keyframes[0].s[0].i.length;
                this.v = shapePool.newElement(),
                this.v.setPathData(this.keyframes[0].s[0].c, pt),
                this.pv = shapePool.clone(this.v),
                this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                this.paths = this.localShapeCollection,
                this.paths.addShape(this.v),
                this.lastFrame = d,
                this.reset = _,
                this._caching = {
                    lastFrame: d,
                    lastIndex: 0
                },
                this.effectsSequence = [b.bind(this)]
            }
            it.prototype.getValue = tt,
            it.prototype.interpolateShape = g,
            it.prototype.setVValue = et,
            it.prototype.addEffect = nt;
            var ot = function() {
                var lt = roundCorner;
                function ct(ut, pt) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 4),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.paths = this.localShapeCollection,
                    this.localShapeCollection.addShape(this.v),
                    this.d = pt.d,
                    this.elem = ut,
                    this.comp = ut.comp,
                    this.frameId = -1,
                    this.initDynamicPropertyContainer(ut),
                    this.p = PropertyFactory.getProp(ut, pt.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(ut, pt.s, 1, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertEllToPath())
                }
                return ct.prototype = {
                    reset: _,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertEllToPath())
                    },
                    convertEllToPath: function() {
                        var pt = this.p.v[0]
                          , vt = this.p.v[1]
                          , _t = this.s.v[0] / 2
                          , Pt = this.s.v[1] / 2
                          , kt = this.d !== 3
                          , $t = this.v;
                        $t.v[0][0] = pt,
                        $t.v[0][1] = vt - Pt,
                        $t.v[1][0] = kt ? pt + _t : pt - _t,
                        $t.v[1][1] = vt,
                        $t.v[2][0] = pt,
                        $t.v[2][1] = vt + Pt,
                        $t.v[3][0] = kt ? pt - _t : pt + _t,
                        $t.v[3][1] = vt,
                        $t.i[0][0] = kt ? pt - _t * lt : pt + _t * lt,
                        $t.i[0][1] = vt - Pt,
                        $t.i[1][0] = kt ? pt + _t : pt - _t,
                        $t.i[1][1] = vt - Pt * lt,
                        $t.i[2][0] = kt ? pt + _t * lt : pt - _t * lt,
                        $t.i[2][1] = vt + Pt,
                        $t.i[3][0] = kt ? pt - _t : pt + _t,
                        $t.i[3][1] = vt + Pt * lt,
                        $t.o[0][0] = kt ? pt + _t * lt : pt - _t * lt,
                        $t.o[0][1] = vt - Pt,
                        $t.o[1][0] = kt ? pt + _t : pt - _t,
                        $t.o[1][1] = vt + Pt * lt,
                        $t.o[2][0] = kt ? pt - _t * lt : pt + _t * lt,
                        $t.o[2][1] = vt + Pt,
                        $t.o[3][0] = kt ? pt - _t : pt + _t,
                        $t.o[3][1] = vt - Pt * lt
                    }
                },
                extendPrototype([DynamicPropertyContainer], ct),
                ct
            }()
              , at = function() {
                function lt(ct, ut) {
                    this.v = shapePool.newElement(),
                    this.v.setPathData(!0, 0),
                    this.elem = ct,
                    this.comp = ct.comp,
                    this.data = ut,
                    this.frameId = -1,
                    this.d = ut.d,
                    this.initDynamicPropertyContainer(ct),
                    ut.sy === 1 ? (this.ir = PropertyFactory.getProp(ct, ut.ir, 0, 0, this),
                    this.is = PropertyFactory.getProp(ct, ut.is, 0, .01, this),
                    this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath,
                    this.pt = PropertyFactory.getProp(ct, ut.pt, 0, 0, this),
                    this.p = PropertyFactory.getProp(ct, ut.p, 1, 0, this),
                    this.r = PropertyFactory.getProp(ct, ut.r, 0, degToRads, this),
                    this.or = PropertyFactory.getProp(ct, ut.or, 0, 0, this),
                    this.os = PropertyFactory.getProp(ct, ut.os, 0, .01, this),
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertToPath())
                }
                return lt.prototype = {
                    reset: _,
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertToPath())
                    },
                    convertStarToPath: function() {
                        var ut = Math.floor(this.pt.v) * 2, pt = Math.PI * 2 / ut, vt = !0, _t = this.or.v, Pt = this.ir.v, kt = this.os.v, $t = this.is.v, Wt = 2 * Math.PI * _t / (ut * 2), Ht = 2 * Math.PI * Pt / (ut * 2), Dt, Vt, Ft, Kt, Rt = -Math.PI / 2;
                        Rt += this.r.v;
                        var qt = this.data.d === 3 ? -1 : 1;
                        for (this.v._length = 0,
                        Dt = 0; Dt < ut; Dt += 1) {
                            Vt = vt ? _t : Pt,
                            Ft = vt ? kt : $t,
                            Kt = vt ? Wt : Ht;
                            var Et = Vt * Math.cos(Rt)
                              , St = Vt * Math.sin(Rt)
                              , Lt = Et === 0 && St === 0 ? 0 : St / Math.sqrt(Et * Et + St * St)
                              , Mt = Et === 0 && St === 0 ? 0 : -Et / Math.sqrt(Et * Et + St * St);
                            Et += +this.p.v[0],
                            St += +this.p.v[1],
                            this.v.setTripleAt(Et, St, Et - Lt * Kt * Ft * qt, St - Mt * Kt * Ft * qt, Et + Lt * Kt * Ft * qt, St + Mt * Kt * Ft * qt, Dt, !0),
                            vt = !vt,
                            Rt += pt * qt
                        }
                    },
                    convertPolygonToPath: function() {
                        var ut = Math.floor(this.pt.v), pt = Math.PI * 2 / ut, vt = this.or.v, _t = this.os.v, Pt = 2 * Math.PI * vt / (ut * 4), kt, $t = -Math.PI * .5, Wt = this.data.d === 3 ? -1 : 1;
                        for ($t += this.r.v,
                        this.v._length = 0,
                        kt = 0; kt < ut; kt += 1) {
                            var Ht = vt * Math.cos($t)
                              , Dt = vt * Math.sin($t)
                              , Vt = Ht === 0 && Dt === 0 ? 0 : Dt / Math.sqrt(Ht * Ht + Dt * Dt)
                              , Ft = Ht === 0 && Dt === 0 ? 0 : -Ht / Math.sqrt(Ht * Ht + Dt * Dt);
                            Ht += +this.p.v[0],
                            Dt += +this.p.v[1],
                            this.v.setTripleAt(Ht, Dt, Ht - Vt * Pt * _t * Wt, Dt - Ft * Pt * _t * Wt, Ht + Vt * Pt * _t * Wt, Dt + Ft * Pt * _t * Wt, kt, !0),
                            $t += pt * Wt
                        }
                        this.paths.length = 0,
                        this.paths[0] = this.v
                    }
                },
                extendPrototype([DynamicPropertyContainer], lt),
                lt
            }()
              , st = function() {
                function lt(ct, ut) {
                    this.v = shapePool.newElement(),
                    this.v.c = !0,
                    this.localShapeCollection = shapeCollectionPool.newShapeCollection(),
                    this.localShapeCollection.addShape(this.v),
                    this.paths = this.localShapeCollection,
                    this.elem = ct,
                    this.comp = ct.comp,
                    this.frameId = -1,
                    this.d = ut.d,
                    this.initDynamicPropertyContainer(ct),
                    this.p = PropertyFactory.getProp(ct, ut.p, 1, 0, this),
                    this.s = PropertyFactory.getProp(ct, ut.s, 1, 0, this),
                    this.r = PropertyFactory.getProp(ct, ut.r, 0, 0, this),
                    this.dynamicProperties.length ? this.k = !0 : (this.k = !1,
                    this.convertRectToPath())
                }
                return lt.prototype = {
                    convertRectToPath: function() {
                        var ut = this.p.v[0]
                          , pt = this.p.v[1]
                          , vt = this.s.v[0] / 2
                          , _t = this.s.v[1] / 2
                          , Pt = bmMin(vt, _t, this.r.v)
                          , kt = Pt * (1 - roundCorner);
                        this.v._length = 0,
                        this.d === 2 || this.d === 1 ? (this.v.setTripleAt(ut + vt, pt - _t + Pt, ut + vt, pt - _t + Pt, ut + vt, pt - _t + kt, 0, !0),
                        this.v.setTripleAt(ut + vt, pt + _t - Pt, ut + vt, pt + _t - kt, ut + vt, pt + _t - Pt, 1, !0),
                        Pt !== 0 ? (this.v.setTripleAt(ut + vt - Pt, pt + _t, ut + vt - Pt, pt + _t, ut + vt - kt, pt + _t, 2, !0),
                        this.v.setTripleAt(ut - vt + Pt, pt + _t, ut - vt + kt, pt + _t, ut - vt + Pt, pt + _t, 3, !0),
                        this.v.setTripleAt(ut - vt, pt + _t - Pt, ut - vt, pt + _t - Pt, ut - vt, pt + _t - kt, 4, !0),
                        this.v.setTripleAt(ut - vt, pt - _t + Pt, ut - vt, pt - _t + kt, ut - vt, pt - _t + Pt, 5, !0),
                        this.v.setTripleAt(ut - vt + Pt, pt - _t, ut - vt + Pt, pt - _t, ut - vt + kt, pt - _t, 6, !0),
                        this.v.setTripleAt(ut + vt - Pt, pt - _t, ut + vt - kt, pt - _t, ut + vt - Pt, pt - _t, 7, !0)) : (this.v.setTripleAt(ut - vt, pt + _t, ut - vt + kt, pt + _t, ut - vt, pt + _t, 2),
                        this.v.setTripleAt(ut - vt, pt - _t, ut - vt, pt - _t + kt, ut - vt, pt - _t, 3))) : (this.v.setTripleAt(ut + vt, pt - _t + Pt, ut + vt, pt - _t + kt, ut + vt, pt - _t + Pt, 0, !0),
                        Pt !== 0 ? (this.v.setTripleAt(ut + vt - Pt, pt - _t, ut + vt - Pt, pt - _t, ut + vt - kt, pt - _t, 1, !0),
                        this.v.setTripleAt(ut - vt + Pt, pt - _t, ut - vt + kt, pt - _t, ut - vt + Pt, pt - _t, 2, !0),
                        this.v.setTripleAt(ut - vt, pt - _t + Pt, ut - vt, pt - _t + Pt, ut - vt, pt - _t + kt, 3, !0),
                        this.v.setTripleAt(ut - vt, pt + _t - Pt, ut - vt, pt + _t - kt, ut - vt, pt + _t - Pt, 4, !0),
                        this.v.setTripleAt(ut - vt + Pt, pt + _t, ut - vt + Pt, pt + _t, ut - vt + kt, pt + _t, 5, !0),
                        this.v.setTripleAt(ut + vt - Pt, pt + _t, ut + vt - kt, pt + _t, ut + vt - Pt, pt + _t, 6, !0),
                        this.v.setTripleAt(ut + vt, pt + _t - Pt, ut + vt, pt + _t - Pt, ut + vt, pt + _t - kt, 7, !0)) : (this.v.setTripleAt(ut - vt, pt - _t, ut - vt + kt, pt - _t, ut - vt, pt - _t, 1, !0),
                        this.v.setTripleAt(ut - vt, pt + _t, ut - vt, pt + _t - kt, ut - vt, pt + _t, 2, !0),
                        this.v.setTripleAt(ut + vt, pt + _t, ut + vt - kt, pt + _t, ut + vt, pt + _t, 3, !0)))
                    },
                    getValue: function() {
                        this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertRectToPath())
                    },
                    reset: _
                },
                extendPrototype([DynamicPropertyContainer], lt),
                lt
            }();
            function dt(lt, ct, ut) {
                var pt;
                if (ut === 3 || ut === 4) {
                    var vt = ut === 3 ? ct.pt : ct.ks
                      , _t = vt.k;
                    _t.length ? pt = new it(lt,ct,ut) : pt = new rt(lt,ct,ut)
                } else
                    ut === 5 ? pt = new st(lt,ct) : ut === 6 ? pt = new ot(lt,ct) : ut === 7 && (pt = new at(lt,ct));
                return pt.k && lt.addDynamicProperty(pt),
                pt
            }
            function ft() {
                return rt
            }
            function ht() {
                return it
            }
            var xt = {};
            return xt.getShapeProp = dt,
            xt.getConstructorFunction = ft,
            xt.getKeyframedConstructorFunction = ht,
            xt
        }();
        /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */
        var Matrix = function() {
            var d = Math.cos
              , g = Math.sin
              , b = Math.tan
              , _ = Math.round;
            function $() {
                return this.props[0] = 1,
                this.props[1] = 0,
                this.props[2] = 0,
                this.props[3] = 0,
                this.props[4] = 0,
                this.props[5] = 1,
                this.props[6] = 0,
                this.props[7] = 0,
                this.props[8] = 0,
                this.props[9] = 0,
                this.props[10] = 1,
                this.props[11] = 0,
                this.props[12] = 0,
                this.props[13] = 0,
                this.props[14] = 0,
                this.props[15] = 1,
                this
            }
            function et(Et) {
                if (Et === 0)
                    return this;
                var St = d(Et)
                  , Lt = g(Et);
                return this._t(St, -Lt, 0, 0, Lt, St, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function tt(Et) {
                if (Et === 0)
                    return this;
                var St = d(Et)
                  , Lt = g(Et);
                return this._t(1, 0, 0, 0, 0, St, -Lt, 0, 0, Lt, St, 0, 0, 0, 0, 1)
            }
            function rt(Et) {
                if (Et === 0)
                    return this;
                var St = d(Et)
                  , Lt = g(Et);
                return this._t(St, 0, Lt, 0, 0, 1, 0, 0, -Lt, 0, St, 0, 0, 0, 0, 1)
            }
            function nt(Et) {
                if (Et === 0)
                    return this;
                var St = d(Et)
                  , Lt = g(Et);
                return this._t(St, -Lt, 0, 0, Lt, St, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function it(Et, St) {
                return this._t(1, St, Et, 1, 0, 0)
            }
            function ot(Et, St) {
                return this.shear(b(Et), b(St))
            }
            function at(Et, St) {
                var Lt = d(St)
                  , Mt = g(St);
                return this._t(Lt, Mt, 0, 0, -Mt, Lt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, b(Et), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Lt, -Mt, 0, 0, Mt, Lt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function st(Et, St, Lt) {
                return !Lt && Lt !== 0 && (Lt = 1),
                Et === 1 && St === 1 && Lt === 1 ? this : this._t(Et, 0, 0, 0, 0, St, 0, 0, 0, 0, Lt, 0, 0, 0, 0, 1)
            }
            function dt(Et, St, Lt, Mt, ar, wr, Tr, Pr, kr, jr, cr, dr, lr, ir, gr, Cr) {
                return this.props[0] = Et,
                this.props[1] = St,
                this.props[2] = Lt,
                this.props[3] = Mt,
                this.props[4] = ar,
                this.props[5] = wr,
                this.props[6] = Tr,
                this.props[7] = Pr,
                this.props[8] = kr,
                this.props[9] = jr,
                this.props[10] = cr,
                this.props[11] = dr,
                this.props[12] = lr,
                this.props[13] = ir,
                this.props[14] = gr,
                this.props[15] = Cr,
                this
            }
            function ft(Et, St, Lt) {
                return Lt = Lt || 0,
                Et !== 0 || St !== 0 || Lt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, Et, St, Lt, 1) : this
            }
            function ht(Et, St, Lt, Mt, ar, wr, Tr, Pr, kr, jr, cr, dr, lr, ir, gr, Cr) {
                var hr = this.props;
                if (Et === 1 && St === 0 && Lt === 0 && Mt === 0 && ar === 0 && wr === 1 && Tr === 0 && Pr === 0 && kr === 0 && jr === 0 && cr === 1 && dr === 0)
                    return hr[12] = hr[12] * Et + hr[15] * lr,
                    hr[13] = hr[13] * wr + hr[15] * ir,
                    hr[14] = hr[14] * cr + hr[15] * gr,
                    hr[15] *= Cr,
                    this._identityCalculated = !1,
                    this;
                var zr = hr[0]
                  , Zr = hr[1]
                  , ln = hr[2]
                  , Gr = hr[3]
                  , vn = hr[4]
                  , fn = hr[5]
                  , Rn = hr[6]
                  , bn = hr[7]
                  , Un = hr[8]
                  , zn = hr[9]
                  , er = hr[10]
                  , Ut = hr[11]
                  , Ct = hr[12]
                  , yt = hr[13]
                  , bt = hr[14]
                  , At = hr[15];
                return hr[0] = zr * Et + Zr * ar + ln * kr + Gr * lr,
                hr[1] = zr * St + Zr * wr + ln * jr + Gr * ir,
                hr[2] = zr * Lt + Zr * Tr + ln * cr + Gr * gr,
                hr[3] = zr * Mt + Zr * Pr + ln * dr + Gr * Cr,
                hr[4] = vn * Et + fn * ar + Rn * kr + bn * lr,
                hr[5] = vn * St + fn * wr + Rn * jr + bn * ir,
                hr[6] = vn * Lt + fn * Tr + Rn * cr + bn * gr,
                hr[7] = vn * Mt + fn * Pr + Rn * dr + bn * Cr,
                hr[8] = Un * Et + zn * ar + er * kr + Ut * lr,
                hr[9] = Un * St + zn * wr + er * jr + Ut * ir,
                hr[10] = Un * Lt + zn * Tr + er * cr + Ut * gr,
                hr[11] = Un * Mt + zn * Pr + er * dr + Ut * Cr,
                hr[12] = Ct * Et + yt * ar + bt * kr + At * lr,
                hr[13] = Ct * St + yt * wr + bt * jr + At * ir,
                hr[14] = Ct * Lt + yt * Tr + bt * cr + At * gr,
                hr[15] = Ct * Mt + yt * Pr + bt * dr + At * Cr,
                this._identityCalculated = !1,
                this
            }
            function xt(Et) {
                var St = Et.props;
                return this.transform(St[0], St[1], St[2], St[3], St[4], St[5], St[6], St[7], St[8], St[9], St[10], St[11], St[12], St[13], St[14], St[15])
            }
            function lt() {
                return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1),
                this._identityCalculated = !0),
                this._identity
            }
            function ct(Et) {
                for (var St = 0; St < 16; ) {
                    if (Et.props[St] !== this.props[St])
                        return !1;
                    St += 1
                }
                return !0
            }
            function ut(Et) {
                var St;
                for (St = 0; St < 16; St += 1)
                    Et.props[St] = this.props[St];
                return Et
            }
            function pt(Et) {
                var St;
                for (St = 0; St < 16; St += 1)
                    this.props[St] = Et[St]
            }
            function vt(Et, St, Lt) {
                return {
                    x: Et * this.props[0] + St * this.props[4] + Lt * this.props[8] + this.props[12],
                    y: Et * this.props[1] + St * this.props[5] + Lt * this.props[9] + this.props[13],
                    z: Et * this.props[2] + St * this.props[6] + Lt * this.props[10] + this.props[14]
                }
            }
            function _t(Et, St, Lt) {
                return Et * this.props[0] + St * this.props[4] + Lt * this.props[8] + this.props[12]
            }
            function Pt(Et, St, Lt) {
                return Et * this.props[1] + St * this.props[5] + Lt * this.props[9] + this.props[13]
            }
            function kt(Et, St, Lt) {
                return Et * this.props[2] + St * this.props[6] + Lt * this.props[10] + this.props[14]
            }
            function $t() {
                var Et = this.props[0] * this.props[5] - this.props[1] * this.props[4]
                  , St = this.props[5] / Et
                  , Lt = -this.props[1] / Et
                  , Mt = -this.props[4] / Et
                  , ar = this.props[0] / Et
                  , wr = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / Et
                  , Tr = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / Et
                  , Pr = new Matrix;
                return Pr.props[0] = St,
                Pr.props[1] = Lt,
                Pr.props[4] = Mt,
                Pr.props[5] = ar,
                Pr.props[12] = wr,
                Pr.props[13] = Tr,
                Pr
            }
            function Wt(Et) {
                var St = this.getInverseMatrix();
                return St.applyToPointArray(Et[0], Et[1], Et[2] || 0)
            }
            function Ht(Et) {
                var St, Lt = Et.length, Mt = [];
                for (St = 0; St < Lt; St += 1)
                    Mt[St] = Wt(Et[St]);
                return Mt
            }
            function Dt(Et, St, Lt) {
                var Mt = createTypedArray("float32", 6);
                if (this.isIdentity())
                    Mt[0] = Et[0],
                    Mt[1] = Et[1],
                    Mt[2] = St[0],
                    Mt[3] = St[1],
                    Mt[4] = Lt[0],
                    Mt[5] = Lt[1];
                else {
                    var ar = this.props[0]
                      , wr = this.props[1]
                      , Tr = this.props[4]
                      , Pr = this.props[5]
                      , kr = this.props[12]
                      , jr = this.props[13];
                    Mt[0] = Et[0] * ar + Et[1] * Tr + kr,
                    Mt[1] = Et[0] * wr + Et[1] * Pr + jr,
                    Mt[2] = St[0] * ar + St[1] * Tr + kr,
                    Mt[3] = St[0] * wr + St[1] * Pr + jr,
                    Mt[4] = Lt[0] * ar + Lt[1] * Tr + kr,
                    Mt[5] = Lt[0] * wr + Lt[1] * Pr + jr
                }
                return Mt
            }
            function Vt(Et, St, Lt) {
                var Mt;
                return this.isIdentity() ? Mt = [Et, St, Lt] : Mt = [Et * this.props[0] + St * this.props[4] + Lt * this.props[8] + this.props[12], Et * this.props[1] + St * this.props[5] + Lt * this.props[9] + this.props[13], Et * this.props[2] + St * this.props[6] + Lt * this.props[10] + this.props[14]],
                Mt
            }
            function Ft(Et, St) {
                if (this.isIdentity())
                    return Et + "," + St;
                var Lt = this.props;
                return Math.round((Et * Lt[0] + St * Lt[4] + Lt[12]) * 100) / 100 + "," + Math.round((Et * Lt[1] + St * Lt[5] + Lt[13]) * 100) / 100
            }
            function Kt() {
                for (var Et = 0, St = this.props, Lt = "matrix3d(", Mt = 1e4; Et < 16; )
                    Lt += _(St[Et] * Mt) / Mt,
                    Lt += Et === 15 ? ")" : ",",
                    Et += 1;
                return Lt
            }
            function Rt(Et) {
                var St = 1e4;
                return Et < 1e-6 && Et > 0 || Et > -1e-6 && Et < 0 ? _(Et * St) / St : Et
            }
            function qt() {
                var Et = this.props
                  , St = Rt(Et[0])
                  , Lt = Rt(Et[1])
                  , Mt = Rt(Et[4])
                  , ar = Rt(Et[5])
                  , wr = Rt(Et[12])
                  , Tr = Rt(Et[13]);
                return "matrix(" + St + "," + Lt + "," + Mt + "," + ar + "," + wr + "," + Tr + ")"
            }
            return function() {
                this.reset = $,
                this.rotate = et,
                this.rotateX = tt,
                this.rotateY = rt,
                this.rotateZ = nt,
                this.skew = ot,
                this.skewFromAxis = at,
                this.shear = it,
                this.scale = st,
                this.setTransform = dt,
                this.translate = ft,
                this.transform = ht,
                this.multiply = xt,
                this.applyToPoint = vt,
                this.applyToX = _t,
                this.applyToY = Pt,
                this.applyToZ = kt,
                this.applyToPointArray = Vt,
                this.applyToTriplePoints = Dt,
                this.applyToPointStringified = Ft,
                this.toCSS = Kt,
                this.to2dCSS = qt,
                this.clone = ut,
                this.cloneFromProps = pt,
                this.equals = ct,
                this.inversePoints = Ht,
                this.inversePoint = Wt,
                this.getInverseMatrix = $t,
                this._t = this.transform,
                this.isIdentity = lt,
                this._identity = !0,
                this._identityCalculated = !1,
                this.props = createTypedArray("float32", 16),
                this.reset()
            }
        }();
        function _typeof$3(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(b) {
                return typeof b
            }
            : _typeof$3 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$3(d)
        }
        var lottie = {};
        function setLocation(d) {
            setLocationHref(d)
        }
        function searchAnimations() {
            animationManager.searchAnimations()
        }
        function setSubframeRendering(d) {
            setSubframeEnabled(d)
        }
        function setPrefix(d) {
            setIdPrefix(d)
        }
        function loadAnimation(d) {
            return animationManager.loadAnimation(d)
        }
        function setQuality(d) {
            if (typeof d == "string")
                switch (d) {
                case "high":
                    setDefaultCurveSegments(200);
                    break;
                default:
                case "medium":
                    setDefaultCurveSegments(50);
                    break;
                case "low":
                    setDefaultCurveSegments(10);
                    break
                }
            else
                !isNaN(d) && d > 1 && setDefaultCurveSegments(d)
        }
        function inBrowser() {
            return typeof navigator < "u"
        }
        function installPlugin(d, g) {
            d === "expressions" && setExpressionsPlugin(g)
        }
        function getFactory(d) {
            switch (d) {
            case "propertyFactory":
                return PropertyFactory;
            case "shapePropertyFactory":
                return ShapePropertyFactory;
            case "matrix":
                return Matrix;
            default:
                return null
            }
        }
        lottie.play = animationManager.play,
        lottie.pause = animationManager.pause,
        lottie.setLocationHref = setLocation,
        lottie.togglePause = animationManager.togglePause,
        lottie.setSpeed = animationManager.setSpeed,
        lottie.setDirection = animationManager.setDirection,
        lottie.stop = animationManager.stop,
        lottie.searchAnimations = searchAnimations,
        lottie.registerAnimation = animationManager.registerAnimation,
        lottie.loadAnimation = loadAnimation,
        lottie.setSubframeRendering = setSubframeRendering,
        lottie.resize = animationManager.resize,
        lottie.goToAndStop = animationManager.goToAndStop,
        lottie.destroy = animationManager.destroy,
        lottie.setQuality = setQuality,
        lottie.inBrowser = inBrowser,
        lottie.installPlugin = installPlugin,
        lottie.freeze = animationManager.freeze,
        lottie.unfreeze = animationManager.unfreeze,
        lottie.setVolume = animationManager.setVolume,
        lottie.mute = animationManager.mute,
        lottie.unmute = animationManager.unmute,
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations,
        lottie.useWebWorker = setWebWorker,
        lottie.setIDPrefix = setPrefix,
        lottie.__getFactory = getFactory,
        lottie.version = "5.12.2";
        function checkReady() {
            document.readyState === "complete" && (clearInterval(readyStateCheckInterval),
            searchAnimations())
        }
        function getQueryVariable(d) {
            for (var g = queryString.split("&"), b = 0; b < g.length; b += 1) {
                var _ = g[b].split("=");
                if (decodeURIComponent(_[0]) == d)
                    return decodeURIComponent(_[1])
            }
            return null
        }
        var queryString = "";
        {
            var scripts = document.getElementsByTagName("script")
              , index = scripts.length - 1
              , myScript = scripts[index] || {
                src: ""
            };
            queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "",
            getQueryVariable("renderer")
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        try {
            _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
        } catch (d) {}
        var ShapeModifiers = function() {
            var d = {}
              , g = {};
            d.registerModifier = b,
            d.getModifier = _;
            function b($, et) {
                g[$] || (g[$] = et)
            }
            function _($, et, tt) {
                return new g[$](et,tt)
            }
            return d
        }();
        function ShapeModifier() {}
        ShapeModifier.prototype.initModifierProperties = function() {}
        ,
        ShapeModifier.prototype.addShapeToModifier = function() {}
        ,
        ShapeModifier.prototype.addShape = function(d) {
            if (!this.closed) {
                d.sh.container.addDynamicProperty(d.sh);
                var g = {
                    shape: d.sh,
                    data: d,
                    localShapeCollection: shapeCollectionPool.newShapeCollection()
                };
                this.shapes.push(g),
                this.addShapeToModifier(g),
                this._isAnimated && d.setAsAnimated()
            }
        }
        ,
        ShapeModifier.prototype.init = function(d, g) {
            this.shapes = [],
            this.elem = d,
            this.initDynamicPropertyContainer(d),
            this.initModifierProperties(d, g),
            this.frameId = initialDefaultFrame,
            this.closed = !1,
            this.k = !1,
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        ShapeModifier.prototype.processKeys = function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {}
        extendPrototype([ShapeModifier], TrimModifier),
        TrimModifier.prototype.initModifierProperties = function(d, g) {
            this.s = PropertyFactory.getProp(d, g.s, 0, .01, this),
            this.e = PropertyFactory.getProp(d, g.e, 0, .01, this),
            this.o = PropertyFactory.getProp(d, g.o, 0, 0, this),
            this.sValue = 0,
            this.eValue = 0,
            this.getValue = this.processKeys,
            this.m = g.m,
            this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length
        }
        ,
        TrimModifier.prototype.addShapeToModifier = function(d) {
            d.pathsData = []
        }
        ,
        TrimModifier.prototype.calculateShapeEdges = function(d, g, b, _, $) {
            var et = [];
            g <= 1 ? et.push({
                s: d,
                e: g
            }) : d >= 1 ? et.push({
                s: d - 1,
                e: g - 1
            }) : (et.push({
                s: d,
                e: 1
            }),
            et.push({
                s: 0,
                e: g - 1
            }));
            var tt = [], rt, nt = et.length, it;
            for (rt = 0; rt < nt; rt += 1)
                if (it = et[rt],
                !(it.e * $ < _ || it.s * $ > _ + b)) {
                    var ot, at;
                    it.s * $ <= _ ? ot = 0 : ot = (it.s * $ - _) / b,
                    it.e * $ >= _ + b ? at = 1 : at = (it.e * $ - _) / b,
                    tt.push([ot, at])
                }
            return tt.length || tt.push([0, 0]),
            tt
        }
        ,
        TrimModifier.prototype.releasePathsData = function(d) {
            var g, b = d.length;
            for (g = 0; g < b; g += 1)
                segmentsLengthPool.release(d[g]);
            return d.length = 0,
            d
        }
        ,
        TrimModifier.prototype.processShapes = function(d) {
            var g, b;
            if (this._mdf || d) {
                var _ = this.o.v % 360 / 360;
                if (_ < 0 && (_ += 1),
                this.s.v > 1 ? g = 1 + _ : this.s.v < 0 ? g = 0 + _ : g = this.s.v + _,
                this.e.v > 1 ? b = 1 + _ : this.e.v < 0 ? b = 0 + _ : b = this.e.v + _,
                g > b) {
                    var $ = g;
                    g = b,
                    b = $
                }
                g = Math.round(g * 1e4) * 1e-4,
                b = Math.round(b * 1e4) * 1e-4,
                this.sValue = g,
                this.eValue = b
            } else
                g = this.sValue,
                b = this.eValue;
            var et, tt, rt = this.shapes.length, nt, it, ot, at, st, dt = 0;
            if (b === g)
                for (tt = 0; tt < rt; tt += 1)
                    this.shapes[tt].localShapeCollection.releaseShapes(),
                    this.shapes[tt].shape._mdf = !0,
                    this.shapes[tt].shape.paths = this.shapes[tt].localShapeCollection,
                    this._mdf && (this.shapes[tt].pathsData.length = 0);
            else if (b === 1 && g === 0 || b === 0 && g === 1) {
                if (this._mdf)
                    for (tt = 0; tt < rt; tt += 1)
                        this.shapes[tt].pathsData.length = 0,
                        this.shapes[tt].shape._mdf = !0
            } else {
                var ft = [], ht, xt;
                for (tt = 0; tt < rt; tt += 1)
                    if (ht = this.shapes[tt],
                    !ht.shape._mdf && !this._mdf && !d && this.m !== 2)
                        ht.shape.paths = ht.localShapeCollection;
                    else {
                        if (et = ht.shape.paths,
                        it = et._length,
                        st = 0,
                        !ht.shape._mdf && ht.pathsData.length)
                            st = ht.totalShapeLength;
                        else {
                            for (ot = this.releasePathsData(ht.pathsData),
                            nt = 0; nt < it; nt += 1)
                                at = bez.getSegmentsLength(et.shapes[nt]),
                                ot.push(at),
                                st += at.totalLength;
                            ht.totalShapeLength = st,
                            ht.pathsData = ot
                        }
                        dt += st,
                        ht.shape._mdf = !0
                    }
                var lt = g, ct = b, ut = 0, pt;
                for (tt = rt - 1; tt >= 0; tt -= 1)
                    if (ht = this.shapes[tt],
                    ht.shape._mdf) {
                        for (xt = ht.localShapeCollection,
                        xt.releaseShapes(),
                        this.m === 2 && rt > 1 ? (pt = this.calculateShapeEdges(g, b, ht.totalShapeLength, ut, dt),
                        ut += ht.totalShapeLength) : pt = [[lt, ct]],
                        it = pt.length,
                        nt = 0; nt < it; nt += 1) {
                            lt = pt[nt][0],
                            ct = pt[nt][1],
                            ft.length = 0,
                            ct <= 1 ? ft.push({
                                s: ht.totalShapeLength * lt,
                                e: ht.totalShapeLength * ct
                            }) : lt >= 1 ? ft.push({
                                s: ht.totalShapeLength * (lt - 1),
                                e: ht.totalShapeLength * (ct - 1)
                            }) : (ft.push({
                                s: ht.totalShapeLength * lt,
                                e: ht.totalShapeLength
                            }),
                            ft.push({
                                s: 0,
                                e: ht.totalShapeLength * (ct - 1)
                            }));
                            var vt = this.addShapes(ht, ft[0]);
                            if (ft[0].s !== ft[0].e) {
                                if (ft.length > 1) {
                                    var _t = ht.shape.paths.shapes[ht.shape.paths._length - 1];
                                    if (_t.c) {
                                        var Pt = vt.pop();
                                        this.addPaths(vt, xt),
                                        vt = this.addShapes(ht, ft[1], Pt)
                                    } else
                                        this.addPaths(vt, xt),
                                        vt = this.addShapes(ht, ft[1])
                                }
                                this.addPaths(vt, xt)
                            }
                        }
                        ht.shape.paths = xt
                    }
            }
        }
        ,
        TrimModifier.prototype.addPaths = function(d, g) {
            var b, _ = d.length;
            for (b = 0; b < _; b += 1)
                g.addShape(d[b])
        }
        ,
        TrimModifier.prototype.addSegment = function(d, g, b, _, $, et, tt) {
            $.setXYAt(g[0], g[1], "o", et),
            $.setXYAt(b[0], b[1], "i", et + 1),
            tt && $.setXYAt(d[0], d[1], "v", et),
            $.setXYAt(_[0], _[1], "v", et + 1)
        }
        ,
        TrimModifier.prototype.addSegmentFromArray = function(d, g, b, _) {
            g.setXYAt(d[1], d[5], "o", b),
            g.setXYAt(d[2], d[6], "i", b + 1),
            _ && g.setXYAt(d[0], d[4], "v", b),
            g.setXYAt(d[3], d[7], "v", b + 1)
        }
        ,
        TrimModifier.prototype.addShapes = function(d, g, b) {
            var _ = d.pathsData, $ = d.shape.paths.shapes, et, tt = d.shape.paths._length, rt, nt, it = 0, ot, at, st, dt, ft = [], ht, xt = !0;
            for (b ? (at = b._length,
            ht = b._length) : (b = shapePool.newElement(),
            at = 0,
            ht = 0),
            ft.push(b),
            et = 0; et < tt; et += 1) {
                for (st = _[et].lengths,
                b.c = $[et].c,
                nt = $[et].c ? st.length : st.length + 1,
                rt = 1; rt < nt; rt += 1)
                    if (ot = st[rt - 1],
                    it + ot.addedLength < g.s)
                        it += ot.addedLength,
                        b.c = !1;
                    else if (it > g.e) {
                        b.c = !1;
                        break
                    } else
                        g.s <= it && g.e >= it + ot.addedLength ? (this.addSegment($[et].v[rt - 1], $[et].o[rt - 1], $[et].i[rt], $[et].v[rt], b, at, xt),
                        xt = !1) : (dt = bez.getNewSegment($[et].v[rt - 1], $[et].v[rt], $[et].o[rt - 1], $[et].i[rt], (g.s - it) / ot.addedLength, (g.e - it) / ot.addedLength, st[rt - 1]),
                        this.addSegmentFromArray(dt, b, at, xt),
                        xt = !1,
                        b.c = !1),
                        it += ot.addedLength,
                        at += 1;
                if ($[et].c && st.length) {
                    if (ot = st[rt - 1],
                    it <= g.e) {
                        var lt = st[rt - 1].addedLength;
                        g.s <= it && g.e >= it + lt ? (this.addSegment($[et].v[rt - 1], $[et].o[rt - 1], $[et].i[0], $[et].v[0], b, at, xt),
                        xt = !1) : (dt = bez.getNewSegment($[et].v[rt - 1], $[et].v[0], $[et].o[rt - 1], $[et].i[0], (g.s - it) / lt, (g.e - it) / lt, st[rt - 1]),
                        this.addSegmentFromArray(dt, b, at, xt),
                        xt = !1,
                        b.c = !1)
                    } else
                        b.c = !1;
                    it += ot.addedLength,
                    at += 1
                }
                if (b._length && (b.setXYAt(b.v[ht][0], b.v[ht][1], "i", ht),
                b.setXYAt(b.v[b._length - 1][0], b.v[b._length - 1][1], "o", b._length - 1)),
                it > g.e)
                    break;
                et < tt - 1 && (b = shapePool.newElement(),
                xt = !0,
                ft.push(b),
                at = 0)
            }
            return ft
        }
        ;
        function PuckerAndBloatModifier() {}
        extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        PuckerAndBloatModifier.prototype.initModifierProperties = function(d, g) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(d, g.a, 0, null, this),
            this._isAnimated = !!this.amount.effectsSequence.length
        }
        ,
        PuckerAndBloatModifier.prototype.processPath = function(d, g) {
            var b = g / 100
              , _ = [0, 0]
              , $ = d._length
              , et = 0;
            for (et = 0; et < $; et += 1)
                _[0] += d.v[et][0],
                _[1] += d.v[et][1];
            _[0] /= $,
            _[1] /= $;
            var tt = shapePool.newElement();
            tt.c = d.c;
            var rt, nt, it, ot, at, st;
            for (et = 0; et < $; et += 1)
                rt = d.v[et][0] + (_[0] - d.v[et][0]) * b,
                nt = d.v[et][1] + (_[1] - d.v[et][1]) * b,
                it = d.o[et][0] + (_[0] - d.o[et][0]) * -b,
                ot = d.o[et][1] + (_[1] - d.o[et][1]) * -b,
                at = d.i[et][0] + (_[0] - d.i[et][0]) * -b,
                st = d.i[et][1] + (_[1] - d.i[et][1]) * -b,
                tt.setTripleAt(rt, nt, it, ot, at, st, et);
            return tt
        }
        ,
        PuckerAndBloatModifier.prototype.processShapes = function(d) {
            var g, b, _ = this.shapes.length, $, et, tt = this.amount.v;
            if (tt !== 0) {
                var rt, nt;
                for (b = 0; b < _; b += 1) {
                    if (rt = this.shapes[b],
                    nt = rt.localShapeCollection,
                    !(!rt.shape._mdf && !this._mdf && !d))
                        for (nt.releaseShapes(),
                        rt.shape._mdf = !0,
                        g = rt.shape.paths.shapes,
                        et = rt.shape.paths._length,
                        $ = 0; $ < et; $ += 1)
                            nt.addShape(this.processPath(g[$], tt));
                    rt.shape.paths = rt.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        var TransformPropertyFactory = function() {
            var d = [0, 0];
            function g(nt) {
                var it = this._mdf;
                this.iterateDynamicProperties(),
                this._mdf = this._mdf || it,
                this.a && nt.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.s && nt.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk && nt.skewFromAxis(-this.sk.v, this.sa.v),
                this.r ? nt.rotate(-this.r.v) : nt.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.data.p.s ? this.data.p.z ? nt.translate(this.px.v, this.py.v, -this.pz.v) : nt.translate(this.px.v, this.py.v, 0) : nt.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
            }
            function b(nt) {
                if (this.elem.globalData.frameId !== this.frameId) {
                    if (this._isDirty && (this.precalculateMatrix(),
                    this._isDirty = !1),
                    this.iterateDynamicProperties(),
                    this._mdf || nt) {
                        var it;
                        if (this.v.cloneFromProps(this.pre.props),
                        this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                        this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                        this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v),
                        this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                        this.autoOriented) {
                            var ot, at;
                            if (it = this.elem.globalData.frameRate,
                            this.p && this.p.keyframes && this.p.getValueAtTime)
                                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (ot = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / it, 0),
                                at = this.p.getValueAtTime(this.p.keyframes[0].t / it, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (ot = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / it, 0),
                                at = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / it, 0)) : (ot = this.p.pv,
                                at = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / it, this.p.offsetTime));
                            else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                                ot = [],
                                at = [];
                                var st = this.px
                                  , dt = this.py;
                                st._caching.lastFrame + st.offsetTime <= st.keyframes[0].t ? (ot[0] = st.getValueAtTime((st.keyframes[0].t + .01) / it, 0),
                                ot[1] = dt.getValueAtTime((dt.keyframes[0].t + .01) / it, 0),
                                at[0] = st.getValueAtTime(st.keyframes[0].t / it, 0),
                                at[1] = dt.getValueAtTime(dt.keyframes[0].t / it, 0)) : st._caching.lastFrame + st.offsetTime >= st.keyframes[st.keyframes.length - 1].t ? (ot[0] = st.getValueAtTime(st.keyframes[st.keyframes.length - 1].t / it, 0),
                                ot[1] = dt.getValueAtTime(dt.keyframes[dt.keyframes.length - 1].t / it, 0),
                                at[0] = st.getValueAtTime((st.keyframes[st.keyframes.length - 1].t - .01) / it, 0),
                                at[1] = dt.getValueAtTime((dt.keyframes[dt.keyframes.length - 1].t - .01) / it, 0)) : (ot = [st.pv, dt.pv],
                                at[0] = st.getValueAtTime((st._caching.lastFrame + st.offsetTime - .01) / it, st.offsetTime),
                                at[1] = dt.getValueAtTime((dt._caching.lastFrame + dt.offsetTime - .01) / it, dt.offsetTime))
                            } else
                                at = d,
                                ot = at;
                            this.v.rotate(-Math.atan2(ot[1] - at[1], ot[0] - at[0]))
                        }
                        this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    }
                    this.frameId = this.elem.globalData.frameId
                }
            }
            function _() {
                if (this.appliedTransformations = 0,
                this.pre.reset(),
                !this.a.effectsSequence.length)
                    this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.appliedTransformations = 1;
                else
                    return;
                if (!this.s.effectsSequence.length)
                    this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.appliedTransformations = 2;
                else
                    return;
                if (this.sk)
                    if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
                        this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                        this.appliedTransformations = 3;
                    else
                        return;
                this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v),
                this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]),
                this.appliedTransformations = 4)
            }
            function $() {}
            function et(nt) {
                this._addDynamicProperty(nt),
                this.elem.addDynamicProperty(nt),
                this._isDirty = !0
            }
            function tt(nt, it, ot) {
                if (this.elem = nt,
                this.frameId = -1,
                this.propType = "transform",
                this.data = it,
                this.v = new Matrix,
                this.pre = new Matrix,
                this.appliedTransformations = 0,
                this.initDynamicPropertyContainer(ot || nt),
                it.p && it.p.s ? (this.px = PropertyFactory.getProp(nt, it.p.x, 0, 0, this),
                this.py = PropertyFactory.getProp(nt, it.p.y, 0, 0, this),
                it.p.z && (this.pz = PropertyFactory.getProp(nt, it.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(nt, it.p || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                it.rx) {
                    if (this.rx = PropertyFactory.getProp(nt, it.rx, 0, degToRads, this),
                    this.ry = PropertyFactory.getProp(nt, it.ry, 0, degToRads, this),
                    this.rz = PropertyFactory.getProp(nt, it.rz, 0, degToRads, this),
                    it.or.k[0].ti) {
                        var at, st = it.or.k.length;
                        for (at = 0; at < st; at += 1)
                            it.or.k[at].to = null,
                            it.or.k[at].ti = null
                    }
                    this.or = PropertyFactory.getProp(nt, it.or, 1, degToRads, this),
                    this.or.sh = !0
                } else
                    this.r = PropertyFactory.getProp(nt, it.r || {
                        k: 0
                    }, 0, degToRads, this);
                it.sk && (this.sk = PropertyFactory.getProp(nt, it.sk, 0, degToRads, this),
                this.sa = PropertyFactory.getProp(nt, it.sa, 0, degToRads, this)),
                this.a = PropertyFactory.getProp(nt, it.a || {
                    k: [0, 0, 0]
                }, 1, 0, this),
                this.s = PropertyFactory.getProp(nt, it.s || {
                    k: [100, 100, 100]
                }, 1, .01, this),
                it.o ? this.o = PropertyFactory.getProp(nt, it.o, 0, .01, nt) : this.o = {
                    _mdf: !1,
                    v: 1
                },
                this._isDirty = !0,
                this.dynamicProperties.length || this.getValue(!0)
            }
            tt.prototype = {
                applyToMatrix: g,
                getValue: b,
                precalculateMatrix: _,
                autoOrient: $
            },
            extendPrototype([DynamicPropertyContainer], tt),
            tt.prototype.addDynamicProperty = et,
            tt.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
            function rt(nt, it, ot) {
                return new tt(nt,it,ot)
            }
            return {
                getTransformProperty: rt
            }
        }();
        function RepeaterModifier() {}
        extendPrototype([ShapeModifier], RepeaterModifier),
        RepeaterModifier.prototype.initModifierProperties = function(d, g) {
            this.getValue = this.processKeys,
            this.c = PropertyFactory.getProp(d, g.c, 0, null, this),
            this.o = PropertyFactory.getProp(d, g.o, 0, null, this),
            this.tr = TransformPropertyFactory.getTransformProperty(d, g.tr, this),
            this.so = PropertyFactory.getProp(d, g.tr.so, 0, .01, this),
            this.eo = PropertyFactory.getProp(d, g.tr.eo, 0, .01, this),
            this.data = g,
            this.dynamicProperties.length || this.getValue(!0),
            this._isAnimated = !!this.dynamicProperties.length,
            this.pMatrix = new Matrix,
            this.rMatrix = new Matrix,
            this.sMatrix = new Matrix,
            this.tMatrix = new Matrix,
            this.matrix = new Matrix
        }
        ,
        RepeaterModifier.prototype.applyTransforms = function(d, g, b, _, $, et) {
            var tt = et ? -1 : 1
              , rt = _.s.v[0] + (1 - _.s.v[0]) * (1 - $)
              , nt = _.s.v[1] + (1 - _.s.v[1]) * (1 - $);
            d.translate(_.p.v[0] * tt * $, _.p.v[1] * tt * $, _.p.v[2]),
            g.translate(-_.a.v[0], -_.a.v[1], _.a.v[2]),
            g.rotate(-_.r.v * tt * $),
            g.translate(_.a.v[0], _.a.v[1], _.a.v[2]),
            b.translate(-_.a.v[0], -_.a.v[1], _.a.v[2]),
            b.scale(et ? 1 / rt : rt, et ? 1 / nt : nt),
            b.translate(_.a.v[0], _.a.v[1], _.a.v[2])
        }
        ,
        RepeaterModifier.prototype.init = function(d, g, b, _) {
            for (this.elem = d,
            this.arr = g,
            this.pos = b,
            this.elemsData = _,
            this._currentCopies = 0,
            this._elements = [],
            this._groups = [],
            this.frameId = -1,
            this.initDynamicPropertyContainer(d),
            this.initModifierProperties(d, g[b]); b > 0; )
                b -= 1,
                this._elements.unshift(g[b]);
            this.dynamicProperties.length ? this.k = !0 : this.getValue(!0)
        }
        ,
        RepeaterModifier.prototype.resetElements = function(d) {
            var g, b = d.length;
            for (g = 0; g < b; g += 1)
                d[g]._processed = !1,
                d[g].ty === "gr" && this.resetElements(d[g].it)
        }
        ,
        RepeaterModifier.prototype.cloneElements = function(d) {
            var g = JSON.parse(JSON.stringify(d));
            return this.resetElements(g),
            g
        }
        ,
        RepeaterModifier.prototype.changeGroupRender = function(d, g) {
            var b, _ = d.length;
            for (b = 0; b < _; b += 1)
                d[b]._render = g,
                d[b].ty === "gr" && this.changeGroupRender(d[b].it, g)
        }
        ,
        RepeaterModifier.prototype.processShapes = function(d) {
            var g, b, _, $, et, tt = !1;
            if (this._mdf || d) {
                var rt = Math.ceil(this.c.v);
                if (this._groups.length < rt) {
                    for (; this._groups.length < rt; ) {
                        var nt = {
                            it: this.cloneElements(this._elements),
                            ty: "gr"
                        };
                        nt.it.push({
                            a: {
                                a: 0,
                                ix: 1,
                                k: [0, 0]
                            },
                            nm: "Transform",
                            o: {
                                a: 0,
                                ix: 7,
                                k: 100
                            },
                            p: {
                                a: 0,
                                ix: 2,
                                k: [0, 0]
                            },
                            r: {
                                a: 1,
                                ix: 6,
                                k: [{
                                    s: 0,
                                    e: 0,
                                    t: 0
                                }, {
                                    s: 0,
                                    e: 0,
                                    t: 1
                                }]
                            },
                            s: {
                                a: 0,
                                ix: 3,
                                k: [100, 100]
                            },
                            sa: {
                                a: 0,
                                ix: 5,
                                k: 0
                            },
                            sk: {
                                a: 0,
                                ix: 4,
                                k: 0
                            },
                            ty: "tr"
                        }),
                        this.arr.splice(0, 0, nt),
                        this._groups.splice(0, 0, nt),
                        this._currentCopies += 1
                    }
                    this.elem.reloadShapes(),
                    tt = !0
                }
                et = 0;
                var it;
                for (_ = 0; _ <= this._groups.length - 1; _ += 1) {
                    if (it = et < rt,
                    this._groups[_]._render = it,
                    this.changeGroupRender(this._groups[_].it, it),
                    !it) {
                        var ot = this.elemsData[_].it
                          , at = ot[ot.length - 1];
                        at.transform.op.v !== 0 ? (at.transform.op._mdf = !0,
                        at.transform.op.v = 0) : at.transform.op._mdf = !1
                    }
                    et += 1
                }
                this._currentCopies = rt;
                var st = this.o.v
                  , dt = st % 1
                  , ft = st > 0 ? Math.floor(st) : Math.ceil(st)
                  , ht = this.pMatrix.props
                  , xt = this.rMatrix.props
                  , lt = this.sMatrix.props;
                this.pMatrix.reset(),
                this.rMatrix.reset(),
                this.sMatrix.reset(),
                this.tMatrix.reset(),
                this.matrix.reset();
                var ct = 0;
                if (st > 0) {
                    for (; ct < ft; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        ct += 1;
                    dt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, dt, !1),
                    ct += dt)
                } else if (st < 0) {
                    for (; ct > ft; )
                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                        ct -= 1;
                    dt && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -dt, !0),
                    ct -= dt)
                }
                _ = this.data.m === 1 ? 0 : this._currentCopies - 1,
                $ = this.data.m === 1 ? 1 : -1,
                et = this._currentCopies;
                for (var ut, pt; et; ) {
                    if (g = this.elemsData[_].it,
                    b = g[g.length - 1].transform.mProps.v.props,
                    pt = b.length,
                    g[g.length - 1].transform.mProps._mdf = !0,
                    g[g.length - 1].transform.op._mdf = !0,
                    g[g.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (_ / (this._currentCopies - 1)),
                    ct !== 0) {
                        for ((_ !== 0 && $ === 1 || _ !== this._currentCopies - 1 && $ === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                        this.matrix.transform(xt[0], xt[1], xt[2], xt[3], xt[4], xt[5], xt[6], xt[7], xt[8], xt[9], xt[10], xt[11], xt[12], xt[13], xt[14], xt[15]),
                        this.matrix.transform(lt[0], lt[1], lt[2], lt[3], lt[4], lt[5], lt[6], lt[7], lt[8], lt[9], lt[10], lt[11], lt[12], lt[13], lt[14], lt[15]),
                        this.matrix.transform(ht[0], ht[1], ht[2], ht[3], ht[4], ht[5], ht[6], ht[7], ht[8], ht[9], ht[10], ht[11], ht[12], ht[13], ht[14], ht[15]),
                        ut = 0; ut < pt; ut += 1)
                            b[ut] = this.matrix.props[ut];
                        this.matrix.reset()
                    } else
                        for (this.matrix.reset(),
                        ut = 0; ut < pt; ut += 1)
                            b[ut] = this.matrix.props[ut];
                    ct += 1,
                    et -= 1,
                    _ += $
                }
            } else
                for (et = this._currentCopies,
                _ = 0,
                $ = 1; et; )
                    g = this.elemsData[_].it,
                    b = g[g.length - 1].transform.mProps.v.props,
                    g[g.length - 1].transform.mProps._mdf = !1,
                    g[g.length - 1].transform.op._mdf = !1,
                    et -= 1,
                    _ += $;
            return tt
        }
        ,
        RepeaterModifier.prototype.addShape = function() {}
        ;
        function RoundCornersModifier() {}
        extendPrototype([ShapeModifier], RoundCornersModifier),
        RoundCornersModifier.prototype.initModifierProperties = function(d, g) {
            this.getValue = this.processKeys,
            this.rd = PropertyFactory.getProp(d, g.r, 0, null, this),
            this._isAnimated = !!this.rd.effectsSequence.length
        }
        ,
        RoundCornersModifier.prototype.processPath = function(d, g) {
            var b = shapePool.newElement();
            b.c = d.c;
            var _, $ = d._length, et, tt, rt, nt, it, ot, at = 0, st, dt, ft, ht, xt, lt;
            for (_ = 0; _ < $; _ += 1)
                et = d.v[_],
                rt = d.o[_],
                tt = d.i[_],
                et[0] === rt[0] && et[1] === rt[1] && et[0] === tt[0] && et[1] === tt[1] ? (_ === 0 || _ === $ - 1) && !d.c ? (b.setTripleAt(et[0], et[1], rt[0], rt[1], tt[0], tt[1], at),
                at += 1) : (_ === 0 ? nt = d.v[$ - 1] : nt = d.v[_ - 1],
                it = Math.sqrt(Math.pow(et[0] - nt[0], 2) + Math.pow(et[1] - nt[1], 2)),
                ot = it ? Math.min(it / 2, g) / it : 0,
                xt = et[0] + (nt[0] - et[0]) * ot,
                st = xt,
                lt = et[1] - (et[1] - nt[1]) * ot,
                dt = lt,
                ft = st - (st - et[0]) * roundCorner,
                ht = dt - (dt - et[1]) * roundCorner,
                b.setTripleAt(st, dt, ft, ht, xt, lt, at),
                at += 1,
                _ === $ - 1 ? nt = d.v[0] : nt = d.v[_ + 1],
                it = Math.sqrt(Math.pow(et[0] - nt[0], 2) + Math.pow(et[1] - nt[1], 2)),
                ot = it ? Math.min(it / 2, g) / it : 0,
                ft = et[0] + (nt[0] - et[0]) * ot,
                st = ft,
                ht = et[1] + (nt[1] - et[1]) * ot,
                dt = ht,
                xt = st - (st - et[0]) * roundCorner,
                lt = dt - (dt - et[1]) * roundCorner,
                b.setTripleAt(st, dt, ft, ht, xt, lt, at),
                at += 1) : (b.setTripleAt(d.v[_][0], d.v[_][1], d.o[_][0], d.o[_][1], d.i[_][0], d.i[_][1], at),
                at += 1);
            return b
        }
        ,
        RoundCornersModifier.prototype.processShapes = function(d) {
            var g, b, _ = this.shapes.length, $, et, tt = this.rd.v;
            if (tt !== 0) {
                var rt, nt;
                for (b = 0; b < _; b += 1) {
                    if (rt = this.shapes[b],
                    nt = rt.localShapeCollection,
                    !(!rt.shape._mdf && !this._mdf && !d))
                        for (nt.releaseShapes(),
                        rt.shape._mdf = !0,
                        g = rt.shape.paths.shapes,
                        et = rt.shape.paths._length,
                        $ = 0; $ < et; $ += 1)
                            nt.addShape(this.processPath(g[$], tt));
                    rt.shape.paths = rt.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function floatEqual(d, g) {
            return Math.abs(d - g) * 1e5 <= Math.min(Math.abs(d), Math.abs(g))
        }
        function floatZero(d) {
            return Math.abs(d) <= 1e-5
        }
        function lerp(d, g, b) {
            return d * (1 - b) + g * b
        }
        function lerpPoint(d, g, b) {
            return [lerp(d[0], g[0], b), lerp(d[1], g[1], b)]
        }
        function quadRoots(d, g, b) {
            if (d === 0)
                return [];
            var _ = g * g - 4 * d * b;
            if (_ < 0)
                return [];
            var $ = -g / (2 * d);
            if (_ === 0)
                return [$];
            var et = Math.sqrt(_) / (2 * d);
            return [$ - et, $ + et]
        }
        function polynomialCoefficients(d, g, b, _) {
            return [-d + 3 * g - 3 * b + _, 3 * d - 6 * g + 3 * b, -3 * d + 3 * g, d]
        }
        function singlePoint(d) {
            return new PolynomialBezier(d,d,d,d,!1)
        }
        function PolynomialBezier(d, g, b, _, $) {
            $ && pointEqual(d, g) && (g = lerpPoint(d, _, 1 / 3)),
            $ && pointEqual(b, _) && (b = lerpPoint(d, _, 2 / 3));
            var et = polynomialCoefficients(d[0], g[0], b[0], _[0])
              , tt = polynomialCoefficients(d[1], g[1], b[1], _[1]);
            this.a = [et[0], tt[0]],
            this.b = [et[1], tt[1]],
            this.c = [et[2], tt[2]],
            this.d = [et[3], tt[3]],
            this.points = [d, g, b, _]
        }
        PolynomialBezier.prototype.point = function(d) {
            return [((this.a[0] * d + this.b[0]) * d + this.c[0]) * d + this.d[0], ((this.a[1] * d + this.b[1]) * d + this.c[1]) * d + this.d[1]]
        }
        ,
        PolynomialBezier.prototype.derivative = function(d) {
            return [(3 * d * this.a[0] + 2 * this.b[0]) * d + this.c[0], (3 * d * this.a[1] + 2 * this.b[1]) * d + this.c[1]]
        }
        ,
        PolynomialBezier.prototype.tangentAngle = function(d) {
            var g = this.derivative(d);
            return Math.atan2(g[1], g[0])
        }
        ,
        PolynomialBezier.prototype.normalAngle = function(d) {
            var g = this.derivative(d);
            return Math.atan2(g[0], g[1])
        }
        ,
        PolynomialBezier.prototype.inflectionPoints = function() {
            var d = this.a[1] * this.b[0] - this.a[0] * this.b[1];
            if (floatZero(d))
                return [];
            var g = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / d
              , b = g * g - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / d;
            if (b < 0)
                return [];
            var _ = Math.sqrt(b);
            return floatZero(_) ? _ > 0 && _ < 1 ? [g] : [] : [g - _, g + _].filter(function($) {
                return $ > 0 && $ < 1
            })
        }
        ,
        PolynomialBezier.prototype.split = function(d) {
            if (d <= 0)
                return [singlePoint(this.points[0]), this];
            if (d >= 1)
                return [this, singlePoint(this.points[this.points.length - 1])];
            var g = lerpPoint(this.points[0], this.points[1], d)
              , b = lerpPoint(this.points[1], this.points[2], d)
              , _ = lerpPoint(this.points[2], this.points[3], d)
              , $ = lerpPoint(g, b, d)
              , et = lerpPoint(b, _, d)
              , tt = lerpPoint($, et, d);
            return [new PolynomialBezier(this.points[0],g,$,tt,!0), new PolynomialBezier(tt,et,_,this.points[3],!0)]
        }
        ;
        function extrema(d, g) {
            var b = d.points[0][g]
              , _ = d.points[d.points.length - 1][g];
            if (b > _) {
                var $ = _;
                _ = b,
                b = $
            }
            for (var et = quadRoots(3 * d.a[g], 2 * d.b[g], d.c[g]), tt = 0; tt < et.length; tt += 1)
                if (et[tt] > 0 && et[tt] < 1) {
                    var rt = d.point(et[tt])[g];
                    rt < b ? b = rt : rt > _ && (_ = rt)
                }
            return {
                min: b,
                max: _
            }
        }
        PolynomialBezier.prototype.bounds = function() {
            return {
                x: extrema(this, 0),
                y: extrema(this, 1)
            }
        }
        ,
        PolynomialBezier.prototype.boundingBox = function() {
            var d = this.bounds();
            return {
                left: d.x.min,
                right: d.x.max,
                top: d.y.min,
                bottom: d.y.max,
                width: d.x.max - d.x.min,
                height: d.y.max - d.y.min,
                cx: (d.x.max + d.x.min) / 2,
                cy: (d.y.max + d.y.min) / 2
            }
        }
        ;
        function intersectData(d, g, b) {
            var _ = d.boundingBox();
            return {
                cx: _.cx,
                cy: _.cy,
                width: _.width,
                height: _.height,
                bez: d,
                t: (g + b) / 2,
                t1: g,
                t2: b
            }
        }
        function splitData(d) {
            var g = d.bez.split(.5);
            return [intersectData(g[0], d.t1, d.t), intersectData(g[1], d.t, d.t2)]
        }
        function boxIntersect(d, g) {
            return Math.abs(d.cx - g.cx) * 2 < d.width + g.width && Math.abs(d.cy - g.cy) * 2 < d.height + g.height
        }
        function intersectsImpl(d, g, b, _, $, et) {
            if (boxIntersect(d, g)) {
                if (b >= et || d.width <= _ && d.height <= _ && g.width <= _ && g.height <= _) {
                    $.push([d.t, g.t]);
                    return
                }
                var tt = splitData(d)
                  , rt = splitData(g);
                intersectsImpl(tt[0], rt[0], b + 1, _, $, et),
                intersectsImpl(tt[0], rt[1], b + 1, _, $, et),
                intersectsImpl(tt[1], rt[0], b + 1, _, $, et),
                intersectsImpl(tt[1], rt[1], b + 1, _, $, et)
            }
        }
        PolynomialBezier.prototype.intersections = function(d, g, b) {
            g === void 0 && (g = 2),
            b === void 0 && (b = 7);
            var _ = [];
            return intersectsImpl(intersectData(this, 0, 1), intersectData(d, 0, 1), 0, g, _, b),
            _
        }
        ,
        PolynomialBezier.shapeSegment = function(d, g) {
            var b = (g + 1) % d.length();
            return new PolynomialBezier(d.v[g],d.o[g],d.i[b],d.v[b],!0)
        }
        ,
        PolynomialBezier.shapeSegmentInverted = function(d, g) {
            var b = (g + 1) % d.length();
            return new PolynomialBezier(d.v[b],d.i[b],d.o[g],d.v[g],!0)
        }
        ;
        function crossProduct(d, g) {
            return [d[1] * g[2] - d[2] * g[1], d[2] * g[0] - d[0] * g[2], d[0] * g[1] - d[1] * g[0]]
        }
        function lineIntersection(d, g, b, _) {
            var $ = [d[0], d[1], 1]
              , et = [g[0], g[1], 1]
              , tt = [b[0], b[1], 1]
              , rt = [_[0], _[1], 1]
              , nt = crossProduct(crossProduct($, et), crossProduct(tt, rt));
            return floatZero(nt[2]) ? null : [nt[0] / nt[2], nt[1] / nt[2]]
        }
        function polarOffset(d, g, b) {
            return [d[0] + Math.cos(g) * b, d[1] - Math.sin(g) * b]
        }
        function pointDistance(d, g) {
            return Math.hypot(d[0] - g[0], d[1] - g[1])
        }
        function pointEqual(d, g) {
            return floatEqual(d[0], g[0]) && floatEqual(d[1], g[1])
        }
        function ZigZagModifier() {}
        extendPrototype([ShapeModifier], ZigZagModifier),
        ZigZagModifier.prototype.initModifierProperties = function(d, g) {
            this.getValue = this.processKeys,
            this.amplitude = PropertyFactory.getProp(d, g.s, 0, null, this),
            this.frequency = PropertyFactory.getProp(d, g.r, 0, null, this),
            this.pointsType = PropertyFactory.getProp(d, g.pt, 0, null, this),
            this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0
        }
        ;
        function setPoint(d, g, b, _, $, et, tt) {
            var rt = b - Math.PI / 2
              , nt = b + Math.PI / 2
              , it = g[0] + Math.cos(b) * _ * $
              , ot = g[1] - Math.sin(b) * _ * $;
            d.setTripleAt(it, ot, it + Math.cos(rt) * et, ot - Math.sin(rt) * et, it + Math.cos(nt) * tt, ot - Math.sin(nt) * tt, d.length())
        }
        function getPerpendicularVector(d, g) {
            var b = [g[0] - d[0], g[1] - d[1]]
              , _ = -Math.PI * .5
              , $ = [Math.cos(_) * b[0] - Math.sin(_) * b[1], Math.sin(_) * b[0] + Math.cos(_) * b[1]];
            return $
        }
        function getProjectingAngle(d, g) {
            var b = g === 0 ? d.length() - 1 : g - 1
              , _ = (g + 1) % d.length()
              , $ = d.v[b]
              , et = d.v[_]
              , tt = getPerpendicularVector($, et);
            return Math.atan2(0, 1) - Math.atan2(tt[1], tt[0])
        }
        function zigZagCorner(d, g, b, _, $, et, tt) {
            var rt = getProjectingAngle(g, b)
              , nt = g.v[b % g._length]
              , it = g.v[b === 0 ? g._length - 1 : b - 1]
              , ot = g.v[(b + 1) % g._length]
              , at = et === 2 ? Math.sqrt(Math.pow(nt[0] - it[0], 2) + Math.pow(nt[1] - it[1], 2)) : 0
              , st = et === 2 ? Math.sqrt(Math.pow(nt[0] - ot[0], 2) + Math.pow(nt[1] - ot[1], 2)) : 0;
            setPoint(d, g.v[b % g._length], rt, tt, _, st / (($ + 1) * 2), at / (($ + 1) * 2))
        }
        function zigZagSegment(d, g, b, _, $, et) {
            for (var tt = 0; tt < _; tt += 1) {
                var rt = (tt + 1) / (_ + 1)
                  , nt = $ === 2 ? Math.sqrt(Math.pow(g.points[3][0] - g.points[0][0], 2) + Math.pow(g.points[3][1] - g.points[0][1], 2)) : 0
                  , it = g.normalAngle(rt)
                  , ot = g.point(rt);
                setPoint(d, ot, it, et, b, nt / ((_ + 1) * 2), nt / ((_ + 1) * 2)),
                et = -et
            }
            return et
        }
        ZigZagModifier.prototype.processPath = function(d, g, b, _) {
            var $ = d._length
              , et = shapePool.newElement();
            if (et.c = d.c,
            d.c || ($ -= 1),
            $ === 0)
                return et;
            var tt = -1
              , rt = PolynomialBezier.shapeSegment(d, 0);
            zigZagCorner(et, d, 0, g, b, _, tt);
            for (var nt = 0; nt < $; nt += 1)
                tt = zigZagSegment(et, rt, g, b, _, -tt),
                nt === $ - 1 && !d.c ? rt = null : rt = PolynomialBezier.shapeSegment(d, (nt + 1) % $),
                zigZagCorner(et, d, nt + 1, g, b, _, tt);
            return et
        }
        ,
        ZigZagModifier.prototype.processShapes = function(d) {
            var g, b, _ = this.shapes.length, $, et, tt = this.amplitude.v, rt = Math.max(0, Math.round(this.frequency.v)), nt = this.pointsType.v;
            if (tt !== 0) {
                var it, ot;
                for (b = 0; b < _; b += 1) {
                    if (it = this.shapes[b],
                    ot = it.localShapeCollection,
                    !(!it.shape._mdf && !this._mdf && !d))
                        for (ot.releaseShapes(),
                        it.shape._mdf = !0,
                        g = it.shape.paths.shapes,
                        et = it.shape.paths._length,
                        $ = 0; $ < et; $ += 1)
                            ot.addShape(this.processPath(g[$], tt, rt, nt));
                    it.shape.paths = it.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function linearOffset(d, g, b) {
            var _ = Math.atan2(g[0] - d[0], g[1] - d[1]);
            return [polarOffset(d, _, b), polarOffset(g, _, b)]
        }
        function offsetSegment(d, g) {
            var b, _, $, et, tt, rt, nt;
            nt = linearOffset(d.points[0], d.points[1], g),
            b = nt[0],
            _ = nt[1],
            nt = linearOffset(d.points[1], d.points[2], g),
            $ = nt[0],
            et = nt[1],
            nt = linearOffset(d.points[2], d.points[3], g),
            tt = nt[0],
            rt = nt[1];
            var it = lineIntersection(b, _, $, et);
            it === null && (it = _);
            var ot = lineIntersection(tt, rt, $, et);
            return ot === null && (ot = tt),
            new PolynomialBezier(b,it,ot,rt)
        }
        function joinLines(d, g, b, _, $) {
            var et = g.points[3]
              , tt = b.points[0];
            if (_ === 3 || pointEqual(et, tt))
                return et;
            if (_ === 2) {
                var rt = -g.tangentAngle(1)
                  , nt = -b.tangentAngle(0) + Math.PI
                  , it = lineIntersection(et, polarOffset(et, rt + Math.PI / 2, 100), tt, polarOffset(tt, rt + Math.PI / 2, 100))
                  , ot = it ? pointDistance(it, et) : pointDistance(et, tt) / 2
                  , at = polarOffset(et, rt, 2 * ot * roundCorner);
                return d.setXYAt(at[0], at[1], "o", d.length() - 1),
                at = polarOffset(tt, nt, 2 * ot * roundCorner),
                d.setTripleAt(tt[0], tt[1], tt[0], tt[1], at[0], at[1], d.length()),
                tt
            }
            var st = pointEqual(et, g.points[2]) ? g.points[0] : g.points[2]
              , dt = pointEqual(tt, b.points[1]) ? b.points[3] : b.points[1]
              , ft = lineIntersection(st, et, tt, dt);
            return ft && pointDistance(ft, et) < $ ? (d.setTripleAt(ft[0], ft[1], ft[0], ft[1], ft[0], ft[1], d.length()),
            ft) : et
        }
        function getIntersection(d, g) {
            var b = d.intersections(g);
            return b.length && floatEqual(b[0][0], 1) && b.shift(),
            b.length ? b[0] : null
        }
        function pruneSegmentIntersection(d, g) {
            var b = d.slice()
              , _ = g.slice()
              , $ = getIntersection(d[d.length - 1], g[0]);
            return $ && (b[d.length - 1] = d[d.length - 1].split($[0])[0],
            _[0] = g[0].split($[1])[1]),
            d.length > 1 && g.length > 1 && ($ = getIntersection(d[0], g[g.length - 1]),
            $) ? [[d[0].split($[0])[0]], [g[g.length - 1].split($[1])[1]]] : [b, _]
        }
        function pruneIntersections(d) {
            for (var g, b = 1; b < d.length; b += 1)
                g = pruneSegmentIntersection(d[b - 1], d[b]),
                d[b - 1] = g[0],
                d[b] = g[1];
            return d.length > 1 && (g = pruneSegmentIntersection(d[d.length - 1], d[0]),
            d[d.length - 1] = g[0],
            d[0] = g[1]),
            d
        }
        function offsetSegmentSplit(d, g) {
            var b = d.inflectionPoints(), _, $, et, tt;
            if (b.length === 0)
                return [offsetSegment(d, g)];
            if (b.length === 1 || floatEqual(b[1], 1))
                return et = d.split(b[0]),
                _ = et[0],
                $ = et[1],
                [offsetSegment(_, g), offsetSegment($, g)];
            et = d.split(b[0]),
            _ = et[0];
            var rt = (b[1] - b[0]) / (1 - b[0]);
            return et = et[1].split(rt),
            tt = et[0],
            $ = et[1],
            [offsetSegment(_, g), offsetSegment(tt, g), offsetSegment($, g)]
        }
        function OffsetPathModifier() {}
        extendPrototype([ShapeModifier], OffsetPathModifier),
        OffsetPathModifier.prototype.initModifierProperties = function(d, g) {
            this.getValue = this.processKeys,
            this.amount = PropertyFactory.getProp(d, g.a, 0, null, this),
            this.miterLimit = PropertyFactory.getProp(d, g.ml, 0, null, this),
            this.lineJoin = g.lj,
            this._isAnimated = this.amount.effectsSequence.length !== 0
        }
        ,
        OffsetPathModifier.prototype.processPath = function(d, g, b, _) {
            var $ = shapePool.newElement();
            $.c = d.c;
            var et = d.length();
            d.c || (et -= 1);
            var tt, rt, nt, it = [];
            for (tt = 0; tt < et; tt += 1)
                nt = PolynomialBezier.shapeSegment(d, tt),
                it.push(offsetSegmentSplit(nt, g));
            if (!d.c)
                for (tt = et - 1; tt >= 0; tt -= 1)
                    nt = PolynomialBezier.shapeSegmentInverted(d, tt),
                    it.push(offsetSegmentSplit(nt, g));
            it = pruneIntersections(it);
            var ot = null
              , at = null;
            for (tt = 0; tt < it.length; tt += 1) {
                var st = it[tt];
                for (at && (ot = joinLines($, at, st[0], b, _)),
                at = st[st.length - 1],
                rt = 0; rt < st.length; rt += 1)
                    nt = st[rt],
                    ot && pointEqual(nt.points[0], ot) ? $.setXYAt(nt.points[1][0], nt.points[1][1], "o", $.length() - 1) : $.setTripleAt(nt.points[0][0], nt.points[0][1], nt.points[1][0], nt.points[1][1], nt.points[0][0], nt.points[0][1], $.length()),
                    $.setTripleAt(nt.points[3][0], nt.points[3][1], nt.points[3][0], nt.points[3][1], nt.points[2][0], nt.points[2][1], $.length()),
                    ot = nt.points[3]
            }
            return it.length && joinLines($, at, it[0][0], b, _),
            $
        }
        ,
        OffsetPathModifier.prototype.processShapes = function(d) {
            var g, b, _ = this.shapes.length, $, et, tt = this.amount.v, rt = this.miterLimit.v, nt = this.lineJoin;
            if (tt !== 0) {
                var it, ot;
                for (b = 0; b < _; b += 1) {
                    if (it = this.shapes[b],
                    ot = it.localShapeCollection,
                    !(!it.shape._mdf && !this._mdf && !d))
                        for (ot.releaseShapes(),
                        it.shape._mdf = !0,
                        g = it.shape.paths.shapes,
                        et = it.shape.paths._length,
                        $ = 0; $ < et; $ += 1)
                            ot.addShape(this.processPath(g[$], tt, nt, rt));
                    it.shape.paths = it.localShapeCollection
                }
            }
            this.dynamicProperties.length || (this._mdf = !1)
        }
        ;
        function getFontProperties(d) {
            for (var g = d.fStyle ? d.fStyle.split(" ") : [], b = "normal", _ = "normal", $ = g.length, et, tt = 0; tt < $; tt += 1)
                switch (et = g[tt].toLowerCase(),
                et) {
                case "italic":
                    _ = "italic";
                    break;
                case "bold":
                    b = "700";
                    break;
                case "black":
                    b = "900";
                    break;
                case "medium":
                    b = "500";
                    break;
                case "regular":
                case "normal":
                    b = "400";
                    break;
                case "light":
                case "thin":
                    b = "200";
                    break
                }
            return {
                style: _,
                weight: d.fWeight || b
            }
        }
        var FontManager = function() {
            var d = 5e3
              , g = {
                w: 0,
                size: 0,
                shapes: [],
                data: {
                    shapes: []
                }
            }
              , b = [];
            b = b.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
            var _ = 127988
              , $ = 917631
              , et = 917601
              , tt = 917626
              , rt = 65039
              , nt = 8205
              , it = 127462
              , ot = 127487
              , at = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
            function st(Rt) {
                var qt = Rt.split(","), Et, St = qt.length, Lt = [];
                for (Et = 0; Et < St; Et += 1)
                    qt[Et] !== "sans-serif" && qt[Et] !== "monospace" && Lt.push(qt[Et]);
                return Lt.join(",")
            }
            function dt(Rt, qt) {
                var Et = createTag("span");
                Et.setAttribute("aria-hidden", !0),
                Et.style.fontFamily = qt;
                var St = createTag("span");
                St.innerText = "giItT1WQy@!-/#",
                Et.style.position = "absolute",
                Et.style.left = "-10000px",
                Et.style.top = "-10000px",
                Et.style.fontSize = "300px",
                Et.style.fontVariant = "normal",
                Et.style.fontStyle = "normal",
                Et.style.fontWeight = "normal",
                Et.style.letterSpacing = "0",
                Et.appendChild(St),
                document.body.appendChild(Et);
                var Lt = St.offsetWidth;
                return St.style.fontFamily = st(Rt) + ", " + qt,
                {
                    node: St,
                    w: Lt,
                    parent: Et
                }
            }
            function ft() {
                var Rt, qt = this.fonts.length, Et, St, Lt = qt;
                for (Rt = 0; Rt < qt; Rt += 1)
                    this.fonts[Rt].loaded ? Lt -= 1 : this.fonts[Rt].fOrigin === "n" || this.fonts[Rt].origin === 0 ? this.fonts[Rt].loaded = !0 : (Et = this.fonts[Rt].monoCase.node,
                    St = this.fonts[Rt].monoCase.w,
                    Et.offsetWidth !== St ? (Lt -= 1,
                    this.fonts[Rt].loaded = !0) : (Et = this.fonts[Rt].sansCase.node,
                    St = this.fonts[Rt].sansCase.w,
                    Et.offsetWidth !== St && (Lt -= 1,
                    this.fonts[Rt].loaded = !0)),
                    this.fonts[Rt].loaded && (this.fonts[Rt].sansCase.parent.parentNode.removeChild(this.fonts[Rt].sansCase.parent),
                    this.fonts[Rt].monoCase.parent.parentNode.removeChild(this.fonts[Rt].monoCase.parent)));
                Lt !== 0 && Date.now() - this.initTime < d ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10)
            }
            function ht(Rt, qt) {
                var Et = document.body && qt ? "svg" : "canvas", St, Lt = getFontProperties(Rt);
                if (Et === "svg") {
                    var Mt = createNS("text");
                    Mt.style.fontSize = "100px",
                    Mt.setAttribute("font-family", Rt.fFamily),
                    Mt.setAttribute("font-style", Lt.style),
                    Mt.setAttribute("font-weight", Lt.weight),
                    Mt.textContent = "1",
                    Rt.fClass ? (Mt.style.fontFamily = "inherit",
                    Mt.setAttribute("class", Rt.fClass)) : Mt.style.fontFamily = Rt.fFamily,
                    qt.appendChild(Mt),
                    St = Mt
                } else {
                    var ar = new OffscreenCanvas(500,500).getContext("2d");
                    ar.font = Lt.style + " " + Lt.weight + " 100px " + Rt.fFamily,
                    St = ar
                }
                function wr(Tr) {
                    return Et === "svg" ? (St.textContent = Tr,
                    St.getComputedTextLength()) : St.measureText(Tr).width
                }
                return {
                    measureText: wr
                }
            }
            function xt(Rt, qt) {
                if (!Rt) {
                    this.isLoaded = !0;
                    return
                }
                if (this.chars) {
                    this.isLoaded = !0,
                    this.fonts = Rt.list;
                    return
                }
                if (!document.body) {
                    this.isLoaded = !0,
                    Rt.list.forEach(function(cr) {
                        cr.helper = ht(cr),
                        cr.cache = {}
                    }),
                    this.fonts = Rt.list;
                    return
                }
                var Et = Rt.list, St, Lt = Et.length, Mt = Lt;
                for (St = 0; St < Lt; St += 1) {
                    var ar = !0, wr, Tr;
                    if (Et[St].loaded = !1,
                    Et[St].monoCase = dt(Et[St].fFamily, "monospace"),
                    Et[St].sansCase = dt(Et[St].fFamily, "sans-serif"),
                    !Et[St].fPath)
                        Et[St].loaded = !0,
                        Mt -= 1;
                    else if (Et[St].fOrigin === "p" || Et[St].origin === 3) {
                        if (wr = document.querySelectorAll('style[f-forigin="p"][f-family="' + Et[St].fFamily + '"], style[f-origin="3"][f-family="' + Et[St].fFamily + '"]'),
                        wr.length > 0 && (ar = !1),
                        ar) {
                            var Pr = createTag("style");
                            Pr.setAttribute("f-forigin", Et[St].fOrigin),
                            Pr.setAttribute("f-origin", Et[St].origin),
                            Pr.setAttribute("f-family", Et[St].fFamily),
                            Pr.type = "text/css",
                            Pr.innerText = "@font-face {font-family: " + Et[St].fFamily + "; font-style: normal; src: url('" + Et[St].fPath + "');}",
                            qt.appendChild(Pr)
                        }
                    } else if (Et[St].fOrigin === "g" || Et[St].origin === 1) {
                        for (wr = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'),
                        Tr = 0; Tr < wr.length; Tr += 1)
                            wr[Tr].href.indexOf(Et[St].fPath) !== -1 && (ar = !1);
                        if (ar) {
                            var kr = createTag("link");
                            kr.setAttribute("f-forigin", Et[St].fOrigin),
                            kr.setAttribute("f-origin", Et[St].origin),
                            kr.type = "text/css",
                            kr.rel = "stylesheet",
                            kr.href = Et[St].fPath,
                            document.body.appendChild(kr)
                        }
                    } else if (Et[St].fOrigin === "t" || Et[St].origin === 2) {
                        for (wr = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'),
                        Tr = 0; Tr < wr.length; Tr += 1)
                            Et[St].fPath === wr[Tr].src && (ar = !1);
                        if (ar) {
                            var jr = createTag("link");
                            jr.setAttribute("f-forigin", Et[St].fOrigin),
                            jr.setAttribute("f-origin", Et[St].origin),
                            jr.setAttribute("rel", "stylesheet"),
                            jr.setAttribute("href", Et[St].fPath),
                            qt.appendChild(jr)
                        }
                    }
                    Et[St].helper = ht(Et[St], qt),
                    Et[St].cache = {},
                    this.fonts.push(Et[St])
                }
                Mt === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100)
            }
            function lt(Rt) {
                if (Rt) {
                    this.chars || (this.chars = []);
                    var qt, Et = Rt.length, St, Lt = this.chars.length, Mt;
                    for (qt = 0; qt < Et; qt += 1) {
                        for (St = 0,
                        Mt = !1; St < Lt; )
                            this.chars[St].style === Rt[qt].style && this.chars[St].fFamily === Rt[qt].fFamily && this.chars[St].ch === Rt[qt].ch && (Mt = !0),
                            St += 1;
                        Mt || (this.chars.push(Rt[qt]),
                        Lt += 1)
                    }
                }
            }
            function ct(Rt, qt, Et) {
                for (var St = 0, Lt = this.chars.length; St < Lt; ) {
                    if (this.chars[St].ch === Rt && this.chars[St].style === qt && this.chars[St].fFamily === Et)
                        return this.chars[St];
                    St += 1
                }
                return (typeof Rt == "string" && Rt.charCodeAt(0) !== 13 || !Rt) && console && console.warn && !this._warned && (this._warned = !0,
                console.warn("Missing character from exported characters list: ", Rt, qt, Et)),
                g
            }
            function ut(Rt, qt, Et) {
                var St = this.getFontByName(qt)
                  , Lt = Rt;
                if (!St.cache[Lt]) {
                    var Mt = St.helper;
                    if (Rt === " ") {
                        var ar = Mt.measureText("|" + Rt + "|")
                          , wr = Mt.measureText("||");
                        St.cache[Lt] = (ar - wr) / 100
                    } else
                        St.cache[Lt] = Mt.measureText(Rt) / 100
                }
                return St.cache[Lt] * Et
            }
            function pt(Rt) {
                for (var qt = 0, Et = this.fonts.length; qt < Et; ) {
                    if (this.fonts[qt].fName === Rt)
                        return this.fonts[qt];
                    qt += 1
                }
                return this.fonts[0]
            }
            function vt(Rt) {
                var qt = 0
                  , Et = Rt.charCodeAt(0);
                if (Et >= 55296 && Et <= 56319) {
                    var St = Rt.charCodeAt(1);
                    St >= 56320 && St <= 57343 && (qt = (Et - 55296) * 1024 + St - 56320 + 65536)
                }
                return qt
            }
            function _t(Rt, qt) {
                var Et = Rt.toString(16) + qt.toString(16);
                return at.indexOf(Et) !== -1
            }
            function Pt(Rt) {
                return Rt === nt
            }
            function kt(Rt) {
                return Rt === rt
            }
            function $t(Rt) {
                var qt = vt(Rt);
                return qt >= it && qt <= ot
            }
            function Wt(Rt) {
                return $t(Rt.substr(0, 2)) && $t(Rt.substr(2, 2))
            }
            function Ht(Rt) {
                return b.indexOf(Rt) !== -1
            }
            function Dt(Rt, qt) {
                var Et = vt(Rt.substr(qt, 2));
                if (Et !== _)
                    return !1;
                var St = 0;
                for (qt += 2; St < 5; ) {
                    if (Et = vt(Rt.substr(qt, 2)),
                    Et < et || Et > tt)
                        return !1;
                    St += 1,
                    qt += 2
                }
                return vt(Rt.substr(qt, 2)) === $
            }
            function Vt() {
                this.isLoaded = !0
            }
            var Ft = function() {
                this.fonts = [],
                this.chars = null,
                this.typekitLoaded = 0,
                this.isLoaded = !1,
                this._warned = !1,
                this.initTime = Date.now(),
                this.setIsLoadedBinded = this.setIsLoaded.bind(this),
                this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this)
            };
            Ft.isModifier = _t,
            Ft.isZeroWidthJoiner = Pt,
            Ft.isFlagEmoji = Wt,
            Ft.isRegionalCode = $t,
            Ft.isCombinedCharacter = Ht,
            Ft.isRegionalFlag = Dt,
            Ft.isVariationSelector = kt,
            Ft.BLACK_FLAG_CODE_POINT = _;
            var Kt = {
                addChars: lt,
                addFonts: xt,
                getCharData: ct,
                getFontByName: pt,
                measureText: ut,
                checkLoadedFonts: ft,
                setIsLoaded: Vt
            };
            return Ft.prototype = Kt,
            Ft
        }();
        function SlotManager(d) {
            this.animationData = d
        }
        SlotManager.prototype.getProp = function(d) {
            return this.animationData.slots && this.animationData.slots[d.sid] ? Object.assign(d, this.animationData.slots[d.sid].p) : d
        }
        ;
        function slotFactory(d) {
            return new SlotManager(d)
        }
        function RenderableElement() {}
        RenderableElement.prototype = {
            initRenderable: function() {
                this.isInRange = !1,
                this.hidden = !1,
                this.isTransparent = !1,
                this.renderableComponents = []
            },
            addRenderableComponent: function(g) {
                this.renderableComponents.indexOf(g) === -1 && this.renderableComponents.push(g)
            },
            removeRenderableComponent: function(g) {
                this.renderableComponents.indexOf(g) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(g), 1)
            },
            prepareRenderableFrame: function(g) {
                this.checkLayerLimits(g)
            },
            checkTransparency: function() {
                this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0,
                this.hide()) : this.isTransparent && (this.isTransparent = !1,
                this.show())
            },
            checkLayerLimits: function(g) {
                this.data.ip - this.data.st <= g && this.data.op - this.data.st > g ? this.isInRange !== !0 && (this.globalData._mdf = !0,
                this._mdf = !0,
                this.isInRange = !0,
                this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0,
                this.isInRange = !1,
                this.hide())
            },
            renderRenderable: function() {
                var g, b = this.renderableComponents.length;
                for (g = 0; g < b; g += 1)
                    this.renderableComponents[g].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function() {
                return {
                    top: 0,
                    left: 0,
                    width: 100,
                    height: 100
                }
            },
            getLayerSize: function() {
                return this.data.ty === 5 ? {
                    w: this.data.textData.width,
                    h: this.data.textData.height
                } : {
                    w: this.data.width,
                    h: this.data.height
                }
            }
        };
        var getBlendMode = function() {
            var d = {
                0: "source-over",
                1: "multiply",
                2: "screen",
                3: "overlay",
                4: "darken",
                5: "lighten",
                6: "color-dodge",
                7: "color-burn",
                8: "hard-light",
                9: "soft-light",
                10: "difference",
                11: "exclusion",
                12: "hue",
                13: "saturation",
                14: "color",
                15: "luminosity"
            };
            return function(g) {
                return d[g] || ""
            }
        }();
        function SliderEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 0, 0, b)
        }
        function AngleEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 0, 0, b)
        }
        function ColorEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 1, 0, b)
        }
        function PointEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 1, 0, b)
        }
        function LayerIndexEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 0, 0, b)
        }
        function MaskIndexEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 0, 0, b)
        }
        function CheckboxEffect(d, g, b) {
            this.p = PropertyFactory.getProp(g, d.v, 0, 0, b)
        }
        function NoValueEffect() {
            this.p = {}
        }
        function EffectsManager(d, g) {
            var b = d.ef || [];
            this.effectElements = [];
            var _, $ = b.length, et;
            for (_ = 0; _ < $; _ += 1)
                et = new GroupEffect(b[_],g),
                this.effectElements.push(et)
        }
        function GroupEffect(d, g) {
            this.init(d, g)
        }
        extendPrototype([DynamicPropertyContainer], GroupEffect),
        GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties,
        GroupEffect.prototype.init = function(d, g) {
            this.data = d,
            this.effectElements = [],
            this.initDynamicPropertyContainer(g);
            var b, _ = this.data.ef.length, $, et = this.data.ef;
            for (b = 0; b < _; b += 1) {
                switch ($ = null,
                et[b].ty) {
                case 0:
                    $ = new SliderEffect(et[b],g,this);
                    break;
                case 1:
                    $ = new AngleEffect(et[b],g,this);
                    break;
                case 2:
                    $ = new ColorEffect(et[b],g,this);
                    break;
                case 3:
                    $ = new PointEffect(et[b],g,this);
                    break;
                case 4:
                case 7:
                    $ = new CheckboxEffect(et[b],g,this);
                    break;
                case 10:
                    $ = new LayerIndexEffect(et[b],g,this);
                    break;
                case 11:
                    $ = new MaskIndexEffect(et[b],g,this);
                    break;
                case 5:
                    $ = new EffectsManager(et[b],g);
                    break;
                default:
                    $ = new NoValueEffect(et[b]);
                    break
                }
                $ && this.effectElements.push($)
            }
        }
        ;
        function BaseElement() {}
        BaseElement.prototype = {
            checkMasks: function() {
                if (!this.data.hasMask)
                    return !1;
                for (var g = 0, b = this.data.masksProperties.length; g < b; ) {
                    if (this.data.masksProperties[g].mode !== "n" && this.data.masksProperties[g].cl !== !1)
                        return !0;
                    g += 1
                }
                return !1
            },
            initExpressions: function() {
                var g = getExpressionInterfaces();
                if (g) {
                    var b = g("layer")
                      , _ = g("effects")
                      , $ = g("shape")
                      , et = g("text")
                      , tt = g("comp");
                    this.layerInterface = b(this),
                    this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
                    var rt = _.createEffectsInterface(this, this.layerInterface);
                    this.layerInterface.registerEffectsInterface(rt),
                    this.data.ty === 0 || this.data.xt ? this.compInterface = tt(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = $(this.shapesData, this.itemsData, this.layerInterface),
                    this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = et(this),
                    this.layerInterface.text = this.layerInterface.textInterface)
                }
            },
            setBlendMode: function() {
                var g = getBlendMode(this.data.bm)
                  , b = this.baseElement || this.layerElement;
                b.style["mix-blend-mode"] = g
            },
            initBaseData: function(g, b, _) {
                this.globalData = b,
                this.comp = _,
                this.data = g,
                this.layerId = createElementID(),
                this.data.sr || (this.data.sr = 1),
                this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties)
            },
            getType: function() {
                return this.type
            },
            sourceRectAtTime: function() {}
        };
        function FrameElement() {}
        FrameElement.prototype = {
            initFrame: function() {
                this._isFirstFrame = !1,
                this.dynamicProperties = [],
                this._mdf = !1
            },
            prepareProperties: function(g, b) {
                var _, $ = this.dynamicProperties.length;
                for (_ = 0; _ < $; _ += 1)
                    (b || this._isParent && this.dynamicProperties[_].propType === "transform") && (this.dynamicProperties[_].getValue(),
                    this.dynamicProperties[_]._mdf && (this.globalData._mdf = !0,
                    this._mdf = !0))
            },
            addDynamicProperty: function(g) {
                this.dynamicProperties.indexOf(g) === -1 && this.dynamicProperties.push(g)
            }
        };
        function FootageElement(d, g, b) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = g.getAssetData(d.refId),
            this.footageData = g.imageLoader.getAsset(this.assetData),
            this.initBaseData(d, g, b)
        }
        FootageElement.prototype.prepareFrame = function() {}
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
        FootageElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        FootageElement.prototype.renderFrame = function() {}
        ,
        FootageElement.prototype.destroy = function() {}
        ,
        FootageElement.prototype.initExpressions = function() {
            var d = getExpressionInterfaces();
            if (d) {
                var g = d("footage");
                this.layerInterface = g(this)
            }
        }
        ,
        FootageElement.prototype.getFootageData = function() {
            return this.footageData
        }
        ;
        function AudioElement(d, g, b) {
            this.initFrame(),
            this.initRenderable(),
            this.assetData = g.getAssetData(d.refId),
            this.initBaseData(d, g, b),
            this._isPlaying = !1,
            this._canPlay = !1;
            var _ = this.globalData.getAssetsPath(this.assetData);
            this.audio = this.globalData.audioController.createAudio(_),
            this._currentTime = 0,
            this.globalData.audioController.addAudio(this),
            this._volumeMultiplier = 1,
            this._volume = 1,
            this._previousVolume = null,
            this.tm = d.tm ? PropertyFactory.getProp(this, d.tm, 0, g.frameRate, this) : {
                _placeholder: !0
            },
            this.lv = PropertyFactory.getProp(this, d.au && d.au.lv ? d.au.lv : {
                k: [100]
            }, 1, .01, this)
        }
        AudioElement.prototype.prepareFrame = function(d) {
            if (this.prepareRenderableFrame(d, !0),
            this.prepareProperties(d, !0),
            this.tm._placeholder)
                this._currentTime = d / this.data.sr;
            else {
                var g = this.tm.v;
                this._currentTime = g
            }
            this._volume = this.lv.v[0];
            var b = this._volume * this._volumeMultiplier;
            this._previousVolume !== b && (this._previousVolume = b,
            this.audio.volume(b))
        }
        ,
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
        AudioElement.prototype.renderFrame = function() {
            this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(),
            this.audio.seek(this._currentTime / this.globalData.frameRate),
            this._isPlaying = !0))
        }
        ,
        AudioElement.prototype.show = function() {}
        ,
        AudioElement.prototype.hide = function() {
            this.audio.pause(),
            this._isPlaying = !1
        }
        ,
        AudioElement.prototype.pause = function() {
            this.audio.pause(),
            this._isPlaying = !1,
            this._canPlay = !1
        }
        ,
        AudioElement.prototype.resume = function() {
            this._canPlay = !0
        }
        ,
        AudioElement.prototype.setRate = function(d) {
            this.audio.rate(d)
        }
        ,
        AudioElement.prototype.volume = function(d) {
            this._volumeMultiplier = d,
            this._previousVolume = d * this._volume,
            this.audio.volume(this._previousVolume)
        }
        ,
        AudioElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        AudioElement.prototype.destroy = function() {}
        ,
        AudioElement.prototype.sourceRectAtTime = function() {}
        ,
        AudioElement.prototype.initExpressions = function() {}
        ;
        function BaseRenderer() {}
        BaseRenderer.prototype.checkLayers = function(d) {
            var g, b = this.layers.length, _;
            for (this.completeLayers = !0,
            g = b - 1; g >= 0; g -= 1)
                this.elements[g] || (_ = this.layers[g],
                _.ip - _.st <= d - this.layers[g].st && _.op - _.st > d - this.layers[g].st && this.buildItem(g)),
                this.completeLayers = this.elements[g] ? this.completeLayers : !1;
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.createItem = function(d) {
            switch (d.ty) {
            case 2:
                return this.createImage(d);
            case 0:
                return this.createComp(d);
            case 1:
                return this.createSolid(d);
            case 3:
                return this.createNull(d);
            case 4:
                return this.createShape(d);
            case 5:
                return this.createText(d);
            case 6:
                return this.createAudio(d);
            case 13:
                return this.createCamera(d);
            case 15:
                return this.createFootage(d);
            default:
                return this.createNull(d)
            }
        }
        ,
        BaseRenderer.prototype.createCamera = function() {
            throw new Error("You're using a 3d camera. Try the html renderer.")
        }
        ,
        BaseRenderer.prototype.createAudio = function(d) {
            return new AudioElement(d,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.createFootage = function(d) {
            return new FootageElement(d,this.globalData,this)
        }
        ,
        BaseRenderer.prototype.buildAllItems = function() {
            var d, g = this.layers.length;
            for (d = 0; d < g; d += 1)
                this.buildItem(d);
            this.checkPendingElements()
        }
        ,
        BaseRenderer.prototype.includeLayers = function(d) {
            this.completeLayers = !1;
            var g, b = d.length, _, $ = this.layers.length;
            for (g = 0; g < b; g += 1)
                for (_ = 0; _ < $; ) {
                    if (this.layers[_].id === d[g].id) {
                        this.layers[_] = d[g];
                        break
                    }
                    _ += 1
                }
        }
        ,
        BaseRenderer.prototype.setProjectInterface = function(d) {
            this.globalData.projectInterface = d
        }
        ,
        BaseRenderer.prototype.initItems = function() {
            this.globalData.progressiveLoad || this.buildAllItems()
        }
        ,
        BaseRenderer.prototype.buildElementParenting = function(d, g, b) {
            for (var _ = this.elements, $ = this.layers, et = 0, tt = $.length; et < tt; )
                $[et].ind == g && (!_[et] || _[et] === !0 ? (this.buildItem(et),
                this.addPendingElement(d)) : (b.push(_[et]),
                _[et].setAsParent(),
                $[et].parent !== void 0 ? this.buildElementParenting(d, $[et].parent, b) : d.setHierarchy(b))),
                et += 1
        }
        ,
        BaseRenderer.prototype.addPendingElement = function(d) {
            this.pendingElements.push(d)
        }
        ,
        BaseRenderer.prototype.searchExtraCompositions = function(d) {
            var g, b = d.length;
            for (g = 0; g < b; g += 1)
                if (d[g].xt) {
                    var _ = this.createComp(d[g]);
                    _.initExpressions(),
                    this.globalData.projectInterface.registerComposition(_)
                }
        }
        ,
        BaseRenderer.prototype.getElementById = function(d) {
            var g, b = this.elements.length;
            for (g = 0; g < b; g += 1)
                if (this.elements[g].data.ind === d)
                    return this.elements[g];
            return null
        }
        ,
        BaseRenderer.prototype.getElementByPath = function(d) {
            var g = d.shift(), b;
            if (typeof g == "number")
                b = this.elements[g];
            else {
                var _, $ = this.elements.length;
                for (_ = 0; _ < $; _ += 1)
                    if (this.elements[_].data.nm === g) {
                        b = this.elements[_];
                        break
                    }
            }
            return d.length === 0 ? b : b.getElementByPath(d)
        }
        ,
        BaseRenderer.prototype.setupGlobalData = function(d, g) {
            this.globalData.fontManager = new FontManager,
            this.globalData.slotManager = slotFactory(d),
            this.globalData.fontManager.addChars(d.chars),
            this.globalData.fontManager.addFonts(d.fonts, g),
            this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem),
            this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem),
            this.globalData.imageLoader = this.animationItem.imagePreloader,
            this.globalData.audioController = this.animationItem.audioController,
            this.globalData.frameId = 0,
            this.globalData.frameRate = d.fr,
            this.globalData.nm = d.nm,
            this.globalData.compSize = {
                w: d.w,
                h: d.h
            }
        }
        ;
        var effectTypes = {
            TRANSFORM_EFFECT: "transformEFfect"
        };
        function TransformElement() {}
        TransformElement.prototype = {
            initTransform: function() {
                var g = new Matrix;
                this.finalTransform = {
                    mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
                        o: 0
                    },
                    _matMdf: !1,
                    _localMatMdf: !1,
                    _opMdf: !1,
                    mat: g,
                    localMat: g,
                    localOpacity: 1
                },
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                this.data.ty
            },
            renderTransform: function() {
                if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame,
                this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame,
                this.hierarchy) {
                    var g, b = this.finalTransform.mat, _ = 0, $ = this.hierarchy.length;
                    if (!this.finalTransform._matMdf)
                        for (; _ < $; ) {
                            if (this.hierarchy[_].finalTransform.mProp._mdf) {
                                this.finalTransform._matMdf = !0;
                                break
                            }
                            _ += 1
                        }
                    if (this.finalTransform._matMdf)
                        for (g = this.finalTransform.mProp.v.props,
                        b.cloneFromProps(g),
                        _ = 0; _ < $; _ += 1)
                            b.multiply(this.hierarchy[_].finalTransform.mProp.v)
                }
                this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
                this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
            },
            renderLocalTransform: function() {
                if (this.localTransforms) {
                    var g = 0
                      , b = this.localTransforms.length;
                    if (this.finalTransform._localMatMdf = this.finalTransform._matMdf,
                    !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
                        for (; g < b; )
                            this.localTransforms[g]._mdf && (this.finalTransform._localMatMdf = !0),
                            this.localTransforms[g]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v,
                            this.finalTransform._opMdf = !0),
                            g += 1;
                    if (this.finalTransform._localMatMdf) {
                        var _ = this.finalTransform.localMat;
                        for (this.localTransforms[0].matrix.clone(_),
                        g = 1; g < b; g += 1) {
                            var $ = this.localTransforms[g].matrix;
                            _.multiply($)
                        }
                        _.multiply(this.finalTransform.mat)
                    }
                    if (this.finalTransform._opMdf) {
                        var et = this.finalTransform.localOpacity;
                        for (g = 0; g < b; g += 1)
                            et *= this.localTransforms[g].opacity * .01;
                        this.finalTransform.localOpacity = et
                    }
                }
            },
            searchEffectTransforms: function() {
                if (this.renderableEffectsManager) {
                    var g = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
                    if (g.length) {
                        this.localTransforms = [],
                        this.finalTransform.localMat = new Matrix;
                        var b = 0
                          , _ = g.length;
                        for (b = 0; b < _; b += 1)
                            this.localTransforms.push(g[b])
                    }
                }
            },
            globalToLocal: function(g) {
                var b = [];
                b.push(this.finalTransform);
                for (var _ = !0, $ = this.comp; _; )
                    $.finalTransform ? ($.data.hasMask && b.splice(0, 0, $.finalTransform),
                    $ = $.comp) : _ = !1;
                var et, tt = b.length, rt;
                for (et = 0; et < tt; et += 1)
                    rt = b[et].mat.applyToPointArray(0, 0, 0),
                    g = [g[0] - rt[0], g[1] - rt[1], 0];
                return g
            },
            mHelper: new Matrix
        };
        function MaskElement(d, g, b) {
            this.data = d,
            this.element = g,
            this.globalData = b,
            this.storedData = [],
            this.masksProperties = this.data.masksProperties || [],
            this.maskElement = null;
            var _ = this.globalData.defs, $, et = this.masksProperties ? this.masksProperties.length : 0;
            this.viewData = createSizedArray(et),
            this.solidPath = "";
            var tt, rt = this.masksProperties, nt = 0, it = [], ot, at, st = createElementID(), dt, ft, ht, xt, lt = "clipPath", ct = "clip-path";
            for ($ = 0; $ < et; $ += 1)
                if ((rt[$].mode !== "a" && rt[$].mode !== "n" || rt[$].inv || rt[$].o.k !== 100 || rt[$].o.x) && (lt = "mask",
                ct = "mask"),
                (rt[$].mode === "s" || rt[$].mode === "i") && nt === 0 ? (dt = createNS("rect"),
                dt.setAttribute("fill", "#ffffff"),
                dt.setAttribute("width", this.element.comp.data.w || 0),
                dt.setAttribute("height", this.element.comp.data.h || 0),
                it.push(dt)) : dt = null,
                tt = createNS("path"),
                rt[$].mode === "n")
                    this.viewData[$] = {
                        op: PropertyFactory.getProp(this.element, rt[$].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, rt[$], 3),
                        elem: tt,
                        lastPath: ""
                    },
                    _.appendChild(tt);
                else {
                    nt += 1,
                    tt.setAttribute("fill", rt[$].mode === "s" ? "#000000" : "#ffffff"),
                    tt.setAttribute("clip-rule", "nonzero");
                    var ut;
                    if (rt[$].x.k !== 0 ? (lt = "mask",
                    ct = "mask",
                    xt = PropertyFactory.getProp(this.element, rt[$].x, 0, null, this.element),
                    ut = createElementID(),
                    ft = createNS("filter"),
                    ft.setAttribute("id", ut),
                    ht = createNS("feMorphology"),
                    ht.setAttribute("operator", "erode"),
                    ht.setAttribute("in", "SourceGraphic"),
                    ht.setAttribute("radius", "0"),
                    ft.appendChild(ht),
                    _.appendChild(ft),
                    tt.setAttribute("stroke", rt[$].mode === "s" ? "#000000" : "#ffffff")) : (ht = null,
                    xt = null),
                    this.storedData[$] = {
                        elem: tt,
                        x: xt,
                        expan: ht,
                        lastPath: "",
                        lastOperator: "",
                        filterId: ut,
                        lastRadius: 0
                    },
                    rt[$].mode === "i") {
                        at = it.length;
                        var pt = createNS("g");
                        for (ot = 0; ot < at; ot += 1)
                            pt.appendChild(it[ot]);
                        var vt = createNS("mask");
                        vt.setAttribute("mask-type", "alpha"),
                        vt.setAttribute("id", st + "_" + nt),
                        vt.appendChild(tt),
                        _.appendChild(vt),
                        pt.setAttribute("mask", "url(" + getLocationHref() + "#" + st + "_" + nt + ")"),
                        it.length = 0,
                        it.push(pt)
                    } else
                        it.push(tt);
                    rt[$].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                    this.viewData[$] = {
                        elem: tt,
                        lastPath: "",
                        op: PropertyFactory.getProp(this.element, rt[$].o, 0, .01, this.element),
                        prop: ShapePropertyFactory.getShapeProp(this.element, rt[$], 3),
                        invRect: dt
                    },
                    this.viewData[$].prop.k || this.drawPath(rt[$], this.viewData[$].prop.v, this.viewData[$])
                }
            for (this.maskElement = createNS(lt),
            et = it.length,
            $ = 0; $ < et; $ += 1)
                this.maskElement.appendChild(it[$]);
            nt > 0 && (this.maskElement.setAttribute("id", st),
            this.element.maskedElement.setAttribute(ct, "url(" + getLocationHref() + "#" + st + ")"),
            _.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
        }
        MaskElement.prototype.getMaskProperty = function(d) {
            return this.viewData[d].prop
        }
        ,
        MaskElement.prototype.renderFrame = function(d) {
            var g = this.element.finalTransform.mat, b, _ = this.masksProperties.length;
            for (b = 0; b < _; b += 1)
                if ((this.viewData[b].prop._mdf || d) && this.drawPath(this.masksProperties[b], this.viewData[b].prop.v, this.viewData[b]),
                (this.viewData[b].op._mdf || d) && this.viewData[b].elem.setAttribute("fill-opacity", this.viewData[b].op.v),
                this.masksProperties[b].mode !== "n" && (this.viewData[b].invRect && (this.element.finalTransform.mProp._mdf || d) && this.viewData[b].invRect.setAttribute("transform", g.getInverseMatrix().to2dCSS()),
                this.storedData[b].x && (this.storedData[b].x._mdf || d))) {
                    var $ = this.storedData[b].expan;
                    this.storedData[b].x.v < 0 ? (this.storedData[b].lastOperator !== "erode" && (this.storedData[b].lastOperator = "erode",
                    this.storedData[b].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[b].filterId + ")")),
                    $.setAttribute("radius", -this.storedData[b].x.v)) : (this.storedData[b].lastOperator !== "dilate" && (this.storedData[b].lastOperator = "dilate",
                    this.storedData[b].elem.setAttribute("filter", null)),
                    this.storedData[b].elem.setAttribute("stroke-width", this.storedData[b].x.v * 2))
                }
        }
        ,
        MaskElement.prototype.getMaskelement = function() {
            return this.maskElement
        }
        ,
        MaskElement.prototype.createLayerSolidPath = function() {
            var d = "M0,0 ";
            return d += " h" + this.globalData.compSize.w,
            d += " v" + this.globalData.compSize.h,
            d += " h-" + this.globalData.compSize.w,
            d += " v-" + this.globalData.compSize.h + " ",
            d
        }
        ,
        MaskElement.prototype.drawPath = function(d, g, b) {
            var _ = " M" + g.v[0][0] + "," + g.v[0][1], $, et;
            for (et = g._length,
            $ = 1; $ < et; $ += 1)
                _ += " C" + g.o[$ - 1][0] + "," + g.o[$ - 1][1] + " " + g.i[$][0] + "," + g.i[$][1] + " " + g.v[$][0] + "," + g.v[$][1];
            if (g.c && et > 1 && (_ += " C" + g.o[$ - 1][0] + "," + g.o[$ - 1][1] + " " + g.i[0][0] + "," + g.i[0][1] + " " + g.v[0][0] + "," + g.v[0][1]),
            b.lastPath !== _) {
                var tt = "";
                b.elem && (g.c && (tt = d.inv ? this.solidPath + _ : _),
                b.elem.setAttribute("d", tt)),
                b.lastPath = _
            }
        }
        ,
        MaskElement.prototype.destroy = function() {
            this.element = null,
            this.globalData = null,
            this.maskElement = null,
            this.data = null,
            this.masksProperties = null
        }
        ;
        var filtersFactory = function() {
            var d = {};
            d.createFilter = g,
            d.createAlphaToLuminanceFilter = b;
            function g(_, $) {
                var et = createNS("filter");
                return et.setAttribute("id", _),
                $ !== !0 && (et.setAttribute("filterUnits", "objectBoundingBox"),
                et.setAttribute("x", "0%"),
                et.setAttribute("y", "0%"),
                et.setAttribute("width", "100%"),
                et.setAttribute("height", "100%")),
                et
            }
            function b() {
                var _ = createNS("feColorMatrix");
                return _.setAttribute("type", "matrix"),
                _.setAttribute("color-interpolation-filters", "sRGB"),
                _.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"),
                _
            }
            return d
        }()
          , featureSupport = function() {
            var d = {
                maskType: !0,
                svgLumaHidden: !0,
                offscreenCanvas: typeof OffscreenCanvas < "u"
            };
            return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (d.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (d.svgLumaHidden = !1),
            d
        }()
          , registeredEffects$1 = {}
          , idPrefix = "filter_result_";
        function SVGEffects(d) {
            var g, b = "SourceGraphic", _ = d.data.ef ? d.data.ef.length : 0, $ = createElementID(), et = filtersFactory.createFilter($, !0), tt = 0;
            this.filters = [];
            var rt;
            for (g = 0; g < _; g += 1) {
                rt = null;
                var nt = d.data.ef[g].ty;
                if (registeredEffects$1[nt]) {
                    var it = registeredEffects$1[nt].effect;
                    rt = new it(et,d.effectsManager.effectElements[g],d,idPrefix + tt,b),
                    b = idPrefix + tt,
                    registeredEffects$1[nt].countsAsEffect && (tt += 1)
                }
                rt && this.filters.push(rt)
            }
            tt && (d.globalData.defs.appendChild(et),
            d.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + $ + ")")),
            this.filters.length && d.addRenderableComponent(this)
        }
        SVGEffects.prototype.renderFrame = function(d) {
            var g, b = this.filters.length;
            for (g = 0; g < b; g += 1)
                this.filters[g].renderFrame(d)
        }
        ,
        SVGEffects.prototype.getEffects = function(d) {
            var g, b = this.filters.length, _ = [];
            for (g = 0; g < b; g += 1)
                this.filters[g].type === d && _.push(this.filters[g]);
            return _
        }
        ;
        function registerEffect$1(d, g, b) {
            registeredEffects$1[d] = {
                effect: g,
                countsAsEffect: b
            }
        }
        function SVGBaseElement() {}
        SVGBaseElement.prototype = {
            initRendererElement: function() {
                this.layerElement = createNS("g")
            },
            createContainerElements: function() {
                this.matteElement = createNS("g"),
                this.transformedElement = this.layerElement,
                this.maskedElement = this.layerElement,
                this._sizeChanged = !1;
                var g = null;
                if (this.data.td) {
                    this.matteMasks = {};
                    var b = createNS("g");
                    b.setAttribute("id", this.layerId),
                    b.appendChild(this.layerElement),
                    g = b,
                    this.globalData.defs.appendChild(b)
                } else
                    this.data.tt ? (this.matteElement.appendChild(this.layerElement),
                    g = this.matteElement,
                    this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
                if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.ty === 0 && !this.data.hd) {
                    var _ = createNS("clipPath")
                      , $ = createNS("path");
                    $.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
                    var et = createElementID();
                    if (_.setAttribute("id", et),
                    _.appendChild($),
                    this.globalData.defs.appendChild(_),
                    this.checkMasks()) {
                        var tt = createNS("g");
                        tt.setAttribute("clip-path", "url(" + getLocationHref() + "#" + et + ")"),
                        tt.appendChild(this.layerElement),
                        this.transformedElement = tt,
                        g ? g.appendChild(this.transformedElement) : this.baseElement = this.transformedElement
                    } else
                        this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + et + ")")
                }
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()),
                this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity)
            },
            destroyBaseElement: function() {
                this.layerElement = null,
                this.matteElement = null,
                this.maskManager.destroy()
            },
            getBaseElement: function() {
                return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData),
                this.renderableEffectsManager = new SVGEffects(this),
                this.searchEffectTransforms()
            },
            getMatte: function(g) {
                if (this.matteMasks || (this.matteMasks = {}),
                !this.matteMasks[g]) {
                    var b = this.layerId + "_" + g, _, $, et, tt;
                    if (g === 1 || g === 3) {
                        var rt = createNS("mask");
                        rt.setAttribute("id", b),
                        rt.setAttribute("mask-type", g === 3 ? "luminance" : "alpha"),
                        et = createNS("use"),
                        et.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        rt.appendChild(et),
                        this.globalData.defs.appendChild(rt),
                        !featureSupport.maskType && g === 1 && (rt.setAttribute("mask-type", "luminance"),
                        _ = createElementID(),
                        $ = filtersFactory.createFilter(_),
                        this.globalData.defs.appendChild($),
                        $.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        tt = createNS("g"),
                        tt.appendChild(et),
                        rt.appendChild(tt),
                        tt.setAttribute("filter", "url(" + getLocationHref() + "#" + _ + ")"))
                    } else if (g === 2) {
                        var nt = createNS("mask");
                        nt.setAttribute("id", b),
                        nt.setAttribute("mask-type", "alpha");
                        var it = createNS("g");
                        nt.appendChild(it),
                        _ = createElementID(),
                        $ = filtersFactory.createFilter(_);
                        var ot = createNS("feComponentTransfer");
                        ot.setAttribute("in", "SourceGraphic"),
                        $.appendChild(ot);
                        var at = createNS("feFuncA");
                        at.setAttribute("type", "table"),
                        at.setAttribute("tableValues", "1.0 0.0"),
                        ot.appendChild(at),
                        this.globalData.defs.appendChild($);
                        var st = createNS("rect");
                        st.setAttribute("width", this.comp.data.w),
                        st.setAttribute("height", this.comp.data.h),
                        st.setAttribute("x", "0"),
                        st.setAttribute("y", "0"),
                        st.setAttribute("fill", "#ffffff"),
                        st.setAttribute("opacity", "0"),
                        it.setAttribute("filter", "url(" + getLocationHref() + "#" + _ + ")"),
                        it.appendChild(st),
                        et = createNS("use"),
                        et.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId),
                        it.appendChild(et),
                        featureSupport.maskType || (nt.setAttribute("mask-type", "luminance"),
                        $.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                        tt = createNS("g"),
                        it.appendChild(st),
                        tt.appendChild(this.layerElement),
                        it.appendChild(tt)),
                        this.globalData.defs.appendChild(nt)
                    }
                    this.matteMasks[g] = b
                }
                return this.matteMasks[g]
            },
            setMatte: function(g) {
                this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + g + ")")
            }
        };
        function HierarchyElement() {}
        HierarchyElement.prototype = {
            initHierarchy: function() {
                this.hierarchy = [],
                this._isParent = !1,
                this.checkParenting()
            },
            setHierarchy: function(g) {
                this.hierarchy = g
            },
            setAsParent: function() {
                this._isParent = !0
            },
            checkParenting: function() {
                this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, [])
            }
        };
        function RenderableDOMElement() {}
        (function() {
            var d = {
                initElement: function(b, _, $) {
                    this.initFrame(),
                    this.initBaseData(b, _, $),
                    this.initTransform(b, _, $),
                    this.initHierarchy(),
                    this.initRenderable(),
                    this.initRendererElement(),
                    this.createContainerElements(),
                    this.createRenderableComponents(),
                    this.createContent(),
                    this.hide()
                },
                hide: function() {
                    if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                        var b = this.baseElement || this.layerElement;
                        b.style.display = "none",
                        this.hidden = !0
                    }
                },
                show: function() {
                    if (this.isInRange && !this.isTransparent) {
                        if (!this.data.hd) {
                            var b = this.baseElement || this.layerElement;
                            b.style.display = "block"
                        }
                        this.hidden = !1,
                        this._isFirstFrame = !0
                    }
                },
                renderFrame: function() {
                    this.data.hd || this.hidden || (this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.renderElement(),
                    this.renderInnerContent(),
                    this._isFirstFrame && (this._isFirstFrame = !1))
                },
                renderInnerContent: function() {},
                prepareFrame: function(b) {
                    this._mdf = !1,
                    this.prepareRenderableFrame(b),
                    this.prepareProperties(b, this.isInRange),
                    this.checkTransparency()
                },
                destroy: function() {
                    this.innerElem = null,
                    this.destroyBaseElement()
                }
            };
            extendPrototype([RenderableElement, createProxyFunction(d)], RenderableDOMElement)
        }
        )();
        function IImageElement(d, g, b) {
            this.assetData = g.getAssetData(d.refId),
            this.assetData && this.assetData.sid && (this.assetData = g.slotManager.getProp(this.assetData)),
            this.initElement(d, g, b),
            this.sourceRect = {
                top: 0,
                left: 0,
                width: this.assetData.w,
                height: this.assetData.h
            }
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement),
        IImageElement.prototype.createContent = function() {
            var d = this.globalData.getAssetsPath(this.assetData);
            this.innerElem = createNS("image"),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio),
            this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", d),
            this.layerElement.appendChild(this.innerElem)
        }
        ,
        IImageElement.prototype.sourceRectAtTime = function() {
            return this.sourceRect
        }
        ;
        function ProcessedElement(d, g) {
            this.elem = d,
            this.pos = g
        }
        function IShapeElement() {}
        IShapeElement.prototype = {
            addShapeToModifiers: function(g) {
                var b, _ = this.shapeModifiers.length;
                for (b = 0; b < _; b += 1)
                    this.shapeModifiers[b].addShape(g)
            },
            isShapeInAnimatedModifiers: function(g) {
                for (var b = 0, _ = this.shapeModifiers.length; b < _; )
                    if (this.shapeModifiers[b].isAnimatedWithShape(g))
                        return !0;
                return !1
            },
            renderModifiers: function() {
                if (this.shapeModifiers.length) {
                    var g, b = this.shapes.length;
                    for (g = 0; g < b; g += 1)
                        this.shapes[g].sh.reset();
                    b = this.shapeModifiers.length;
                    var _;
                    for (g = b - 1; g >= 0 && (_ = this.shapeModifiers[g].processShapes(this._isFirstFrame),
                    !_); g -= 1)
                        ;
                }
            },
            searchProcessedElement: function(g) {
                for (var b = this.processedElements, _ = 0, $ = b.length; _ < $; ) {
                    if (b[_].elem === g)
                        return b[_].pos;
                    _ += 1
                }
                return 0
            },
            addProcessedElement: function(g, b) {
                for (var _ = this.processedElements, $ = _.length; $; )
                    if ($ -= 1,
                    _[$].elem === g) {
                        _[$].pos = b;
                        return
                    }
                _.push(new ProcessedElement(g,b))
            },
            prepareFrame: function(g) {
                this.prepareRenderableFrame(g),
                this.prepareProperties(g, this.isInRange)
            }
        };
        var lineCapEnum = {
            1: "butt",
            2: "round",
            3: "square"
        }
          , lineJoinEnum = {
            1: "miter",
            2: "round",
            3: "bevel"
        };
        function SVGShapeData(d, g, b) {
            this.caches = [],
            this.styles = [],
            this.transformers = d,
            this.lStr = "",
            this.sh = b,
            this.lvl = g,
            this._isAnimated = !!b.k;
            for (var _ = 0, $ = d.length; _ < $; ) {
                if (d[_].mProps.dynamicProperties.length) {
                    this._isAnimated = !0;
                    break
                }
                _ += 1
            }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
            this._isAnimated = !0
        }
        ;
        function SVGStyleData(d, g) {
            this.data = d,
            this.type = d.ty,
            this.d = "",
            this.lvl = g,
            this._mdf = !1,
            this.closed = d.hd === !0,
            this.pElem = createNS("path"),
            this.msElem = null
        }
        SVGStyleData.prototype.reset = function() {
            this.d = "",
            this._mdf = !1
        }
        ;
        function DashProperty(d, g, b, _) {
            this.elem = d,
            this.frameId = -1,
            this.dataProps = createSizedArray(g.length),
            this.renderer = b,
            this.k = !1,
            this.dashStr = "",
            this.dashArray = createTypedArray("float32", g.length ? g.length - 1 : 0),
            this.dashoffset = createTypedArray("float32", 1),
            this.initDynamicPropertyContainer(_);
            var $, et = g.length || 0, tt;
            for ($ = 0; $ < et; $ += 1)
                tt = PropertyFactory.getProp(d, g[$].v, 0, 0, this),
                this.k = tt.k || this.k,
                this.dataProps[$] = {
                    n: g[$].n,
                    p: tt
                };
            this.k || this.getValue(!0),
            this._isAnimated = this.k
        }
        DashProperty.prototype.getValue = function(d) {
            if (!(this.elem.globalData.frameId === this.frameId && !d) && (this.frameId = this.elem.globalData.frameId,
            this.iterateDynamicProperties(),
            this._mdf = this._mdf || d,
            this._mdf)) {
                var g = 0
                  , b = this.dataProps.length;
                for (this.renderer === "svg" && (this.dashStr = ""),
                g = 0; g < b; g += 1)
                    this.dataProps[g].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[g].p.v : this.dashArray[g] = this.dataProps[g].p.v : this.dashoffset[0] = this.dataProps[g].p.v
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function SVGStrokeStyleData(d, g, b) {
            this.initDynamicPropertyContainer(d),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(d, g.o, 0, .01, this),
            this.w = PropertyFactory.getProp(d, g.w, 0, null, this),
            this.d = new DashProperty(d,g.d || {},"svg",this),
            this.c = PropertyFactory.getProp(d, g.c, 1, 255, this),
            this.style = b,
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(d, g, b) {
            this.initDynamicPropertyContainer(d),
            this.getValue = this.iterateDynamicProperties,
            this.o = PropertyFactory.getProp(d, g.o, 0, .01, this),
            this.c = PropertyFactory.getProp(d, g.c, 1, 255, this),
            this.style = b
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGNoStyleData(d, g, b) {
            this.initDynamicPropertyContainer(d),
            this.getValue = this.iterateDynamicProperties,
            this.style = b
        }
        extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
        function GradientProperty(d, g, b) {
            this.data = g,
            this.c = createTypedArray("uint8c", g.p * 4);
            var _ = g.k.k[0].s ? g.k.k[0].s.length - g.p * 4 : g.k.k.length - g.p * 4;
            this.o = createTypedArray("float32", _),
            this._cmdf = !1,
            this._omdf = !1,
            this._collapsable = this.checkCollapsable(),
            this._hasOpacity = _,
            this.initDynamicPropertyContainer(b),
            this.prop = PropertyFactory.getProp(d, g.k, 1, null, this),
            this.k = this.prop.k,
            this.getValue(!0)
        }
        GradientProperty.prototype.comparePoints = function(d, g) {
            for (var b = 0, _ = this.o.length / 2, $; b < _; ) {
                if ($ = Math.abs(d[b * 4] - d[g * 4 + b * 2]),
                $ > .01)
                    return !1;
                b += 1
            }
            return !0
        }
        ,
        GradientProperty.prototype.checkCollapsable = function() {
            if (this.o.length / 2 !== this.c.length / 4)
                return !1;
            if (this.data.k.k[0].s)
                for (var d = 0, g = this.data.k.k.length; d < g; ) {
                    if (!this.comparePoints(this.data.k.k[d].s, this.data.p))
                        return !1;
                    d += 1
                }
            else if (!this.comparePoints(this.data.k.k, this.data.p))
                return !1;
            return !0
        }
        ,
        GradientProperty.prototype.getValue = function(d) {
            if (this.prop.getValue(),
            this._mdf = !1,
            this._cmdf = !1,
            this._omdf = !1,
            this.prop._mdf || d) {
                var g, b = this.data.p * 4, _, $;
                for (g = 0; g < b; g += 1)
                    _ = g % 4 === 0 ? 100 : 255,
                    $ = Math.round(this.prop.v[g] * _),
                    this.c[g] !== $ && (this.c[g] = $,
                    this._cmdf = !d);
                if (this.o.length)
                    for (b = this.prop.v.length,
                    g = this.data.p * 4; g < b; g += 1)
                        _ = g % 2 === 0 ? 100 : 1,
                        $ = g % 2 === 0 ? Math.round(this.prop.v[g] * 100) : this.prop.v[g],
                        this.o[g - this.data.p * 4] !== $ && (this.o[g - this.data.p * 4] = $,
                        this._omdf = !d);
                this._mdf = !d
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        function SVGGradientFillStyleData(d, g, b) {
            this.initDynamicPropertyContainer(d),
            this.getValue = this.iterateDynamicProperties,
            this.initGradientData(d, g, b)
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(d, g, b) {
            this.o = PropertyFactory.getProp(d, g.o, 0, .01, this),
            this.s = PropertyFactory.getProp(d, g.s, 1, null, this),
            this.e = PropertyFactory.getProp(d, g.e, 1, null, this),
            this.h = PropertyFactory.getProp(d, g.h || {
                k: 0
            }, 0, .01, this),
            this.a = PropertyFactory.getProp(d, g.a || {
                k: 0
            }, 0, degToRads, this),
            this.g = new GradientProperty(d,g.g,this),
            this.style = b,
            this.stops = [],
            this.setGradientData(b.pElem, g),
            this.setGradientOpacity(g, b),
            this._isAnimated = !!this._isAnimated
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientData = function(d, g) {
            var b = createElementID()
              , _ = createNS(g.t === 1 ? "linearGradient" : "radialGradient");
            _.setAttribute("id", b),
            _.setAttribute("spreadMethod", "pad"),
            _.setAttribute("gradientUnits", "userSpaceOnUse");
            var $ = [], et, tt, rt;
            for (rt = g.g.p * 4,
            tt = 0; tt < rt; tt += 4)
                et = createNS("stop"),
                _.appendChild(et),
                $.push(et);
            d.setAttribute(g.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + b + ")"),
            this.gf = _,
            this.cst = $
        }
        ,
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(d, g) {
            if (this.g._hasOpacity && !this.g._collapsable) {
                var b, _, $, et = createNS("mask"), tt = createNS("path");
                et.appendChild(tt);
                var rt = createElementID()
                  , nt = createElementID();
                et.setAttribute("id", nt);
                var it = createNS(d.t === 1 ? "linearGradient" : "radialGradient");
                it.setAttribute("id", rt),
                it.setAttribute("spreadMethod", "pad"),
                it.setAttribute("gradientUnits", "userSpaceOnUse"),
                $ = d.g.k.k[0].s ? d.g.k.k[0].s.length : d.g.k.k.length;
                var ot = this.stops;
                for (_ = d.g.p * 4; _ < $; _ += 2)
                    b = createNS("stop"),
                    b.setAttribute("stop-color", "rgb(255,255,255)"),
                    it.appendChild(b),
                    ot.push(b);
                tt.setAttribute(d.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + rt + ")"),
                d.ty === "gs" && (tt.setAttribute("stroke-linecap", lineCapEnum[d.lc || 2]),
                tt.setAttribute("stroke-linejoin", lineJoinEnum[d.lj || 2]),
                d.lj === 1 && tt.setAttribute("stroke-miterlimit", d.ml)),
                this.of = it,
                this.ms = et,
                this.ost = ot,
                this.maskId = nt,
                g.msElem = tt
            }
        }
        ,
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(d, g, b) {
            this.initDynamicPropertyContainer(d),
            this.getValue = this.iterateDynamicProperties,
            this.w = PropertyFactory.getProp(d, g.w, 0, null, this),
            this.d = new DashProperty(d,g.d || {},"svg",this),
            this.initGradientData(d, g, b),
            this._isAnimated = !!this._isAnimated
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
            this.it = [],
            this.prevViewData = [],
            this.gr = createNS("g")
        }
        function SVGTransformData(d, g, b) {
            this.transform = {
                mProps: d,
                op: g,
                container: b
            },
            this.elements = [],
            this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length
        }
        var buildShapeString = function(g, b, _, $) {
            if (b === 0)
                return "";
            var et = g.o, tt = g.i, rt = g.v, nt, it = " M" + $.applyToPointStringified(rt[0][0], rt[0][1]);
            for (nt = 1; nt < b; nt += 1)
                it += " C" + $.applyToPointStringified(et[nt - 1][0], et[nt - 1][1]) + " " + $.applyToPointStringified(tt[nt][0], tt[nt][1]) + " " + $.applyToPointStringified(rt[nt][0], rt[nt][1]);
            return _ && b && (it += " C" + $.applyToPointStringified(et[nt - 1][0], et[nt - 1][1]) + " " + $.applyToPointStringified(tt[0][0], tt[0][1]) + " " + $.applyToPointStringified(rt[0][0], rt[0][1]),
            it += "z"),
            it
        }
          , SVGElementsRenderer = function() {
            var d = new Matrix
              , g = new Matrix
              , b = {
                createRenderFunction: _
            };
            function _(at) {
                switch (at.ty) {
                case "fl":
                    return rt;
                case "gf":
                    return it;
                case "gs":
                    return nt;
                case "st":
                    return ot;
                case "sh":
                case "el":
                case "rc":
                case "sr":
                    return tt;
                case "tr":
                    return $;
                case "no":
                    return et;
                default:
                    return null
                }
            }
            function $(at, st, dt) {
                (dt || st.transform.op._mdf) && st.transform.container.setAttribute("opacity", st.transform.op.v),
                (dt || st.transform.mProps._mdf) && st.transform.container.setAttribute("transform", st.transform.mProps.v.to2dCSS())
            }
            function et() {}
            function tt(at, st, dt) {
                var ft, ht, xt, lt, ct, ut, pt = st.styles.length, vt = st.lvl, _t, Pt, kt, $t;
                for (ut = 0; ut < pt; ut += 1) {
                    if (lt = st.sh._mdf || dt,
                    st.styles[ut].lvl < vt) {
                        for (Pt = g.reset(),
                        kt = vt - st.styles[ut].lvl,
                        $t = st.transformers.length - 1; !lt && kt > 0; )
                            lt = st.transformers[$t].mProps._mdf || lt,
                            kt -= 1,
                            $t -= 1;
                        if (lt)
                            for (kt = vt - st.styles[ut].lvl,
                            $t = st.transformers.length - 1; kt > 0; )
                                Pt.multiply(st.transformers[$t].mProps.v),
                                kt -= 1,
                                $t -= 1
                    } else
                        Pt = d;
                    if (_t = st.sh.paths,
                    ht = _t._length,
                    lt) {
                        for (xt = "",
                        ft = 0; ft < ht; ft += 1)
                            ct = _t.shapes[ft],
                            ct && ct._length && (xt += buildShapeString(ct, ct._length, ct.c, Pt));
                        st.caches[ut] = xt
                    } else
                        xt = st.caches[ut];
                    st.styles[ut].d += at.hd === !0 ? "" : xt,
                    st.styles[ut]._mdf = lt || st.styles[ut]._mdf
                }
            }
            function rt(at, st, dt) {
                var ft = st.style;
                (st.c._mdf || dt) && ft.pElem.setAttribute("fill", "rgb(" + bmFloor(st.c.v[0]) + "," + bmFloor(st.c.v[1]) + "," + bmFloor(st.c.v[2]) + ")"),
                (st.o._mdf || dt) && ft.pElem.setAttribute("fill-opacity", st.o.v)
            }
            function nt(at, st, dt) {
                it(at, st, dt),
                ot(at, st, dt)
            }
            function it(at, st, dt) {
                var ft = st.gf
                  , ht = st.g._hasOpacity
                  , xt = st.s.v
                  , lt = st.e.v;
                if (st.o._mdf || dt) {
                    var ct = at.ty === "gf" ? "fill-opacity" : "stroke-opacity";
                    st.style.pElem.setAttribute(ct, st.o.v)
                }
                if (st.s._mdf || dt) {
                    var ut = at.t === 1 ? "x1" : "cx"
                      , pt = ut === "x1" ? "y1" : "cy";
                    ft.setAttribute(ut, xt[0]),
                    ft.setAttribute(pt, xt[1]),
                    ht && !st.g._collapsable && (st.of.setAttribute(ut, xt[0]),
                    st.of.setAttribute(pt, xt[1]))
                }
                var vt, _t, Pt, kt;
                if (st.g._cmdf || dt) {
                    vt = st.cst;
                    var $t = st.g.c;
                    for (Pt = vt.length,
                    _t = 0; _t < Pt; _t += 1)
                        kt = vt[_t],
                        kt.setAttribute("offset", $t[_t * 4] + "%"),
                        kt.setAttribute("stop-color", "rgb(" + $t[_t * 4 + 1] + "," + $t[_t * 4 + 2] + "," + $t[_t * 4 + 3] + ")")
                }
                if (ht && (st.g._omdf || dt)) {
                    var Wt = st.g.o;
                    for (st.g._collapsable ? vt = st.cst : vt = st.ost,
                    Pt = vt.length,
                    _t = 0; _t < Pt; _t += 1)
                        kt = vt[_t],
                        st.g._collapsable || kt.setAttribute("offset", Wt[_t * 2] + "%"),
                        kt.setAttribute("stop-opacity", Wt[_t * 2 + 1])
                }
                if (at.t === 1)
                    (st.e._mdf || dt) && (ft.setAttribute("x2", lt[0]),
                    ft.setAttribute("y2", lt[1]),
                    ht && !st.g._collapsable && (st.of.setAttribute("x2", lt[0]),
                    st.of.setAttribute("y2", lt[1])));
                else {
                    var Ht;
                    if ((st.s._mdf || st.e._mdf || dt) && (Ht = Math.sqrt(Math.pow(xt[0] - lt[0], 2) + Math.pow(xt[1] - lt[1], 2)),
                    ft.setAttribute("r", Ht),
                    ht && !st.g._collapsable && st.of.setAttribute("r", Ht)),
                    st.e._mdf || st.h._mdf || st.a._mdf || dt) {
                        Ht || (Ht = Math.sqrt(Math.pow(xt[0] - lt[0], 2) + Math.pow(xt[1] - lt[1], 2)));
                        var Dt = Math.atan2(lt[1] - xt[1], lt[0] - xt[0])
                          , Vt = st.h.v;
                        Vt >= 1 ? Vt = .99 : Vt <= -1 && (Vt = -.99);
                        var Ft = Ht * Vt
                          , Kt = Math.cos(Dt + st.a.v) * Ft + xt[0]
                          , Rt = Math.sin(Dt + st.a.v) * Ft + xt[1];
                        ft.setAttribute("fx", Kt),
                        ft.setAttribute("fy", Rt),
                        ht && !st.g._collapsable && (st.of.setAttribute("fx", Kt),
                        st.of.setAttribute("fy", Rt))
                    }
                }
            }
            function ot(at, st, dt) {
                var ft = st.style
                  , ht = st.d;
                ht && (ht._mdf || dt) && ht.dashStr && (ft.pElem.setAttribute("stroke-dasharray", ht.dashStr),
                ft.pElem.setAttribute("stroke-dashoffset", ht.dashoffset[0])),
                st.c && (st.c._mdf || dt) && ft.pElem.setAttribute("stroke", "rgb(" + bmFloor(st.c.v[0]) + "," + bmFloor(st.c.v[1]) + "," + bmFloor(st.c.v[2]) + ")"),
                (st.o._mdf || dt) && ft.pElem.setAttribute("stroke-opacity", st.o.v),
                (st.w._mdf || dt) && (ft.pElem.setAttribute("stroke-width", st.w.v),
                ft.msElem && ft.msElem.setAttribute("stroke-width", st.w.v))
            }
            return b
        }();
        function SVGShapeElement(d, g, b) {
            this.shapes = [],
            this.shapesData = d.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.initElement(d, g, b),
            this.prevViewData = []
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement),
        SVGShapeElement.prototype.initSecondaryElement = function() {}
        ,
        SVGShapeElement.prototype.identityMatrix = new Matrix,
        SVGShapeElement.prototype.buildExpressionInterface = function() {}
        ,
        SVGShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes()
        }
        ,
        SVGShapeElement.prototype.filterUniqueShapes = function() {
            var d, g = this.shapes.length, b, _, $ = this.stylesList.length, et, tt = [], rt = !1;
            for (_ = 0; _ < $; _ += 1) {
                for (et = this.stylesList[_],
                rt = !1,
                tt.length = 0,
                d = 0; d < g; d += 1)
                    b = this.shapes[d],
                    b.styles.indexOf(et) !== -1 && (tt.push(b),
                    rt = b._isAnimated || rt);
                tt.length > 1 && rt && this.setShapesAsAnimated(tt)
            }
        }
        ,
        SVGShapeElement.prototype.setShapesAsAnimated = function(d) {
            var g, b = d.length;
            for (g = 0; g < b; g += 1)
                d[g].setAsAnimated()
        }
        ,
        SVGShapeElement.prototype.createStyleElement = function(d, g) {
            var b, _ = new SVGStyleData(d,g), $ = _.pElem;
            if (d.ty === "st")
                b = new SVGStrokeStyleData(this,d,_);
            else if (d.ty === "fl")
                b = new SVGFillStyleData(this,d,_);
            else if (d.ty === "gf" || d.ty === "gs") {
                var et = d.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
                b = new et(this,d,_),
                this.globalData.defs.appendChild(b.gf),
                b.maskId && (this.globalData.defs.appendChild(b.ms),
                this.globalData.defs.appendChild(b.of),
                $.setAttribute("mask", "url(" + getLocationHref() + "#" + b.maskId + ")"))
            } else
                d.ty === "no" && (b = new SVGNoStyleData(this,d,_));
            return (d.ty === "st" || d.ty === "gs") && ($.setAttribute("stroke-linecap", lineCapEnum[d.lc || 2]),
            $.setAttribute("stroke-linejoin", lineJoinEnum[d.lj || 2]),
            $.setAttribute("fill-opacity", "0"),
            d.lj === 1 && $.setAttribute("stroke-miterlimit", d.ml)),
            d.r === 2 && $.setAttribute("fill-rule", "evenodd"),
            d.ln && $.setAttribute("id", d.ln),
            d.cl && $.setAttribute("class", d.cl),
            d.bm && ($.style["mix-blend-mode"] = getBlendMode(d.bm)),
            this.stylesList.push(_),
            this.addToAnimatedContents(d, b),
            b
        }
        ,
        SVGShapeElement.prototype.createGroupElement = function(d) {
            var g = new ShapeGroupData;
            return d.ln && g.gr.setAttribute("id", d.ln),
            d.cl && g.gr.setAttribute("class", d.cl),
            d.bm && (g.gr.style["mix-blend-mode"] = getBlendMode(d.bm)),
            g
        }
        ,
        SVGShapeElement.prototype.createTransformElement = function(d, g) {
            var b = TransformPropertyFactory.getTransformProperty(this, d, this)
              , _ = new SVGTransformData(b,b.o,g);
            return this.addToAnimatedContents(d, _),
            _
        }
        ,
        SVGShapeElement.prototype.createShapeElement = function(d, g, b) {
            var _ = 4;
            d.ty === "rc" ? _ = 5 : d.ty === "el" ? _ = 6 : d.ty === "sr" && (_ = 7);
            var $ = ShapePropertyFactory.getShapeProp(this, d, _, this)
              , et = new SVGShapeData(g,b,$);
            return this.shapes.push(et),
            this.addShapeToModifiers(et),
            this.addToAnimatedContents(d, et),
            et
        }
        ,
        SVGShapeElement.prototype.addToAnimatedContents = function(d, g) {
            for (var b = 0, _ = this.animatedContents.length; b < _; ) {
                if (this.animatedContents[b].element === g)
                    return;
                b += 1
            }
            this.animatedContents.push({
                fn: SVGElementsRenderer.createRenderFunction(d),
                element: g,
                data: d
            })
        }
        ,
        SVGShapeElement.prototype.setElementStyles = function(d) {
            var g = d.styles, b, _ = this.stylesList.length;
            for (b = 0; b < _; b += 1)
                this.stylesList[b].closed || g.push(this.stylesList[b])
        }
        ,
        SVGShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var d, g = this.itemsData.length;
            for (d = 0; d < g; d += 1)
                this.prevViewData[d] = this.itemsData[d];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0),
            this.filterUniqueShapes(),
            g = this.dynamicProperties.length,
            d = 0; d < g; d += 1)
                this.dynamicProperties[d].getValue();
            this.renderModifiers()
        }
        ,
        SVGShapeElement.prototype.searchShapes = function(d, g, b, _, $, et, tt) {
            var rt = [].concat(et), nt, it = d.length - 1, ot, at, st = [], dt = [], ft, ht, xt;
            for (nt = it; nt >= 0; nt -= 1) {
                if (xt = this.searchProcessedElement(d[nt]),
                xt ? g[nt] = b[xt - 1] : d[nt]._render = tt,
                d[nt].ty === "fl" || d[nt].ty === "st" || d[nt].ty === "gf" || d[nt].ty === "gs" || d[nt].ty === "no")
                    xt ? g[nt].style.closed = !1 : g[nt] = this.createStyleElement(d[nt], $),
                    d[nt]._render && g[nt].style.pElem.parentNode !== _ && _.appendChild(g[nt].style.pElem),
                    st.push(g[nt].style);
                else if (d[nt].ty === "gr") {
                    if (!xt)
                        g[nt] = this.createGroupElement(d[nt]);
                    else
                        for (at = g[nt].it.length,
                        ot = 0; ot < at; ot += 1)
                            g[nt].prevViewData[ot] = g[nt].it[ot];
                    this.searchShapes(d[nt].it, g[nt].it, g[nt].prevViewData, g[nt].gr, $ + 1, rt, tt),
                    d[nt]._render && g[nt].gr.parentNode !== _ && _.appendChild(g[nt].gr)
                } else
                    d[nt].ty === "tr" ? (xt || (g[nt] = this.createTransformElement(d[nt], _)),
                    ft = g[nt].transform,
                    rt.push(ft)) : d[nt].ty === "sh" || d[nt].ty === "rc" || d[nt].ty === "el" || d[nt].ty === "sr" ? (xt || (g[nt] = this.createShapeElement(d[nt], rt, $)),
                    this.setElementStyles(g[nt])) : d[nt].ty === "tm" || d[nt].ty === "rd" || d[nt].ty === "ms" || d[nt].ty === "pb" || d[nt].ty === "zz" || d[nt].ty === "op" ? (xt ? (ht = g[nt],
                    ht.closed = !1) : (ht = ShapeModifiers.getModifier(d[nt].ty),
                    ht.init(this, d[nt]),
                    g[nt] = ht,
                    this.shapeModifiers.push(ht)),
                    dt.push(ht)) : d[nt].ty === "rp" && (xt ? (ht = g[nt],
                    ht.closed = !0) : (ht = ShapeModifiers.getModifier(d[nt].ty),
                    g[nt] = ht,
                    ht.init(this, d, nt, g),
                    this.shapeModifiers.push(ht),
                    tt = !1),
                    dt.push(ht));
                this.addProcessedElement(d[nt], nt + 1)
            }
            for (it = st.length,
            nt = 0; nt < it; nt += 1)
                st[nt].closed = !0;
            for (it = dt.length,
            nt = 0; nt < it; nt += 1)
                dt[nt].closed = !0
        }
        ,
        SVGShapeElement.prototype.renderInnerContent = function() {
            this.renderModifiers();
            var d, g = this.stylesList.length;
            for (d = 0; d < g; d += 1)
                this.stylesList[d].reset();
            for (this.renderShape(),
            d = 0; d < g; d += 1)
                (this.stylesList[d]._mdf || this._isFirstFrame) && (this.stylesList[d].msElem && (this.stylesList[d].msElem.setAttribute("d", this.stylesList[d].d),
                this.stylesList[d].d = "M0 0" + this.stylesList[d].d),
                this.stylesList[d].pElem.setAttribute("d", this.stylesList[d].d || "M0 0"))
        }
        ,
        SVGShapeElement.prototype.renderShape = function() {
            var d, g = this.animatedContents.length, b;
            for (d = 0; d < g; d += 1)
                b = this.animatedContents[d],
                (this._isFirstFrame || b.element._isAnimated) && b.data !== !0 && b.fn(b.data, b.element, this._isFirstFrame)
        }
        ,
        SVGShapeElement.prototype.destroy = function() {
            this.destroyBaseElement(),
            this.shapesData = null,
            this.itemsData = null
        }
        ;
        function LetterProps(d, g, b, _, $, et) {
            this.o = d,
            this.sw = g,
            this.sc = b,
            this.fc = _,
            this.m = $,
            this.p = et,
            this._mdf = {
                o: !0,
                sw: !!g,
                sc: !!b,
                fc: !!_,
                m: !0,
                p: !0
            }
        }
        LetterProps.prototype.update = function(d, g, b, _, $, et) {
            this._mdf.o = !1,
            this._mdf.sw = !1,
            this._mdf.sc = !1,
            this._mdf.fc = !1,
            this._mdf.m = !1,
            this._mdf.p = !1;
            var tt = !1;
            return this.o !== d && (this.o = d,
            this._mdf.o = !0,
            tt = !0),
            this.sw !== g && (this.sw = g,
            this._mdf.sw = !0,
            tt = !0),
            this.sc !== b && (this.sc = b,
            this._mdf.sc = !0,
            tt = !0),
            this.fc !== _ && (this.fc = _,
            this._mdf.fc = !0,
            tt = !0),
            this.m !== $ && (this.m = $,
            this._mdf.m = !0,
            tt = !0),
            et.length && (this.p[0] !== et[0] || this.p[1] !== et[1] || this.p[4] !== et[4] || this.p[5] !== et[5] || this.p[12] !== et[12] || this.p[13] !== et[13]) && (this.p = et,
            this._mdf.p = !0,
            tt = !0),
            tt
        }
        ;
        function TextProperty(d, g) {
            this._frameId = initialDefaultFrame,
            this.pv = "",
            this.v = "",
            this.kf = !1,
            this._isFirstFrame = !0,
            this._mdf = !1,
            g.d && g.d.sid && (g.d = d.globalData.slotManager.getProp(g.d)),
            this.data = g,
            this.elem = d,
            this.comp = this.elem.comp,
            this.keysIndex = 0,
            this.canResize = !1,
            this.minimumFontSize = 1,
            this.effectsSequence = [],
            this.currentData = {
                ascent: 0,
                boxWidth: this.defaultBoxWidth,
                f: "",
                fStyle: "",
                fWeight: "",
                fc: "",
                j: "",
                justifyOffset: "",
                l: [],
                lh: 0,
                lineWidths: [],
                ls: "",
                of: "",
                s: "",
                sc: "",
                sw: 0,
                t: 0,
                tr: 0,
                sz: 0,
                ps: null,
                fillColorAnim: !1,
                strokeColorAnim: !1,
                strokeWidthAnim: !1,
                yOffset: 0,
                finalSize: 0,
                finalText: [],
                finalLineHeight: 0,
                __complete: !1
            },
            this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0],
        TextProperty.prototype.copyData = function(d, g) {
            for (var b in g)
                Object.prototype.hasOwnProperty.call(g, b) && (d[b] = g[b]);
            return d
        }
        ,
        TextProperty.prototype.setCurrentData = function(d) {
            d.__complete || this.completeTextData(d),
            this.currentData = d,
            this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth,
            this._mdf = !0
        }
        ,
        TextProperty.prototype.searchProperty = function() {
            return this.searchKeyframes()
        }
        ,
        TextProperty.prototype.searchKeyframes = function() {
            return this.kf = this.data.d.k.length > 1,
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
        }
        ,
        TextProperty.prototype.addEffect = function(d) {
            this.effectsSequence.push(d),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.getValue = function(d) {
            if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !d)) {
                this.currentData.t = this.data.d.k[this.keysIndex].s.t;
                var g = this.currentData
                  , b = this.keysIndex;
                if (this.lock) {
                    this.setCurrentData(this.currentData);
                    return
                }
                this.lock = !0,
                this._mdf = !1;
                var _, $ = this.effectsSequence.length, et = d || this.data.d.k[this.keysIndex].s;
                for (_ = 0; _ < $; _ += 1)
                    b !== this.keysIndex ? et = this.effectsSequence[_](et, et.t) : et = this.effectsSequence[_](this.currentData, et.t);
                g !== et && this.setCurrentData(et),
                this.v = this.currentData,
                this.pv = this.v,
                this.lock = !1,
                this.frameId = this.elem.globalData.frameId
            }
        }
        ,
        TextProperty.prototype.getKeyframeValue = function() {
            for (var d = this.data.d.k, g = this.elem.comp.renderedFrame, b = 0, _ = d.length; b <= _ - 1 && !(b === _ - 1 || d[b + 1].t > g); )
                b += 1;
            return this.keysIndex !== b && (this.keysIndex = b),
            this.data.d.k[this.keysIndex].s
        }
        ,
        TextProperty.prototype.buildFinalText = function(d) {
            for (var g = [], b = 0, _ = d.length, $, et, tt = !1, rt = !1, nt = ""; b < _; )
                tt = rt,
                rt = !1,
                $ = d.charCodeAt(b),
                nt = d.charAt(b),
                FontManager.isCombinedCharacter($) ? tt = !0 : $ >= 55296 && $ <= 56319 ? FontManager.isRegionalFlag(d, b) ? nt = d.substr(b, 14) : (et = d.charCodeAt(b + 1),
                et >= 56320 && et <= 57343 && (FontManager.isModifier($, et) ? (nt = d.substr(b, 2),
                tt = !0) : FontManager.isFlagEmoji(d.substr(b, 4)) ? nt = d.substr(b, 4) : nt = d.substr(b, 2))) : $ > 56319 ? (et = d.charCodeAt(b + 1),
                FontManager.isVariationSelector($) && (tt = !0)) : FontManager.isZeroWidthJoiner($) && (tt = !0,
                rt = !0),
                tt ? (g[g.length - 1] += nt,
                tt = !1) : g.push(nt),
                b += nt.length;
            return g
        }
        ,
        TextProperty.prototype.completeTextData = function(d) {
            d.__complete = !0;
            var g = this.elem.globalData.fontManager, b = this.data, _ = [], $, et, tt, rt = 0, nt, it = b.m.g, ot = 0, at = 0, st = 0, dt = [], ft = 0, ht = 0, xt, lt, ct = g.getFontByName(d.f), ut, pt = 0, vt = getFontProperties(ct);
            d.fWeight = vt.weight,
            d.fStyle = vt.style,
            d.finalSize = d.s,
            d.finalText = this.buildFinalText(d.t),
            et = d.finalText.length,
            d.finalLineHeight = d.lh;
            var _t = d.tr / 1e3 * d.finalSize, Pt;
            if (d.sz)
                for (var kt = !0, $t = d.sz[0], Wt = d.sz[1], Ht, Dt; kt; ) {
                    Dt = this.buildFinalText(d.t),
                    Ht = 0,
                    ft = 0,
                    et = Dt.length,
                    _t = d.tr / 1e3 * d.finalSize;
                    var Vt = -1;
                    for ($ = 0; $ < et; $ += 1)
                        Pt = Dt[$].charCodeAt(0),
                        tt = !1,
                        Dt[$] === " " ? Vt = $ : (Pt === 13 || Pt === 3) && (ft = 0,
                        tt = !0,
                        Ht += d.finalLineHeight || d.finalSize * 1.2),
                        g.chars ? (ut = g.getCharData(Dt[$], ct.fStyle, ct.fFamily),
                        pt = tt ? 0 : ut.w * d.finalSize / 100) : pt = g.measureText(Dt[$], d.f, d.finalSize),
                        ft + pt > $t && Dt[$] !== " " ? (Vt === -1 ? et += 1 : $ = Vt,
                        Ht += d.finalLineHeight || d.finalSize * 1.2,
                        Dt.splice($, Vt === $ ? 1 : 0, "\r"),
                        Vt = -1,
                        ft = 0) : (ft += pt,
                        ft += _t);
                    Ht += ct.ascent * d.finalSize / 100,
                    this.canResize && d.finalSize > this.minimumFontSize && Wt < Ht ? (d.finalSize -= 1,
                    d.finalLineHeight = d.finalSize * d.lh / d.s) : (d.finalText = Dt,
                    et = d.finalText.length,
                    kt = !1)
                }
            ft = -_t,
            pt = 0;
            var Ft = 0, Kt;
            for ($ = 0; $ < et; $ += 1)
                if (tt = !1,
                Kt = d.finalText[$],
                Pt = Kt.charCodeAt(0),
                Pt === 13 || Pt === 3 ? (Ft = 0,
                dt.push(ft),
                ht = ft > ht ? ft : ht,
                ft = -2 * _t,
                nt = "",
                tt = !0,
                st += 1) : nt = Kt,
                g.chars ? (ut = g.getCharData(Kt, ct.fStyle, g.getFontByName(d.f).fFamily),
                pt = tt ? 0 : ut.w * d.finalSize / 100) : pt = g.measureText(nt, d.f, d.finalSize),
                Kt === " " ? Ft += pt + _t : (ft += pt + _t + Ft,
                Ft = 0),
                _.push({
                    l: pt,
                    an: pt,
                    add: ot,
                    n: tt,
                    anIndexes: [],
                    val: nt,
                    line: st,
                    animatorJustifyOffset: 0
                }),
                it == 2) {
                    if (ot += pt,
                    nt === "" || nt === " " || $ === et - 1) {
                        for ((nt === "" || nt === " ") && (ot -= pt); at <= $; )
                            _[at].an = ot,
                            _[at].ind = rt,
                            _[at].extra = pt,
                            at += 1;
                        rt += 1,
                        ot = 0
                    }
                } else if (it == 3) {
                    if (ot += pt,
                    nt === "" || $ === et - 1) {
                        for (nt === "" && (ot -= pt); at <= $; )
                            _[at].an = ot,
                            _[at].ind = rt,
                            _[at].extra = pt,
                            at += 1;
                        ot = 0,
                        rt += 1
                    }
                } else
                    _[rt].ind = rt,
                    _[rt].extra = 0,
                    rt += 1;
            if (d.l = _,
            ht = ft > ht ? ft : ht,
            dt.push(ft),
            d.sz)
                d.boxWidth = d.sz[0],
                d.justifyOffset = 0;
            else
                switch (d.boxWidth = ht,
                d.j) {
                case 1:
                    d.justifyOffset = -d.boxWidth;
                    break;
                case 2:
                    d.justifyOffset = -d.boxWidth / 2;
                    break;
                default:
                    d.justifyOffset = 0
                }
            d.lineWidths = dt;
            var Rt = b.a, qt, Et;
            lt = Rt.length;
            var St, Lt, Mt = [];
            for (xt = 0; xt < lt; xt += 1) {
                for (qt = Rt[xt],
                qt.a.sc && (d.strokeColorAnim = !0),
                qt.a.sw && (d.strokeWidthAnim = !0),
                (qt.a.fc || qt.a.fh || qt.a.fs || qt.a.fb) && (d.fillColorAnim = !0),
                Lt = 0,
                St = qt.s.b,
                $ = 0; $ < et; $ += 1)
                    Et = _[$],
                    Et.anIndexes[xt] = Lt,
                    (St == 1 && Et.val !== "" || St == 2 && Et.val !== "" && Et.val !== " " || St == 3 && (Et.n || Et.val == " " || $ == et - 1) || St == 4 && (Et.n || $ == et - 1)) && (qt.s.rn === 1 && Mt.push(Lt),
                    Lt += 1);
                b.a[xt].s.totalChars = Lt;
                var ar = -1, wr;
                if (qt.s.rn === 1)
                    for ($ = 0; $ < et; $ += 1)
                        Et = _[$],
                        ar != Et.anIndexes[xt] && (ar = Et.anIndexes[xt],
                        wr = Mt.splice(Math.floor(Math.random() * Mt.length), 1)[0]),
                        Et.anIndexes[xt] = wr
            }
            d.yOffset = d.finalLineHeight || d.finalSize * 1.2,
            d.ls = d.ls || 0,
            d.ascent = ct.ascent * d.finalSize / 100
        }
        ,
        TextProperty.prototype.updateDocumentData = function(d, g) {
            g = g === void 0 ? this.keysIndex : g;
            var b = this.copyData({}, this.data.d.k[g].s);
            b = this.copyData(b, d),
            this.data.d.k[g].s = b,
            this.recalculate(g),
            this.setCurrentData(b),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.recalculate = function(d) {
            var g = this.data.d.k[d].s;
            g.__complete = !1,
            this.keysIndex = 0,
            this._isFirstFrame = !0,
            this.getValue(g)
        }
        ,
        TextProperty.prototype.canResizeFont = function(d) {
            this.canResize = d,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ,
        TextProperty.prototype.setMinimumFontSize = function(d) {
            this.minimumFontSize = Math.floor(d) || 1,
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }
        ;
        var TextSelectorProp = function() {
            var d = Math.max
              , g = Math.min
              , b = Math.floor;
            function _(et, tt) {
                this._currentTextLength = -1,
                this.k = !1,
                this.data = tt,
                this.elem = et,
                this.comp = et.comp,
                this.finalS = 0,
                this.finalE = 0,
                this.initDynamicPropertyContainer(et),
                this.s = PropertyFactory.getProp(et, tt.s || {
                    k: 0
                }, 0, 0, this),
                "e"in tt ? this.e = PropertyFactory.getProp(et, tt.e, 0, 0, this) : this.e = {
                    v: 100
                },
                this.o = PropertyFactory.getProp(et, tt.o || {
                    k: 0
                }, 0, 0, this),
                this.xe = PropertyFactory.getProp(et, tt.xe || {
                    k: 0
                }, 0, 0, this),
                this.ne = PropertyFactory.getProp(et, tt.ne || {
                    k: 0
                }, 0, 0, this),
                this.sm = PropertyFactory.getProp(et, tt.sm || {
                    k: 100
                }, 0, 0, this),
                this.a = PropertyFactory.getProp(et, tt.a, 0, .01, this),
                this.dynamicProperties.length || this.getValue()
            }
            _.prototype = {
                getMult: function(tt) {
                    this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
                    var rt = 0
                      , nt = 0
                      , it = 1
                      , ot = 1;
                    this.ne.v > 0 ? rt = this.ne.v / 100 : nt = -this.ne.v / 100,
                    this.xe.v > 0 ? it = 1 - this.xe.v / 100 : ot = 1 + this.xe.v / 100;
                    var at = BezierFactory.getBezierEasing(rt, nt, it, ot).get
                      , st = 0
                      , dt = this.finalS
                      , ft = this.finalE
                      , ht = this.data.sh;
                    if (ht === 2)
                        ft === dt ? st = tt >= ft ? 1 : 0 : st = d(0, g(.5 / (ft - dt) + (tt - dt) / (ft - dt), 1)),
                        st = at(st);
                    else if (ht === 3)
                        ft === dt ? st = tt >= ft ? 0 : 1 : st = 1 - d(0, g(.5 / (ft - dt) + (tt - dt) / (ft - dt), 1)),
                        st = at(st);
                    else if (ht === 4)
                        ft === dt ? st = 0 : (st = d(0, g(.5 / (ft - dt) + (tt - dt) / (ft - dt), 1)),
                        st < .5 ? st *= 2 : st = 1 - 2 * (st - .5)),
                        st = at(st);
                    else if (ht === 5) {
                        if (ft === dt)
                            st = 0;
                        else {
                            var xt = ft - dt;
                            tt = g(d(0, tt + .5 - dt), ft - dt);
                            var lt = -xt / 2 + tt
                              , ct = xt / 2;
                            st = Math.sqrt(1 - lt * lt / (ct * ct))
                        }
                        st = at(st)
                    } else
                        ht === 6 ? (ft === dt ? st = 0 : (tt = g(d(0, tt + .5 - dt), ft - dt),
                        st = (1 + Math.cos(Math.PI + Math.PI * 2 * tt / (ft - dt))) / 2),
                        st = at(st)) : (tt >= b(dt) && (tt - dt < 0 ? st = d(0, g(g(ft, 1) - (dt - tt), 1)) : st = d(0, g(ft - tt, 1))),
                        st = at(st));
                    if (this.sm.v !== 100) {
                        var ut = this.sm.v * .01;
                        ut === 0 && (ut = 1e-8);
                        var pt = .5 - ut * .5;
                        st < pt ? st = 0 : (st = (st - pt) / ut,
                        st > 1 && (st = 1))
                    }
                    return st * this.a.v
                },
                getValue: function(tt) {
                    this.iterateDynamicProperties(),
                    this._mdf = tt || this._mdf,
                    this._currentTextLength = this.elem.textProperty.currentData.l.length || 0,
                    tt && this.data.r === 2 && (this.e.v = this._currentTextLength);
                    var rt = this.data.r === 2 ? 1 : 100 / this.data.totalChars
                      , nt = this.o.v / rt
                      , it = this.s.v / rt + nt
                      , ot = this.e.v / rt + nt;
                    if (it > ot) {
                        var at = it;
                        it = ot,
                        ot = at
                    }
                    this.finalS = it,
                    this.finalE = ot
                }
            },
            extendPrototype([DynamicPropertyContainer], _);
            function $(et, tt, rt) {
                return new _(et,tt)
            }
            return {
                getTextSelectorProp: $
            }
        }();
        function TextAnimatorDataProperty(d, g, b) {
            var _ = {
                propType: !1
            }
              , $ = PropertyFactory.getProp
              , et = g.a;
            this.a = {
                r: et.r ? $(d, et.r, 0, degToRads, b) : _,
                rx: et.rx ? $(d, et.rx, 0, degToRads, b) : _,
                ry: et.ry ? $(d, et.ry, 0, degToRads, b) : _,
                sk: et.sk ? $(d, et.sk, 0, degToRads, b) : _,
                sa: et.sa ? $(d, et.sa, 0, degToRads, b) : _,
                s: et.s ? $(d, et.s, 1, .01, b) : _,
                a: et.a ? $(d, et.a, 1, 0, b) : _,
                o: et.o ? $(d, et.o, 0, .01, b) : _,
                p: et.p ? $(d, et.p, 1, 0, b) : _,
                sw: et.sw ? $(d, et.sw, 0, 0, b) : _,
                sc: et.sc ? $(d, et.sc, 1, 0, b) : _,
                fc: et.fc ? $(d, et.fc, 1, 0, b) : _,
                fh: et.fh ? $(d, et.fh, 0, 0, b) : _,
                fs: et.fs ? $(d, et.fs, 0, .01, b) : _,
                fb: et.fb ? $(d, et.fb, 0, .01, b) : _,
                t: et.t ? $(d, et.t, 0, 0, b) : _
            },
            this.s = TextSelectorProp.getTextSelectorProp(d, g.s, b),
            this.s.t = g.s.t
        }
        function TextAnimatorProperty(d, g, b) {
            this._isFirstFrame = !0,
            this._hasMaskedPath = !1,
            this._frameId = -1,
            this._textData = d,
            this._renderType = g,
            this._elem = b,
            this._animatorsData = createSizedArray(this._textData.a.length),
            this._pathData = {},
            this._moreOptions = {
                alignment: {}
            },
            this.renderedLetters = [],
            this.lettersChangedFlag = !1,
            this.initDynamicPropertyContainer(b)
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
            var d, g = this._textData.a.length, b, _ = PropertyFactory.getProp;
            for (d = 0; d < g; d += 1)
                b = this._textData.a[d],
                this._animatorsData[d] = new TextAnimatorDataProperty(this._elem,b,this);
            this._textData.p && "m"in this._textData.p ? (this._pathData = {
                a: _(this._elem, this._textData.p.a, 0, 0, this),
                f: _(this._elem, this._textData.p.f, 0, 0, this),
                l: _(this._elem, this._textData.p.l, 0, 0, this),
                r: _(this._elem, this._textData.p.r, 0, 0, this),
                p: _(this._elem, this._textData.p.p, 0, 0, this),
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            },
            this._hasMaskedPath = !0) : this._hasMaskedPath = !1,
            this._moreOptions.alignment = _(this._elem, this._textData.m.a, 1, 0, this)
        }
        ,
        TextAnimatorProperty.prototype.getMeasures = function(d, g) {
            if (this.lettersChangedFlag = g,
            !(!this._mdf && !this._isFirstFrame && !g && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
                this._isFirstFrame = !1;
                var b = this._moreOptions.alignment.v, _ = this._animatorsData, $ = this._textData, et = this.mHelper, tt = this._renderType, rt = this.renderedLetters.length, nt, it, ot, at, st = d.l, dt, ft, ht, xt, lt, ct, ut, pt, vt, _t, Pt, kt, $t, Wt, Ht;
                if (this._hasMaskedPath) {
                    if (Ht = this._pathData.m,
                    !this._pathData.n || this._pathData._mdf) {
                        var Dt = Ht.v;
                        this._pathData.r.v && (Dt = Dt.reverse()),
                        dt = {
                            tLength: 0,
                            segments: []
                        },
                        at = Dt._length - 1;
                        var Vt;
                        for (kt = 0,
                        ot = 0; ot < at; ot += 1)
                            Vt = bez.buildBezierData(Dt.v[ot], Dt.v[ot + 1], [Dt.o[ot][0] - Dt.v[ot][0], Dt.o[ot][1] - Dt.v[ot][1]], [Dt.i[ot + 1][0] - Dt.v[ot + 1][0], Dt.i[ot + 1][1] - Dt.v[ot + 1][1]]),
                            dt.tLength += Vt.segmentLength,
                            dt.segments.push(Vt),
                            kt += Vt.segmentLength;
                        ot = at,
                        Ht.v.c && (Vt = bez.buildBezierData(Dt.v[ot], Dt.v[0], [Dt.o[ot][0] - Dt.v[ot][0], Dt.o[ot][1] - Dt.v[ot][1]], [Dt.i[0][0] - Dt.v[0][0], Dt.i[0][1] - Dt.v[0][1]]),
                        dt.tLength += Vt.segmentLength,
                        dt.segments.push(Vt),
                        kt += Vt.segmentLength),
                        this._pathData.pi = dt
                    }
                    if (dt = this._pathData.pi,
                    ft = this._pathData.f.v,
                    ut = 0,
                    ct = 1,
                    xt = 0,
                    lt = !0,
                    _t = dt.segments,
                    ft < 0 && Ht.v.c)
                        for (dt.tLength < Math.abs(ft) && (ft = -Math.abs(ft) % dt.tLength),
                        ut = _t.length - 1,
                        vt = _t[ut].points,
                        ct = vt.length - 1; ft < 0; )
                            ft += vt[ct].partialLength,
                            ct -= 1,
                            ct < 0 && (ut -= 1,
                            vt = _t[ut].points,
                            ct = vt.length - 1);
                    vt = _t[ut].points,
                    pt = vt[ct - 1],
                    ht = vt[ct],
                    Pt = ht.partialLength
                }
                at = st.length,
                nt = 0,
                it = 0;
                var Ft = d.finalSize * 1.2 * .714, Kt = !0, Rt, qt, Et, St, Lt;
                St = _.length;
                var Mt, ar = -1, wr, Tr, Pr, kr = ft, jr = ut, cr = ct, dr = -1, lr, ir, gr, Cr, hr, zr, Zr, ln, Gr = "", vn = this.defaultPropsArray, fn;
                if (d.j === 2 || d.j === 1) {
                    var Rn = 0
                      , bn = 0
                      , Un = d.j === 2 ? -.5 : -1
                      , zn = 0
                      , er = !0;
                    for (ot = 0; ot < at; ot += 1)
                        if (st[ot].n) {
                            for (Rn && (Rn += bn); zn < ot; )
                                st[zn].animatorJustifyOffset = Rn,
                                zn += 1;
                            Rn = 0,
                            er = !0
                        } else {
                            for (Et = 0; Et < St; Et += 1)
                                Rt = _[Et].a,
                                Rt.t.propType && (er && d.j === 2 && (bn += Rt.t.v * Un),
                                qt = _[Et].s,
                                Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                                Mt.length ? Rn += Rt.t.v * Mt[0] * Un : Rn += Rt.t.v * Mt * Un);
                            er = !1
                        }
                    for (Rn && (Rn += bn); zn < ot; )
                        st[zn].animatorJustifyOffset = Rn,
                        zn += 1
                }
                for (ot = 0; ot < at; ot += 1) {
                    if (et.reset(),
                    lr = 1,
                    st[ot].n)
                        nt = 0,
                        it += d.yOffset,
                        it += Kt ? 1 : 0,
                        ft = kr,
                        Kt = !1,
                        this._hasMaskedPath && (ut = jr,
                        ct = cr,
                        vt = _t[ut].points,
                        pt = vt[ct - 1],
                        ht = vt[ct],
                        Pt = ht.partialLength,
                        xt = 0),
                        Gr = "",
                        ln = "",
                        zr = "",
                        fn = "",
                        vn = this.defaultPropsArray;
                    else {
                        if (this._hasMaskedPath) {
                            if (dr !== st[ot].line) {
                                switch (d.j) {
                                case 1:
                                    ft += kt - d.lineWidths[st[ot].line];
                                    break;
                                case 2:
                                    ft += (kt - d.lineWidths[st[ot].line]) / 2;
                                    break
                                }
                                dr = st[ot].line
                            }
                            ar !== st[ot].ind && (st[ar] && (ft += st[ar].extra),
                            ft += st[ot].an / 2,
                            ar = st[ot].ind),
                            ft += b[0] * st[ot].an * .005;
                            var Ut = 0;
                            for (Et = 0; Et < St; Et += 1)
                                Rt = _[Et].a,
                                Rt.p.propType && (qt = _[Et].s,
                                Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                                Mt.length ? Ut += Rt.p.v[0] * Mt[0] : Ut += Rt.p.v[0] * Mt),
                                Rt.a.propType && (qt = _[Et].s,
                                Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                                Mt.length ? Ut += Rt.a.v[0] * Mt[0] : Ut += Rt.a.v[0] * Mt);
                            for (lt = !0,
                            this._pathData.a.v && (ft = st[0].an * .5 + (kt - this._pathData.f.v - st[0].an * .5 - st[st.length - 1].an * .5) * ar / (at - 1),
                            ft += this._pathData.f.v); lt; )
                                xt + Pt >= ft + Ut || !vt ? ($t = (ft + Ut - xt) / ht.partialLength,
                                Tr = pt.point[0] + (ht.point[0] - pt.point[0]) * $t,
                                Pr = pt.point[1] + (ht.point[1] - pt.point[1]) * $t,
                                et.translate(-b[0] * st[ot].an * .005, -(b[1] * Ft) * .01),
                                lt = !1) : vt && (xt += ht.partialLength,
                                ct += 1,
                                ct >= vt.length && (ct = 0,
                                ut += 1,
                                _t[ut] ? vt = _t[ut].points : Ht.v.c ? (ct = 0,
                                ut = 0,
                                vt = _t[ut].points) : (xt -= ht.partialLength,
                                vt = null)),
                                vt && (pt = ht,
                                ht = vt[ct],
                                Pt = ht.partialLength));
                            wr = st[ot].an / 2 - st[ot].add,
                            et.translate(-wr, 0, 0)
                        } else
                            wr = st[ot].an / 2 - st[ot].add,
                            et.translate(-wr, 0, 0),
                            et.translate(-b[0] * st[ot].an * .005, -b[1] * Ft * .01, 0);
                        for (Et = 0; Et < St; Et += 1)
                            Rt = _[Et].a,
                            Rt.t.propType && (qt = _[Et].s,
                            Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                            (nt !== 0 || d.j !== 0) && (this._hasMaskedPath ? Mt.length ? ft += Rt.t.v * Mt[0] : ft += Rt.t.v * Mt : Mt.length ? nt += Rt.t.v * Mt[0] : nt += Rt.t.v * Mt));
                        for (d.strokeWidthAnim && (gr = d.sw || 0),
                        d.strokeColorAnim && (d.sc ? ir = [d.sc[0], d.sc[1], d.sc[2]] : ir = [0, 0, 0]),
                        d.fillColorAnim && d.fc && (Cr = [d.fc[0], d.fc[1], d.fc[2]]),
                        Et = 0; Et < St; Et += 1)
                            Rt = _[Et].a,
                            Rt.a.propType && (qt = _[Et].s,
                            Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                            Mt.length ? et.translate(-Rt.a.v[0] * Mt[0], -Rt.a.v[1] * Mt[1], Rt.a.v[2] * Mt[2]) : et.translate(-Rt.a.v[0] * Mt, -Rt.a.v[1] * Mt, Rt.a.v[2] * Mt));
                        for (Et = 0; Et < St; Et += 1)
                            Rt = _[Et].a,
                            Rt.s.propType && (qt = _[Et].s,
                            Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                            Mt.length ? et.scale(1 + (Rt.s.v[0] - 1) * Mt[0], 1 + (Rt.s.v[1] - 1) * Mt[1], 1) : et.scale(1 + (Rt.s.v[0] - 1) * Mt, 1 + (Rt.s.v[1] - 1) * Mt, 1));
                        for (Et = 0; Et < St; Et += 1) {
                            if (Rt = _[Et].a,
                            qt = _[Et].s,
                            Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                            Rt.sk.propType && (Mt.length ? et.skewFromAxis(-Rt.sk.v * Mt[0], Rt.sa.v * Mt[1]) : et.skewFromAxis(-Rt.sk.v * Mt, Rt.sa.v * Mt)),
                            Rt.r.propType && (Mt.length ? et.rotateZ(-Rt.r.v * Mt[2]) : et.rotateZ(-Rt.r.v * Mt)),
                            Rt.ry.propType && (Mt.length ? et.rotateY(Rt.ry.v * Mt[1]) : et.rotateY(Rt.ry.v * Mt)),
                            Rt.rx.propType && (Mt.length ? et.rotateX(Rt.rx.v * Mt[0]) : et.rotateX(Rt.rx.v * Mt)),
                            Rt.o.propType && (Mt.length ? lr += (Rt.o.v * Mt[0] - lr) * Mt[0] : lr += (Rt.o.v * Mt - lr) * Mt),
                            d.strokeWidthAnim && Rt.sw.propType && (Mt.length ? gr += Rt.sw.v * Mt[0] : gr += Rt.sw.v * Mt),
                            d.strokeColorAnim && Rt.sc.propType)
                                for (hr = 0; hr < 3; hr += 1)
                                    Mt.length ? ir[hr] += (Rt.sc.v[hr] - ir[hr]) * Mt[0] : ir[hr] += (Rt.sc.v[hr] - ir[hr]) * Mt;
                            if (d.fillColorAnim && d.fc) {
                                if (Rt.fc.propType)
                                    for (hr = 0; hr < 3; hr += 1)
                                        Mt.length ? Cr[hr] += (Rt.fc.v[hr] - Cr[hr]) * Mt[0] : Cr[hr] += (Rt.fc.v[hr] - Cr[hr]) * Mt;
                                Rt.fh.propType && (Mt.length ? Cr = addHueToRGB(Cr, Rt.fh.v * Mt[0]) : Cr = addHueToRGB(Cr, Rt.fh.v * Mt)),
                                Rt.fs.propType && (Mt.length ? Cr = addSaturationToRGB(Cr, Rt.fs.v * Mt[0]) : Cr = addSaturationToRGB(Cr, Rt.fs.v * Mt)),
                                Rt.fb.propType && (Mt.length ? Cr = addBrightnessToRGB(Cr, Rt.fb.v * Mt[0]) : Cr = addBrightnessToRGB(Cr, Rt.fb.v * Mt))
                            }
                        }
                        for (Et = 0; Et < St; Et += 1)
                            Rt = _[Et].a,
                            Rt.p.propType && (qt = _[Et].s,
                            Mt = qt.getMult(st[ot].anIndexes[Et], $.a[Et].s.totalChars),
                            this._hasMaskedPath ? Mt.length ? et.translate(0, Rt.p.v[1] * Mt[0], -Rt.p.v[2] * Mt[1]) : et.translate(0, Rt.p.v[1] * Mt, -Rt.p.v[2] * Mt) : Mt.length ? et.translate(Rt.p.v[0] * Mt[0], Rt.p.v[1] * Mt[1], -Rt.p.v[2] * Mt[2]) : et.translate(Rt.p.v[0] * Mt, Rt.p.v[1] * Mt, -Rt.p.v[2] * Mt));
                        if (d.strokeWidthAnim && (zr = gr < 0 ? 0 : gr),
                        d.strokeColorAnim && (Zr = "rgb(" + Math.round(ir[0] * 255) + "," + Math.round(ir[1] * 255) + "," + Math.round(ir[2] * 255) + ")"),
                        d.fillColorAnim && d.fc && (ln = "rgb(" + Math.round(Cr[0] * 255) + "," + Math.round(Cr[1] * 255) + "," + Math.round(Cr[2] * 255) + ")"),
                        this._hasMaskedPath) {
                            if (et.translate(0, -d.ls),
                            et.translate(0, b[1] * Ft * .01 + it, 0),
                            this._pathData.p.v) {
                                Wt = (ht.point[1] - pt.point[1]) / (ht.point[0] - pt.point[0]);
                                var Ct = Math.atan(Wt) * 180 / Math.PI;
                                ht.point[0] < pt.point[0] && (Ct += 180),
                                et.rotate(-Ct * Math.PI / 180)
                            }
                            et.translate(Tr, Pr, 0),
                            ft -= b[0] * st[ot].an * .005,
                            st[ot + 1] && ar !== st[ot + 1].ind && (ft += st[ot].an / 2,
                            ft += d.tr * .001 * d.finalSize)
                        } else {
                            switch (et.translate(nt, it, 0),
                            d.ps && et.translate(d.ps[0], d.ps[1] + d.ascent, 0),
                            d.j) {
                            case 1:
                                et.translate(st[ot].animatorJustifyOffset + d.justifyOffset + (d.boxWidth - d.lineWidths[st[ot].line]), 0, 0);
                                break;
                            case 2:
                                et.translate(st[ot].animatorJustifyOffset + d.justifyOffset + (d.boxWidth - d.lineWidths[st[ot].line]) / 2, 0, 0);
                                break
                            }
                            et.translate(0, -d.ls),
                            et.translate(wr, 0, 0),
                            et.translate(b[0] * st[ot].an * .005, b[1] * Ft * .01, 0),
                            nt += st[ot].l + d.tr * .001 * d.finalSize
                        }
                        tt === "html" ? Gr = et.toCSS() : tt === "svg" ? Gr = et.to2dCSS() : vn = [et.props[0], et.props[1], et.props[2], et.props[3], et.props[4], et.props[5], et.props[6], et.props[7], et.props[8], et.props[9], et.props[10], et.props[11], et.props[12], et.props[13], et.props[14], et.props[15]],
                        fn = lr
                    }
                    rt <= ot ? (Lt = new LetterProps(fn,zr,Zr,ln,Gr,vn),
                    this.renderedLetters.push(Lt),
                    rt += 1,
                    this.lettersChangedFlag = !0) : (Lt = this.renderedLetters[ot],
                    this.lettersChangedFlag = Lt.update(fn, zr, Zr, ln, Gr, vn) || this.lettersChangedFlag)
                }
            }
        }
        ,
        TextAnimatorProperty.prototype.getValue = function() {
            this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId,
            this.iterateDynamicProperties())
        }
        ,
        TextAnimatorProperty.prototype.mHelper = new Matrix,
        TextAnimatorProperty.prototype.defaultPropsArray = [],
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function ITextElement() {}
        ITextElement.prototype.initElement = function(d, g, b) {
            this.lettersChangedFlag = !0,
            this.initFrame(),
            this.initBaseData(d, g, b),
            this.textProperty = new TextProperty(this,d.t,this.dynamicProperties),
            this.textAnimator = new TextAnimatorProperty(d.t,this.renderType,this),
            this.initTransform(d, g, b),
            this.initHierarchy(),
            this.initRenderable(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            this.createContent(),
            this.hide(),
            this.textAnimator.searchProperties(this.dynamicProperties)
        }
        ,
        ITextElement.prototype.prepareFrame = function(d) {
            this._mdf = !1,
            this.prepareRenderableFrame(d),
            this.prepareProperties(d, this.isInRange)
        }
        ,
        ITextElement.prototype.createPathShape = function(d, g) {
            var b, _ = g.length, $, et = "";
            for (b = 0; b < _; b += 1)
                g[b].ty === "sh" && ($ = g[b].ks.k,
                et += buildShapeString($, $.i.length, !0, d));
            return et
        }
        ,
        ITextElement.prototype.updateDocumentData = function(d, g) {
            this.textProperty.updateDocumentData(d, g)
        }
        ,
        ITextElement.prototype.canResizeFont = function(d) {
            this.textProperty.canResizeFont(d)
        }
        ,
        ITextElement.prototype.setMinimumFontSize = function(d) {
            this.textProperty.setMinimumFontSize(d)
        }
        ,
        ITextElement.prototype.applyTextPropertiesToMatrix = function(d, g, b, _, $) {
            switch (d.ps && g.translate(d.ps[0], d.ps[1] + d.ascent, 0),
            g.translate(0, -d.ls, 0),
            d.j) {
            case 1:
                g.translate(d.justifyOffset + (d.boxWidth - d.lineWidths[b]), 0, 0);
                break;
            case 2:
                g.translate(d.justifyOffset + (d.boxWidth - d.lineWidths[b]) / 2, 0, 0);
                break
            }
            g.translate(_, $, 0)
        }
        ,
        ITextElement.prototype.buildColor = function(d) {
            return "rgb(" + Math.round(d[0] * 255) + "," + Math.round(d[1] * 255) + "," + Math.round(d[2] * 255) + ")"
        }
        ,
        ITextElement.prototype.emptyProp = new LetterProps,
        ITextElement.prototype.destroy = function() {}
        ,
        ITextElement.prototype.validateText = function() {
            (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(),
            this.textProperty._isFirstFrame = !1,
            this.textProperty._mdf = !1)
        }
        ;
        var emptyShapeData = {
            shapes: []
        };
        function SVGTextLottieElement(d, g, b) {
            this.textSpans = [],
            this.renderType = "svg",
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement),
        SVGTextLottieElement.prototype.createContent = function() {
            this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"))
        }
        ,
        SVGTextLottieElement.prototype.buildTextContents = function(d) {
            for (var g = 0, b = d.length, _ = [], $ = ""; g < b; )
                d[g] === String.fromCharCode(13) || d[g] === String.fromCharCode(3) ? (_.push($),
                $ = "") : $ += d[g],
                g += 1;
            return _.push($),
            _
        }
        ,
        SVGTextLottieElement.prototype.buildShapeData = function(d, g) {
            if (d.shapes && d.shapes.length) {
                var b = d.shapes[0];
                if (b.it) {
                    var _ = b.it[b.it.length - 1];
                    _.s && (_.s.k[0] = g,
                    _.s.k[1] = g)
                }
            }
            return d
        }
        ,
        SVGTextLottieElement.prototype.buildNewText = function() {
            this.addDynamicProperty(this);
            var d, g, b = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(b ? b.l.length : 0),
            b.fc ? this.layerElement.setAttribute("fill", this.buildColor(b.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            b.sc && (this.layerElement.setAttribute("stroke", this.buildColor(b.sc)),
            this.layerElement.setAttribute("stroke-width", b.sw)),
            this.layerElement.setAttribute("font-size", b.finalSize);
            var _ = this.globalData.fontManager.getFontByName(b.f);
            if (_.fClass)
                this.layerElement.setAttribute("class", _.fClass);
            else {
                this.layerElement.setAttribute("font-family", _.fFamily);
                var $ = b.fWeight
                  , et = b.fStyle;
                this.layerElement.setAttribute("font-style", et),
                this.layerElement.setAttribute("font-weight", $)
            }
            this.layerElement.setAttribute("aria-label", b.t);
            var tt = b.l || []
              , rt = !!this.globalData.fontManager.chars;
            g = tt.length;
            var nt, it = this.mHelper, ot = "", at = this.data.singleShape, st = 0, dt = 0, ft = !0, ht = b.tr * .001 * b.finalSize;
            if (at && !rt && !b.sz) {
                var xt = this.textContainer
                  , lt = "start";
                switch (b.j) {
                case 1:
                    lt = "end";
                    break;
                case 2:
                    lt = "middle";
                    break;
                default:
                    lt = "start";
                    break
                }
                xt.setAttribute("text-anchor", lt),
                xt.setAttribute("letter-spacing", ht);
                var ct = this.buildTextContents(b.finalText);
                for (g = ct.length,
                dt = b.ps ? b.ps[1] + b.ascent : 0,
                d = 0; d < g; d += 1)
                    nt = this.textSpans[d].span || createNS("tspan"),
                    nt.textContent = ct[d],
                    nt.setAttribute("x", 0),
                    nt.setAttribute("y", dt),
                    nt.style.display = "inherit",
                    xt.appendChild(nt),
                    this.textSpans[d] || (this.textSpans[d] = {
                        span: null,
                        glyph: null
                    }),
                    this.textSpans[d].span = nt,
                    dt += b.finalLineHeight;
                this.layerElement.appendChild(xt)
            } else {
                var ut = this.textSpans.length, pt;
                for (d = 0; d < g; d += 1) {
                    if (this.textSpans[d] || (this.textSpans[d] = {
                        span: null,
                        childSpan: null,
                        glyph: null
                    }),
                    !rt || !at || d === 0) {
                        if (nt = ut > d ? this.textSpans[d].span : createNS(rt ? "g" : "text"),
                        ut <= d) {
                            if (nt.setAttribute("stroke-linecap", "butt"),
                            nt.setAttribute("stroke-linejoin", "round"),
                            nt.setAttribute("stroke-miterlimit", "4"),
                            this.textSpans[d].span = nt,
                            rt) {
                                var vt = createNS("g");
                                nt.appendChild(vt),
                                this.textSpans[d].childSpan = vt
                            }
                            this.textSpans[d].span = nt,
                            this.layerElement.appendChild(nt)
                        }
                        nt.style.display = "inherit"
                    }
                    if (it.reset(),
                    at && (tt[d].n && (st = -ht,
                    dt += b.yOffset,
                    dt += ft ? 1 : 0,
                    ft = !1),
                    this.applyTextPropertiesToMatrix(b, it, tt[d].line, st, dt),
                    st += tt[d].l || 0,
                    st += ht),
                    rt) {
                        pt = this.globalData.fontManager.getCharData(b.finalText[d], _.fStyle, this.globalData.fontManager.getFontByName(b.f).fFamily);
                        var _t;
                        if (pt.t === 1)
                            _t = new SVGCompElement(pt.data,this.globalData,this);
                        else {
                            var Pt = emptyShapeData;
                            pt.data && pt.data.shapes && (Pt = this.buildShapeData(pt.data, b.finalSize)),
                            _t = new SVGShapeElement(Pt,this.globalData,this)
                        }
                        if (this.textSpans[d].glyph) {
                            var kt = this.textSpans[d].glyph;
                            this.textSpans[d].childSpan.removeChild(kt.layerElement),
                            kt.destroy()
                        }
                        this.textSpans[d].glyph = _t,
                        _t._debug = !0,
                        _t.prepareFrame(0),
                        _t.renderFrame(),
                        this.textSpans[d].childSpan.appendChild(_t.layerElement),
                        pt.t === 1 && this.textSpans[d].childSpan.setAttribute("transform", "scale(" + b.finalSize / 100 + "," + b.finalSize / 100 + ")")
                    } else
                        at && nt.setAttribute("transform", "translate(" + it.props[12] + "," + it.props[13] + ")"),
                        nt.textContent = tt[d].val,
                        nt.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve")
                }
                at && nt && nt.setAttribute("d", ot)
            }
            for (; d < this.textSpans.length; )
                this.textSpans[d].span.style.display = "none",
                d += 1;
            this._sizeChanged = !0
        }
        ,
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
            if (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged) {
                this._sizeChanged = !1;
                var d = this.layerElement.getBBox();
                this.bbox = {
                    top: d.y,
                    left: d.x,
                    width: d.width,
                    height: d.height
                }
            }
            return this.bbox
        }
        ,
        SVGTextLottieElement.prototype.getValue = function() {
            var d, g = this.textSpans.length, b;
            for (this.renderedFrame = this.comp.renderedFrame,
            d = 0; d < g; d += 1)
                b = this.textSpans[d].glyph,
                b && (b.prepareFrame(this.comp.renderedFrame - this.data.st),
                b._mdf && (this._mdf = !0))
        }
        ,
        SVGTextLottieElement.prototype.renderInnerContent = function() {
            if (this.validateText(),
            (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
                this._sizeChanged = !0;
                var d, g, b = this.textAnimator.renderedLetters, _ = this.textProperty.currentData.l;
                g = _.length;
                var $, et, tt;
                for (d = 0; d < g; d += 1)
                    _[d].n || ($ = b[d],
                    et = this.textSpans[d].span,
                    tt = this.textSpans[d].glyph,
                    tt && tt.renderFrame(),
                    $._mdf.m && et.setAttribute("transform", $.m),
                    $._mdf.o && et.setAttribute("opacity", $.o),
                    $._mdf.sw && et.setAttribute("stroke-width", $.sw),
                    $._mdf.sc && et.setAttribute("stroke", $.sc),
                    $._mdf.fc && et.setAttribute("fill", $.fc))
            }
        }
        ;
        function ISolidElement(d, g, b) {
            this.initElement(d, g, b)
        }
        extendPrototype([IImageElement], ISolidElement),
        ISolidElement.prototype.createContent = function() {
            var d = createNS("rect");
            d.setAttribute("width", this.data.sw),
            d.setAttribute("height", this.data.sh),
            d.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(d)
        }
        ;
        function NullElement(d, g, b) {
            this.initFrame(),
            this.initBaseData(d, g, b),
            this.initFrame(),
            this.initTransform(d, g, b),
            this.initHierarchy()
        }
        NullElement.prototype.prepareFrame = function(d) {
            this.prepareProperties(d, !0)
        }
        ,
        NullElement.prototype.renderFrame = function() {}
        ,
        NullElement.prototype.getBaseElement = function() {
            return null
        }
        ,
        NullElement.prototype.destroy = function() {}
        ,
        NullElement.prototype.sourceRectAtTime = function() {}
        ,
        NullElement.prototype.hide = function() {}
        ,
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGRendererBase() {}
        extendPrototype([BaseRenderer], SVGRendererBase),
        SVGRendererBase.prototype.createNull = function(d) {
            return new NullElement(d,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createShape = function(d) {
            return new SVGShapeElement(d,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createText = function(d) {
            return new SVGTextLottieElement(d,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createImage = function(d) {
            return new IImageElement(d,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.createSolid = function(d) {
            return new ISolidElement(d,this.globalData,this)
        }
        ,
        SVGRendererBase.prototype.configAnimation = function(d) {
            this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"),
            this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + d.w + " " + d.h),
            this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", d.w),
            this.svgElement.setAttribute("height", d.h),
            this.svgElement.style.width = "100%",
            this.svgElement.style.height = "100%",
            this.svgElement.style.transform = "translate3d(0,0,0)",
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility),
            this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className),
            this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable),
            this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio),
            this.animationItem.wrapper.appendChild(this.svgElement);
            var g = this.globalData.defs;
            this.setupGlobalData(d, g),
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.data = d;
            var b = createNS("clipPath")
              , _ = createNS("rect");
            _.setAttribute("width", d.w),
            _.setAttribute("height", d.h),
            _.setAttribute("x", 0),
            _.setAttribute("y", 0);
            var $ = createElementID();
            b.setAttribute("id", $),
            b.appendChild(_),
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + $ + ")"),
            g.appendChild(b),
            this.layers = d.layers,
            this.elements = createSizedArray(d.layers.length)
        }
        ,
        SVGRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.layerElement = null,
            this.globalData.defs = null;
            var d, g = this.layers ? this.layers.length : 0;
            for (d = 0; d < g; d += 1)
                this.elements[d] && this.elements[d].destroy && this.elements[d].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        SVGRendererBase.prototype.updateContainerSize = function() {}
        ,
        SVGRendererBase.prototype.findIndexByInd = function(d) {
            var g = 0
              , b = this.layers.length;
            for (g = 0; g < b; g += 1)
                if (this.layers[g].ind === d)
                    return g;
            return -1
        }
        ,
        SVGRendererBase.prototype.buildItem = function(d) {
            var g = this.elements;
            if (!(g[d] || this.layers[d].ty === 99)) {
                g[d] = !0;
                var b = this.createItem(this.layers[d]);
                if (g[d] = b,
                getExpressionsPlugin() && (this.layers[d].ty === 0 && this.globalData.projectInterface.registerComposition(b),
                b.initExpressions()),
                this.appendElementInPos(b, d),
                this.layers[d].tt) {
                    var _ = "tp"in this.layers[d] ? this.findIndexByInd(this.layers[d].tp) : d - 1;
                    if (_ === -1)
                        return;
                    if (!this.elements[_] || this.elements[_] === !0)
                        this.buildItem(_),
                        this.addPendingElement(b);
                    else {
                        var $ = g[_]
                          , et = $.getMatte(this.layers[d].tt);
                        b.setMatte(et)
                    }
                }
            }
        }
        ,
        SVGRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var d = this.pendingElements.pop();
                if (d.checkParenting(),
                d.data.tt)
                    for (var g = 0, b = this.elements.length; g < b; ) {
                        if (this.elements[g] === d) {
                            var _ = "tp"in d.data ? this.findIndexByInd(d.data.tp) : g - 1
                              , $ = this.elements[_]
                              , et = $.getMatte(this.layers[g].tt);
                            d.setMatte(et);
                            break
                        }
                        g += 1
                    }
            }
        }
        ,
        SVGRendererBase.prototype.renderFrame = function(d) {
            if (!(this.renderedFrame === d || this.destroyed)) {
                d === null ? d = this.renderedFrame : this.renderedFrame = d,
                this.globalData.frameNum = d,
                this.globalData.frameId += 1,
                this.globalData.projectInterface.currentFrame = d,
                this.globalData._mdf = !1;
                var g, b = this.layers.length;
                for (this.completeLayers || this.checkLayers(d),
                g = b - 1; g >= 0; g -= 1)
                    (this.completeLayers || this.elements[g]) && this.elements[g].prepareFrame(d - this.layers[g].st);
                if (this.globalData._mdf)
                    for (g = 0; g < b; g += 1)
                        (this.completeLayers || this.elements[g]) && this.elements[g].renderFrame()
            }
        }
        ,
        SVGRendererBase.prototype.appendElementInPos = function(d, g) {
            var b = d.getBaseElement();
            if (b) {
                for (var _ = 0, $; _ < g; )
                    this.elements[_] && this.elements[_] !== !0 && this.elements[_].getBaseElement() && ($ = this.elements[_].getBaseElement()),
                    _ += 1;
                $ ? this.layerElement.insertBefore(b, $) : this.layerElement.appendChild(b)
            }
        }
        ,
        SVGRendererBase.prototype.hide = function() {
            this.layerElement.style.display = "none"
        }
        ,
        SVGRendererBase.prototype.show = function() {
            this.layerElement.style.display = "block"
        }
        ;
        function ICompElement() {}
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement),
        ICompElement.prototype.initElement = function(d, g, b) {
            this.initFrame(),
            this.initBaseData(d, g, b),
            this.initTransform(d, g, b),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !g.progressiveLoad) && this.buildAllItems(),
            this.hide()
        }
        ,
        ICompElement.prototype.prepareFrame = function(d) {
            if (this._mdf = !1,
            this.prepareRenderableFrame(d),
            this.prepareProperties(d, this.isInRange),
            !(!this.isInRange && !this.data.xt)) {
                if (this.tm._placeholder)
                    this.renderedFrame = d / this.data.sr;
                else {
                    var g = this.tm.v;
                    g === this.data.op && (g = this.data.op - 1),
                    this.renderedFrame = g
                }
                var b, _ = this.elements.length;
                for (this.completeLayers || this.checkLayers(this.renderedFrame),
                b = _ - 1; b >= 0; b -= 1)
                    (this.completeLayers || this.elements[b]) && (this.elements[b].prepareFrame(this.renderedFrame - this.layers[b].st),
                    this.elements[b]._mdf && (this._mdf = !0))
            }
        }
        ,
        ICompElement.prototype.renderInnerContent = function() {
            var d, g = this.layers.length;
            for (d = 0; d < g; d += 1)
                (this.completeLayers || this.elements[d]) && this.elements[d].renderFrame()
        }
        ,
        ICompElement.prototype.setElements = function(d) {
            this.elements = d
        }
        ,
        ICompElement.prototype.getElements = function() {
            return this.elements
        }
        ,
        ICompElement.prototype.destroyElements = function() {
            var d, g = this.layers.length;
            for (d = 0; d < g; d += 1)
                this.elements[d] && this.elements[d].destroy()
        }
        ,
        ICompElement.prototype.destroy = function() {
            this.destroyElements(),
            this.destroyBaseElement()
        }
        ;
        function SVGCompElement(d, g, b) {
            this.layers = d.layers,
            this.supports3d = !0,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(d, g, b),
            this.tm = d.tm ? PropertyFactory.getProp(this, d.tm, 0, g.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement),
        SVGCompElement.prototype.createComp = function(d) {
            return new SVGCompElement(d,this.globalData,this)
        }
        ;
        function SVGRenderer(d, g) {
            this.animationItem = d,
            this.layers = null,
            this.renderedFrame = -1,
            this.svgElement = createNS("svg");
            var b = "";
            if (g && g.title) {
                var _ = createNS("title")
                  , $ = createElementID();
                _.setAttribute("id", $),
                _.textContent = g.title,
                this.svgElement.appendChild(_),
                b += $
            }
            if (g && g.description) {
                var et = createNS("desc")
                  , tt = createElementID();
                et.setAttribute("id", tt),
                et.textContent = g.description,
                this.svgElement.appendChild(et),
                b += " " + tt
            }
            b && this.svgElement.setAttribute("aria-labelledby", b);
            var rt = createNS("defs");
            this.svgElement.appendChild(rt);
            var nt = createNS("g");
            this.svgElement.appendChild(nt),
            this.layerElement = nt,
            this.renderConfig = {
                preserveAspectRatio: g && g.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: g && g.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: g && g.contentVisibility || "visible",
                progressiveLoad: g && g.progressiveLoad || !1,
                hideOnTransparent: !(g && g.hideOnTransparent === !1),
                viewBoxOnly: g && g.viewBoxOnly || !1,
                viewBoxSize: g && g.viewBoxSize || !1,
                className: g && g.className || "",
                id: g && g.id || "",
                focusable: g && g.focusable,
                filterSize: {
                    width: g && g.filterSize && g.filterSize.width || "100%",
                    height: g && g.filterSize && g.filterSize.height || "100%",
                    x: g && g.filterSize && g.filterSize.x || "0%",
                    y: g && g.filterSize && g.filterSize.y || "0%"
                },
                width: g && g.width,
                height: g && g.height,
                runExpressions: !g || g.runExpressions === void 0 || g.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                defs: rt,
                renderConfig: this.renderConfig
            },
            this.elements = [],
            this.pendingElements = [],
            this.destroyed = !1,
            this.rendererType = "svg"
        }
        extendPrototype([SVGRendererBase], SVGRenderer),
        SVGRenderer.prototype.createComp = function(d) {
            return new SVGCompElement(d,this.globalData,this)
        }
        ;
        function ShapeTransformManager() {
            this.sequences = {},
            this.sequenceList = [],
            this.transform_key_count = 0
        }
        ShapeTransformManager.prototype = {
            addTransformSequence: function(g) {
                var b, _ = g.length, $ = "_";
                for (b = 0; b < _; b += 1)
                    $ += g[b].transform.key + "_";
                var et = this.sequences[$];
                return et || (et = {
                    transforms: [].concat(g),
                    finalTransform: new Matrix,
                    _mdf: !1
                },
                this.sequences[$] = et,
                this.sequenceList.push(et)),
                et
            },
            processSequence: function(g, b) {
                for (var _ = 0, $ = g.transforms.length, et = b; _ < $ && !b; ) {
                    if (g.transforms[_].transform.mProps._mdf) {
                        et = !0;
                        break
                    }
                    _ += 1
                }
                if (et)
                    for (g.finalTransform.reset(),
                    _ = $ - 1; _ >= 0; _ -= 1)
                        g.finalTransform.multiply(g.transforms[_].transform.mProps.v);
                g._mdf = et
            },
            processSequences: function(g) {
                var b, _ = this.sequenceList.length;
                for (b = 0; b < _; b += 1)
                    this.processSequence(this.sequenceList[b], g)
            },
            getNewKey: function() {
                return this.transform_key_count += 1,
                "_" + this.transform_key_count
            }
        };
        var lumaLoader = function() {
            var g = "__lottie_element_luma_buffer"
              , b = null
              , _ = null
              , $ = null;
            function et() {
                var nt = createNS("svg")
                  , it = createNS("filter")
                  , ot = createNS("feColorMatrix");
                return it.setAttribute("id", g),
                ot.setAttribute("type", "matrix"),
                ot.setAttribute("color-interpolation-filters", "sRGB"),
                ot.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"),
                it.appendChild(ot),
                nt.appendChild(it),
                nt.setAttribute("id", g + "_svg"),
                featureSupport.svgLumaHidden && (nt.style.display = "none"),
                nt
            }
            function tt() {
                b || ($ = et(),
                document.body.appendChild($),
                b = createTag("canvas"),
                _ = b.getContext("2d"),
                _.filter = "url(#" + g + ")",
                _.fillStyle = "rgba(0,0,0,0)",
                _.fillRect(0, 0, 1, 1))
            }
            function rt(nt) {
                return b || tt(),
                b.width = nt.width,
                b.height = nt.height,
                _.filter = "url(#" + g + ")",
                b
            }
            return {
                load: tt,
                get: rt
            }
        };
        function createCanvas(d, g) {
            if (featureSupport.offscreenCanvas)
                return new OffscreenCanvas(d,g);
            var b = createTag("canvas");
            return b.width = d,
            b.height = g,
            b
        }
        var assetLoader = function() {
            return {
                loadLumaCanvas: lumaLoader.load,
                getLumaCanvas: lumaLoader.get,
                createCanvas
            }
        }()
          , registeredEffects = {};
        function CVEffects(d) {
            var g, b = d.data.ef ? d.data.ef.length : 0;
            this.filters = [];
            var _;
            for (g = 0; g < b; g += 1) {
                _ = null;
                var $ = d.data.ef[g].ty;
                if (registeredEffects[$]) {
                    var et = registeredEffects[$].effect;
                    _ = new et(d.effectsManager.effectElements[g],d)
                }
                _ && this.filters.push(_)
            }
            this.filters.length && d.addRenderableComponent(this)
        }
        CVEffects.prototype.renderFrame = function(d) {
            var g, b = this.filters.length;
            for (g = 0; g < b; g += 1)
                this.filters[g].renderFrame(d)
        }
        ,
        CVEffects.prototype.getEffects = function(d) {
            var g, b = this.filters.length, _ = [];
            for (g = 0; g < b; g += 1)
                this.filters[g].type === d && _.push(this.filters[g]);
            return _
        }
        ;
        function registerEffect(d, g) {
            registeredEffects[d] = {
                effect: g
            }
        }
        function CVMaskElement(d, g) {
            this.data = d,
            this.element = g,
            this.masksProperties = this.data.masksProperties || [],
            this.viewData = createSizedArray(this.masksProperties.length);
            var b, _ = this.masksProperties.length, $ = !1;
            for (b = 0; b < _; b += 1)
                this.masksProperties[b].mode !== "n" && ($ = !0),
                this.viewData[b] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[b], 3);
            this.hasMasks = $,
            $ && this.element.addRenderableComponent(this)
        }
        CVMaskElement.prototype.renderFrame = function() {
            if (this.hasMasks) {
                var d = this.element.finalTransform.mat, g = this.element.canvasContext, b, _ = this.masksProperties.length, $, et, tt;
                for (g.beginPath(),
                b = 0; b < _; b += 1)
                    if (this.masksProperties[b].mode !== "n") {
                        this.masksProperties[b].inv && (g.moveTo(0, 0),
                        g.lineTo(this.element.globalData.compSize.w, 0),
                        g.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h),
                        g.lineTo(0, this.element.globalData.compSize.h),
                        g.lineTo(0, 0)),
                        tt = this.viewData[b].v,
                        $ = d.applyToPointArray(tt.v[0][0], tt.v[0][1], 0),
                        g.moveTo($[0], $[1]);
                        var rt, nt = tt._length;
                        for (rt = 1; rt < nt; rt += 1)
                            et = d.applyToTriplePoints(tt.o[rt - 1], tt.i[rt], tt.v[rt]),
                            g.bezierCurveTo(et[0], et[1], et[2], et[3], et[4], et[5]);
                        et = d.applyToTriplePoints(tt.o[rt - 1], tt.i[0], tt.v[0]),
                        g.bezierCurveTo(et[0], et[1], et[2], et[3], et[4], et[5])
                    }
                this.element.globalData.renderer.save(!0),
                g.clip()
            }
        }
        ,
        CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty,
        CVMaskElement.prototype.destroy = function() {
            this.element = null
        }
        ;
        function CVBaseElement() {}
        var operationsMap = {
            1: "source-in",
            2: "source-out",
            3: "source-in",
            4: "source-out"
        };
        CVBaseElement.prototype = {
            createElements: function() {},
            initRendererElement: function() {},
            createContainerElements: function() {
                if (this.data.tt >= 1) {
                    this.buffers = [];
                    var g = this.globalData.canvasContext
                      , b = assetLoader.createCanvas(g.canvas.width, g.canvas.height);
                    this.buffers.push(b);
                    var _ = assetLoader.createCanvas(g.canvas.width, g.canvas.height);
                    this.buffers.push(_),
                    this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas()
                }
                this.canvasContext = this.globalData.canvasContext,
                this.transformCanvas = this.globalData.transformCanvas,
                this.renderableEffectsManager = new CVEffects(this),
                this.searchEffectTransforms()
            },
            createContent: function() {},
            setBlendMode: function() {
                var g = this.globalData;
                if (g.blendMode !== this.data.bm) {
                    g.blendMode = this.data.bm;
                    var b = getBlendMode(this.data.bm);
                    g.canvasContext.globalCompositeOperation = b
                }
            },
            createRenderableComponents: function() {
                this.maskManager = new CVMaskElement(this.data,this),
                this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT)
            },
            hideElement: function() {
                !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0)
            },
            showElement: function() {
                this.isInRange && !this.isTransparent && (this.hidden = !1,
                this._isFirstFrame = !0,
                this.maskManager._isFirstFrame = !0)
            },
            clearCanvas: function(g) {
                g.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy)
            },
            prepareLayer: function() {
                if (this.data.tt >= 1) {
                    var g = this.buffers[0]
                      , b = g.getContext("2d");
                    this.clearCanvas(b),
                    b.drawImage(this.canvasContext.canvas, 0, 0),
                    this.currentTransform = this.canvasContext.getTransform(),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform)
                }
            },
            exitLayer: function() {
                if (this.data.tt >= 1) {
                    var g = this.buffers[1]
                      , b = g.getContext("2d");
                    this.clearCanvas(b),
                    b.drawImage(this.canvasContext.canvas, 0, 0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.clearCanvas(this.canvasContext),
                    this.canvasContext.setTransform(this.currentTransform);
                    var _ = this.comp.getElementById("tp"in this.data ? this.data.tp : this.data.ind - 1);
                    if (_.renderFrame(!0),
                    this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
                    this.data.tt >= 3 && !document._isProxy) {
                        var $ = assetLoader.getLumaCanvas(this.canvasContext.canvas)
                          , et = $.getContext("2d");
                        et.drawImage(this.canvasContext.canvas, 0, 0),
                        this.clearCanvas(this.canvasContext),
                        this.canvasContext.drawImage($, 0, 0)
                    }
                    this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt],
                    this.canvasContext.drawImage(g, 0, 0),
                    this.canvasContext.globalCompositeOperation = "destination-over",
                    this.canvasContext.drawImage(this.buffers[0], 0, 0),
                    this.canvasContext.setTransform(this.currentTransform),
                    this.canvasContext.globalCompositeOperation = "source-over"
                }
            },
            renderFrame: function(g) {
                if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !g)) {
                    this.renderTransform(),
                    this.renderRenderable(),
                    this.renderLocalTransform(),
                    this.setBlendMode();
                    var b = this.data.ty === 0;
                    this.prepareLayer(),
                    this.globalData.renderer.save(b),
                    this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props),
                    this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity),
                    this.renderInnerContent(),
                    this.globalData.renderer.restore(b),
                    this.exitLayer(),
                    this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                    this._isFirstFrame && (this._isFirstFrame = !1)
                }
            },
            destroy: function() {
                this.canvasContext = null,
                this.data = null,
                this.globalData = null,
                this.maskManager.destroy()
            },
            mHelper: new Matrix
        },
        CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement,
        CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
        function CVShapeData(d, g, b, _) {
            this.styledShapes = [],
            this.tr = [0, 0, 0, 0, 0, 0];
            var $ = 4;
            g.ty === "rc" ? $ = 5 : g.ty === "el" ? $ = 6 : g.ty === "sr" && ($ = 7),
            this.sh = ShapePropertyFactory.getShapeProp(d, g, $, d);
            var et, tt = b.length, rt;
            for (et = 0; et < tt; et += 1)
                b[et].closed || (rt = {
                    transforms: _.addTransformSequence(b[et].transforms),
                    trNodes: []
                },
                this.styledShapes.push(rt),
                b[et].elements.push(rt))
        }
        CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
        function CVShapeElement(d, g, b) {
            this.shapes = [],
            this.shapesData = d.shapes,
            this.stylesList = [],
            this.itemsData = [],
            this.prevViewData = [],
            this.shapeModifiers = [],
            this.processedElements = [],
            this.transformsManager = new ShapeTransformManager,
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement),
        CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement,
        CVShapeElement.prototype.transformHelper = {
            opacity: 1,
            _opMdf: !1
        },
        CVShapeElement.prototype.dashResetter = [],
        CVShapeElement.prototype.createContent = function() {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
        }
        ,
        CVShapeElement.prototype.createStyleElement = function(d, g) {
            var b = {
                data: d,
                type: d.ty,
                preTransforms: this.transformsManager.addTransformSequence(g),
                transforms: [],
                elements: [],
                closed: d.hd === !0
            }
              , _ = {};
            if (d.ty === "fl" || d.ty === "st" ? (_.c = PropertyFactory.getProp(this, d.c, 1, 255, this),
            _.c.k || (b.co = "rgb(" + bmFloor(_.c.v[0]) + "," + bmFloor(_.c.v[1]) + "," + bmFloor(_.c.v[2]) + ")")) : (d.ty === "gf" || d.ty === "gs") && (_.s = PropertyFactory.getProp(this, d.s, 1, null, this),
            _.e = PropertyFactory.getProp(this, d.e, 1, null, this),
            _.h = PropertyFactory.getProp(this, d.h || {
                k: 0
            }, 0, .01, this),
            _.a = PropertyFactory.getProp(this, d.a || {
                k: 0
            }, 0, degToRads, this),
            _.g = new GradientProperty(this,d.g,this)),
            _.o = PropertyFactory.getProp(this, d.o, 0, .01, this),
            d.ty === "st" || d.ty === "gs") {
                if (b.lc = lineCapEnum[d.lc || 2],
                b.lj = lineJoinEnum[d.lj || 2],
                d.lj == 1 && (b.ml = d.ml),
                _.w = PropertyFactory.getProp(this, d.w, 0, null, this),
                _.w.k || (b.wi = _.w.v),
                d.d) {
                    var $ = new DashProperty(this,d.d,"canvas",this);
                    _.d = $,
                    _.d.k || (b.da = _.d.dashArray,
                    b.do = _.d.dashoffset[0])
                }
            } else
                b.r = d.r === 2 ? "evenodd" : "nonzero";
            return this.stylesList.push(b),
            _.style = b,
            _
        }
        ,
        CVShapeElement.prototype.createGroupElement = function() {
            var d = {
                it: [],
                prevViewData: []
            };
            return d
        }
        ,
        CVShapeElement.prototype.createTransformElement = function(d) {
            var g = {
                transform: {
                    opacity: 1,
                    _opMdf: !1,
                    key: this.transformsManager.getNewKey(),
                    op: PropertyFactory.getProp(this, d.o, 0, .01, this),
                    mProps: TransformPropertyFactory.getTransformProperty(this, d, this)
                }
            };
            return g
        }
        ,
        CVShapeElement.prototype.createShapeElement = function(d) {
            var g = new CVShapeData(this,d,this.stylesList,this.transformsManager);
            return this.shapes.push(g),
            this.addShapeToModifiers(g),
            g
        }
        ,
        CVShapeElement.prototype.reloadShapes = function() {
            this._isFirstFrame = !0;
            var d, g = this.itemsData.length;
            for (d = 0; d < g; d += 1)
                this.prevViewData[d] = this.itemsData[d];
            for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
            g = this.dynamicProperties.length,
            d = 0; d < g; d += 1)
                this.dynamicProperties[d].getValue();
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame)
        }
        ,
        CVShapeElement.prototype.addTransformToStyleList = function(d) {
            var g, b = this.stylesList.length;
            for (g = 0; g < b; g += 1)
                this.stylesList[g].closed || this.stylesList[g].transforms.push(d)
        }
        ,
        CVShapeElement.prototype.removeTransformFromStyleList = function() {
            var d, g = this.stylesList.length;
            for (d = 0; d < g; d += 1)
                this.stylesList[d].closed || this.stylesList[d].transforms.pop()
        }
        ,
        CVShapeElement.prototype.closeStyles = function(d) {
            var g, b = d.length;
            for (g = 0; g < b; g += 1)
                d[g].closed = !0
        }
        ,
        CVShapeElement.prototype.searchShapes = function(d, g, b, _, $) {
            var et, tt = d.length - 1, rt, nt, it = [], ot = [], at, st, dt, ft = [].concat($);
            for (et = tt; et >= 0; et -= 1) {
                if (at = this.searchProcessedElement(d[et]),
                at ? g[et] = b[at - 1] : d[et]._shouldRender = _,
                d[et].ty === "fl" || d[et].ty === "st" || d[et].ty === "gf" || d[et].ty === "gs")
                    at ? g[et].style.closed = !1 : g[et] = this.createStyleElement(d[et], ft),
                    it.push(g[et].style);
                else if (d[et].ty === "gr") {
                    if (!at)
                        g[et] = this.createGroupElement(d[et]);
                    else
                        for (nt = g[et].it.length,
                        rt = 0; rt < nt; rt += 1)
                            g[et].prevViewData[rt] = g[et].it[rt];
                    this.searchShapes(d[et].it, g[et].it, g[et].prevViewData, _, ft)
                } else
                    d[et].ty === "tr" ? (at || (dt = this.createTransformElement(d[et]),
                    g[et] = dt),
                    ft.push(g[et]),
                    this.addTransformToStyleList(g[et])) : d[et].ty === "sh" || d[et].ty === "rc" || d[et].ty === "el" || d[et].ty === "sr" ? at || (g[et] = this.createShapeElement(d[et])) : d[et].ty === "tm" || d[et].ty === "rd" || d[et].ty === "pb" || d[et].ty === "zz" || d[et].ty === "op" ? (at ? (st = g[et],
                    st.closed = !1) : (st = ShapeModifiers.getModifier(d[et].ty),
                    st.init(this, d[et]),
                    g[et] = st,
                    this.shapeModifiers.push(st)),
                    ot.push(st)) : d[et].ty === "rp" && (at ? (st = g[et],
                    st.closed = !0) : (st = ShapeModifiers.getModifier(d[et].ty),
                    g[et] = st,
                    st.init(this, d, et, g),
                    this.shapeModifiers.push(st),
                    _ = !1),
                    ot.push(st));
                this.addProcessedElement(d[et], et + 1)
            }
            for (this.removeTransformFromStyleList(),
            this.closeStyles(it),
            tt = ot.length,
            et = 0; et < tt; et += 1)
                ot[et].closed = !0
        }
        ,
        CVShapeElement.prototype.renderInnerContent = function() {
            this.transformHelper.opacity = 1,
            this.transformHelper._opMdf = !1,
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
        }
        ,
        CVShapeElement.prototype.renderShapeTransform = function(d, g) {
            (d._opMdf || g.op._mdf || this._isFirstFrame) && (g.opacity = d.opacity,
            g.opacity *= g.op.v,
            g._opMdf = !0)
        }
        ,
        CVShapeElement.prototype.drawLayer = function() {
            var d, g = this.stylesList.length, b, _, $, et, tt, rt, nt = this.globalData.renderer, it = this.globalData.canvasContext, ot, at;
            for (d = 0; d < g; d += 1)
                if (at = this.stylesList[d],
                ot = at.type,
                !((ot === "st" || ot === "gs") && at.wi === 0 || !at.data._shouldRender || at.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
                    for (nt.save(),
                    tt = at.elements,
                    ot === "st" || ot === "gs" ? (nt.ctxStrokeStyle(ot === "st" ? at.co : at.grd),
                    nt.ctxLineWidth(at.wi),
                    nt.ctxLineCap(at.lc),
                    nt.ctxLineJoin(at.lj),
                    nt.ctxMiterLimit(at.ml || 0)) : nt.ctxFillStyle(ot === "fl" ? at.co : at.grd),
                    nt.ctxOpacity(at.coOp),
                    ot !== "st" && ot !== "gs" && it.beginPath(),
                    nt.ctxTransform(at.preTransforms.finalTransform.props),
                    _ = tt.length,
                    b = 0; b < _; b += 1) {
                        for ((ot === "st" || ot === "gs") && (it.beginPath(),
                        at.da && (it.setLineDash(at.da),
                        it.lineDashOffset = at.do)),
                        rt = tt[b].trNodes,
                        et = rt.length,
                        $ = 0; $ < et; $ += 1)
                            rt[$].t === "m" ? it.moveTo(rt[$].p[0], rt[$].p[1]) : rt[$].t === "c" ? it.bezierCurveTo(rt[$].pts[0], rt[$].pts[1], rt[$].pts[2], rt[$].pts[3], rt[$].pts[4], rt[$].pts[5]) : it.closePath();
                        (ot === "st" || ot === "gs") && (nt.ctxStroke(),
                        at.da && it.setLineDash(this.dashResetter))
                    }
                    ot !== "st" && ot !== "gs" && this.globalData.renderer.ctxFill(at.r),
                    nt.restore()
                }
        }
        ,
        CVShapeElement.prototype.renderShape = function(d, g, b, _) {
            var $, et = g.length - 1, tt;
            for (tt = d,
            $ = et; $ >= 0; $ -= 1)
                g[$].ty === "tr" ? (tt = b[$].transform,
                this.renderShapeTransform(d, tt)) : g[$].ty === "sh" || g[$].ty === "el" || g[$].ty === "rc" || g[$].ty === "sr" ? this.renderPath(g[$], b[$]) : g[$].ty === "fl" ? this.renderFill(g[$], b[$], tt) : g[$].ty === "st" ? this.renderStroke(g[$], b[$], tt) : g[$].ty === "gf" || g[$].ty === "gs" ? this.renderGradientFill(g[$], b[$], tt) : g[$].ty === "gr" ? this.renderShape(tt, g[$].it, b[$].it) : g[$].ty;
            _ && this.drawLayer()
        }
        ,
        CVShapeElement.prototype.renderStyledShape = function(d, g) {
            if (this._isFirstFrame || g._mdf || d.transforms._mdf) {
                var b = d.trNodes, _ = g.paths, $, et, tt, rt = _._length;
                b.length = 0;
                var nt = d.transforms.finalTransform;
                for (tt = 0; tt < rt; tt += 1) {
                    var it = _.shapes[tt];
                    if (it && it.v) {
                        for (et = it._length,
                        $ = 1; $ < et; $ += 1)
                            $ === 1 && b.push({
                                t: "m",
                                p: nt.applyToPointArray(it.v[0][0], it.v[0][1], 0)
                            }),
                            b.push({
                                t: "c",
                                pts: nt.applyToTriplePoints(it.o[$ - 1], it.i[$], it.v[$])
                            });
                        et === 1 && b.push({
                            t: "m",
                            p: nt.applyToPointArray(it.v[0][0], it.v[0][1], 0)
                        }),
                        it.c && et && (b.push({
                            t: "c",
                            pts: nt.applyToTriplePoints(it.o[$ - 1], it.i[0], it.v[0])
                        }),
                        b.push({
                            t: "z"
                        }))
                    }
                }
                d.trNodes = b
            }
        }
        ,
        CVShapeElement.prototype.renderPath = function(d, g) {
            if (d.hd !== !0 && d._shouldRender) {
                var b, _ = g.styledShapes.length;
                for (b = 0; b < _; b += 1)
                    this.renderStyledShape(g.styledShapes[b], g.sh)
            }
        }
        ,
        CVShapeElement.prototype.renderFill = function(d, g, b) {
            var _ = g.style;
            (g.c._mdf || this._isFirstFrame) && (_.co = "rgb(" + bmFloor(g.c.v[0]) + "," + bmFloor(g.c.v[1]) + "," + bmFloor(g.c.v[2]) + ")"),
            (g.o._mdf || b._opMdf || this._isFirstFrame) && (_.coOp = g.o.v * b.opacity)
        }
        ,
        CVShapeElement.prototype.renderGradientFill = function(d, g, b) {
            var _ = g.style, $;
            if (!_.grd || g.g._mdf || g.s._mdf || g.e._mdf || d.t !== 1 && (g.h._mdf || g.a._mdf)) {
                var et = this.globalData.canvasContext
                  , tt = g.s.v
                  , rt = g.e.v;
                if (d.t === 1)
                    $ = et.createLinearGradient(tt[0], tt[1], rt[0], rt[1]);
                else {
                    var nt = Math.sqrt(Math.pow(tt[0] - rt[0], 2) + Math.pow(tt[1] - rt[1], 2))
                      , it = Math.atan2(rt[1] - tt[1], rt[0] - tt[0])
                      , ot = g.h.v;
                    ot >= 1 ? ot = .99 : ot <= -1 && (ot = -.99);
                    var at = nt * ot
                      , st = Math.cos(it + g.a.v) * at + tt[0]
                      , dt = Math.sin(it + g.a.v) * at + tt[1];
                    $ = et.createRadialGradient(st, dt, 0, tt[0], tt[1], nt)
                }
                var ft, ht = d.g.p, xt = g.g.c, lt = 1;
                for (ft = 0; ft < ht; ft += 1)
                    g.g._hasOpacity && g.g._collapsable && (lt = g.g.o[ft * 2 + 1]),
                    $.addColorStop(xt[ft * 4] / 100, "rgba(" + xt[ft * 4 + 1] + "," + xt[ft * 4 + 2] + "," + xt[ft * 4 + 3] + "," + lt + ")");
                _.grd = $
            }
            _.coOp = g.o.v * b.opacity
        }
        ,
        CVShapeElement.prototype.renderStroke = function(d, g, b) {
            var _ = g.style
              , $ = g.d;
            $ && ($._mdf || this._isFirstFrame) && (_.da = $.dashArray,
            _.do = $.dashoffset[0]),
            (g.c._mdf || this._isFirstFrame) && (_.co = "rgb(" + bmFloor(g.c.v[0]) + "," + bmFloor(g.c.v[1]) + "," + bmFloor(g.c.v[2]) + ")"),
            (g.o._mdf || b._opMdf || this._isFirstFrame) && (_.coOp = g.o.v * b.opacity),
            (g.w._mdf || this._isFirstFrame) && (_.wi = g.w.v)
        }
        ,
        CVShapeElement.prototype.destroy = function() {
            this.shapesData = null,
            this.globalData = null,
            this.canvasContext = null,
            this.stylesList.length = 0,
            this.itemsData.length = 0
        }
        ;
        function CVTextElement(d, g, b) {
            this.textSpans = [],
            this.yOffset = 0,
            this.fillColorAnim = !1,
            this.strokeColorAnim = !1,
            this.strokeWidthAnim = !1,
            this.stroke = !1,
            this.fill = !1,
            this.justifyOffset = 0,
            this.currentRender = null,
            this.renderType = "canvas",
            this.values = {
                fill: "rgba(0,0,0,0)",
                stroke: "rgba(0,0,0,0)",
                sWidth: 0,
                fValue: ""
            },
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement),
        CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"),
        CVTextElement.prototype.buildNewText = function() {
            var d = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(d.l ? d.l.length : 0);
            var g = !1;
            d.fc ? (g = !0,
            this.values.fill = this.buildColor(d.fc)) : this.values.fill = "rgba(0,0,0,0)",
            this.fill = g;
            var b = !1;
            d.sc && (b = !0,
            this.values.stroke = this.buildColor(d.sc),
            this.values.sWidth = d.sw);
            var _ = this.globalData.fontManager.getFontByName(d.f), $, et, tt = d.l, rt = this.mHelper;
            this.stroke = b,
            this.values.fValue = d.finalSize + "px " + this.globalData.fontManager.getFontByName(d.f).fFamily,
            et = d.finalText.length;
            var nt, it, ot, at, st, dt, ft, ht, xt, lt, ct = this.data.singleShape, ut = d.tr * .001 * d.finalSize, pt = 0, vt = 0, _t = !0, Pt = 0;
            for ($ = 0; $ < et; $ += 1) {
                nt = this.globalData.fontManager.getCharData(d.finalText[$], _.fStyle, this.globalData.fontManager.getFontByName(d.f).fFamily),
                it = nt && nt.data || {},
                rt.reset(),
                ct && tt[$].n && (pt = -ut,
                vt += d.yOffset,
                vt += _t ? 1 : 0,
                _t = !1),
                st = it.shapes ? it.shapes[0].it : [],
                ft = st.length,
                rt.scale(d.finalSize / 100, d.finalSize / 100),
                ct && this.applyTextPropertiesToMatrix(d, rt, tt[$].line, pt, vt),
                xt = createSizedArray(ft - 1);
                var kt = 0;
                for (dt = 0; dt < ft; dt += 1)
                    if (st[dt].ty === "sh") {
                        for (at = st[dt].ks.k.i.length,
                        ht = st[dt].ks.k,
                        lt = [],
                        ot = 1; ot < at; ot += 1)
                            ot === 1 && lt.push(rt.applyToX(ht.v[0][0], ht.v[0][1], 0), rt.applyToY(ht.v[0][0], ht.v[0][1], 0)),
                            lt.push(rt.applyToX(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), rt.applyToY(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), rt.applyToX(ht.i[ot][0], ht.i[ot][1], 0), rt.applyToY(ht.i[ot][0], ht.i[ot][1], 0), rt.applyToX(ht.v[ot][0], ht.v[ot][1], 0), rt.applyToY(ht.v[ot][0], ht.v[ot][1], 0));
                        lt.push(rt.applyToX(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), rt.applyToY(ht.o[ot - 1][0], ht.o[ot - 1][1], 0), rt.applyToX(ht.i[0][0], ht.i[0][1], 0), rt.applyToY(ht.i[0][0], ht.i[0][1], 0), rt.applyToX(ht.v[0][0], ht.v[0][1], 0), rt.applyToY(ht.v[0][0], ht.v[0][1], 0)),
                        xt[kt] = lt,
                        kt += 1
                    }
                ct && (pt += tt[$].l,
                pt += ut),
                this.textSpans[Pt] ? this.textSpans[Pt].elem = xt : this.textSpans[Pt] = {
                    elem: xt
                },
                Pt += 1
            }
        }
        ,
        CVTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var d = this.canvasContext;
            d.font = this.values.fValue,
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            var g, b, _, $, et, tt, rt = this.textAnimator.renderedLetters, nt = this.textProperty.currentData.l;
            b = nt.length;
            var it, ot = null, at = null, st = null, dt, ft, ht = this.globalData.renderer;
            for (g = 0; g < b; g += 1)
                if (!nt[g].n) {
                    if (it = rt[g],
                    it && (ht.save(),
                    ht.ctxTransform(it.p),
                    ht.ctxOpacity(it.o)),
                    this.fill) {
                        for (it && it.fc ? ot !== it.fc && (ht.ctxFillStyle(it.fc),
                        ot = it.fc) : ot !== this.values.fill && (ot = this.values.fill,
                        ht.ctxFillStyle(this.values.fill)),
                        dt = this.textSpans[g].elem,
                        $ = dt.length,
                        this.globalData.canvasContext.beginPath(),
                        _ = 0; _ < $; _ += 1)
                            for (ft = dt[_],
                            tt = ft.length,
                            this.globalData.canvasContext.moveTo(ft[0], ft[1]),
                            et = 2; et < tt; et += 6)
                                this.globalData.canvasContext.bezierCurveTo(ft[et], ft[et + 1], ft[et + 2], ft[et + 3], ft[et + 4], ft[et + 5]);
                        this.globalData.canvasContext.closePath(),
                        ht.ctxFill()
                    }
                    if (this.stroke) {
                        for (it && it.sw ? st !== it.sw && (st = it.sw,
                        ht.ctxLineWidth(it.sw)) : st !== this.values.sWidth && (st = this.values.sWidth,
                        ht.ctxLineWidth(this.values.sWidth)),
                        it && it.sc ? at !== it.sc && (at = it.sc,
                        ht.ctxStrokeStyle(it.sc)) : at !== this.values.stroke && (at = this.values.stroke,
                        ht.ctxStrokeStyle(this.values.stroke)),
                        dt = this.textSpans[g].elem,
                        $ = dt.length,
                        this.globalData.canvasContext.beginPath(),
                        _ = 0; _ < $; _ += 1)
                            for (ft = dt[_],
                            tt = ft.length,
                            this.globalData.canvasContext.moveTo(ft[0], ft[1]),
                            et = 2; et < tt; et += 6)
                                this.globalData.canvasContext.bezierCurveTo(ft[et], ft[et + 1], ft[et + 2], ft[et + 3], ft[et + 4], ft[et + 5]);
                        this.globalData.canvasContext.closePath(),
                        ht.ctxStroke()
                    }
                    it && this.globalData.renderer.restore()
                }
        }
        ;
        function CVImageElement(d, g, b) {
            this.assetData = g.getAssetData(d.refId),
            this.img = g.imageLoader.getAsset(this.assetData),
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement),
        CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVImageElement.prototype.createContent = function() {
            if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
                var d = createTag("canvas");
                d.width = this.assetData.w,
                d.height = this.assetData.h;
                var g = d.getContext("2d"), b = this.img.width, _ = this.img.height, $ = b / _, et = this.assetData.w / this.assetData.h, tt, rt, nt = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
                $ > et && nt === "xMidYMid slice" || $ < et && nt !== "xMidYMid slice" ? (rt = _,
                tt = rt * et) : (tt = b,
                rt = tt / et),
                g.drawImage(this.img, (b - tt) / 2, (_ - rt) / 2, tt, rt, 0, 0, this.assetData.w, this.assetData.h),
                this.img = d
            }
        }
        ,
        CVImageElement.prototype.renderInnerContent = function() {
            this.canvasContext.drawImage(this.img, 0, 0)
        }
        ,
        CVImageElement.prototype.destroy = function() {
            this.img = null
        }
        ;
        function CVSolidElement(d, g, b) {
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement),
        CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement,
        CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame,
        CVSolidElement.prototype.renderInnerContent = function() {
            this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh)
        }
        ;
        function CanvasRendererBase() {}
        extendPrototype([BaseRenderer], CanvasRendererBase),
        CanvasRendererBase.prototype.createShape = function(d) {
            return new CVShapeElement(d,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createText = function(d) {
            return new CVTextElement(d,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createImage = function(d) {
            return new CVImageElement(d,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createSolid = function(d) {
            return new CVSolidElement(d,this.globalData,this)
        }
        ,
        CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        CanvasRendererBase.prototype.ctxTransform = function(d) {
            d[0] === 1 && d[1] === 0 && d[4] === 0 && d[5] === 1 && d[12] === 0 && d[13] === 0 || this.canvasContext.transform(d[0], d[1], d[4], d[5], d[12], d[13])
        }
        ,
        CanvasRendererBase.prototype.ctxOpacity = function(d) {
            this.canvasContext.globalAlpha *= d < 0 ? 0 : d
        }
        ,
        CanvasRendererBase.prototype.ctxFillStyle = function(d) {
            this.canvasContext.fillStyle = d
        }
        ,
        CanvasRendererBase.prototype.ctxStrokeStyle = function(d) {
            this.canvasContext.strokeStyle = d
        }
        ,
        CanvasRendererBase.prototype.ctxLineWidth = function(d) {
            this.canvasContext.lineWidth = d
        }
        ,
        CanvasRendererBase.prototype.ctxLineCap = function(d) {
            this.canvasContext.lineCap = d
        }
        ,
        CanvasRendererBase.prototype.ctxLineJoin = function(d) {
            this.canvasContext.lineJoin = d
        }
        ,
        CanvasRendererBase.prototype.ctxMiterLimit = function(d) {
            this.canvasContext.miterLimit = d
        }
        ,
        CanvasRendererBase.prototype.ctxFill = function(d) {
            this.canvasContext.fill(d)
        }
        ,
        CanvasRendererBase.prototype.ctxFillRect = function(d, g, b, _) {
            this.canvasContext.fillRect(d, g, b, _)
        }
        ,
        CanvasRendererBase.prototype.ctxStroke = function() {
            this.canvasContext.stroke()
        }
        ,
        CanvasRendererBase.prototype.reset = function() {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            this.contextData.reset()
        }
        ,
        CanvasRendererBase.prototype.save = function() {
            this.canvasContext.save()
        }
        ,
        CanvasRendererBase.prototype.restore = function(d) {
            if (!this.renderConfig.clearCanvas) {
                this.canvasContext.restore();
                return
            }
            d && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(d)
        }
        ,
        CanvasRendererBase.prototype.configAnimation = function(d) {
            if (this.animationItem.wrapper) {
                this.animationItem.container = createTag("canvas");
                var g = this.animationItem.container.style;
                g.width = "100%",
                g.height = "100%";
                var b = "0px 0px 0px";
                g.transformOrigin = b,
                g.mozTransformOrigin = b,
                g.webkitTransformOrigin = b,
                g["-webkit-transform"] = b,
                g.contentVisibility = this.renderConfig.contentVisibility,
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                this.canvasContext = this.animationItem.container.getContext("2d"),
                this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className),
                this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id)
            } else
                this.canvasContext = this.renderConfig.context;
            this.contextData.setContext(this.canvasContext),
            this.data = d,
            this.layers = d.layers,
            this.transformCanvas = {
                w: d.w,
                h: d.h,
                sx: 0,
                sy: 0,
                tx: 0,
                ty: 0
            },
            this.setupGlobalData(d, document.body),
            this.globalData.canvasContext = this.canvasContext,
            this.globalData.renderer = this,
            this.globalData.isDashed = !1,
            this.globalData.progressiveLoad = this.renderConfig.progressiveLoad,
            this.globalData.transformCanvas = this.transformCanvas,
            this.elements = createSizedArray(d.layers.length),
            this.updateContainerSize()
        }
        ,
        CanvasRendererBase.prototype.updateContainerSize = function(d, g) {
            this.reset();
            var b, _;
            d ? (b = d,
            _ = g,
            this.canvasContext.canvas.width = b,
            this.canvasContext.canvas.height = _) : (this.animationItem.wrapper && this.animationItem.container ? (b = this.animationItem.wrapper.offsetWidth,
            _ = this.animationItem.wrapper.offsetHeight) : (b = this.canvasContext.canvas.width,
            _ = this.canvasContext.canvas.height),
            this.canvasContext.canvas.width = b * this.renderConfig.dpr,
            this.canvasContext.canvas.height = _ * this.renderConfig.dpr);
            var $, et;
            if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
                var tt = this.renderConfig.preserveAspectRatio.split(" ")
                  , rt = tt[1] || "meet"
                  , nt = tt[0] || "xMidYMid"
                  , it = nt.substr(0, 4)
                  , ot = nt.substr(4);
                $ = b / _,
                et = this.transformCanvas.w / this.transformCanvas.h,
                et > $ && rt === "meet" || et < $ && rt === "slice" ? (this.transformCanvas.sx = b / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = b / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = _ / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.sy = _ / (this.transformCanvas.h / this.renderConfig.dpr)),
                it === "xMid" && (et < $ && rt === "meet" || et > $ && rt === "slice") ? this.transformCanvas.tx = (b - this.transformCanvas.w * (_ / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : it === "xMax" && (et < $ && rt === "meet" || et > $ && rt === "slice") ? this.transformCanvas.tx = (b - this.transformCanvas.w * (_ / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0,
                ot === "YMid" && (et > $ && rt === "meet" || et < $ && rt === "slice") ? this.transformCanvas.ty = (_ - this.transformCanvas.h * (b / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : ot === "YMax" && (et > $ && rt === "meet" || et < $ && rt === "slice") ? this.transformCanvas.ty = (_ - this.transformCanvas.h * (b / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0
            } else
                this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = b / (this.transformCanvas.w / this.renderConfig.dpr),
                this.transformCanvas.sy = _ / (this.transformCanvas.h / this.renderConfig.dpr),
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr,
                this.transformCanvas.sy = this.renderConfig.dpr,
                this.transformCanvas.tx = 0,
                this.transformCanvas.ty = 0);
            this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1],
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0)
        }
        ,
        CanvasRendererBase.prototype.destroy = function() {
            this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
            var d, g = this.layers ? this.layers.length : 0;
            for (d = g - 1; d >= 0; d -= 1)
                this.elements[d] && this.elements[d].destroy && this.elements[d].destroy();
            this.elements.length = 0,
            this.globalData.canvasContext = null,
            this.animationItem.container = null,
            this.destroyed = !0
        }
        ,
        CanvasRendererBase.prototype.renderFrame = function(d, g) {
            if (!(this.renderedFrame === d && this.renderConfig.clearCanvas === !0 && !g || this.destroyed || d === -1)) {
                this.renderedFrame = d,
                this.globalData.frameNum = d - this.animationItem._isFirstFrame,
                this.globalData.frameId += 1,
                this.globalData._mdf = !this.renderConfig.clearCanvas || g,
                this.globalData.projectInterface.currentFrame = d;
                var b, _ = this.layers.length;
                for (this.completeLayers || this.checkLayers(d),
                b = _ - 1; b >= 0; b -= 1)
                    (this.completeLayers || this.elements[b]) && this.elements[b].prepareFrame(d - this.layers[b].st);
                if (this.globalData._mdf) {
                    for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(),
                    b = _ - 1; b >= 0; b -= 1)
                        (this.completeLayers || this.elements[b]) && this.elements[b].renderFrame();
                    this.renderConfig.clearCanvas !== !0 && this.restore()
                }
            }
        }
        ,
        CanvasRendererBase.prototype.buildItem = function(d) {
            var g = this.elements;
            if (!(g[d] || this.layers[d].ty === 99)) {
                var b = this.createItem(this.layers[d], this, this.globalData);
                g[d] = b,
                b.initExpressions()
            }
        }
        ,
        CanvasRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var d = this.pendingElements.pop();
                d.checkParenting()
            }
        }
        ,
        CanvasRendererBase.prototype.hide = function() {
            this.animationItem.container.style.display = "none"
        }
        ,
        CanvasRendererBase.prototype.show = function() {
            this.animationItem.container.style.display = "block"
        }
        ;
        function CanvasContext() {
            this.opacity = -1,
            this.transform = createTypedArray("float32", 16),
            this.fillStyle = "",
            this.strokeStyle = "",
            this.lineWidth = "",
            this.lineCap = "",
            this.lineJoin = "",
            this.miterLimit = "",
            this.id = Math.random()
        }
        function CVContextData() {
            this.stack = [],
            this.cArrPos = 0,
            this.cTr = new Matrix;
            var d, g = 15;
            for (d = 0; d < g; d += 1) {
                var b = new CanvasContext;
                this.stack[d] = b
            }
            this._length = g,
            this.nativeContext = null,
            this.transformMat = new Matrix,
            this.currentOpacity = 1,
            this.currentFillStyle = "",
            this.appliedFillStyle = "",
            this.currentStrokeStyle = "",
            this.appliedStrokeStyle = "",
            this.currentLineWidth = "",
            this.appliedLineWidth = "",
            this.currentLineCap = "",
            this.appliedLineCap = "",
            this.currentLineJoin = "",
            this.appliedLineJoin = "",
            this.appliedMiterLimit = "",
            this.currentMiterLimit = ""
        }
        CVContextData.prototype.duplicate = function() {
            var d = this._length * 2
              , g = 0;
            for (g = this._length; g < d; g += 1)
                this.stack[g] = new CanvasContext;
            this._length = d
        }
        ,
        CVContextData.prototype.reset = function() {
            this.cArrPos = 0,
            this.cTr.reset(),
            this.stack[this.cArrPos].opacity = 1
        }
        ,
        CVContextData.prototype.restore = function(d) {
            this.cArrPos -= 1;
            var g = this.stack[this.cArrPos], b = g.transform, _, $ = this.cTr.props;
            for (_ = 0; _ < 16; _ += 1)
                $[_] = b[_];
            if (d) {
                this.nativeContext.restore();
                var et = this.stack[this.cArrPos + 1];
                this.appliedFillStyle = et.fillStyle,
                this.appliedStrokeStyle = et.strokeStyle,
                this.appliedLineWidth = et.lineWidth,
                this.appliedLineCap = et.lineCap,
                this.appliedLineJoin = et.lineJoin,
                this.appliedMiterLimit = et.miterLimit
            }
            this.nativeContext.setTransform(b[0], b[1], b[4], b[5], b[12], b[13]),
            (d || g.opacity !== -1 && this.currentOpacity !== g.opacity) && (this.nativeContext.globalAlpha = g.opacity,
            this.currentOpacity = g.opacity),
            this.currentFillStyle = g.fillStyle,
            this.currentStrokeStyle = g.strokeStyle,
            this.currentLineWidth = g.lineWidth,
            this.currentLineCap = g.lineCap,
            this.currentLineJoin = g.lineJoin,
            this.currentMiterLimit = g.miterLimit
        }
        ,
        CVContextData.prototype.save = function(d) {
            d && this.nativeContext.save();
            var g = this.cTr.props;
            this._length <= this.cArrPos && this.duplicate();
            var b = this.stack[this.cArrPos], _;
            for (_ = 0; _ < 16; _ += 1)
                b.transform[_] = g[_];
            this.cArrPos += 1;
            var $ = this.stack[this.cArrPos];
            $.opacity = b.opacity,
            $.fillStyle = b.fillStyle,
            $.strokeStyle = b.strokeStyle,
            $.lineWidth = b.lineWidth,
            $.lineCap = b.lineCap,
            $.lineJoin = b.lineJoin,
            $.miterLimit = b.miterLimit
        }
        ,
        CVContextData.prototype.setOpacity = function(d) {
            this.stack[this.cArrPos].opacity = d
        }
        ,
        CVContextData.prototype.setContext = function(d) {
            this.nativeContext = d
        }
        ,
        CVContextData.prototype.fillStyle = function(d) {
            this.stack[this.cArrPos].fillStyle !== d && (this.currentFillStyle = d,
            this.stack[this.cArrPos].fillStyle = d)
        }
        ,
        CVContextData.prototype.strokeStyle = function(d) {
            this.stack[this.cArrPos].strokeStyle !== d && (this.currentStrokeStyle = d,
            this.stack[this.cArrPos].strokeStyle = d)
        }
        ,
        CVContextData.prototype.lineWidth = function(d) {
            this.stack[this.cArrPos].lineWidth !== d && (this.currentLineWidth = d,
            this.stack[this.cArrPos].lineWidth = d)
        }
        ,
        CVContextData.prototype.lineCap = function(d) {
            this.stack[this.cArrPos].lineCap !== d && (this.currentLineCap = d,
            this.stack[this.cArrPos].lineCap = d)
        }
        ,
        CVContextData.prototype.lineJoin = function(d) {
            this.stack[this.cArrPos].lineJoin !== d && (this.currentLineJoin = d,
            this.stack[this.cArrPos].lineJoin = d)
        }
        ,
        CVContextData.prototype.miterLimit = function(d) {
            this.stack[this.cArrPos].miterLimit !== d && (this.currentMiterLimit = d,
            this.stack[this.cArrPos].miterLimit = d)
        }
        ,
        CVContextData.prototype.transform = function(d) {
            this.transformMat.cloneFromProps(d);
            var g = this.cTr;
            this.transformMat.multiply(g),
            g.cloneFromProps(this.transformMat.props);
            var b = g.props;
            this.nativeContext.setTransform(b[0], b[1], b[4], b[5], b[12], b[13])
        }
        ,
        CVContextData.prototype.opacity = function(d) {
            var g = this.stack[this.cArrPos].opacity;
            g *= d < 0 ? 0 : d,
            this.stack[this.cArrPos].opacity !== g && (this.currentOpacity !== d && (this.nativeContext.globalAlpha = d,
            this.currentOpacity = d),
            this.stack[this.cArrPos].opacity = g)
        }
        ,
        CVContextData.prototype.fill = function(d) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fill(d)
        }
        ,
        CVContextData.prototype.fillRect = function(d, g, b, _) {
            this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle,
            this.nativeContext.fillStyle = this.appliedFillStyle),
            this.nativeContext.fillRect(d, g, b, _)
        }
        ,
        CVContextData.prototype.stroke = function() {
            this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle,
            this.nativeContext.strokeStyle = this.appliedStrokeStyle),
            this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth,
            this.nativeContext.lineWidth = this.appliedLineWidth),
            this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap,
            this.nativeContext.lineCap = this.appliedLineCap),
            this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin,
            this.nativeContext.lineJoin = this.appliedLineJoin),
            this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit,
            this.nativeContext.miterLimit = this.appliedMiterLimit),
            this.nativeContext.stroke()
        }
        ;
        function CVCompElement(d, g, b) {
            this.completeLayers = !1,
            this.layers = d.layers,
            this.pendingElements = [],
            this.elements = createSizedArray(this.layers.length),
            this.initElement(d, g, b),
            this.tm = d.tm ? PropertyFactory.getProp(this, d.tm, 0, g.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement),
        CVCompElement.prototype.renderInnerContent = function() {
            var d = this.canvasContext;
            d.beginPath(),
            d.moveTo(0, 0),
            d.lineTo(this.data.w, 0),
            d.lineTo(this.data.w, this.data.h),
            d.lineTo(0, this.data.h),
            d.lineTo(0, 0),
            d.clip();
            var g, b = this.layers.length;
            for (g = b - 1; g >= 0; g -= 1)
                (this.completeLayers || this.elements[g]) && this.elements[g].renderFrame()
        }
        ,
        CVCompElement.prototype.destroy = function() {
            var d, g = this.layers.length;
            for (d = g - 1; d >= 0; d -= 1)
                this.elements[d] && this.elements[d].destroy();
            this.layers = null,
            this.elements = null
        }
        ,
        CVCompElement.prototype.createComp = function(d) {
            return new CVCompElement(d,this.globalData,this)
        }
        ;
        function CanvasRenderer(d, g) {
            this.animationItem = d,
            this.renderConfig = {
                clearCanvas: g && g.clearCanvas !== void 0 ? g.clearCanvas : !0,
                context: g && g.context || null,
                progressiveLoad: g && g.progressiveLoad || !1,
                preserveAspectRatio: g && g.preserveAspectRatio || "xMidYMid meet",
                imagePreserveAspectRatio: g && g.imagePreserveAspectRatio || "xMidYMid slice",
                contentVisibility: g && g.contentVisibility || "visible",
                className: g && g.className || "",
                id: g && g.id || "",
                runExpressions: !g || g.runExpressions === void 0 || g.runExpressions
            },
            this.renderConfig.dpr = g && g.dpr || 1,
            this.animationItem.wrapper && (this.renderConfig.dpr = g && g.dpr || window.devicePixelRatio || 1),
            this.renderedFrame = -1,
            this.globalData = {
                frameNum: -1,
                _mdf: !1,
                renderConfig: this.renderConfig,
                currentGlobalAlpha: -1
            },
            this.contextData = new CVContextData,
            this.elements = [],
            this.pendingElements = [],
            this.transformMat = new Matrix,
            this.completeLayers = !1,
            this.rendererType = "canvas",
            this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData),
            this.ctxOpacity = this.contextData.opacity.bind(this.contextData),
            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData),
            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData),
            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData),
            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData),
            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData),
            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData),
            this.ctxFill = this.contextData.fill.bind(this.contextData),
            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData),
            this.ctxStroke = this.contextData.stroke.bind(this.contextData),
            this.save = this.contextData.save.bind(this.contextData))
        }
        extendPrototype([CanvasRendererBase], CanvasRenderer),
        CanvasRenderer.prototype.createComp = function(d) {
            return new CVCompElement(d,this.globalData,this)
        }
        ;
        function HBaseElement() {}
        HBaseElement.prototype = {
            checkBlendMode: function() {},
            initRendererElement: function() {
                this.baseElement = createTag(this.data.tg || "div"),
                this.data.hasMask ? (this.svgElement = createNS("svg"),
                this.layerElement = createNS("g"),
                this.maskedElement = this.layerElement,
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement,
                styleDiv(this.baseElement)
            },
            createContainerElements: function() {
                this.renderableEffectsManager = new CVEffects(this),
                this.transformedElement = this.baseElement,
                this.maskedElement = this.layerElement,
                this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
                this.data.cl && this.layerElement.setAttribute("class", this.data.cl),
                this.data.bm !== 0 && this.setBlendMode()
            },
            renderElement: function() {
                var g = this.transformedElement ? this.transformedElement.style : {};
                if (this.finalTransform._matMdf) {
                    var b = this.finalTransform.mat.toCSS();
                    g.transform = b,
                    g.webkitTransform = b
                }
                this.finalTransform._opMdf && (g.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function() {
                this.data.hd || this.hidden || (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function() {
                this.layerElement = null,
                this.transformedElement = null,
                this.matteElement && (this.matteElement = null),
                this.maskManager && (this.maskManager.destroy(),
                this.maskManager = null)
            },
            createRenderableComponents: function() {
                this.maskManager = new MaskElement(this.data,this,this.globalData)
            },
            addEffects: function() {},
            setMatte: function() {}
        },
        HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement,
        HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy,
        HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
        function HSolidElement(d, g, b) {
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement),
        HSolidElement.prototype.createContent = function() {
            var d;
            this.data.hasMask ? (d = createNS("rect"),
            d.setAttribute("width", this.data.sw),
            d.setAttribute("height", this.data.sh),
            d.setAttribute("fill", this.data.sc),
            this.svgElement.setAttribute("width", this.data.sw),
            this.svgElement.setAttribute("height", this.data.sh)) : (d = createTag("div"),
            d.style.width = this.data.sw + "px",
            d.style.height = this.data.sh + "px",
            d.style.backgroundColor = this.data.sc),
            this.layerElement.appendChild(d)
        }
        ;
        function HShapeElement(d, g, b) {
            this.shapes = [],
            this.shapesData = d.shapes,
            this.stylesList = [],
            this.shapeModifiers = [],
            this.itemsData = [],
            this.processedElements = [],
            this.animatedContents = [],
            this.shapesContainer = createNS("g"),
            this.initElement(d, g, b),
            this.prevViewData = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            }
        }
        extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement),
        HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent,
        HShapeElement.prototype.createContent = function() {
            var d;
            if (this.baseElement.style.fontSize = 0,
            this.data.hasMask)
                this.layerElement.appendChild(this.shapesContainer),
                d = this.svgElement;
            else {
                d = createNS("svg");
                var g = this.comp.data ? this.comp.data : this.globalData.compSize;
                d.setAttribute("width", g.w),
                d.setAttribute("height", g.h),
                d.appendChild(this.shapesContainer),
                this.layerElement.appendChild(d)
            }
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0),
            this.filterUniqueShapes(),
            this.shapeCont = d
        }
        ,
        HShapeElement.prototype.getTransformedPoint = function(d, g) {
            var b, _ = d.length;
            for (b = 0; b < _; b += 1)
                g = d[b].mProps.v.applyToPointArray(g[0], g[1], 0);
            return g
        }
        ,
        HShapeElement.prototype.calculateShapeBoundingBox = function(d, g) {
            var b = d.sh.v, _ = d.transformers, $, et = b._length, tt, rt, nt, it;
            if (!(et <= 1)) {
                for ($ = 0; $ < et - 1; $ += 1)
                    tt = this.getTransformedPoint(_, b.v[$]),
                    rt = this.getTransformedPoint(_, b.o[$]),
                    nt = this.getTransformedPoint(_, b.i[$ + 1]),
                    it = this.getTransformedPoint(_, b.v[$ + 1]),
                    this.checkBounds(tt, rt, nt, it, g);
                b.c && (tt = this.getTransformedPoint(_, b.v[$]),
                rt = this.getTransformedPoint(_, b.o[$]),
                nt = this.getTransformedPoint(_, b.i[0]),
                it = this.getTransformedPoint(_, b.v[0]),
                this.checkBounds(tt, rt, nt, it, g))
            }
        }
        ,
        HShapeElement.prototype.checkBounds = function(d, g, b, _, $) {
            this.getBoundsOfCurve(d, g, b, _);
            var et = this.shapeBoundingBox;
            $.x = bmMin(et.left, $.x),
            $.xMax = bmMax(et.right, $.xMax),
            $.y = bmMin(et.top, $.y),
            $.yMax = bmMax(et.bottom, $.yMax)
        }
        ,
        HShapeElement.prototype.shapeBoundingBox = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        },
        HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
        },
        HShapeElement.prototype.getBoundsOfCurve = function(d, g, b, _) {
            for (var $ = [[d[0], _[0]], [d[1], _[1]]], et, tt, rt, nt, it, ot, at, st = 0; st < 2; ++st)
                tt = 6 * d[st] - 12 * g[st] + 6 * b[st],
                et = -3 * d[st] + 9 * g[st] - 9 * b[st] + 3 * _[st],
                rt = 3 * g[st] - 3 * d[st],
                tt |= 0,
                et |= 0,
                rt |= 0,
                et === 0 && tt === 0 || (et === 0 ? (nt = -rt / tt,
                nt > 0 && nt < 1 && $[st].push(this.calculateF(nt, d, g, b, _, st))) : (it = tt * tt - 4 * rt * et,
                it >= 0 && (ot = (-tt + bmSqrt(it)) / (2 * et),
                ot > 0 && ot < 1 && $[st].push(this.calculateF(ot, d, g, b, _, st)),
                at = (-tt - bmSqrt(it)) / (2 * et),
                at > 0 && at < 1 && $[st].push(this.calculateF(at, d, g, b, _, st)))));
            this.shapeBoundingBox.left = bmMin.apply(null, $[0]),
            this.shapeBoundingBox.top = bmMin.apply(null, $[1]),
            this.shapeBoundingBox.right = bmMax.apply(null, $[0]),
            this.shapeBoundingBox.bottom = bmMax.apply(null, $[1])
        }
        ,
        HShapeElement.prototype.calculateF = function(d, g, b, _, $, et) {
            return bmPow(1 - d, 3) * g[et] + 3 * bmPow(1 - d, 2) * d * b[et] + 3 * (1 - d) * bmPow(d, 2) * _[et] + bmPow(d, 3) * $[et]
        }
        ,
        HShapeElement.prototype.calculateBoundingBox = function(d, g) {
            var b, _ = d.length;
            for (b = 0; b < _; b += 1)
                d[b] && d[b].sh ? this.calculateShapeBoundingBox(d[b], g) : d[b] && d[b].it ? this.calculateBoundingBox(d[b].it, g) : d[b] && d[b].style && d[b].w && this.expandStrokeBoundingBox(d[b].w, g)
        }
        ,
        HShapeElement.prototype.expandStrokeBoundingBox = function(d, g) {
            var b = 0;
            if (d.keyframes) {
                for (var _ = 0; _ < d.keyframes.length; _ += 1) {
                    var $ = d.keyframes[_].s;
                    $ > b && (b = $)
                }
                b *= d.mult
            } else
                b = d.v * d.mult;
            g.x -= b,
            g.xMax += b,
            g.y -= b,
            g.yMax += b
        }
        ,
        HShapeElement.prototype.currentBoxContains = function(d) {
            return this.currentBBox.x <= d.x && this.currentBBox.y <= d.y && this.currentBBox.width + this.currentBBox.x >= d.x + d.width && this.currentBBox.height + this.currentBBox.y >= d.y + d.height
        }
        ,
        HShapeElement.prototype.renderInnerContent = function() {
            if (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf)) {
                var d = this.tempBoundingBox
                  , g = 999999;
                if (d.x = g,
                d.xMax = -g,
                d.y = g,
                d.yMax = -g,
                this.calculateBoundingBox(this.itemsData, d),
                d.width = d.xMax < d.x ? 0 : d.xMax - d.x,
                d.height = d.yMax < d.y ? 0 : d.yMax - d.y,
                this.currentBoxContains(d))
                    return;
                var b = !1;
                if (this.currentBBox.w !== d.width && (this.currentBBox.w = d.width,
                this.shapeCont.setAttribute("width", d.width),
                b = !0),
                this.currentBBox.h !== d.height && (this.currentBBox.h = d.height,
                this.shapeCont.setAttribute("height", d.height),
                b = !0),
                b || this.currentBBox.x !== d.x || this.currentBBox.y !== d.y) {
                    this.currentBBox.w = d.width,
                    this.currentBBox.h = d.height,
                    this.currentBBox.x = d.x,
                    this.currentBBox.y = d.y,
                    this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
                    var _ = this.shapeCont.style
                      , $ = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                    _.transform = $,
                    _.webkitTransform = $
                }
            }
        }
        ;
        function HTextElement(d, g, b) {
            this.textSpans = [],
            this.textPaths = [],
            this.currentBBox = {
                x: 999999,
                y: -999999,
                h: 0,
                w: 0
            },
            this.renderType = "svg",
            this.isMasked = !1,
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement),
        HTextElement.prototype.createContent = function() {
            if (this.isMasked = this.checkMasks(),
            this.isMasked) {
                this.renderType = "svg",
                this.compW = this.comp.data.w,
                this.compH = this.comp.data.h,
                this.svgElement.setAttribute("width", this.compW),
                this.svgElement.setAttribute("height", this.compH);
                var d = createNS("g");
                this.maskedElement.appendChild(d),
                this.innerElem = d
            } else
                this.renderType = "html",
                this.innerElem = this.layerElement;
            this.checkParenting()
        }
        ,
        HTextElement.prototype.buildNewText = function() {
            var d = this.textProperty.currentData;
            this.renderedLetters = createSizedArray(d.l ? d.l.length : 0);
            var g = this.innerElem.style
              , b = d.fc ? this.buildColor(d.fc) : "rgba(0,0,0,0)";
            g.fill = b,
            g.color = b,
            d.sc && (g.stroke = this.buildColor(d.sc),
            g.strokeWidth = d.sw + "px");
            var _ = this.globalData.fontManager.getFontByName(d.f);
            if (!this.globalData.fontManager.chars)
                if (g.fontSize = d.finalSize + "px",
                g.lineHeight = d.finalSize + "px",
                _.fClass)
                    this.innerElem.className = _.fClass;
                else {
                    g.fontFamily = _.fFamily;
                    var $ = d.fWeight
                      , et = d.fStyle;
                    g.fontStyle = et,
                    g.fontWeight = $
                }
            var tt, rt, nt = d.l;
            rt = nt.length;
            var it, ot, at, st = this.mHelper, dt, ft = "", ht = 0;
            for (tt = 0; tt < rt; tt += 1) {
                if (this.globalData.fontManager.chars ? (this.textPaths[ht] ? it = this.textPaths[ht] : (it = createNS("path"),
                it.setAttribute("stroke-linecap", lineCapEnum[1]),
                it.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                it.setAttribute("stroke-miterlimit", "4")),
                this.isMasked || (this.textSpans[ht] ? (ot = this.textSpans[ht],
                at = ot.children[0]) : (ot = createTag("div"),
                ot.style.lineHeight = 0,
                at = createNS("svg"),
                at.appendChild(it),
                styleDiv(ot)))) : this.isMasked ? it = this.textPaths[ht] ? this.textPaths[ht] : createNS("text") : this.textSpans[ht] ? (ot = this.textSpans[ht],
                it = this.textPaths[ht]) : (ot = createTag("span"),
                styleDiv(ot),
                it = createTag("span"),
                styleDiv(it),
                ot.appendChild(it)),
                this.globalData.fontManager.chars) {
                    var xt = this.globalData.fontManager.getCharData(d.finalText[tt], _.fStyle, this.globalData.fontManager.getFontByName(d.f).fFamily), lt;
                    if (xt ? lt = xt.data : lt = null,
                    st.reset(),
                    lt && lt.shapes && lt.shapes.length && (dt = lt.shapes[0].it,
                    st.scale(d.finalSize / 100, d.finalSize / 100),
                    ft = this.createPathShape(st, dt),
                    it.setAttribute("d", ft)),
                    this.isMasked)
                        this.innerElem.appendChild(it);
                    else {
                        if (this.innerElem.appendChild(ot),
                        lt && lt.shapes) {
                            document.body.appendChild(at);
                            var ct = at.getBBox();
                            at.setAttribute("width", ct.width + 2),
                            at.setAttribute("height", ct.height + 2),
                            at.setAttribute("viewBox", ct.x - 1 + " " + (ct.y - 1) + " " + (ct.width + 2) + " " + (ct.height + 2));
                            var ut = at.style
                              , pt = "translate(" + (ct.x - 1) + "px," + (ct.y - 1) + "px)";
                            ut.transform = pt,
                            ut.webkitTransform = pt,
                            nt[tt].yOffset = ct.y - 1
                        } else
                            at.setAttribute("width", 1),
                            at.setAttribute("height", 1);
                        ot.appendChild(at)
                    }
                } else if (it.textContent = nt[tt].val,
                it.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"),
                this.isMasked)
                    this.innerElem.appendChild(it);
                else {
                    this.innerElem.appendChild(ot);
                    var vt = it.style
                      , _t = "translate3d(0," + -d.finalSize / 1.2 + "px,0)";
                    vt.transform = _t,
                    vt.webkitTransform = _t
                }
                this.isMasked ? this.textSpans[ht] = it : this.textSpans[ht] = ot,
                this.textSpans[ht].style.display = "block",
                this.textPaths[ht] = it,
                ht += 1
            }
            for (; ht < this.textSpans.length; )
                this.textSpans[ht].style.display = "none",
                ht += 1
        }
        ,
        HTextElement.prototype.renderInnerContent = function() {
            this.validateText();
            var d;
            if (this.data.singleShape) {
                if (!this._isFirstFrame && !this.lettersChangedFlag)
                    return;
                if (this.isMasked && this.finalTransform._matMdf) {
                    this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH),
                    d = this.svgElement.style;
                    var g = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
                    d.transform = g,
                    d.webkitTransform = g
                }
            }
            if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag),
            !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
                var b, _, $ = 0, et = this.textAnimator.renderedLetters, tt = this.textProperty.currentData.l;
                _ = tt.length;
                var rt, nt, it;
                for (b = 0; b < _; b += 1)
                    tt[b].n ? $ += 1 : (nt = this.textSpans[b],
                    it = this.textPaths[b],
                    rt = et[$],
                    $ += 1,
                    rt._mdf.m && (this.isMasked ? nt.setAttribute("transform", rt.m) : (nt.style.webkitTransform = rt.m,
                    nt.style.transform = rt.m)),
                    nt.style.opacity = rt.o,
                    rt.sw && rt._mdf.sw && it.setAttribute("stroke-width", rt.sw),
                    rt.sc && rt._mdf.sc && it.setAttribute("stroke", rt.sc),
                    rt.fc && rt._mdf.fc && (it.setAttribute("fill", rt.fc),
                    it.style.color = rt.fc));
                if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                    var ot = this.innerElem.getBBox();
                    this.currentBBox.w !== ot.width && (this.currentBBox.w = ot.width,
                    this.svgElement.setAttribute("width", ot.width)),
                    this.currentBBox.h !== ot.height && (this.currentBBox.h = ot.height,
                    this.svgElement.setAttribute("height", ot.height));
                    var at = 1;
                    if (this.currentBBox.w !== ot.width + at * 2 || this.currentBBox.h !== ot.height + at * 2 || this.currentBBox.x !== ot.x - at || this.currentBBox.y !== ot.y - at) {
                        this.currentBBox.w = ot.width + at * 2,
                        this.currentBBox.h = ot.height + at * 2,
                        this.currentBBox.x = ot.x - at,
                        this.currentBBox.y = ot.y - at,
                        this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h),
                        d = this.svgElement.style;
                        var st = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
                        d.transform = st,
                        d.webkitTransform = st
                    }
                }
            }
        }
        ;
        function HCameraElement(d, g, b) {
            this.initFrame(),
            this.initBaseData(d, g, b),
            this.initHierarchy();
            var _ = PropertyFactory.getProp;
            if (this.pe = _(this, d.pe, 0, 0, this),
            d.ks.p.s ? (this.px = _(this, d.ks.p.x, 1, 0, this),
            this.py = _(this, d.ks.p.y, 1, 0, this),
            this.pz = _(this, d.ks.p.z, 1, 0, this)) : this.p = _(this, d.ks.p, 1, 0, this),
            d.ks.a && (this.a = _(this, d.ks.a, 1, 0, this)),
            d.ks.or.k.length && d.ks.or.k[0].to) {
                var $, et = d.ks.or.k.length;
                for ($ = 0; $ < et; $ += 1)
                    d.ks.or.k[$].to = null,
                    d.ks.or.k[$].ti = null
            }
            this.or = _(this, d.ks.or, 1, degToRads, this),
            this.or.sh = !0,
            this.rx = _(this, d.ks.rx, 0, degToRads, this),
            this.ry = _(this, d.ks.ry, 0, degToRads, this),
            this.rz = _(this, d.ks.rz, 0, degToRads, this),
            this.mat = new Matrix,
            this._prevMat = new Matrix,
            this._isFirstFrame = !0,
            this.finalTransform = {
                mProp: this
            }
        }
        extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
        HCameraElement.prototype.setup = function() {
            var d, g = this.comp.threeDElements.length, b, _, $;
            for (d = 0; d < g; d += 1)
                if (b = this.comp.threeDElements[d],
                b.type === "3d") {
                    _ = b.perspectiveElem.style,
                    $ = b.container.style;
                    var et = this.pe.v + "px"
                      , tt = "0px 0px 0px"
                      , rt = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                    _.perspective = et,
                    _.webkitPerspective = et,
                    $.transformOrigin = tt,
                    $.mozTransformOrigin = tt,
                    $.webkitTransformOrigin = tt,
                    _.transform = rt,
                    _.webkitTransform = rt
                }
        }
        ,
        HCameraElement.prototype.createElements = function() {}
        ,
        HCameraElement.prototype.hide = function() {}
        ,
        HCameraElement.prototype.renderFrame = function() {
            var d = this._isFirstFrame, g, b;
            if (this.hierarchy)
                for (b = this.hierarchy.length,
                g = 0; g < b; g += 1)
                    d = this.hierarchy[g].finalTransform.mProp._mdf || d;
            if (d || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
                if (this.mat.reset(),
                this.hierarchy)
                    for (b = this.hierarchy.length - 1,
                    g = b; g >= 0; g -= 1) {
                        var _ = this.hierarchy[g].finalTransform.mProp;
                        this.mat.translate(-_.p.v[0], -_.p.v[1], _.p.v[2]),
                        this.mat.rotateX(-_.or.v[0]).rotateY(-_.or.v[1]).rotateZ(_.or.v[2]),
                        this.mat.rotateX(-_.rx.v).rotateY(-_.ry.v).rotateZ(_.rz.v),
                        this.mat.scale(1 / _.s.v[0], 1 / _.s.v[1], 1 / _.s.v[2]),
                        this.mat.translate(_.a.v[0], _.a.v[1], _.a.v[2])
                    }
                if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a) {
                    var $;
                    this.p ? $ = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : $ = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
                    var et = Math.sqrt(Math.pow($[0], 2) + Math.pow($[1], 2) + Math.pow($[2], 2))
                      , tt = [$[0] / et, $[1] / et, $[2] / et]
                      , rt = Math.sqrt(tt[2] * tt[2] + tt[0] * tt[0])
                      , nt = Math.atan2(tt[1], rt)
                      , it = Math.atan2(tt[0], -tt[2]);
                    this.mat.rotateY(it).rotateX(-nt)
                }
                this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0),
                this.mat.translate(0, 0, this.pe.v);
                var ot = !this._prevMat.equals(this.mat);
                if ((ot || this.pe._mdf) && this.comp.threeDElements) {
                    b = this.comp.threeDElements.length;
                    var at, st, dt;
                    for (g = 0; g < b; g += 1)
                        if (at = this.comp.threeDElements[g],
                        at.type === "3d") {
                            if (ot) {
                                var ft = this.mat.toCSS();
                                dt = at.container.style,
                                dt.transform = ft,
                                dt.webkitTransform = ft
                            }
                            this.pe._mdf && (st = at.perspectiveElem.style,
                            st.perspective = this.pe.v + "px",
                            st.webkitPerspective = this.pe.v + "px")
                        }
                    this.mat.clone(this._prevMat)
                }
            }
            this._isFirstFrame = !1
        }
        ,
        HCameraElement.prototype.prepareFrame = function(d) {
            this.prepareProperties(d, !0)
        }
        ,
        HCameraElement.prototype.destroy = function() {}
        ,
        HCameraElement.prototype.getBaseElement = function() {
            return null
        }
        ;
        function HImageElement(d, g, b) {
            this.assetData = g.getAssetData(d.refId),
            this.initElement(d, g, b)
        }
        extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement),
        HImageElement.prototype.createContent = function() {
            var d = this.globalData.getAssetsPath(this.assetData)
              , g = new Image;
            this.data.hasMask ? (this.imageElem = createNS("image"),
            this.imageElem.setAttribute("width", this.assetData.w + "px"),
            this.imageElem.setAttribute("height", this.assetData.h + "px"),
            this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", d),
            this.layerElement.appendChild(this.imageElem),
            this.baseElement.setAttribute("width", this.assetData.w),
            this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(g),
            g.crossOrigin = "anonymous",
            g.src = d,
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        }
        ;
        function HybridRendererBase(d, g) {
            this.animationItem = d,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: g && g.className || "",
                imagePreserveAspectRatio: g && g.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(g && g.hideOnTransparent === !1),
                filterSize: {
                    width: g && g.filterSize && g.filterSize.width || "400%",
                    height: g && g.filterSize && g.filterSize.height || "400%",
                    x: g && g.filterSize && g.filterSize.x || "-100%",
                    y: g && g.filterSize && g.filterSize.y || "-100%"
                }
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([BaseRenderer], HybridRendererBase),
        HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem,
        HybridRendererBase.prototype.checkPendingElements = function() {
            for (; this.pendingElements.length; ) {
                var d = this.pendingElements.pop();
                d.checkParenting()
            }
        }
        ,
        HybridRendererBase.prototype.appendElementInPos = function(d, g) {
            var b = d.getBaseElement();
            if (b) {
                var _ = this.layers[g];
                if (!_.ddd || !this.supports3d)
                    if (this.threeDElements)
                        this.addTo3dContainer(b, g);
                    else {
                        for (var $ = 0, et, tt, rt; $ < g; )
                            this.elements[$] && this.elements[$] !== !0 && this.elements[$].getBaseElement && (tt = this.elements[$],
                            rt = this.layers[$].ddd ? this.getThreeDContainerByPos($) : tt.getBaseElement(),
                            et = rt || et),
                            $ += 1;
                        et ? (!_.ddd || !this.supports3d) && this.layerElement.insertBefore(b, et) : (!_.ddd || !this.supports3d) && this.layerElement.appendChild(b)
                    }
                else
                    this.addTo3dContainer(b, g)
            }
        }
        ,
        HybridRendererBase.prototype.createShape = function(d) {
            return this.supports3d ? new HShapeElement(d,this.globalData,this) : new SVGShapeElement(d,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createText = function(d) {
            return this.supports3d ? new HTextElement(d,this.globalData,this) : new SVGTextLottieElement(d,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createCamera = function(d) {
            return this.camera = new HCameraElement(d,this.globalData,this),
            this.camera
        }
        ,
        HybridRendererBase.prototype.createImage = function(d) {
            return this.supports3d ? new HImageElement(d,this.globalData,this) : new IImageElement(d,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createSolid = function(d) {
            return this.supports3d ? new HSolidElement(d,this.globalData,this) : new ISolidElement(d,this.globalData,this)
        }
        ,
        HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull,
        HybridRendererBase.prototype.getThreeDContainerByPos = function(d) {
            for (var g = 0, b = this.threeDElements.length; g < b; ) {
                if (this.threeDElements[g].startPos <= d && this.threeDElements[g].endPos >= d)
                    return this.threeDElements[g].perspectiveElem;
                g += 1
            }
            return null
        }
        ,
        HybridRendererBase.prototype.createThreeDContainer = function(d, g) {
            var b = createTag("div"), _, $;
            styleDiv(b);
            var et = createTag("div");
            if (styleDiv(et),
            g === "3d") {
                _ = b.style,
                _.width = this.globalData.compSize.w + "px",
                _.height = this.globalData.compSize.h + "px";
                var tt = "50% 50%";
                _.webkitTransformOrigin = tt,
                _.mozTransformOrigin = tt,
                _.transformOrigin = tt,
                $ = et.style;
                var rt = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
                $.transform = rt,
                $.webkitTransform = rt
            }
            b.appendChild(et);
            var nt = {
                container: et,
                perspectiveElem: b,
                startPos: d,
                endPos: d,
                type: g
            };
            return this.threeDElements.push(nt),
            nt
        }
        ,
        HybridRendererBase.prototype.build3dContainers = function() {
            var d, g = this.layers.length, b, _ = "";
            for (d = 0; d < g; d += 1)
                this.layers[d].ddd && this.layers[d].ty !== 3 ? (_ !== "3d" && (_ = "3d",
                b = this.createThreeDContainer(d, "3d")),
                b.endPos = Math.max(b.endPos, d)) : (_ !== "2d" && (_ = "2d",
                b = this.createThreeDContainer(d, "2d")),
                b.endPos = Math.max(b.endPos, d));
            for (g = this.threeDElements.length,
            d = g - 1; d >= 0; d -= 1)
                this.resizerElem.appendChild(this.threeDElements[d].perspectiveElem)
        }
        ,
        HybridRendererBase.prototype.addTo3dContainer = function(d, g) {
            for (var b = 0, _ = this.threeDElements.length; b < _; ) {
                if (g <= this.threeDElements[b].endPos) {
                    for (var $ = this.threeDElements[b].startPos, et; $ < g; )
                        this.elements[$] && this.elements[$].getBaseElement && (et = this.elements[$].getBaseElement()),
                        $ += 1;
                    et ? this.threeDElements[b].container.insertBefore(d, et) : this.threeDElements[b].container.appendChild(d);
                    break
                }
                b += 1
            }
        }
        ,
        HybridRendererBase.prototype.configAnimation = function(d) {
            var g = createTag("div")
              , b = this.animationItem.wrapper
              , _ = g.style;
            _.width = d.w + "px",
            _.height = d.h + "px",
            this.resizerElem = g,
            styleDiv(g),
            _.transformStyle = "flat",
            _.mozTransformStyle = "flat",
            _.webkitTransformStyle = "flat",
            this.renderConfig.className && g.setAttribute("class", this.renderConfig.className),
            b.appendChild(g),
            _.overflow = "hidden";
            var $ = createNS("svg");
            $.setAttribute("width", "1"),
            $.setAttribute("height", "1"),
            styleDiv($),
            this.resizerElem.appendChild($);
            var et = createNS("defs");
            $.appendChild(et),
            this.data = d,
            this.setupGlobalData(d, $),
            this.globalData.defs = et,
            this.layers = d.layers,
            this.layerElement = this.resizerElem,
            this.build3dContainers(),
            this.updateContainerSize()
        }
        ,
        HybridRendererBase.prototype.destroy = function() {
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""),
            this.animationItem.container = null,
            this.globalData.defs = null;
            var d, g = this.layers ? this.layers.length : 0;
            for (d = 0; d < g; d += 1)
                this.elements[d] && this.elements[d].destroy && this.elements[d].destroy();
            this.elements.length = 0,
            this.destroyed = !0,
            this.animationItem = null
        }
        ,
        HybridRendererBase.prototype.updateContainerSize = function() {
            var d = this.animationItem.wrapper.offsetWidth, g = this.animationItem.wrapper.offsetHeight, b = d / g, _ = this.globalData.compSize.w / this.globalData.compSize.h, $, et, tt, rt;
            _ > b ? ($ = d / this.globalData.compSize.w,
            et = d / this.globalData.compSize.w,
            tt = 0,
            rt = (g - this.globalData.compSize.h * (d / this.globalData.compSize.w)) / 2) : ($ = g / this.globalData.compSize.h,
            et = g / this.globalData.compSize.h,
            tt = (d - this.globalData.compSize.w * (g / this.globalData.compSize.h)) / 2,
            rt = 0);
            var nt = this.resizerElem.style;
            nt.webkitTransform = "matrix3d(" + $ + ",0,0,0,0," + et + ",0,0,0,0,1,0," + tt + "," + rt + ",0,1)",
            nt.transform = nt.webkitTransform
        }
        ,
        HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame,
        HybridRendererBase.prototype.hide = function() {
            this.resizerElem.style.display = "none"
        }
        ,
        HybridRendererBase.prototype.show = function() {
            this.resizerElem.style.display = "block"
        }
        ,
        HybridRendererBase.prototype.initItems = function() {
            if (this.buildAllItems(),
            this.camera)
                this.camera.setup();
            else {
                var d = this.globalData.compSize.w, g = this.globalData.compSize.h, b, _ = this.threeDElements.length;
                for (b = 0; b < _; b += 1) {
                    var $ = this.threeDElements[b].perspectiveElem.style;
                    $.webkitPerspective = Math.sqrt(Math.pow(d, 2) + Math.pow(g, 2)) + "px",
                    $.perspective = $.webkitPerspective
                }
            }
        }
        ,
        HybridRendererBase.prototype.searchExtraCompositions = function(d) {
            var g, b = d.length, _ = createTag("div");
            for (g = 0; g < b; g += 1)
                if (d[g].xt) {
                    var $ = this.createComp(d[g], _, this.globalData.comp, null);
                    $.initExpressions(),
                    this.globalData.projectInterface.registerComposition($)
                }
        }
        ;
        function HCompElement(d, g, b) {
            this.layers = d.layers,
            this.supports3d = !d.hasMask,
            this.completeLayers = !1,
            this.pendingElements = [],
            this.elements = this.layers ? createSizedArray(this.layers.length) : [],
            this.initElement(d, g, b),
            this.tm = d.tm ? PropertyFactory.getProp(this, d.tm, 0, g.frameRate, this) : {
                _placeholder: !0
            }
        }
        extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement),
        HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements,
        HCompElement.prototype.createContainerElements = function() {
            this._createBaseContainerElements(),
            this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w),
            this.svgElement.setAttribute("height", this.data.h),
            this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement
        }
        ,
        HCompElement.prototype.addTo3dContainer = function(d, g) {
            for (var b = 0, _; b < g; )
                this.elements[b] && this.elements[b].getBaseElement && (_ = this.elements[b].getBaseElement()),
                b += 1;
            _ ? this.layerElement.insertBefore(d, _) : this.layerElement.appendChild(d)
        }
        ,
        HCompElement.prototype.createComp = function(d) {
            return this.supports3d ? new HCompElement(d,this.globalData,this) : new SVGCompElement(d,this.globalData,this)
        }
        ;
        function HybridRenderer(d, g) {
            this.animationItem = d,
            this.layers = null,
            this.renderedFrame = -1,
            this.renderConfig = {
                className: g && g.className || "",
                imagePreserveAspectRatio: g && g.imagePreserveAspectRatio || "xMidYMid slice",
                hideOnTransparent: !(g && g.hideOnTransparent === !1),
                filterSize: {
                    width: g && g.filterSize && g.filterSize.width || "400%",
                    height: g && g.filterSize && g.filterSize.height || "400%",
                    x: g && g.filterSize && g.filterSize.x || "-100%",
                    y: g && g.filterSize && g.filterSize.y || "-100%"
                },
                runExpressions: !g || g.runExpressions === void 0 || g.runExpressions
            },
            this.globalData = {
                _mdf: !1,
                frameNum: -1,
                renderConfig: this.renderConfig
            },
            this.pendingElements = [],
            this.elements = [],
            this.threeDElements = [],
            this.destroyed = !1,
            this.camera = null,
            this.supports3d = !0,
            this.rendererType = "html"
        }
        extendPrototype([HybridRendererBase], HybridRenderer),
        HybridRenderer.prototype.createComp = function(d) {
            return this.supports3d ? new HCompElement(d,this.globalData,this) : new SVGCompElement(d,this.globalData,this)
        }
        ;
        var CompExpressionInterface = function() {
            return function(d) {
                function g(b) {
                    for (var _ = 0, $ = d.layers.length; _ < $; ) {
                        if (d.layers[_].nm === b || d.layers[_].ind === b)
                            return d.elements[_].layerInterface;
                        _ += 1
                    }
                    return null
                }
                return Object.defineProperty(g, "_name", {
                    value: d.data.nm
                }),
                g.layer = g,
                g.pixelAspect = 1,
                g.height = d.data.h || d.globalData.compSize.h,
                g.width = d.data.w || d.globalData.compSize.w,
                g.pixelAspect = 1,
                g.frameDuration = 1 / d.globalData.frameRate,
                g.displayStartTime = 0,
                g.numLayers = d.layers.length,
                g
            }
        }();
        function _typeof$2(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(b) {
                return typeof b
            }
            : _typeof$2 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$2(d)
        }
        function seedRandom(d, g) {
            var b = this, _ = 256, $ = 6, et = 52, tt = "random", rt = g.pow(_, $), nt = g.pow(2, et), it = nt * 2, ot = _ - 1, at;
            function st(ut, pt, vt) {
                var _t = [];
                pt = pt === !0 ? {
                    entropy: !0
                } : pt || {};
                var Pt = xt(ht(pt.entropy ? [ut, ct(d)] : ut === null ? lt() : ut, 3), _t)
                  , kt = new dt(_t)
                  , $t = function() {
                    for (var Ht = kt.g($), Dt = rt, Vt = 0; Ht < nt; )
                        Ht = (Ht + Vt) * _,
                        Dt *= _,
                        Vt = kt.g(1);
                    for (; Ht >= it; )
                        Ht /= 2,
                        Dt /= 2,
                        Vt >>>= 1;
                    return (Ht + Vt) / Dt
                };
                return $t.int32 = function() {
                    return kt.g(4) | 0
                }
                ,
                $t.quick = function() {
                    return kt.g(4) / 4294967296
                }
                ,
                $t.double = $t,
                xt(ct(kt.S), d),
                (pt.pass || vt || function(Wt, Ht, Dt, Vt) {
                    return Vt && (Vt.S && ft(Vt, kt),
                    Wt.state = function() {
                        return ft(kt, {})
                    }
                    ),
                    Dt ? (g[tt] = Wt,
                    Ht) : Wt
                }
                )($t, Pt, "global"in pt ? pt.global : this == g, pt.state)
            }
            g["seed" + tt] = st;
            function dt(ut) {
                var pt, vt = ut.length, _t = this, Pt = 0, kt = _t.i = _t.j = 0, $t = _t.S = [];
                for (vt || (ut = [vt++]); Pt < _; )
                    $t[Pt] = Pt++;
                for (Pt = 0; Pt < _; Pt++)
                    $t[Pt] = $t[kt = ot & kt + ut[Pt % vt] + (pt = $t[Pt])],
                    $t[kt] = pt;
                _t.g = function(Wt) {
                    for (var Ht, Dt = 0, Vt = _t.i, Ft = _t.j, Kt = _t.S; Wt--; )
                        Ht = Kt[Vt = ot & Vt + 1],
                        Dt = Dt * _ + Kt[ot & (Kt[Vt] = Kt[Ft = ot & Ft + Ht]) + (Kt[Ft] = Ht)];
                    return _t.i = Vt,
                    _t.j = Ft,
                    Dt
                }
            }
            function ft(ut, pt) {
                return pt.i = ut.i,
                pt.j = ut.j,
                pt.S = ut.S.slice(),
                pt
            }
            function ht(ut, pt) {
                var vt = [], _t = _typeof$2(ut), Pt;
                if (pt && _t == "object")
                    for (Pt in ut)
                        try {
                            vt.push(ht(ut[Pt], pt - 1))
                        } catch {}
                return vt.length ? vt : _t == "string" ? ut : ut + "\0"
            }
            function xt(ut, pt) {
                for (var vt = ut + "", _t, Pt = 0; Pt < vt.length; )
                    pt[ot & Pt] = ot & (_t ^= pt[ot & Pt] * 19) + vt.charCodeAt(Pt++);
                return ct(pt)
            }
            function lt() {
                try {
                    var ut = new Uint8Array(_);
                    return (b.crypto || b.msCrypto).getRandomValues(ut),
                    ct(ut)
                } catch {
                    var pt = b.navigator
                      , vt = pt && pt.plugins;
                    return [+new Date, b, vt, b.screen, ct(d)]
                }
            }
            function ct(ut) {
                return String.fromCharCode.apply(0, ut)
            }
            xt(g.random(), d)
        }
        function initialize$2(d) {
            seedRandom([], d)
        }
        var propTypes = {
            SHAPE: "shape"
        };
        function _typeof$1(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(b) {
                return typeof b
            }
            : _typeof$1 = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof$1(d)
        }
        var ExpressionManager = function() {
            var ob = {}
              , Math = BMMath
              , window = null
              , document = null
              , XMLHttpRequest = null
              , fetch = null
              , frames = null
              , _lottieGlobal = {};
            initialize$2(BMMath);
            function resetFrame() {
                _lottieGlobal = {}
            }
            function $bm_isInstanceOfArray(d) {
                return d.constructor === Array || d.constructor === Float32Array
            }
            function isNumerable(d, g) {
                return d === "number" || g instanceof Number || d === "boolean" || d === "string"
            }
            function $bm_neg(d) {
                var g = _typeof$1(d);
                if (g === "number" || d instanceof Number || g === "boolean")
                    return -d;
                if ($bm_isInstanceOfArray(d)) {
                    var b, _ = d.length, $ = [];
                    for (b = 0; b < _; b += 1)
                        $[b] = -d[b];
                    return $
                }
                return d.propType ? d.v : -d
            }
            var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get
              , easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get
              , easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get;
            function sum(d, g) {
                var b = _typeof$1(d)
                  , _ = _typeof$1(g);
                if (isNumerable(b, d) && isNumerable(_, g) || b === "string" || _ === "string")
                    return d + g;
                if ($bm_isInstanceOfArray(d) && isNumerable(_, g))
                    return d = d.slice(0),
                    d[0] += g,
                    d;
                if (isNumerable(b, d) && $bm_isInstanceOfArray(g))
                    return g = g.slice(0),
                    g[0] = d + g[0],
                    g;
                if ($bm_isInstanceOfArray(d) && $bm_isInstanceOfArray(g)) {
                    for (var $ = 0, et = d.length, tt = g.length, rt = []; $ < et || $ < tt; )
                        (typeof d[$] == "number" || d[$]instanceof Number) && (typeof g[$] == "number" || g[$]instanceof Number) ? rt[$] = d[$] + g[$] : rt[$] = g[$] === void 0 ? d[$] : d[$] || g[$],
                        $ += 1;
                    return rt
                }
                return 0
            }
            var add = sum;
            function sub(d, g) {
                var b = _typeof$1(d)
                  , _ = _typeof$1(g);
                if (isNumerable(b, d) && isNumerable(_, g))
                    return b === "string" && (d = parseInt(d, 10)),
                    _ === "string" && (g = parseInt(g, 10)),
                    d - g;
                if ($bm_isInstanceOfArray(d) && isNumerable(_, g))
                    return d = d.slice(0),
                    d[0] -= g,
                    d;
                if (isNumerable(b, d) && $bm_isInstanceOfArray(g))
                    return g = g.slice(0),
                    g[0] = d - g[0],
                    g;
                if ($bm_isInstanceOfArray(d) && $bm_isInstanceOfArray(g)) {
                    for (var $ = 0, et = d.length, tt = g.length, rt = []; $ < et || $ < tt; )
                        (typeof d[$] == "number" || d[$]instanceof Number) && (typeof g[$] == "number" || g[$]instanceof Number) ? rt[$] = d[$] - g[$] : rt[$] = g[$] === void 0 ? d[$] : d[$] || g[$],
                        $ += 1;
                    return rt
                }
                return 0
            }
            function mul(d, g) {
                var b = _typeof$1(d), _ = _typeof$1(g), $;
                if (isNumerable(b, d) && isNumerable(_, g))
                    return d * g;
                var et, tt;
                if ($bm_isInstanceOfArray(d) && isNumerable(_, g)) {
                    for (tt = d.length,
                    $ = createTypedArray("float32", tt),
                    et = 0; et < tt; et += 1)
                        $[et] = d[et] * g;
                    return $
                }
                if (isNumerable(b, d) && $bm_isInstanceOfArray(g)) {
                    for (tt = g.length,
                    $ = createTypedArray("float32", tt),
                    et = 0; et < tt; et += 1)
                        $[et] = d * g[et];
                    return $
                }
                return 0
            }
            function div(d, g) {
                var b = _typeof$1(d), _ = _typeof$1(g), $;
                if (isNumerable(b, d) && isNumerable(_, g))
                    return d / g;
                var et, tt;
                if ($bm_isInstanceOfArray(d) && isNumerable(_, g)) {
                    for (tt = d.length,
                    $ = createTypedArray("float32", tt),
                    et = 0; et < tt; et += 1)
                        $[et] = d[et] / g;
                    return $
                }
                if (isNumerable(b, d) && $bm_isInstanceOfArray(g)) {
                    for (tt = g.length,
                    $ = createTypedArray("float32", tt),
                    et = 0; et < tt; et += 1)
                        $[et] = d / g[et];
                    return $
                }
                return 0
            }
            function mod(d, g) {
                return typeof d == "string" && (d = parseInt(d, 10)),
                typeof g == "string" && (g = parseInt(g, 10)),
                d % g
            }
            var $bm_sum = sum
              , $bm_sub = sub
              , $bm_mul = mul
              , $bm_div = div
              , $bm_mod = mod;
            function clamp(d, g, b) {
                if (g > b) {
                    var _ = b;
                    b = g,
                    g = _
                }
                return Math.min(Math.max(d, g), b)
            }
            function radiansToDegrees(d) {
                return d / degToRads
            }
            var radians_to_degrees = radiansToDegrees;
            function degreesToRadians(d) {
                return d * degToRads
            }
            var degrees_to_radians = radiansToDegrees
              , helperLengthArray = [0, 0, 0, 0, 0, 0];
            function length(d, g) {
                if (typeof d == "number" || d instanceof Number)
                    return g = g || 0,
                    Math.abs(d - g);
                g || (g = helperLengthArray);
                var b, _ = Math.min(d.length, g.length), $ = 0;
                for (b = 0; b < _; b += 1)
                    $ += Math.pow(g[b] - d[b], 2);
                return Math.sqrt($)
            }
            function normalize(d) {
                return div(d, length(d))
            }
            function rgbToHsl(d) {
                var g = d[0], b = d[1], _ = d[2], $ = Math.max(g, b, _), et = Math.min(g, b, _), tt, rt, nt = ($ + et) / 2;
                if ($ === et)
                    tt = 0,
                    rt = 0;
                else {
                    var it = $ - et;
                    switch (rt = nt > .5 ? it / (2 - $ - et) : it / ($ + et),
                    $) {
                    case g:
                        tt = (b - _) / it + (b < _ ? 6 : 0);
                        break;
                    case b:
                        tt = (_ - g) / it + 2;
                        break;
                    case _:
                        tt = (g - b) / it + 4;
                        break
                    }
                    tt /= 6
                }
                return [tt, rt, nt, d[3]]
            }
            function hue2rgb(d, g, b) {
                return b < 0 && (b += 1),
                b > 1 && (b -= 1),
                b < 1 / 6 ? d + (g - d) * 6 * b : b < 1 / 2 ? g : b < 2 / 3 ? d + (g - d) * (2 / 3 - b) * 6 : d
            }
            function hslToRgb(d) {
                var g = d[0], b = d[1], _ = d[2], $, et, tt;
                if (b === 0)
                    $ = _,
                    tt = _,
                    et = _;
                else {
                    var rt = _ < .5 ? _ * (1 + b) : _ + b - _ * b
                      , nt = 2 * _ - rt;
                    $ = hue2rgb(nt, rt, g + 1 / 3),
                    et = hue2rgb(nt, rt, g),
                    tt = hue2rgb(nt, rt, g - 1 / 3)
                }
                return [$, et, tt, d[3]]
            }
            function linear(d, g, b, _, $) {
                if ((_ === void 0 || $ === void 0) && (_ = g,
                $ = b,
                g = 0,
                b = 1),
                b < g) {
                    var et = b;
                    b = g,
                    g = et
                }
                if (d <= g)
                    return _;
                if (d >= b)
                    return $;
                var tt = b === g ? 0 : (d - g) / (b - g);
                if (!_.length)
                    return _ + ($ - _) * tt;
                var rt, nt = _.length, it = createTypedArray("float32", nt);
                for (rt = 0; rt < nt; rt += 1)
                    it[rt] = _[rt] + ($[rt] - _[rt]) * tt;
                return it
            }
            function random(d, g) {
                if (g === void 0 && (d === void 0 ? (d = 0,
                g = 1) : (g = d,
                d = void 0)),
                g.length) {
                    var b, _ = g.length;
                    d || (d = createTypedArray("float32", _));
                    var $ = createTypedArray("float32", _)
                      , et = BMMath.random();
                    for (b = 0; b < _; b += 1)
                        $[b] = d[b] + et * (g[b] - d[b]);
                    return $
                }
                d === void 0 && (d = 0);
                var tt = BMMath.random();
                return d + tt * (g - d)
            }
            function createPath(d, g, b, _) {
                var $, et = d.length, tt = shapePool.newElement();
                tt.setPathData(!!_, et);
                var rt = [0, 0], nt, it;
                for ($ = 0; $ < et; $ += 1)
                    nt = g && g[$] ? g[$] : rt,
                    it = b && b[$] ? b[$] : rt,
                    tt.setTripleAt(d[$][0], d[$][1], it[0] + d[$][0], it[1] + d[$][1], nt[0] + d[$][0], nt[1] + d[$][1], $, !0);
                return tt
            }
            function initiateExpression(elem, data, property) {
                function noOp(d) {
                    return d
                }
                if (!elem.globalData.renderConfig.runExpressions)
                    return noOp;
                var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
                thisProperty.valueAtTime = thisProperty.getValueAtTime,
                Object.defineProperty(thisProperty, "value", {
                    get: function() {
                        return thisProperty.v
                    }
                }),
                elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate,
                elem.comp.displayStartTime = 0;
                var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function d(g, b) {
                    var _, $, et = this.pv.length ? this.pv.length : 1, tt = createTypedArray("float32", et);
                    g = 5;
                    var rt = Math.floor(time * g);
                    for (_ = 0,
                    $ = 0; _ < rt; ) {
                        for ($ = 0; $ < et; $ += 1)
                            tt[$] += -b + b * 2 * BMMath.random();
                        _ += 1
                    }
                    var nt = time * g
                      , it = nt - Math.floor(nt)
                      , ot = createTypedArray("float32", et);
                    if (et > 1) {
                        for ($ = 0; $ < et; $ += 1)
                            ot[$] = this.pv[$] + tt[$] + (-b + b * 2 * BMMath.random()) * it;
                        return ot
                    }
                    return this.pv + tt[0] + (-b + b * 2 * BMMath.random()) * it
                }
                ).bind(this);
                thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty),
                loop_in = loopIn),
                thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty),
                loop_out = loopOut),
                thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
                function loopInDuration(d, g) {
                    return loopIn(d, g, !0)
                }
                function loopOutDuration(d, g) {
                    return loopOut(d, g, !0)
                }
                this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)),
                this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
                var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
                function lookAt(d, g) {
                    var b = [g[0] - d[0], g[1] - d[1], g[2] - d[2]]
                      , _ = Math.atan2(b[0], Math.sqrt(b[1] * b[1] + b[2] * b[2])) / degToRads
                      , $ = -Math.atan2(b[1], b[2]) / degToRads;
                    return [$, _, 0]
                }
                function easeOut(d, g, b, _, $) {
                    return applyEase(easeOutBez, d, g, b, _, $)
                }
                function easeIn(d, g, b, _, $) {
                    return applyEase(easeInBez, d, g, b, _, $)
                }
                function ease(d, g, b, _, $) {
                    return applyEase(easeInOutBez, d, g, b, _, $)
                }
                function applyEase(d, g, b, _, $, et) {
                    $ === void 0 ? ($ = b,
                    et = _) : g = (g - b) / (_ - b),
                    g > 1 ? g = 1 : g < 0 && (g = 0);
                    var tt = d(g);
                    if ($bm_isInstanceOfArray($)) {
                        var rt, nt = $.length, it = createTypedArray("float32", nt);
                        for (rt = 0; rt < nt; rt += 1)
                            it[rt] = (et[rt] - $[rt]) * tt + $[rt];
                        return it
                    }
                    return (et - $) * tt + $
                }
                function nearestKey(d) {
                    var g, b = data.k.length, _, $;
                    if (!data.k.length || typeof data.k[0] == "number")
                        _ = 0,
                        $ = 0;
                    else if (_ = -1,
                    d *= elem.comp.globalData.frameRate,
                    d < data.k[0].t)
                        _ = 1,
                        $ = data.k[0].t;
                    else {
                        for (g = 0; g < b - 1; g += 1)
                            if (d === data.k[g].t) {
                                _ = g + 1,
                                $ = data.k[g].t;
                                break
                            } else if (d > data.k[g].t && d < data.k[g + 1].t) {
                                d - data.k[g].t > data.k[g + 1].t - d ? (_ = g + 2,
                                $ = data.k[g + 1].t) : (_ = g + 1,
                                $ = data.k[g].t);
                                break
                            }
                        _ === -1 && (_ = g + 1,
                        $ = data.k[g].t)
                    }
                    var et = {};
                    return et.index = _,
                    et.time = $ / elem.comp.globalData.frameRate,
                    et
                }
                function key(d) {
                    var g, b, _;
                    if (!data.k.length || typeof data.k[0] == "number")
                        throw new Error("The property has no keyframe at index " + d);
                    d -= 1,
                    g = {
                        time: data.k[d].t / elem.comp.globalData.frameRate,
                        value: []
                    };
                    var $ = Object.prototype.hasOwnProperty.call(data.k[d], "s") ? data.k[d].s : data.k[d - 1].e;
                    for (_ = $.length,
                    b = 0; b < _; b += 1)
                        g[b] = $[b],
                        g.value[b] = $[b];
                    return g
                }
                function framesToTime(d, g) {
                    return g || (g = elem.comp.globalData.frameRate),
                    d / g
                }
                function timeToFrames(d, g) {
                    return !d && d !== 0 && (d = time),
                    g || (g = elem.comp.globalData.frameRate),
                    d * g
                }
                function seedRandom(d) {
                    BMMath.seedrandom(randSeed + d)
                }
                function sourceRectAtTime() {
                    return elem.sourceRectAtTime()
                }
                function substring(d, g) {
                    return typeof value == "string" ? g === void 0 ? value.substring(d) : value.substring(d, g) : ""
                }
                function substr(d, g) {
                    return typeof value == "string" ? g === void 0 ? value.substr(d) : value.substr(d, g) : ""
                }
                function posterizeTime(d) {
                    time = d === 0 ? 0 : Math.floor(time * d) / d,
                    value = valueAtTime(time)
                }
                var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
                function executeExpression(d) {
                    return value = d,
                    this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex,
                    textTotal = this.textTotal,
                    selectorValue = this.selectorValue),
                    thisLayer || (text = elem.layerInterface.text,
                    thisLayer = elem.layerInterface,
                    thisComp = elem.comp.compInterface,
                    toWorld = thisLayer.toWorld.bind(thisLayer),
                    fromWorld = thisLayer.fromWorld.bind(thisLayer),
                    fromComp = thisLayer.fromComp.bind(thisLayer),
                    toComp = thisLayer.toComp.bind(thisLayer),
                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null,
                    fromCompToSurface = fromComp),
                    transform || (transform = elem.layerInterface("ADBE Transform Group"),
                    $bm_transform = transform,
                    transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    hasParent = !!(elem.hierarchy && elem.hierarchy.length),
                    hasParent && !parent && (parent = elem.hierarchy[0].layerInterface),
                    time = this.comp.renderedFrame / this.comp.globalData.frameRate,
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    this.frameExpressionId = elem.globalData.frameId,
                    scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt,
                    scoped_bm_rt)
                }
                return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData],
                executeExpression
            }
            return ob.initiateExpression = initiateExpression,
            ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal],
            ob.resetFrame = resetFrame,
            ob
        }()
          , Expressions = function() {
            var d = {};
            d.initExpressions = g,
            d.resetFrame = ExpressionManager.resetFrame;
            function g(b) {
                var _ = 0
                  , $ = [];
                function et() {
                    _ += 1
                }
                function tt() {
                    _ -= 1,
                    _ === 0 && nt()
                }
                function rt(it) {
                    $.indexOf(it) === -1 && $.push(it)
                }
                function nt() {
                    var it, ot = $.length;
                    for (it = 0; it < ot; it += 1)
                        $[it].release();
                    $.length = 0
                }
                b.renderer.compInterface = CompExpressionInterface(b.renderer),
                b.renderer.globalData.projectInterface.registerComposition(b.renderer),
                b.renderer.globalData.pushExpression = et,
                b.renderer.globalData.popExpression = tt,
                b.renderer.globalData.registerExpressionProperty = rt
            }
            return d
        }()
          , MaskManagerInterface = function() {
            function d(b, _) {
                this._mask = b,
                this._data = _
            }
            Object.defineProperty(d.prototype, "maskPath", {
                get: function() {
                    return this._mask.prop.k && this._mask.prop.getValue(),
                    this._mask.prop
                }
            }),
            Object.defineProperty(d.prototype, "maskOpacity", {
                get: function() {
                    return this._mask.op.k && this._mask.op.getValue(),
                    this._mask.op.v * 100
                }
            });
            var g = function(_) {
                var $ = createSizedArray(_.viewData.length), et, tt = _.viewData.length;
                for (et = 0; et < tt; et += 1)
                    $[et] = new d(_.viewData[et],_.masksProperties[et]);
                var rt = function(it) {
                    for (et = 0; et < tt; ) {
                        if (_.masksProperties[et].nm === it)
                            return $[et];
                        et += 1
                    }
                    return null
                };
                return rt
            };
            return g
        }()
          , ExpressionPropertyInterface = function() {
            var d = {
                pv: 0,
                v: 0,
                mult: 1
            }
              , g = {
                pv: [0, 0, 0],
                v: [0, 0, 0],
                mult: 1
            };
            function b(tt, rt, nt) {
                Object.defineProperty(tt, "velocity", {
                    get: function() {
                        return rt.getVelocityAtTime(rt.comp.currentFrame)
                    }
                }),
                tt.numKeys = rt.keyframes ? rt.keyframes.length : 0,
                tt.key = function(it) {
                    if (!tt.numKeys)
                        return 0;
                    var ot = "";
                    "s"in rt.keyframes[it - 1] ? ot = rt.keyframes[it - 1].s : "e"in rt.keyframes[it - 2] ? ot = rt.keyframes[it - 2].e : ot = rt.keyframes[it - 2].s;
                    var at = nt === "unidimensional" ? new Number(ot) : Object.assign({}, ot);
                    return at.time = rt.keyframes[it - 1].t / rt.elem.comp.globalData.frameRate,
                    at.value = nt === "unidimensional" ? ot[0] : ot,
                    at
                }
                ,
                tt.valueAtTime = rt.getValueAtTime,
                tt.speedAtTime = rt.getSpeedAtTime,
                tt.velocityAtTime = rt.getVelocityAtTime,
                tt.propertyGroup = rt.propertyGroup
            }
            function _(tt) {
                (!tt || !("pv"in tt)) && (tt = d);
                var rt = 1 / tt.mult
                  , nt = tt.pv * rt
                  , it = new Number(nt);
                return it.value = nt,
                b(it, tt, "unidimensional"),
                function() {
                    return tt.k && tt.getValue(),
                    nt = tt.v * rt,
                    it.value !== nt && (it = new Number(nt),
                    it.value = nt,
                    b(it, tt, "unidimensional")),
                    it
                }
            }
            function $(tt) {
                (!tt || !("pv"in tt)) && (tt = g);
                var rt = 1 / tt.mult
                  , nt = tt.data && tt.data.l || tt.pv.length
                  , it = createTypedArray("float32", nt)
                  , ot = createTypedArray("float32", nt);
                return it.value = ot,
                b(it, tt, "multidimensional"),
                function() {
                    tt.k && tt.getValue();
                    for (var at = 0; at < nt; at += 1)
                        ot[at] = tt.v[at] * rt,
                        it[at] = ot[at];
                    return it
                }
            }
            function et() {
                return d
            }
            return function(tt) {
                return tt ? tt.propType === "unidimensional" ? _(tt) : $(tt) : et
            }
        }()
          , TransformExpressionInterface = function() {
            return function(d) {
                function g(tt) {
                    switch (tt) {
                    case "scale":
                    case "Scale":
                    case "ADBE Scale":
                    case 6:
                        return g.scale;
                    case "rotation":
                    case "Rotation":
                    case "ADBE Rotation":
                    case "ADBE Rotate Z":
                    case 10:
                        return g.rotation;
                    case "ADBE Rotate X":
                        return g.xRotation;
                    case "ADBE Rotate Y":
                        return g.yRotation;
                    case "position":
                    case "Position":
                    case "ADBE Position":
                    case 2:
                        return g.position;
                    case "ADBE Position_0":
                        return g.xPosition;
                    case "ADBE Position_1":
                        return g.yPosition;
                    case "ADBE Position_2":
                        return g.zPosition;
                    case "anchorPoint":
                    case "AnchorPoint":
                    case "Anchor Point":
                    case "ADBE AnchorPoint":
                    case 1:
                        return g.anchorPoint;
                    case "opacity":
                    case "Opacity":
                    case 11:
                        return g.opacity;
                    default:
                        return null
                    }
                }
                Object.defineProperty(g, "rotation", {
                    get: ExpressionPropertyInterface(d.r || d.rz)
                }),
                Object.defineProperty(g, "zRotation", {
                    get: ExpressionPropertyInterface(d.rz || d.r)
                }),
                Object.defineProperty(g, "xRotation", {
                    get: ExpressionPropertyInterface(d.rx)
                }),
                Object.defineProperty(g, "yRotation", {
                    get: ExpressionPropertyInterface(d.ry)
                }),
                Object.defineProperty(g, "scale", {
                    get: ExpressionPropertyInterface(d.s)
                });
                var b, _, $, et;
                return d.p ? et = ExpressionPropertyInterface(d.p) : (b = ExpressionPropertyInterface(d.px),
                _ = ExpressionPropertyInterface(d.py),
                d.pz && ($ = ExpressionPropertyInterface(d.pz))),
                Object.defineProperty(g, "position", {
                    get: function() {
                        return d.p ? et() : [b(), _(), $ ? $() : 0]
                    }
                }),
                Object.defineProperty(g, "xPosition", {
                    get: ExpressionPropertyInterface(d.px)
                }),
                Object.defineProperty(g, "yPosition", {
                    get: ExpressionPropertyInterface(d.py)
                }),
                Object.defineProperty(g, "zPosition", {
                    get: ExpressionPropertyInterface(d.pz)
                }),
                Object.defineProperty(g, "anchorPoint", {
                    get: ExpressionPropertyInterface(d.a)
                }),
                Object.defineProperty(g, "opacity", {
                    get: ExpressionPropertyInterface(d.o)
                }),
                Object.defineProperty(g, "skew", {
                    get: ExpressionPropertyInterface(d.sk)
                }),
                Object.defineProperty(g, "skewAxis", {
                    get: ExpressionPropertyInterface(d.sa)
                }),
                Object.defineProperty(g, "orientation", {
                    get: ExpressionPropertyInterface(d.or)
                }),
                g
            }
        }()
          , LayerExpressionInterface = function() {
            function d(it) {
                var ot = new Matrix;
                if (it !== void 0) {
                    var at = this._elem.finalTransform.mProp.getValueAtTime(it);
                    at.clone(ot)
                } else {
                    var st = this._elem.finalTransform.mProp;
                    st.applyToMatrix(ot)
                }
                return ot
            }
            function g(it, ot) {
                var at = this.getMatrix(ot);
                return at.props[12] = 0,
                at.props[13] = 0,
                at.props[14] = 0,
                this.applyPoint(at, it)
            }
            function b(it, ot) {
                var at = this.getMatrix(ot);
                return this.applyPoint(at, it)
            }
            function _(it, ot) {
                var at = this.getMatrix(ot);
                return at.props[12] = 0,
                at.props[13] = 0,
                at.props[14] = 0,
                this.invertPoint(at, it)
            }
            function $(it, ot) {
                var at = this.getMatrix(ot);
                return this.invertPoint(at, it)
            }
            function et(it, ot) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var at, st = this._elem.hierarchy.length;
                    for (at = 0; at < st; at += 1)
                        this._elem.hierarchy[at].finalTransform.mProp.applyToMatrix(it)
                }
                return it.applyToPointArray(ot[0], ot[1], ot[2] || 0)
            }
            function tt(it, ot) {
                if (this._elem.hierarchy && this._elem.hierarchy.length) {
                    var at, st = this._elem.hierarchy.length;
                    for (at = 0; at < st; at += 1)
                        this._elem.hierarchy[at].finalTransform.mProp.applyToMatrix(it)
                }
                return it.inversePoint(ot)
            }
            function rt(it) {
                var ot = new Matrix;
                if (ot.reset(),
                this._elem.finalTransform.mProp.applyToMatrix(ot),
                this._elem.hierarchy && this._elem.hierarchy.length) {
                    var at, st = this._elem.hierarchy.length;
                    for (at = 0; at < st; at += 1)
                        this._elem.hierarchy[at].finalTransform.mProp.applyToMatrix(ot);
                    return ot.inversePoint(it)
                }
                return ot.inversePoint(it)
            }
            function nt() {
                return [1, 1, 1, 1]
            }
            return function(it) {
                var ot;
                function at(ht) {
                    dt.mask = new MaskManagerInterface(ht,it)
                }
                function st(ht) {
                    dt.effect = ht
                }
                function dt(ht) {
                    switch (ht) {
                    case "ADBE Root Vectors Group":
                    case "Contents":
                    case 2:
                        return dt.shapeInterface;
                    case 1:
                    case 6:
                    case "Transform":
                    case "transform":
                    case "ADBE Transform Group":
                        return ot;
                    case 4:
                    case "ADBE Effect Parade":
                    case "effects":
                    case "Effects":
                        return dt.effect;
                    case "ADBE Text Properties":
                        return dt.textInterface;
                    default:
                        return null
                    }
                }
                dt.getMatrix = d,
                dt.invertPoint = tt,
                dt.applyPoint = et,
                dt.toWorld = b,
                dt.toWorldVec = g,
                dt.fromWorld = $,
                dt.fromWorldVec = _,
                dt.toComp = b,
                dt.fromComp = rt,
                dt.sampleImage = nt,
                dt.sourceRectAtTime = it.sourceRectAtTime.bind(it),
                dt._elem = it,
                ot = TransformExpressionInterface(it.finalTransform.mProp);
                var ft = getDescriptor(ot, "anchorPoint");
                return Object.defineProperties(dt, {
                    hasParent: {
                        get: function() {
                            return it.hierarchy.length
                        }
                    },
                    parent: {
                        get: function() {
                            return it.hierarchy[0].layerInterface
                        }
                    },
                    rotation: getDescriptor(ot, "rotation"),
                    scale: getDescriptor(ot, "scale"),
                    position: getDescriptor(ot, "position"),
                    opacity: getDescriptor(ot, "opacity"),
                    anchorPoint: ft,
                    anchor_point: ft,
                    transform: {
                        get: function() {
                            return ot
                        }
                    },
                    active: {
                        get: function() {
                            return it.isInRange
                        }
                    }
                }),
                dt.startTime = it.data.st,
                dt.index = it.data.ind,
                dt.source = it.data.refId,
                dt.height = it.data.ty === 0 ? it.data.h : 100,
                dt.width = it.data.ty === 0 ? it.data.w : 100,
                dt.inPoint = it.data.ip / it.comp.globalData.frameRate,
                dt.outPoint = it.data.op / it.comp.globalData.frameRate,
                dt._name = it.data.nm,
                dt.registerMaskInterface = at,
                dt.registerEffectsInterface = st,
                dt
            }
        }()
          , propertyGroupFactory = function() {
            return function(d, g) {
                return function(b) {
                    return b = b === void 0 ? 1 : b,
                    b <= 0 ? d : g(b - 1)
                }
            }
        }()
          , PropertyInterface = function() {
            return function(d, g) {
                var b = {
                    _name: d
                };
                function _($) {
                    return $ = $ === void 0 ? 1 : $,
                    $ <= 0 ? b : g($ - 1)
                }
                return _
            }
        }()
          , EffectsExpressionInterface = function() {
            var d = {
                createEffectsInterface: g
            };
            function g($, et) {
                if ($.effectsManager) {
                    var tt = [], rt = $.data.ef, nt, it = $.effectsManager.effectElements.length;
                    for (nt = 0; nt < it; nt += 1)
                        tt.push(b(rt[nt], $.effectsManager.effectElements[nt], et, $));
                    var ot = $.data.ef || []
                      , at = function(dt) {
                        for (nt = 0,
                        it = ot.length; nt < it; ) {
                            if (dt === ot[nt].nm || dt === ot[nt].mn || dt === ot[nt].ix)
                                return tt[nt];
                            nt += 1
                        }
                        return null
                    };
                    return Object.defineProperty(at, "numProperties", {
                        get: function() {
                            return ot.length
                        }
                    }),
                    at
                }
                return null
            }
            function b($, et, tt, rt) {
                function nt(dt) {
                    for (var ft = $.ef, ht = 0, xt = ft.length; ht < xt; ) {
                        if (dt === ft[ht].nm || dt === ft[ht].mn || dt === ft[ht].ix)
                            return ft[ht].ty === 5 ? ot[ht] : ot[ht]();
                        ht += 1
                    }
                    throw new Error
                }
                var it = propertyGroupFactory(nt, tt), ot = [], at, st = $.ef.length;
                for (at = 0; at < st; at += 1)
                    $.ef[at].ty === 5 ? ot.push(b($.ef[at], et.effectElements[at], et.effectElements[at].propertyGroup, rt)) : ot.push(_(et.effectElements[at], $.ef[at].ty, rt, it));
                return $.mn === "ADBE Color Control" && Object.defineProperty(nt, "color", {
                    get: function() {
                        return ot[0]()
                    }
                }),
                Object.defineProperties(nt, {
                    numProperties: {
                        get: function() {
                            return $.np
                        }
                    },
                    _name: {
                        value: $.nm
                    },
                    propertyGroup: {
                        value: it
                    }
                }),
                nt.enabled = $.en !== 0,
                nt.active = nt.enabled,
                nt
            }
            function _($, et, tt, rt) {
                var nt = ExpressionPropertyInterface($.p);
                function it() {
                    return et === 10 ? tt.comp.compInterface($.p.v) : nt()
                }
                return $.p.setGroupProperty && $.p.setGroupProperty(PropertyInterface("", rt)),
                it
            }
            return d
        }()
          , ShapePathInterface = function() {
            return function(g, b, _) {
                var $ = b.sh;
                function et(rt) {
                    return rt === "Shape" || rt === "shape" || rt === "Path" || rt === "path" || rt === "ADBE Vector Shape" || rt === 2 ? et.path : null
                }
                var tt = propertyGroupFactory(et, _);
                return $.setGroupProperty(PropertyInterface("Path", tt)),
                Object.defineProperties(et, {
                    path: {
                        get: function() {
                            return $.k && $.getValue(),
                            $
                        }
                    },
                    shape: {
                        get: function() {
                            return $.k && $.getValue(),
                            $
                        }
                    },
                    _name: {
                        value: g.nm
                    },
                    ix: {
                        value: g.ix
                    },
                    propertyIndex: {
                        value: g.ix
                    },
                    mn: {
                        value: g.mn
                    },
                    propertyGroup: {
                        value: _
                    }
                }),
                et
            }
        }()
          , ShapeExpressionInterface = function() {
            function d(ft, ht, xt) {
                var lt = [], ct, ut = ft ? ft.length : 0;
                for (ct = 0; ct < ut; ct += 1)
                    ft[ct].ty === "gr" ? lt.push(b(ft[ct], ht[ct], xt)) : ft[ct].ty === "fl" ? lt.push(_(ft[ct], ht[ct], xt)) : ft[ct].ty === "st" ? lt.push(tt(ft[ct], ht[ct], xt)) : ft[ct].ty === "tm" ? lt.push(rt(ft[ct], ht[ct], xt)) : ft[ct].ty === "tr" || (ft[ct].ty === "el" ? lt.push(it(ft[ct], ht[ct], xt)) : ft[ct].ty === "sr" ? lt.push(ot(ft[ct], ht[ct], xt)) : ft[ct].ty === "sh" ? lt.push(ShapePathInterface(ft[ct], ht[ct], xt)) : ft[ct].ty === "rc" ? lt.push(at(ft[ct], ht[ct], xt)) : ft[ct].ty === "rd" ? lt.push(st(ft[ct], ht[ct], xt)) : ft[ct].ty === "rp" ? lt.push(dt(ft[ct], ht[ct], xt)) : ft[ct].ty === "gf" ? lt.push($(ft[ct], ht[ct], xt)) : lt.push(et(ft[ct], ht[ct])));
                return lt
            }
            function g(ft, ht, xt) {
                var lt, ct = function(vt) {
                    for (var _t = 0, Pt = lt.length; _t < Pt; ) {
                        if (lt[_t]._name === vt || lt[_t].mn === vt || lt[_t].propertyIndex === vt || lt[_t].ix === vt || lt[_t].ind === vt)
                            return lt[_t];
                        _t += 1
                    }
                    return typeof vt == "number" ? lt[vt - 1] : null
                };
                ct.propertyGroup = propertyGroupFactory(ct, xt),
                lt = d(ft.it, ht.it, ct.propertyGroup),
                ct.numProperties = lt.length;
                var ut = nt(ft.it[ft.it.length - 1], ht.it[ht.it.length - 1], ct.propertyGroup);
                return ct.transform = ut,
                ct.propertyIndex = ft.cix,
                ct._name = ft.nm,
                ct
            }
            function b(ft, ht, xt) {
                var lt = function(vt) {
                    switch (vt) {
                    case "ADBE Vectors Group":
                    case "Contents":
                    case 2:
                        return lt.content;
                    default:
                        return lt.transform
                    }
                };
                lt.propertyGroup = propertyGroupFactory(lt, xt);
                var ct = g(ft, ht, lt.propertyGroup)
                  , ut = nt(ft.it[ft.it.length - 1], ht.it[ht.it.length - 1], lt.propertyGroup);
                return lt.content = ct,
                lt.transform = ut,
                Object.defineProperty(lt, "_name", {
                    get: function() {
                        return ft.nm
                    }
                }),
                lt.numProperties = ft.np,
                lt.propertyIndex = ft.ix,
                lt.nm = ft.nm,
                lt.mn = ft.mn,
                lt
            }
            function _(ft, ht, xt) {
                function lt(ct) {
                    return ct === "Color" || ct === "color" ? lt.color : ct === "Opacity" || ct === "opacity" ? lt.opacity : null
                }
                return Object.defineProperties(lt, {
                    color: {
                        get: ExpressionPropertyInterface(ht.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(ht.o)
                    },
                    _name: {
                        value: ft.nm
                    },
                    mn: {
                        value: ft.mn
                    }
                }),
                ht.c.setGroupProperty(PropertyInterface("Color", xt)),
                ht.o.setGroupProperty(PropertyInterface("Opacity", xt)),
                lt
            }
            function $(ft, ht, xt) {
                function lt(ct) {
                    return ct === "Start Point" || ct === "start point" ? lt.startPoint : ct === "End Point" || ct === "end point" ? lt.endPoint : ct === "Opacity" || ct === "opacity" ? lt.opacity : null
                }
                return Object.defineProperties(lt, {
                    startPoint: {
                        get: ExpressionPropertyInterface(ht.s)
                    },
                    endPoint: {
                        get: ExpressionPropertyInterface(ht.e)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(ht.o)
                    },
                    type: {
                        get: function() {
                            return "a"
                        }
                    },
                    _name: {
                        value: ft.nm
                    },
                    mn: {
                        value: ft.mn
                    }
                }),
                ht.s.setGroupProperty(PropertyInterface("Start Point", xt)),
                ht.e.setGroupProperty(PropertyInterface("End Point", xt)),
                ht.o.setGroupProperty(PropertyInterface("Opacity", xt)),
                lt
            }
            function et() {
                function ft() {
                    return null
                }
                return ft
            }
            function tt(ft, ht, xt) {
                var lt = propertyGroupFactory(Pt, xt)
                  , ct = propertyGroupFactory(_t, lt);
                function ut(kt) {
                    Object.defineProperty(_t, ft.d[kt].nm, {
                        get: ExpressionPropertyInterface(ht.d.dataProps[kt].p)
                    })
                }
                var pt, vt = ft.d ? ft.d.length : 0, _t = {};
                for (pt = 0; pt < vt; pt += 1)
                    ut(pt),
                    ht.d.dataProps[pt].p.setGroupProperty(ct);
                function Pt(kt) {
                    return kt === "Color" || kt === "color" ? Pt.color : kt === "Opacity" || kt === "opacity" ? Pt.opacity : kt === "Stroke Width" || kt === "stroke width" ? Pt.strokeWidth : null
                }
                return Object.defineProperties(Pt, {
                    color: {
                        get: ExpressionPropertyInterface(ht.c)
                    },
                    opacity: {
                        get: ExpressionPropertyInterface(ht.o)
                    },
                    strokeWidth: {
                        get: ExpressionPropertyInterface(ht.w)
                    },
                    dash: {
                        get: function() {
                            return _t
                        }
                    },
                    _name: {
                        value: ft.nm
                    },
                    mn: {
                        value: ft.mn
                    }
                }),
                ht.c.setGroupProperty(PropertyInterface("Color", lt)),
                ht.o.setGroupProperty(PropertyInterface("Opacity", lt)),
                ht.w.setGroupProperty(PropertyInterface("Stroke Width", lt)),
                Pt
            }
            function rt(ft, ht, xt) {
                function lt(ut) {
                    return ut === ft.e.ix || ut === "End" || ut === "end" ? lt.end : ut === ft.s.ix ? lt.start : ut === ft.o.ix ? lt.offset : null
                }
                var ct = propertyGroupFactory(lt, xt);
                return lt.propertyIndex = ft.ix,
                ht.s.setGroupProperty(PropertyInterface("Start", ct)),
                ht.e.setGroupProperty(PropertyInterface("End", ct)),
                ht.o.setGroupProperty(PropertyInterface("Offset", ct)),
                lt.propertyIndex = ft.ix,
                lt.propertyGroup = xt,
                Object.defineProperties(lt, {
                    start: {
                        get: ExpressionPropertyInterface(ht.s)
                    },
                    end: {
                        get: ExpressionPropertyInterface(ht.e)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(ht.o)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            function nt(ft, ht, xt) {
                function lt(ut) {
                    return ft.a.ix === ut || ut === "Anchor Point" ? lt.anchorPoint : ft.o.ix === ut || ut === "Opacity" ? lt.opacity : ft.p.ix === ut || ut === "Position" ? lt.position : ft.r.ix === ut || ut === "Rotation" || ut === "ADBE Vector Rotation" ? lt.rotation : ft.s.ix === ut || ut === "Scale" ? lt.scale : ft.sk && ft.sk.ix === ut || ut === "Skew" ? lt.skew : ft.sa && ft.sa.ix === ut || ut === "Skew Axis" ? lt.skewAxis : null
                }
                var ct = propertyGroupFactory(lt, xt);
                return ht.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", ct)),
                ht.transform.mProps.p.setGroupProperty(PropertyInterface("Position", ct)),
                ht.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", ct)),
                ht.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", ct)),
                ht.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", ct)),
                ht.transform.mProps.sk && (ht.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", ct)),
                ht.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", ct))),
                ht.transform.op.setGroupProperty(PropertyInterface("Opacity", ct)),
                Object.defineProperties(lt, {
                    opacity: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.o)
                    },
                    position: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.p)
                    },
                    anchorPoint: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.a)
                    },
                    scale: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.s)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.r)
                    },
                    skew: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.sk)
                    },
                    skewAxis: {
                        get: ExpressionPropertyInterface(ht.transform.mProps.sa)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.ty = "tr",
                lt.mn = ft.mn,
                lt.propertyGroup = xt,
                lt
            }
            function it(ft, ht, xt) {
                function lt(pt) {
                    return ft.p.ix === pt ? lt.position : ft.s.ix === pt ? lt.size : null
                }
                var ct = propertyGroupFactory(lt, xt);
                lt.propertyIndex = ft.ix;
                var ut = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh;
                return ut.s.setGroupProperty(PropertyInterface("Size", ct)),
                ut.p.setGroupProperty(PropertyInterface("Position", ct)),
                Object.defineProperties(lt, {
                    size: {
                        get: ExpressionPropertyInterface(ut.s)
                    },
                    position: {
                        get: ExpressionPropertyInterface(ut.p)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            function ot(ft, ht, xt) {
                function lt(pt) {
                    return ft.p.ix === pt ? lt.position : ft.r.ix === pt ? lt.rotation : ft.pt.ix === pt ? lt.points : ft.or.ix === pt || pt === "ADBE Vector Star Outer Radius" ? lt.outerRadius : ft.os.ix === pt ? lt.outerRoundness : ft.ir && (ft.ir.ix === pt || pt === "ADBE Vector Star Inner Radius") ? lt.innerRadius : ft.is && ft.is.ix === pt ? lt.innerRoundness : null
                }
                var ct = propertyGroupFactory(lt, xt)
                  , ut = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh;
                return lt.propertyIndex = ft.ix,
                ut.or.setGroupProperty(PropertyInterface("Outer Radius", ct)),
                ut.os.setGroupProperty(PropertyInterface("Outer Roundness", ct)),
                ut.pt.setGroupProperty(PropertyInterface("Points", ct)),
                ut.p.setGroupProperty(PropertyInterface("Position", ct)),
                ut.r.setGroupProperty(PropertyInterface("Rotation", ct)),
                ft.ir && (ut.ir.setGroupProperty(PropertyInterface("Inner Radius", ct)),
                ut.is.setGroupProperty(PropertyInterface("Inner Roundness", ct))),
                Object.defineProperties(lt, {
                    position: {
                        get: ExpressionPropertyInterface(ut.p)
                    },
                    rotation: {
                        get: ExpressionPropertyInterface(ut.r)
                    },
                    points: {
                        get: ExpressionPropertyInterface(ut.pt)
                    },
                    outerRadius: {
                        get: ExpressionPropertyInterface(ut.or)
                    },
                    outerRoundness: {
                        get: ExpressionPropertyInterface(ut.os)
                    },
                    innerRadius: {
                        get: ExpressionPropertyInterface(ut.ir)
                    },
                    innerRoundness: {
                        get: ExpressionPropertyInterface(ut.is)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            function at(ft, ht, xt) {
                function lt(pt) {
                    return ft.p.ix === pt ? lt.position : ft.r.ix === pt ? lt.roundness : ft.s.ix === pt || pt === "Size" || pt === "ADBE Vector Rect Size" ? lt.size : null
                }
                var ct = propertyGroupFactory(lt, xt)
                  , ut = ht.sh.ty === "tm" ? ht.sh.prop : ht.sh;
                return lt.propertyIndex = ft.ix,
                ut.p.setGroupProperty(PropertyInterface("Position", ct)),
                ut.s.setGroupProperty(PropertyInterface("Size", ct)),
                ut.r.setGroupProperty(PropertyInterface("Rotation", ct)),
                Object.defineProperties(lt, {
                    position: {
                        get: ExpressionPropertyInterface(ut.p)
                    },
                    roundness: {
                        get: ExpressionPropertyInterface(ut.r)
                    },
                    size: {
                        get: ExpressionPropertyInterface(ut.s)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            function st(ft, ht, xt) {
                function lt(pt) {
                    return ft.r.ix === pt || pt === "Round Corners 1" ? lt.radius : null
                }
                var ct = propertyGroupFactory(lt, xt)
                  , ut = ht;
                return lt.propertyIndex = ft.ix,
                ut.rd.setGroupProperty(PropertyInterface("Radius", ct)),
                Object.defineProperties(lt, {
                    radius: {
                        get: ExpressionPropertyInterface(ut.rd)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            function dt(ft, ht, xt) {
                function lt(pt) {
                    return ft.c.ix === pt || pt === "Copies" ? lt.copies : ft.o.ix === pt || pt === "Offset" ? lt.offset : null
                }
                var ct = propertyGroupFactory(lt, xt)
                  , ut = ht;
                return lt.propertyIndex = ft.ix,
                ut.c.setGroupProperty(PropertyInterface("Copies", ct)),
                ut.o.setGroupProperty(PropertyInterface("Offset", ct)),
                Object.defineProperties(lt, {
                    copies: {
                        get: ExpressionPropertyInterface(ut.c)
                    },
                    offset: {
                        get: ExpressionPropertyInterface(ut.o)
                    },
                    _name: {
                        value: ft.nm
                    }
                }),
                lt.mn = ft.mn,
                lt
            }
            return function(ft, ht, xt) {
                var lt;
                function ct(pt) {
                    if (typeof pt == "number")
                        return pt = pt === void 0 ? 1 : pt,
                        pt === 0 ? xt : lt[pt - 1];
                    for (var vt = 0, _t = lt.length; vt < _t; ) {
                        if (lt[vt]._name === pt)
                            return lt[vt];
                        vt += 1
                    }
                    return null
                }
                function ut() {
                    return xt
                }
                return ct.propertyGroup = propertyGroupFactory(ct, ut),
                lt = d(ft, ht, ct.propertyGroup),
                ct.numProperties = lt.length,
                ct._name = "Contents",
                ct
            }
        }()
          , TextExpressionInterface = function() {
            return function(d) {
                var g;
                function b(_) {
                    switch (_) {
                    case "ADBE Text Document":
                        return b.sourceText;
                    default:
                        return null
                    }
                }
                return Object.defineProperty(b, "sourceText", {
                    get: function() {
                        d.textProperty.getValue();
                        var $ = d.textProperty.currentData.t;
                        return (!g || $ !== g.value) && (g = new String($),
                        g.value = $ || new String($),
                        Object.defineProperty(g, "style", {
                            get: function() {
                                return {
                                    fillColor: d.textProperty.currentData.fc
                                }
                            }
                        })),
                        g
                    }
                }),
                b
            }
        }();
        function _typeof(d) {
            "@babel/helpers - typeof";
            return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(b) {
                return typeof b
            }
            : _typeof = function(b) {
                return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b
            }
            ,
            _typeof(d)
        }
        var FootageInterface = function() {
            var d = function(_) {
                var $ = ""
                  , et = _.getFootageData();
                function tt() {
                    return $ = "",
                    et = _.getFootageData(),
                    rt
                }
                function rt(nt) {
                    if (et[nt])
                        return $ = nt,
                        et = et[nt],
                        _typeof(et) === "object" ? rt : et;
                    var it = nt.indexOf($);
                    if (it !== -1) {
                        var ot = parseInt(nt.substr(it + $.length), 10);
                        return et = et[ot],
                        _typeof(et) === "object" ? rt : et
                    }
                    return ""
                }
                return tt
            }
              , g = function(_) {
                function $(et) {
                    return et === "Outline" ? $.outlineInterface() : null
                }
                return $._name = "Outline",
                $.outlineInterface = d(_),
                $
            };
            return function(b) {
                function _($) {
                    return $ === "Data" ? _.dataInterface : null
                }
                return _._name = "Data",
                _.dataInterface = g(b),
                _
            }
        }()
          , interfaces = {
            layer: LayerExpressionInterface,
            effects: EffectsExpressionInterface,
            comp: CompExpressionInterface,
            shape: ShapeExpressionInterface,
            text: TextExpressionInterface,
            footage: FootageInterface
        };
        function getInterface(d) {
            return interfaces[d] || null
        }
        var expressionHelpers = function() {
            function d(tt, rt, nt) {
                rt.x && (nt.k = !0,
                nt.x = !0,
                nt.initiateExpression = ExpressionManager.initiateExpression,
                nt.effectsSequence.push(nt.initiateExpression(tt, rt, nt).bind(nt)))
            }
            function g(tt) {
                return tt *= this.elem.globalData.frameRate,
                tt -= this.offsetTime,
                tt !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < tt ? this._cachingAtTime.lastIndex : 0,
                this._cachingAtTime.value = this.interpolateValue(tt, this._cachingAtTime),
                this._cachingAtTime.lastFrame = tt),
                this._cachingAtTime.value
            }
            function b(tt) {
                var rt = -.01
                  , nt = this.getValueAtTime(tt)
                  , it = this.getValueAtTime(tt + rt)
                  , ot = 0;
                if (nt.length) {
                    var at;
                    for (at = 0; at < nt.length; at += 1)
                        ot += Math.pow(it[at] - nt[at], 2);
                    ot = Math.sqrt(ot) * 100
                } else
                    ot = 0;
                return ot
            }
            function _(tt) {
                if (this.vel !== void 0)
                    return this.vel;
                var rt = -.001, nt = this.getValueAtTime(tt), it = this.getValueAtTime(tt + rt), ot;
                if (nt.length) {
                    ot = createTypedArray("float32", nt.length);
                    var at;
                    for (at = 0; at < nt.length; at += 1)
                        ot[at] = (it[at] - nt[at]) / rt
                } else
                    ot = (it - nt) / rt;
                return ot
            }
            function $() {
                return this.pv
            }
            function et(tt) {
                this.propertyGroup = tt
            }
            return {
                searchExpressions: d,
                getSpeedAtTime: b,
                getVelocityAtTime: _,
                getValueAtTime: g,
                getStaticValueAtTime: $,
                setGroupProperty: et
            }
        }();
        function addPropertyDecorator() {
            function d(st, dt, ft) {
                if (!this.k || !this.keyframes)
                    return this.pv;
                st = st ? st.toLowerCase() : "";
                var ht = this.comp.renderedFrame
                  , xt = this.keyframes
                  , lt = xt[xt.length - 1].t;
                if (ht <= lt)
                    return this.pv;
                var ct, ut;
                ft ? (dt ? ct = Math.abs(lt - this.elem.comp.globalData.frameRate * dt) : ct = Math.max(0, lt - this.elem.data.ip),
                ut = lt - ct) : ((!dt || dt > xt.length - 1) && (dt = xt.length - 1),
                ut = xt[xt.length - 1 - dt].t,
                ct = lt - ut);
                var pt, vt, _t;
                if (st === "pingpong") {
                    var Pt = Math.floor((ht - ut) / ct);
                    if (Pt % 2 !== 0)
                        return this.getValueAtTime((ct - (ht - ut) % ct + ut) / this.comp.globalData.frameRate, 0)
                } else if (st === "offset") {
                    var kt = this.getValueAtTime(ut / this.comp.globalData.frameRate, 0)
                      , $t = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0)
                      , Wt = this.getValueAtTime(((ht - ut) % ct + ut) / this.comp.globalData.frameRate, 0)
                      , Ht = Math.floor((ht - ut) / ct);
                    if (this.pv.length) {
                        for (_t = new Array(kt.length),
                        vt = _t.length,
                        pt = 0; pt < vt; pt += 1)
                            _t[pt] = ($t[pt] - kt[pt]) * Ht + Wt[pt];
                        return _t
                    }
                    return ($t - kt) * Ht + Wt
                } else if (st === "continue") {
                    var Dt = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0)
                      , Vt = this.getValueAtTime((lt - .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (_t = new Array(Dt.length),
                        vt = _t.length,
                        pt = 0; pt < vt; pt += 1)
                            _t[pt] = Dt[pt] + (Dt[pt] - Vt[pt]) * ((ht - lt) / this.comp.globalData.frameRate) / 5e-4;
                        return _t
                    }
                    return Dt + (Dt - Vt) * ((ht - lt) / .001)
                }
                return this.getValueAtTime(((ht - ut) % ct + ut) / this.comp.globalData.frameRate, 0)
            }
            function g(st, dt, ft) {
                if (!this.k)
                    return this.pv;
                st = st ? st.toLowerCase() : "";
                var ht = this.comp.renderedFrame
                  , xt = this.keyframes
                  , lt = xt[0].t;
                if (ht >= lt)
                    return this.pv;
                var ct, ut;
                ft ? (dt ? ct = Math.abs(this.elem.comp.globalData.frameRate * dt) : ct = Math.max(0, this.elem.data.op - lt),
                ut = lt + ct) : ((!dt || dt > xt.length - 1) && (dt = xt.length - 1),
                ut = xt[dt].t,
                ct = ut - lt);
                var pt, vt, _t;
                if (st === "pingpong") {
                    var Pt = Math.floor((lt - ht) / ct);
                    if (Pt % 2 === 0)
                        return this.getValueAtTime(((lt - ht) % ct + lt) / this.comp.globalData.frameRate, 0)
                } else if (st === "offset") {
                    var kt = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0)
                      , $t = this.getValueAtTime(ut / this.comp.globalData.frameRate, 0)
                      , Wt = this.getValueAtTime((ct - (lt - ht) % ct + lt) / this.comp.globalData.frameRate, 0)
                      , Ht = Math.floor((lt - ht) / ct) + 1;
                    if (this.pv.length) {
                        for (_t = new Array(kt.length),
                        vt = _t.length,
                        pt = 0; pt < vt; pt += 1)
                            _t[pt] = Wt[pt] - ($t[pt] - kt[pt]) * Ht;
                        return _t
                    }
                    return Wt - ($t - kt) * Ht
                } else if (st === "continue") {
                    var Dt = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0)
                      , Vt = this.getValueAtTime((lt + .001) / this.comp.globalData.frameRate, 0);
                    if (this.pv.length) {
                        for (_t = new Array(Dt.length),
                        vt = _t.length,
                        pt = 0; pt < vt; pt += 1)
                            _t[pt] = Dt[pt] + (Dt[pt] - Vt[pt]) * (lt - ht) / .001;
                        return _t
                    }
                    return Dt + (Dt - Vt) * (lt - ht) / .001
                }
                return this.getValueAtTime((ct - ((lt - ht) % ct + lt)) / this.comp.globalData.frameRate, 0)
            }
            function b(st, dt) {
                if (!this.k)
                    return this.pv;
                if (st = (st || .4) * .5,
                dt = Math.floor(dt || 5),
                dt <= 1)
                    return this.pv;
                var ft = this.comp.renderedFrame / this.comp.globalData.frameRate, ht = ft - st, xt = ft + st, lt = dt > 1 ? (xt - ht) / (dt - 1) : 1, ct = 0, ut = 0, pt;
                this.pv.length ? pt = createTypedArray("float32", this.pv.length) : pt = 0;
                for (var vt; ct < dt; ) {
                    if (vt = this.getValueAtTime(ht + ct * lt),
                    this.pv.length)
                        for (ut = 0; ut < this.pv.length; ut += 1)
                            pt[ut] += vt[ut];
                    else
                        pt += vt;
                    ct += 1
                }
                if (this.pv.length)
                    for (ut = 0; ut < this.pv.length; ut += 1)
                        pt[ut] /= dt;
                else
                    pt /= dt;
                return pt
            }
            function _(st) {
                this._transformCachingAtTime || (this._transformCachingAtTime = {
                    v: new Matrix
                });
                var dt = this._transformCachingAtTime.v;
                if (dt.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1) {
                    var ft = this.a.getValueAtTime(st);
                    dt.translate(-ft[0] * this.a.mult, -ft[1] * this.a.mult, ft[2] * this.a.mult)
                }
                if (this.appliedTransformations < 2) {
                    var ht = this.s.getValueAtTime(st);
                    dt.scale(ht[0] * this.s.mult, ht[1] * this.s.mult, ht[2] * this.s.mult)
                }
                if (this.sk && this.appliedTransformations < 3) {
                    var xt = this.sk.getValueAtTime(st)
                      , lt = this.sa.getValueAtTime(st);
                    dt.skewFromAxis(-xt * this.sk.mult, lt * this.sa.mult)
                }
                if (this.r && this.appliedTransformations < 4) {
                    var ct = this.r.getValueAtTime(st);
                    dt.rotate(-ct * this.r.mult)
                } else if (!this.r && this.appliedTransformations < 4) {
                    var ut = this.rz.getValueAtTime(st)
                      , pt = this.ry.getValueAtTime(st)
                      , vt = this.rx.getValueAtTime(st)
                      , _t = this.or.getValueAtTime(st);
                    dt.rotateZ(-ut * this.rz.mult).rotateY(pt * this.ry.mult).rotateX(vt * this.rx.mult).rotateZ(-_t[2] * this.or.mult).rotateY(_t[1] * this.or.mult).rotateX(_t[0] * this.or.mult)
                }
                if (this.data.p && this.data.p.s) {
                    var Pt = this.px.getValueAtTime(st)
                      , kt = this.py.getValueAtTime(st);
                    if (this.data.p.z) {
                        var $t = this.pz.getValueAtTime(st);
                        dt.translate(Pt * this.px.mult, kt * this.py.mult, -$t * this.pz.mult)
                    } else
                        dt.translate(Pt * this.px.mult, kt * this.py.mult, 0)
                } else {
                    var Wt = this.p.getValueAtTime(st);
                    dt.translate(Wt[0] * this.p.mult, Wt[1] * this.p.mult, -Wt[2] * this.p.mult)
                }
                return dt
            }
            function $() {
                return this.v.clone(new Matrix)
            }
            var et = TransformPropertyFactory.getTransformProperty;
            TransformPropertyFactory.getTransformProperty = function(st, dt, ft) {
                var ht = et(st, dt, ft);
                return ht.dynamicProperties.length ? ht.getValueAtTime = _.bind(ht) : ht.getValueAtTime = $.bind(ht),
                ht.setGroupProperty = expressionHelpers.setGroupProperty,
                ht
            }
            ;
            var tt = PropertyFactory.getProp;
            PropertyFactory.getProp = function(st, dt, ft, ht, xt) {
                var lt = tt(st, dt, ft, ht, xt);
                lt.kf ? lt.getValueAtTime = expressionHelpers.getValueAtTime.bind(lt) : lt.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(lt),
                lt.setGroupProperty = expressionHelpers.setGroupProperty,
                lt.loopOut = d,
                lt.loopIn = g,
                lt.smooth = b,
                lt.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(lt),
                lt.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(lt),
                lt.numKeys = dt.a === 1 ? dt.k.length : 0,
                lt.propertyIndex = dt.ix;
                var ct = 0;
                return ft !== 0 && (ct = createTypedArray("float32", dt.a === 1 ? dt.k[0].s.length : dt.k.length)),
                lt._cachingAtTime = {
                    lastFrame: initialDefaultFrame,
                    lastIndex: 0,
                    value: ct
                },
                expressionHelpers.searchExpressions(st, dt, lt),
                lt.k && xt.addDynamicProperty(lt),
                lt
            }
            ;
            function rt(st) {
                return this._cachingAtTime || (this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                }),
                st *= this.elem.globalData.frameRate,
                st -= this.offsetTime,
                st !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < st ? this._caching.lastIndex : 0,
                this._cachingAtTime.lastTime = st,
                this.interpolateShape(st, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                this._cachingAtTime.shapeValue
            }
            var nt = ShapePropertyFactory.getConstructorFunction()
              , it = ShapePropertyFactory.getKeyframedConstructorFunction();
            function ot() {}
            ot.prototype = {
                vertices: function(dt, ft) {
                    this.k && this.getValue();
                    var ht = this.v;
                    ft !== void 0 && (ht = this.getValueAtTime(ft, 0));
                    var xt, lt = ht._length, ct = ht[dt], ut = ht.v, pt = createSizedArray(lt);
                    for (xt = 0; xt < lt; xt += 1)
                        dt === "i" || dt === "o" ? pt[xt] = [ct[xt][0] - ut[xt][0], ct[xt][1] - ut[xt][1]] : pt[xt] = [ct[xt][0], ct[xt][1]];
                    return pt
                },
                points: function(dt) {
                    return this.vertices("v", dt)
                },
                inTangents: function(dt) {
                    return this.vertices("i", dt)
                },
                outTangents: function(dt) {
                    return this.vertices("o", dt)
                },
                isClosed: function() {
                    return this.v.c
                },
                pointOnPath: function(dt, ft) {
                    var ht = this.v;
                    ft !== void 0 && (ht = this.getValueAtTime(ft, 0)),
                    this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(ht));
                    for (var xt = this._segmentsLength, lt = xt.lengths, ct = xt.totalLength * dt, ut = 0, pt = lt.length, vt = 0, _t; ut < pt; ) {
                        if (vt + lt[ut].addedLength > ct) {
                            var Pt = ut
                              , kt = ht.c && ut === pt - 1 ? 0 : ut + 1
                              , $t = (ct - vt) / lt[ut].addedLength;
                            _t = bez.getPointInSegment(ht.v[Pt], ht.v[kt], ht.o[Pt], ht.i[kt], $t, lt[ut]);
                            break
                        } else
                            vt += lt[ut].addedLength;
                        ut += 1
                    }
                    return _t || (_t = ht.c ? [ht.v[0][0], ht.v[0][1]] : [ht.v[ht._length - 1][0], ht.v[ht._length - 1][1]]),
                    _t
                },
                vectorOnPath: function(dt, ft, ht) {
                    dt == 1 ? dt = this.v.c : dt == 0 && (dt = .999);
                    var xt = this.pointOnPath(dt, ft)
                      , lt = this.pointOnPath(dt + .001, ft)
                      , ct = lt[0] - xt[0]
                      , ut = lt[1] - xt[1]
                      , pt = Math.sqrt(Math.pow(ct, 2) + Math.pow(ut, 2));
                    if (pt === 0)
                        return [0, 0];
                    var vt = ht === "tangent" ? [ct / pt, ut / pt] : [-ut / pt, ct / pt];
                    return vt
                },
                tangentOnPath: function(dt, ft) {
                    return this.vectorOnPath(dt, ft, "tangent")
                },
                normalOnPath: function(dt, ft) {
                    return this.vectorOnPath(dt, ft, "normal")
                },
                setGroupProperty: expressionHelpers.setGroupProperty,
                getValueAtTime: expressionHelpers.getStaticValueAtTime
            },
            extendPrototype([ot], nt),
            extendPrototype([ot], it),
            it.prototype.getValueAtTime = rt,
            it.prototype.initiateExpression = ExpressionManager.initiateExpression;
            var at = ShapePropertyFactory.getShapeProp;
            ShapePropertyFactory.getShapeProp = function(st, dt, ft, ht, xt) {
                var lt = at(st, dt, ft, ht, xt);
                return lt.propertyIndex = dt.ix,
                lt.lock = !1,
                ft === 3 ? expressionHelpers.searchExpressions(st, dt.pt, lt) : ft === 4 && expressionHelpers.searchExpressions(st, dt.ks, lt),
                lt.k && st.addDynamicProperty(lt),
                lt
            }
        }
        function initialize$1() {
            addPropertyDecorator()
        }
        function addDecorator() {
            function d() {
                return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this),
                this.addEffect(this.getExpressionValue.bind(this)),
                !0) : null
            }
            TextProperty.prototype.getExpressionValue = function(g, b) {
                var _ = this.calculateExpression(b);
                if (g.t !== _) {
                    var $ = {};
                    return this.copyData($, g),
                    $.t = _.toString(),
                    $.__complete = !1,
                    $
                }
                return g
            }
            ,
            TextProperty.prototype.searchProperty = function() {
                var g = this.searchKeyframes()
                  , b = this.searchExpressions();
                return this.kf = g || b,
                this.kf
            }
            ,
            TextProperty.prototype.searchExpressions = d
        }
        function initialize() {
            addDecorator()
        }
        function SVGComposableEffect() {}
        SVGComposableEffect.prototype = {
            createMergeNode: function d(g, b) {
                var _ = createNS("feMerge");
                _.setAttribute("result", g);
                var $, et;
                for (et = 0; et < b.length; et += 1)
                    $ = createNS("feMergeNode"),
                    $.setAttribute("in", b[et]),
                    _.appendChild($),
                    _.appendChild($);
                return _
            }
        };
        var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
        function SVGTintFilter(d, g, b, _, $) {
            this.filterManager = g;
            var et = createNS("feColorMatrix");
            et.setAttribute("type", "matrix"),
            et.setAttribute("color-interpolation-filters", "linearRGB"),
            et.setAttribute("values", linearFilterValue + " 1 0"),
            this.linearFilter = et,
            et.setAttribute("result", _ + "_tint_1"),
            d.appendChild(et),
            et = createNS("feColorMatrix"),
            et.setAttribute("type", "matrix"),
            et.setAttribute("color-interpolation-filters", "sRGB"),
            et.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            et.setAttribute("result", _ + "_tint_2"),
            d.appendChild(et),
            this.matrixFilter = et;
            var tt = this.createMergeNode(_, [$, _ + "_tint_1", _ + "_tint_2"]);
            d.appendChild(tt)
        }
        extendPrototype([SVGComposableEffect], SVGTintFilter),
        SVGTintFilter.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                var g = this.filterManager.effectElements[0].p.v
                  , b = this.filterManager.effectElements[1].p.v
                  , _ = this.filterManager.effectElements[2].p.v / 100;
                this.linearFilter.setAttribute("values", linearFilterValue + " " + _ + " 0"),
                this.matrixFilter.setAttribute("values", b[0] - g[0] + " 0 0 0 " + g[0] + " " + (b[1] - g[1]) + " 0 0 0 " + g[1] + " " + (b[2] - g[2]) + " 0 0 0 " + g[2] + " 0 0 0 1 0")
            }
        }
        ;
        function SVGFillFilter(d, g, b, _) {
            this.filterManager = g;
            var $ = createNS("feColorMatrix");
            $.setAttribute("type", "matrix"),
            $.setAttribute("color-interpolation-filters", "sRGB"),
            $.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
            $.setAttribute("result", _),
            d.appendChild($),
            this.matrixFilter = $
        }
        SVGFillFilter.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                var g = this.filterManager.effectElements[2].p.v
                  , b = this.filterManager.effectElements[6].p.v;
                this.matrixFilter.setAttribute("values", "0 0 0 0 " + g[0] + " 0 0 0 0 " + g[1] + " 0 0 0 0 " + g[2] + " 0 0 0 " + b + " 0")
            }
        }
        ;
        function SVGStrokeEffect(d, g, b) {
            this.initialized = !1,
            this.filterManager = g,
            this.elem = b,
            this.paths = []
        }
        SVGStrokeEffect.prototype.initialize = function() {
            var d = this.elem.layerElement.children || this.elem.layerElement.childNodes, g, b, _, $;
            for (this.filterManager.effectElements[1].p.v === 1 ? ($ = this.elem.maskManager.masksProperties.length,
            _ = 0) : (_ = this.filterManager.effectElements[0].p.v - 1,
            $ = _ + 1),
            b = createNS("g"),
            b.setAttribute("fill", "none"),
            b.setAttribute("stroke-linecap", "round"),
            b.setAttribute("stroke-dashoffset", 1),
            _; _ < $; _ += 1)
                g = createNS("path"),
                b.appendChild(g),
                this.paths.push({
                    p: g,
                    m: _
                });
            if (this.filterManager.effectElements[10].p.v === 3) {
                var et = createNS("mask")
                  , tt = createElementID();
                et.setAttribute("id", tt),
                et.setAttribute("mask-type", "alpha"),
                et.appendChild(b),
                this.elem.globalData.defs.appendChild(et);
                var rt = createNS("g");
                for (rt.setAttribute("mask", "url(" + getLocationHref() + "#" + tt + ")"); d[0]; )
                    rt.appendChild(d[0]);
                this.elem.layerElement.appendChild(rt),
                this.masker = et,
                b.setAttribute("stroke", "#fff")
            } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
                if (this.filterManager.effectElements[10].p.v === 2)
                    for (d = this.elem.layerElement.children || this.elem.layerElement.childNodes; d.length; )
                        this.elem.layerElement.removeChild(d[0]);
                this.elem.layerElement.appendChild(b),
                this.elem.layerElement.removeAttribute("mask"),
                b.setAttribute("stroke", "#fff")
            }
            this.initialized = !0,
            this.pathMasker = b
        }
        ,
        SVGStrokeEffect.prototype.renderFrame = function(d) {
            this.initialized || this.initialize();
            var g, b = this.paths.length, _, $;
            for (g = 0; g < b; g += 1)
                if (this.paths[g].m !== -1 && (_ = this.elem.maskManager.viewData[this.paths[g].m],
                $ = this.paths[g].p,
                (d || this.filterManager._mdf || _.prop._mdf) && $.setAttribute("d", _.lastPath),
                d || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || _.prop._mdf)) {
                    var et;
                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                        var tt = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , rt = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01
                          , nt = $.getTotalLength();
                        et = "0 0 0 " + nt * tt + " ";
                        var it = nt * (rt - tt), ot = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, at = Math.floor(it / ot), st;
                        for (st = 0; st < at; st += 1)
                            et += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " ";
                        et += "0 " + nt * 10 + " 0 0"
                    } else
                        et = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01;
                    $.setAttribute("stroke-dasharray", et)
                }
            if ((d || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2),
            (d || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v),
            (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (d || this.filterManager.effectElements[3].p._mdf)) {
                var dt = this.filterManager.effectElements[3].p.v;
                this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(dt[0] * 255) + "," + bmFloor(dt[1] * 255) + "," + bmFloor(dt[2] * 255) + ")")
            }
        }
        ;
        function SVGTritoneFilter(d, g, b, _) {
            this.filterManager = g;
            var $ = createNS("feColorMatrix");
            $.setAttribute("type", "matrix"),
            $.setAttribute("color-interpolation-filters", "linearRGB"),
            $.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"),
            d.appendChild($);
            var et = createNS("feComponentTransfer");
            et.setAttribute("color-interpolation-filters", "sRGB"),
            et.setAttribute("result", _),
            this.matrixFilter = et;
            var tt = createNS("feFuncR");
            tt.setAttribute("type", "table"),
            et.appendChild(tt),
            this.feFuncR = tt;
            var rt = createNS("feFuncG");
            rt.setAttribute("type", "table"),
            et.appendChild(rt),
            this.feFuncG = rt;
            var nt = createNS("feFuncB");
            nt.setAttribute("type", "table"),
            et.appendChild(nt),
            this.feFuncB = nt,
            d.appendChild(et)
        }
        SVGTritoneFilter.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                var g = this.filterManager.effectElements[0].p.v
                  , b = this.filterManager.effectElements[1].p.v
                  , _ = this.filterManager.effectElements[2].p.v
                  , $ = _[0] + " " + b[0] + " " + g[0]
                  , et = _[1] + " " + b[1] + " " + g[1]
                  , tt = _[2] + " " + b[2] + " " + g[2];
                this.feFuncR.setAttribute("tableValues", $),
                this.feFuncG.setAttribute("tableValues", et),
                this.feFuncB.setAttribute("tableValues", tt)
            }
        }
        ;
        function SVGProLevelsFilter(d, g, b, _) {
            this.filterManager = g;
            var $ = this.filterManager.effectElements
              , et = createNS("feComponentTransfer");
            ($[10].p.k || $[10].p.v !== 0 || $[11].p.k || $[11].p.v !== 1 || $[12].p.k || $[12].p.v !== 1 || $[13].p.k || $[13].p.v !== 0 || $[14].p.k || $[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", et)),
            ($[17].p.k || $[17].p.v !== 0 || $[18].p.k || $[18].p.v !== 1 || $[19].p.k || $[19].p.v !== 1 || $[20].p.k || $[20].p.v !== 0 || $[21].p.k || $[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", et)),
            ($[24].p.k || $[24].p.v !== 0 || $[25].p.k || $[25].p.v !== 1 || $[26].p.k || $[26].p.v !== 1 || $[27].p.k || $[27].p.v !== 0 || $[28].p.k || $[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", et)),
            ($[31].p.k || $[31].p.v !== 0 || $[32].p.k || $[32].p.v !== 1 || $[33].p.k || $[33].p.v !== 1 || $[34].p.k || $[34].p.v !== 0 || $[35].p.k || $[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", et)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (et.setAttribute("color-interpolation-filters", "sRGB"),
            d.appendChild(et)),
            ($[3].p.k || $[3].p.v !== 0 || $[4].p.k || $[4].p.v !== 1 || $[5].p.k || $[5].p.v !== 1 || $[6].p.k || $[6].p.v !== 0 || $[7].p.k || $[7].p.v !== 1) && (et = createNS("feComponentTransfer"),
            et.setAttribute("color-interpolation-filters", "sRGB"),
            et.setAttribute("result", _),
            d.appendChild(et),
            this.feFuncRComposed = this.createFeFunc("feFuncR", et),
            this.feFuncGComposed = this.createFeFunc("feFuncG", et),
            this.feFuncBComposed = this.createFeFunc("feFuncB", et))
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(d, g) {
            var b = createNS(d);
            return b.setAttribute("type", "table"),
            g.appendChild(b),
            b
        }
        ,
        SVGProLevelsFilter.prototype.getTableValue = function(d, g, b, _, $) {
            for (var et = 0, tt = 256, rt, nt = Math.min(d, g), it = Math.max(d, g), ot = Array.call(null, {
                length: tt
            }), at, st = 0, dt = $ - _, ft = g - d; et <= 256; )
                rt = et / 256,
                rt <= nt ? at = ft < 0 ? $ : _ : rt >= it ? at = ft < 0 ? _ : $ : at = _ + dt * Math.pow((rt - d) / ft, 1 / b),
                ot[st] = at,
                st += 1,
                et += 256 / (tt - 1);
            return ot.join(" ")
        }
        ,
        SVGProLevelsFilter.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                var g, b = this.filterManager.effectElements;
                this.feFuncRComposed && (d || b[3].p._mdf || b[4].p._mdf || b[5].p._mdf || b[6].p._mdf || b[7].p._mdf) && (g = this.getTableValue(b[3].p.v, b[4].p.v, b[5].p.v, b[6].p.v, b[7].p.v),
                this.feFuncRComposed.setAttribute("tableValues", g),
                this.feFuncGComposed.setAttribute("tableValues", g),
                this.feFuncBComposed.setAttribute("tableValues", g)),
                this.feFuncR && (d || b[10].p._mdf || b[11].p._mdf || b[12].p._mdf || b[13].p._mdf || b[14].p._mdf) && (g = this.getTableValue(b[10].p.v, b[11].p.v, b[12].p.v, b[13].p.v, b[14].p.v),
                this.feFuncR.setAttribute("tableValues", g)),
                this.feFuncG && (d || b[17].p._mdf || b[18].p._mdf || b[19].p._mdf || b[20].p._mdf || b[21].p._mdf) && (g = this.getTableValue(b[17].p.v, b[18].p.v, b[19].p.v, b[20].p.v, b[21].p.v),
                this.feFuncG.setAttribute("tableValues", g)),
                this.feFuncB && (d || b[24].p._mdf || b[25].p._mdf || b[26].p._mdf || b[27].p._mdf || b[28].p._mdf) && (g = this.getTableValue(b[24].p.v, b[25].p.v, b[26].p.v, b[27].p.v, b[28].p.v),
                this.feFuncB.setAttribute("tableValues", g)),
                this.feFuncA && (d || b[31].p._mdf || b[32].p._mdf || b[33].p._mdf || b[34].p._mdf || b[35].p._mdf) && (g = this.getTableValue(b[31].p.v, b[32].p.v, b[33].p.v, b[34].p.v, b[35].p.v),
                this.feFuncA.setAttribute("tableValues", g))
            }
        }
        ;
        function SVGDropShadowEffect(d, g, b, _, $) {
            var et = g.container.globalData.renderConfig.filterSize
              , tt = g.data.fs || et;
            d.setAttribute("x", tt.x || et.x),
            d.setAttribute("y", tt.y || et.y),
            d.setAttribute("width", tt.width || et.width),
            d.setAttribute("height", tt.height || et.height),
            this.filterManager = g;
            var rt = createNS("feGaussianBlur");
            rt.setAttribute("in", "SourceAlpha"),
            rt.setAttribute("result", _ + "_drop_shadow_1"),
            rt.setAttribute("stdDeviation", "0"),
            this.feGaussianBlur = rt,
            d.appendChild(rt);
            var nt = createNS("feOffset");
            nt.setAttribute("dx", "25"),
            nt.setAttribute("dy", "0"),
            nt.setAttribute("in", _ + "_drop_shadow_1"),
            nt.setAttribute("result", _ + "_drop_shadow_2"),
            this.feOffset = nt,
            d.appendChild(nt);
            var it = createNS("feFlood");
            it.setAttribute("flood-color", "#00ff00"),
            it.setAttribute("flood-opacity", "1"),
            it.setAttribute("result", _ + "_drop_shadow_3"),
            this.feFlood = it,
            d.appendChild(it);
            var ot = createNS("feComposite");
            ot.setAttribute("in", _ + "_drop_shadow_3"),
            ot.setAttribute("in2", _ + "_drop_shadow_2"),
            ot.setAttribute("operator", "in"),
            ot.setAttribute("result", _ + "_drop_shadow_4"),
            d.appendChild(ot);
            var at = this.createMergeNode(_, [_ + "_drop_shadow_4", $]);
            d.appendChild(at)
        }
        extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        SVGDropShadowEffect.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                if ((d || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4),
                d || this.filterManager.effectElements[0].p._mdf) {
                    var g = this.filterManager.effectElements[0].p.v;
                    this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(g[0] * 255), Math.round(g[1] * 255), Math.round(g[2] * 255)))
                }
                if ((d || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255),
                d || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
                    var b = this.filterManager.effectElements[3].p.v
                      , _ = (this.filterManager.effectElements[2].p.v - 90) * degToRads
                      , $ = b * Math.cos(_)
                      , et = b * Math.sin(_);
                    this.feOffset.setAttribute("dx", $),
                    this.feOffset.setAttribute("dy", et)
                }
            }
        }
        ;
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(d, g, b) {
            this.initialized = !1,
            this.filterManager = g,
            this.filterElem = d,
            this.elem = b,
            b.matteElement = createNS("g"),
            b.matteElement.appendChild(b.layerElement),
            b.matteElement.appendChild(b.transformedElement),
            b.baseElement = b.matteElement
        }
        SVGMatte3Effect.prototype.findSymbol = function(d) {
            for (var g = 0, b = _svgMatteSymbols.length; g < b; ) {
                if (_svgMatteSymbols[g] === d)
                    return _svgMatteSymbols[g];
                g += 1
            }
            return null
        }
        ,
        SVGMatte3Effect.prototype.replaceInParent = function(d, g) {
            var b = d.layerElement.parentNode;
            if (b) {
                for (var _ = b.children, $ = 0, et = _.length; $ < et && _[$] !== d.layerElement; )
                    $ += 1;
                var tt;
                $ <= et - 2 && (tt = _[$ + 1]);
                var rt = createNS("use");
                rt.setAttribute("href", "#" + g),
                tt ? b.insertBefore(rt, tt) : b.appendChild(rt)
            }
        }
        ,
        SVGMatte3Effect.prototype.setElementAsMask = function(d, g) {
            if (!this.findSymbol(g)) {
                var b = createElementID()
                  , _ = createNS("mask");
                _.setAttribute("id", g.layerId),
                _.setAttribute("mask-type", "alpha"),
                _svgMatteSymbols.push(g);
                var $ = d.globalData.defs;
                $.appendChild(_);
                var et = createNS("symbol");
                et.setAttribute("id", b),
                this.replaceInParent(g, b),
                et.appendChild(g.layerElement),
                $.appendChild(et);
                var tt = createNS("use");
                tt.setAttribute("href", "#" + b),
                _.appendChild(tt),
                g.data.hd = !1,
                g.show()
            }
            d.setMatte(g.layerId)
        }
        ,
        SVGMatte3Effect.prototype.initialize = function() {
            for (var d = this.filterManager.effectElements[0].p.v, g = this.elem.comp.elements, b = 0, _ = g.length; b < _; )
                g[b] && g[b].data.ind === d && this.setElementAsMask(this.elem, g[b]),
                b += 1;
            this.initialized = !0
        }
        ,
        SVGMatte3Effect.prototype.renderFrame = function() {
            this.initialized || this.initialize()
        }
        ;
        function SVGGaussianBlurEffect(d, g, b, _) {
            d.setAttribute("x", "-100%"),
            d.setAttribute("y", "-100%"),
            d.setAttribute("width", "300%"),
            d.setAttribute("height", "300%"),
            this.filterManager = g;
            var $ = createNS("feGaussianBlur");
            $.setAttribute("result", _),
            d.appendChild($),
            this.feGaussianBlur = $
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(d) {
            if (d || this.filterManager._mdf) {
                var g = .3
                  , b = this.filterManager.effectElements[0].p.v * g
                  , _ = this.filterManager.effectElements[1].p.v
                  , $ = _ == 3 ? 0 : b
                  , et = _ == 2 ? 0 : b;
                this.feGaussianBlur.setAttribute("stdDeviation", $ + " " + et);
                var tt = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
                this.feGaussianBlur.setAttribute("edgeMode", tt)
            }
        }
        ;
        function TransformEffect() {}
        TransformEffect.prototype.init = function(d) {
            this.effectsManager = d,
            this.type = effectTypes.TRANSFORM_EFFECT,
            this.matrix = new Matrix,
            this.opacity = -1,
            this._mdf = !1,
            this._opMdf = !1
        }
        ,
        TransformEffect.prototype.renderFrame = function(d) {
            if (this._opMdf = !1,
            this._mdf = !1,
            d || this.effectsManager._mdf) {
                var g = this.effectsManager.effectElements
                  , b = g[0].p.v
                  , _ = g[1].p.v
                  , $ = g[2].p.v === 1
                  , et = g[3].p.v
                  , tt = $ ? et : g[4].p.v
                  , rt = g[5].p.v
                  , nt = g[6].p.v
                  , it = g[7].p.v;
                this.matrix.reset(),
                this.matrix.translate(-b[0], -b[1], b[2]),
                this.matrix.scale(tt * .01, et * .01, 1),
                this.matrix.rotate(-it * degToRads),
                this.matrix.skewFromAxis(-rt * degToRads, (nt + 90) * degToRads),
                this.matrix.translate(_[0], _[1], 0),
                this._mdf = !0,
                this.opacity !== g[8].p.v && (this.opacity = g[8].p.v,
                this._opMdf = !0)
            }
        }
        ;
        function SVGTransformEffect(d, g) {
            this.init(g)
        }
        extendPrototype([TransformEffect], SVGTransformEffect);
        function CVTransformEffect(d) {
            this.init(d)
        }
        return extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
    })
}
)(lottie, lottie.exports);
var lottieExports = lottie.exports;
Object.defineProperty(dist, "__esModule", {
    value: !0
});
var _extends2 = _extends
  , _extends3 = _interopRequireDefault(_extends2)
  , _getPrototypeOf = getPrototypeOf$1
  , _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf)
  , _classCallCheck2 = classCallCheck
  , _classCallCheck3 = _interopRequireDefault(_classCallCheck2)
  , _createClass2 = createClass
  , _createClass3 = _interopRequireDefault(_createClass2)
  , _possibleConstructorReturn2 = possibleConstructorReturn
  , _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2)
  , _inherits2 = inherits
  , _inherits3 = _interopRequireDefault(_inherits2)
  , _react = reactExports
  , _react2 = _interopRequireDefault(_react)
  , _propTypes = propTypesExports
  , _propTypes2 = _interopRequireDefault(_propTypes)
  , _lottieWeb = lottieExports
  , _lottieWeb2 = _interopRequireDefault(_lottieWeb);
function _interopRequireDefault(d) {
    return d && d.__esModule ? d : {
        default: d
    }
}
var Lottie = function(d) {
    (0,
    _inherits3.default)(g, d);
    function g() {
        var b, _, $, et;
        (0,
        _classCallCheck3.default)(this, g);
        for (var tt = arguments.length, rt = Array(tt), nt = 0; nt < tt; nt++)
            rt[nt] = arguments[nt];
        return et = (_ = ($ = (0,
        _possibleConstructorReturn3.default)(this, (b = g.__proto__ || (0,
        _getPrototypeOf2.default)(g)).call.apply(b, [this].concat(rt))),
        $),
        $.handleClickToPause = function() {
            $.anim.isPaused ? $.anim.play() : $.anim.pause()
        }
        ,
        _),
        (0,
        _possibleConstructorReturn3.default)($, et)
    }
    return (0,
    _createClass3.default)(g, [{
        key: "componentDidMount",
        value: function() {
            var _ = this.props
              , $ = _.options
              , et = _.eventListeners
              , tt = $.loop
              , rt = $.autoplay
              , nt = $.animationData
              , it = $.rendererSettings
              , ot = $.segments;
            this.options = {
                container: this.el,
                renderer: "svg",
                loop: tt !== !1,
                autoplay: rt !== !1,
                segments: ot !== !1,
                animationData: nt,
                rendererSettings: it
            },
            this.options = (0,
            _extends3.default)({}, this.options, $),
            this.anim = _lottieWeb2.default.loadAnimation(this.options),
            this.registerEvents(et)
        }
    }, {
        key: "componentWillUpdate",
        value: function(_) {
            this.options.animationData !== _.options.animationData && (this.deRegisterEvents(this.props.eventListeners),
            this.destroy(),
            this.options = (0,
            _extends3.default)({}, this.options, _.options),
            this.anim = _lottieWeb2.default.loadAnimation(this.options),
            this.registerEvents(_.eventListeners))
        }
    }, {
        key: "componentDidUpdate",
        value: function() {
            this.props.isStopped ? this.stop() : this.props.segments ? this.playSegments() : this.play(),
            this.pause(),
            this.setSpeed(),
            this.setDirection()
        }
    }, {
        key: "componentWillUnmount",
        value: function() {
            this.deRegisterEvents(this.props.eventListeners),
            this.destroy(),
            this.options.animationData = null,
            this.anim = null
        }
    }, {
        key: "setSpeed",
        value: function() {
            this.anim.setSpeed(this.props.speed)
        }
    }, {
        key: "setDirection",
        value: function() {
            this.anim.setDirection(this.props.direction)
        }
    }, {
        key: "play",
        value: function() {
            this.anim.play()
        }
    }, {
        key: "playSegments",
        value: function() {
            this.anim.playSegments(this.props.segments)
        }
    }, {
        key: "stop",
        value: function() {
            this.anim.stop()
        }
    }, {
        key: "pause",
        value: function() {
            this.props.isPaused && !this.anim.isPaused ? this.anim.pause() : !this.props.isPaused && this.anim.isPaused && this.anim.pause()
        }
    }, {
        key: "destroy",
        value: function() {
            this.anim.destroy()
        }
    }, {
        key: "registerEvents",
        value: function(_) {
            var $ = this;
            _.forEach(function(et) {
                $.anim.addEventListener(et.eventName, et.callback)
            })
        }
    }, {
        key: "deRegisterEvents",
        value: function(_) {
            var $ = this;
            _.forEach(function(et) {
                $.anim.removeEventListener(et.eventName, et.callback)
            })
        }
    }, {
        key: "render",
        value: function() {
            var _ = this
              , $ = this.props
              , et = $.width
              , tt = $.height
              , rt = $.ariaRole
              , nt = $.ariaLabel
              , it = $.isClickToPauseDisabled
              , ot = $.title
              , at = function(ht) {
                var xt = void 0;
                return typeof ht == "number" ? xt = ht + "px" : xt = ht || "100%",
                xt
            }
              , st = (0,
            _extends3.default)({
                width: at(et),
                height: at(tt),
                overflow: "hidden",
                margin: "0 auto",
                outline: "none"
            }, this.props.style)
              , dt = it ? function() {
                return null
            }
            : this.handleClickToPause;
            return _react2.default.createElement("div", {
                ref: function(ht) {
                    _.el = ht
                },
                style: st,
                onClick: dt,
                title: ot,
                role: rt,
                "aria-label": nt,
                tabIndex: "0"
            })
        }
    }]),
    g
}(_react2.default.Component)
  , _default = dist.default = Lottie;
Lottie.propTypes = {
    eventListeners: _propTypes2.default.arrayOf(_propTypes2.default.object),
    options: _propTypes2.default.object.isRequired,
    height: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    width: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number]),
    isStopped: _propTypes2.default.bool,
    isPaused: _propTypes2.default.bool,
    speed: _propTypes2.default.number,
    segments: _propTypes2.default.arrayOf(_propTypes2.default.number),
    direction: _propTypes2.default.number,
    ariaRole: _propTypes2.default.string,
    ariaLabel: _propTypes2.default.string,
    isClickToPauseDisabled: _propTypes2.default.bool,
    title: _propTypes2.default.string,
    style: _propTypes2.default.string
};
Lottie.defaultProps = {
    eventListeners: [],
    isStopped: !1,
    isPaused: !1,
    speed: 1,
    ariaRole: "button",
    ariaLabel: "animation",
    isClickToPauseDisabled: !1,
    title: ""
};
export {AnimatedNumbers as A, Pagination as P, React as R, Swiper as S, TonConnect as T, _default as _, create$3 as a, reactDomExports as b, classNames as c, useIsConnectionRestored as d, useTonAddress as e, useTonConnectModal as f, THEME as g, SwiperSlide as h, dist$2 as i, jsxRuntimeExports as j, ky$1 as k, confetti as l, motion as m, TonConnectUIProvider$1 as n, client as o, reactExports as r, useTonConnectUI as u};
